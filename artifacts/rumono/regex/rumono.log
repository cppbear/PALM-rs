Fuzz Target Generator for Rust Libraries: v0.1.0
Fuzz Target Renderer Init
crate: regex
[TypeContext] add candidate #0: u8 => Primitive(U8)
[TypeContext] add candidate #1: &[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
analyse struct: Item { name: Some("SetMatchesIter"), item_id: DefId(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), kind: Struct, docs: "A borrowed iterator over the set of matches from a regex set.\n\nThe lifetime `'a` refers to the lifetime of a `SetMatches` value.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2379 ~ regex[3103]::re_set::unicode::SetMatchesIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatchesIntoIter"), item_id: DefId(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), kind: Struct, docs: "An owned iterator over the set of matches from a regex set.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2373 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatches"), item_id: DefId(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), kind: Struct, docs: "A set of matches returned by a regex set." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("matched_any"), item_id: DefId(DefId(0:2365 ~ regex[3103]::re_set::unicode::SetMatches::matched_any)), kind: StructField, docs: "" }, Item { name: Some("matches"), item_id: DefId(DefId(0:2366 ~ regex[3103]::re_set::unicode::SetMatches::matches)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSet"), item_id: DefId(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), kind: Struct, docs: "Match multiple (possibly overlapping) regular expressions in a single scan.\n\nA regex set corresponds to the union of two or more regular expressions.\nThat is, a regex set will match text where at least one of its\nconstituent regular expressions matches. A regex set as its formulated here\nprovides a touch more power: it will also report *which* regular\nexpressions in the set match. Indeed, this is the key difference between\nregex sets and a single `Regex` with many alternates, since only one\nalternate can match at a time.\n\nFor example, consider regular expressions to match email addresses and\ndomains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\nregex set is constructed from those regexes, then searching the text\n`foo@example.com` will report both regexes as matching. Of course, one\ncould accomplish this by compiling each regex on its own and doing two\nsearches over the text. The key advantage of using a regex set is that it\nwill report the matching regexes using a *single pass through the text*.\nIf one has hundreds or thousands of regexes to match repeatedly (like a URL\nrouter for a complex web application or a user agent matcher), then a regex\nset can realize huge performance gains.\n\n# Example\n\nThis shows how the above two regexes (for matching email addresses and\ndomains) might work:\n\n ```rust\n # use regex::RegexSet;\n let set = RegexSet::new(&[\n     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n     r\"[a-z]+\\.(com|org|net)\",\n ]).unwrap();\n\n // Ask whether any regexes in the set match.\n assert!(set.is_match(\"foo@example.com\"));\n\n // Identify which regexes in the set match.\n let matches: Vec<_> = set.matches(\"foo@example.com\").into_iter().collect();\n assert_eq!(vec![0, 1], matches);\n\n // Try again, but with text that only matches one of the regexes.\n let matches: Vec<_> = set.matches(\"example.com\").into_iter().collect();\n assert_eq!(vec![1], matches);\n\n // Try again, but with text that doesn't match any regex in the set.\n let matches: Vec<_> = set.matches(\"example\").into_iter().collect();\n assert!(matches.is_empty());\n ```\n\nNote that it would be possible to adapt the above example to using `Regex`\nwith an expression like:\n\n```text\n(?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n```\n\nAfter a match, one could then inspect the capture groups to figure out\nwhich alternates matched. The problem is that it is hard to make this\napproach scale when there are many regexes since the overlap between each\nalternate isn't always obvious to reason about.\n\n# Limitations\n\nRegex sets are limited to answering the following two questions:\n\n1. Does any regex in the set match?\n2. If so, which regexes in the set match?\n\nAs with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\ninstead of (2) since the matching engines can stop after the first match\nis found.\n\nYou cannot directly extract [`Match`][crate::Match] or\n[`Captures`][crate::Captures] objects from a regex set. If you need these\noperations, the recommended approach is to compile each pattern in the set\nindependently and scan the exact same input a second time with those\nindependently compiled patterns:\n\n```rust\nuse regex::{Regex, RegexSet};\n\nlet patterns = [\"foo\", \"bar\"];\n// Both patterns will match different ranges of this string.\nlet text = \"barfoo\";\n\n// Compile a set matching any of our patterns.\nlet set = RegexSet::new(&patterns).unwrap();\n// Compile each pattern independently.\nlet regexes: Vec<_> = set.patterns().iter()\n    .map(|pat| Regex::new(pat).unwrap())\n    .collect();\n\n// Match against the whole set first and identify the individual\n// matching patterns.\nlet matches: Vec<&str> = set.matches(text).into_iter()\n    // Dereference the match index to get the corresponding\n    // compiled pattern.\n    .map(|match_idx| &regexes[match_idx])\n    // To get match locations or any other info, we then have to search\n    // the exact same text again, using our separately-compiled pattern.\n    .map(|pat| pat.find(text).unwrap().as_str())\n    .collect();\n\n// Matches arrive in the order the constituent patterns were declared,\n// not the order they appear in the input.\nassert_eq!(vec![\"foo\", \"bar\"], matches);\n```\n\n# Performance\n\nA `RegexSet` has the same performance characteristics as `Regex`. Namely,\nsearch takes `O(mn)` time, where `m` is proportional to the size of the\nregex set and `n` is proportional to the length of the search text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2361 ~ regex[3103]::re_set::unicode::RegexSet::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexBuilder"), item_id: DefId(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), kind: Struct, docs: "A configurable builder for a regular expression.\n\nA builder can be used to configure how the regex is built, for example, by\nsetting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2137 ~ regex[3103]::re_builder::unicode::RegexBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSetBuilder"), item_id: DefId(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), kind: Struct, docs: "A configurable builder for a set of regular expressions.\n\nA builder can be used to configure how the regexes are built, for example,\nby setting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2187 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SubCaptureMatches"), item_id: DefId(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), kind: Struct, docs: "An iterator that yields all capturing matches in the order in which they\nappear in the regex.\n\nIf a particular capture group didn't participate in the match, then `None`\nis yielded for that capture. The first match always corresponds to the\noverall match of the regex.\n\nThe lifetime `'c` corresponds to the lifetime of the `Captures` value, and\nthe lifetime `'t` corresponds to the originally matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("caps"), item_id: DefId(DefId(0:2572 ~ regex[3103]::re_unicode::SubCaptureMatches::caps)), kind: StructField, docs: "" }, Item { name: Some("it"), item_id: DefId(DefId(0:2573 ~ regex[3103]::re_unicode::SubCaptureMatches::it)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SplitN"), item_id: DefId(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), kind: Struct, docs: "Yields at most `N` substrings delimited by a regular expression match.\n\nThe last substring will be whatever remains after splitting.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("splits"), item_id: DefId(DefId(0:2556 ~ regex[3103]::re_unicode::SplitN::splits)), kind: StructField, docs: "" }, Item { name: Some("n"), item_id: DefId(DefId(0:2557 ~ regex[3103]::re_unicode::SplitN::n)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Split"), item_id: DefId(DefId(0:2544 ~ regex[3103]::re_unicode::Split)), kind: Struct, docs: "Yields all substrings delimited by a regular expression match.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("finder"), item_id: DefId(DefId(0:2547 ~ regex[3103]::re_unicode::Split::finder)), kind: StructField, docs: "" }, Item { name: Some("last"), item_id: DefId(DefId(0:2548 ~ regex[3103]::re_unicode::Split::last)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("ReplacerRef"), item_id: DefId(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), kind: Struct, docs: "By-reference adaptor for a `Replacer`\n\nReturned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref)." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], default: None, synthetic: false } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2604 ~ regex[3103]::re_unicode::ReplacerRef::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Regex"), item_id: DefId(DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), kind: Struct, docs: "A compiled regular expression for matching Unicode strings.\n\nIt is represented as either a sequence of bytecode instructions (dynamic)\nor as a specialized Rust function (native). It can be used to search, split\nor replace text. All searching is done with an implicit `.*?` at the\nbeginning and end of an expression. To force an expression to match the\nwhole string (or a prefix or a suffix), you must use an anchor like `^` or\n`$` (or `\\A` and `\\z`).\n\nWhile this crate will handle Unicode strings (whether in the regular\nexpression or in the search text), all positions returned are **byte\nindices**. Every byte index is guaranteed to be at a Unicode code point\nboundary.\n\nThe lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\ncompiled regular expression and text to search, respectively.\n\nThe only methods that allocate new strings are the string replacement\nmethods. All other methods (searching and splitting) return borrowed\npointers into the string given.\n\n# Examples\n\nFind the location of a US phone number:\n\n```rust\n# use regex::Regex;\nlet re = Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\").unwrap();\nlet mat = re.find(\"phone: 111-222-3333\").unwrap();\nassert_eq!((mat.start(), mat.end()), (7, 19));\n```\n\n# Using the `std::str::pattern` methods with `Regex`\n\n> **Note**: This section requires that this crate is compiled with the\n> `pattern` Cargo feature enabled, which **requires nightly Rust**.\n\nSince `Regex` implements `Pattern`, you can use regexes with methods\ndefined on `&str`. For example, `is_match`, `find`, `find_iter`\nand `split` can be replaced with `str::contains`, `str::find`,\n`str::match_indices` and `str::split`.\n\nHere are some examples:\n\n```rust,ignore\n# use regex::Regex;\nlet re = Regex::new(r\"\\d+\").unwrap();\nlet haystack = \"a111b222c\";\n\nassert!(haystack.contains(&re));\nassert_eq!(haystack.find(&re), Some(1));\nassert_eq!(haystack.match_indices(&re).collect::<Vec<_>>(),\n           vec![(1, \"111\"), (5, \"222\")]);\nassert_eq!(haystack.split(&re).collect::<Vec<_>>(), vec![\"a\", \"b\", \"c\"]);\n```" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2531 ~ regex[3103]::re_unicode::Regex::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("NoExpand"), item_id: DefId(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), kind: Struct, docs: "`NoExpand` indicates literal string replacement.\n\nIt can be used with `replace` and `replace_all` to do a literal string\nreplacement without expanding `$name` to their corresponding capture\ngroups. This can be both convenient (to avoid escaping `$`, for example)\nand performant (since capture groups don't need to be found).\n\n`'t` is the lifetime of the literal text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2612 ~ regex[3103]::re_unicode::NoExpand::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Matches"), item_id: DefId(DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), kind: Struct, docs: "An iterator over all non-overlapping matches for a particular string.\n\nThe iterator yields a `Match` value. The iterator stops when no more\nmatches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2595 ~ regex[3103]::re_unicode::Matches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Match"), item_id: DefId(DefId(0:2511 ~ regex[3103]::re_unicode::Match)), kind: Struct, docs: "Match represents a single match of a regex in a haystack.\n\nThe lifetime parameter `'t` refers to the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:2513 ~ regex[3103]::re_unicode::Match::text)), kind: StructField, docs: "" }, Item { name: Some("start"), item_id: DefId(DefId(0:2514 ~ regex[3103]::re_unicode::Match::start)), kind: StructField, docs: "" }, Item { name: Some("end"), item_id: DefId(DefId(0:2515 ~ regex[3103]::re_unicode::Match::end)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Captures"), item_id: DefId(DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), kind: Struct, docs: "Captures represents a group of captured strings for a single match.\n\nThe 0th capture always corresponds to the entire match. Each subsequent\nindex corresponds to the next capture group in the regex. If a capture\ngroup is named, then the matched string is *also* available via the `name`\nmethod. (Note that the 0th capture is always unnamed and so must be\naccessed with the `get` method.)\n\nPositions returned from a capture group are always byte indices.\n\n`'t` is the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:1237 ~ regex[3103]::re_unicode::Captures::text)), kind: StructField, docs: "" }, Item { name: Some("locs"), item_id: DefId(DefId(0:1238 ~ regex[3103]::re_unicode::Captures::locs)), kind: StructField, docs: "" }, Item { name: Some("named_groups"), item_id: DefId(DefId(0:1239 ~ regex[3103]::re_unicode::Captures::named_groups)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureNames"), item_id: DefId(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), kind: Struct, docs: "An iterator over the names of all possible captures.\n\n`None` indicates an unnamed capture; the first element (capture 0, the\nwhole matched region) is always unnamed.\n\n`'r` is the lifetime of the compiled regular expression." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2537 ~ regex[3103]::re_unicode::CaptureNames::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureMatches"), item_id: DefId(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), kind: Struct, docs: "An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.\n\nThe iterator stops when no more matches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2586 ~ regex[3103]::re_unicode::CaptureMatches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureLocations"), item_id: DefId(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), kind: Struct, docs: "CaptureLocations is a low level representation of the raw offsets of each\nsubmatch.\n\nYou can think of this as a lower level\n[`Captures`](struct.Captures.html), where this type does not support\nnamed capturing groups directly and it does not borrow the text that these\noffsets were matched on.\n\nPrimarily, this type is useful when using the lower level `Regex` APIs\nsuch as `read_captures`, which permits amortizing the allocation in which\ncapture match locations are stored.\n\nIn order to build a value of this type, you'll need to call the\n`capture_locations` method on the `Regex` being used to execute the search.\nThe value returned can then be reused in subsequent searches.\n\n# Example\n\nThis example shows how to create and use `CaptureLocations` in a search.\n\n```\nuse regex::Regex;\n\nlet re = Regex::new(r\"(?<first>\\w+)\\s+(?<last>\\w+)\").unwrap();\nlet mut locs = re.capture_locations();\nlet m = re.captures_read(&mut locs, \"Bruce Springsteen\").unwrap();\nassert_eq!(0..17, m.range());\nassert_eq!(Some((0, 17)), locs.get(0));\nassert_eq!(Some((0, 5)), locs.get(1));\nassert_eq!(Some((6, 17)), locs.get(2));\n\n// Asking for an invalid capture group always returns None.\nassert_eq!(None, locs.get(3));\nassert_eq!(None, locs.get(34973498648));\nassert_eq!(None, locs.get(9944060567225171988));\n```" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2564 ~ regex[3103]::re_unicode::CaptureLocations::0)), kind: StructField, docs: "" }] })
Add function: fn regex::escape(&str) -> std::string::String
visibility: Some(Public)
analyse struct: Item { name: Some("NoExpand"), item_id: DefId(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), kind: Struct, docs: "`NoExpand` indicates literal string replacement.\n\nIt can be used with `replace` and `replace_all` to do a literal string\nreplacement without expanding `$name` to their corresponding capture\ngroups. This can be both convenient (to avoid escaping `$`, for example)\nand performant (since capture groups don't need to be found).\n\n`'t` is the lifetime of the literal text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2612 ~ regex[3103]::re_unicode::NoExpand::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("ReplacerRef"), item_id: DefId(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), kind: Struct, docs: "By-reference adaptor for a `Replacer`\n\nReturned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref)." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], default: None, synthetic: false } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2604 ~ regex[3103]::re_unicode::ReplacerRef::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Matches"), item_id: DefId(DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), kind: Struct, docs: "An iterator over all non-overlapping matches for a particular string.\n\nThe iterator yields a `Match` value. The iterator stops when no more\nmatches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2595 ~ regex[3103]::re_unicode::Matches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureMatches"), item_id: DefId(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), kind: Struct, docs: "An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.\n\nThe iterator stops when no more matches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2586 ~ regex[3103]::re_unicode::CaptureMatches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SubCaptureMatches"), item_id: DefId(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), kind: Struct, docs: "An iterator that yields all capturing matches in the order in which they\nappear in the regex.\n\nIf a particular capture group didn't participate in the match, then `None`\nis yielded for that capture. The first match always corresponds to the\noverall match of the regex.\n\nThe lifetime `'c` corresponds to the lifetime of the `Captures` value, and\nthe lifetime `'t` corresponds to the originally matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("caps"), item_id: DefId(DefId(0:2572 ~ regex[3103]::re_unicode::SubCaptureMatches::caps)), kind: StructField, docs: "" }, Item { name: Some("it"), item_id: DefId(DefId(0:2573 ~ regex[3103]::re_unicode::SubCaptureMatches::it)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Captures"), item_id: DefId(DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), kind: Struct, docs: "Captures represents a group of captured strings for a single match.\n\nThe 0th capture always corresponds to the entire match. Each subsequent\nindex corresponds to the next capture group in the regex. If a capture\ngroup is named, then the matched string is *also* available via the `name`\nmethod. (Note that the 0th capture is always unnamed and so must be\naccessed with the `get` method.)\n\nPositions returned from a capture group are always byte indices.\n\n`'t` is the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:1237 ~ regex[3103]::re_unicode::Captures::text)), kind: StructField, docs: "" }, Item { name: Some("locs"), item_id: DefId(DefId(0:1238 ~ regex[3103]::re_unicode::Captures::locs)), kind: StructField, docs: "" }, Item { name: Some("named_groups"), item_id: DefId(DefId(0:1239 ~ regex[3103]::re_unicode::Captures::named_groups)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureLocations"), item_id: DefId(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), kind: Struct, docs: "CaptureLocations is a low level representation of the raw offsets of each\nsubmatch.\n\nYou can think of this as a lower level\n[`Captures`](struct.Captures.html), where this type does not support\nnamed capturing groups directly and it does not borrow the text that these\noffsets were matched on.\n\nPrimarily, this type is useful when using the lower level `Regex` APIs\nsuch as `read_captures`, which permits amortizing the allocation in which\ncapture match locations are stored.\n\nIn order to build a value of this type, you'll need to call the\n`capture_locations` method on the `Regex` being used to execute the search.\nThe value returned can then be reused in subsequent searches.\n\n# Example\n\nThis example shows how to create and use `CaptureLocations` in a search.\n\n```\nuse regex::Regex;\n\nlet re = Regex::new(r\"(?<first>\\w+)\\s+(?<last>\\w+)\").unwrap();\nlet mut locs = re.capture_locations();\nlet m = re.captures_read(&mut locs, \"Bruce Springsteen\").unwrap();\nassert_eq!(0..17, m.range());\nassert_eq!(Some((0, 17)), locs.get(0));\nassert_eq!(Some((0, 5)), locs.get(1));\nassert_eq!(Some((6, 17)), locs.get(2));\n\n// Asking for an invalid capture group always returns None.\nassert_eq!(None, locs.get(3));\nassert_eq!(None, locs.get(34973498648));\nassert_eq!(None, locs.get(9944060567225171988));\n```" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2564 ~ regex[3103]::re_unicode::CaptureLocations::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SplitN"), item_id: DefId(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), kind: Struct, docs: "Yields at most `N` substrings delimited by a regular expression match.\n\nThe last substring will be whatever remains after splitting.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("splits"), item_id: DefId(DefId(0:2556 ~ regex[3103]::re_unicode::SplitN::splits)), kind: StructField, docs: "" }, Item { name: Some("n"), item_id: DefId(DefId(0:2557 ~ regex[3103]::re_unicode::SplitN::n)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Split"), item_id: DefId(DefId(0:2544 ~ regex[3103]::re_unicode::Split)), kind: Struct, docs: "Yields all substrings delimited by a regular expression match.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("finder"), item_id: DefId(DefId(0:2547 ~ regex[3103]::re_unicode::Split::finder)), kind: StructField, docs: "" }, Item { name: Some("last"), item_id: DefId(DefId(0:2548 ~ regex[3103]::re_unicode::Split::last)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureNames"), item_id: DefId(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), kind: Struct, docs: "An iterator over the names of all possible captures.\n\n`None` indicates an unnamed capture; the first element (capture 0, the\nwhole matched region) is always unnamed.\n\n`'r` is the lifetime of the compiled regular expression." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2537 ~ regex[3103]::re_unicode::CaptureNames::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Regex"), item_id: DefId(DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), kind: Struct, docs: "A compiled regular expression for matching Unicode strings.\n\nIt is represented as either a sequence of bytecode instructions (dynamic)\nor as a specialized Rust function (native). It can be used to search, split\nor replace text. All searching is done with an implicit `.*?` at the\nbeginning and end of an expression. To force an expression to match the\nwhole string (or a prefix or a suffix), you must use an anchor like `^` or\n`$` (or `\\A` and `\\z`).\n\nWhile this crate will handle Unicode strings (whether in the regular\nexpression or in the search text), all positions returned are **byte\nindices**. Every byte index is guaranteed to be at a Unicode code point\nboundary.\n\nThe lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\ncompiled regular expression and text to search, respectively.\n\nThe only methods that allocate new strings are the string replacement\nmethods. All other methods (searching and splitting) return borrowed\npointers into the string given.\n\n# Examples\n\nFind the location of a US phone number:\n\n```rust\n# use regex::Regex;\nlet re = Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\").unwrap();\nlet mat = re.find(\"phone: 111-222-3333\").unwrap();\nassert_eq!((mat.start(), mat.end()), (7, 19));\n```\n\n# Using the `std::str::pattern` methods with `Regex`\n\n> **Note**: This section requires that this crate is compiled with the\n> `pattern` Cargo feature enabled, which **requires nightly Rust**.\n\nSince `Regex` implements `Pattern`, you can use regexes with methods\ndefined on `&str`. For example, `is_match`, `find`, `find_iter`\nand `split` can be replaced with `str::contains`, `str::find`,\n`str::match_indices` and `str::split`.\n\nHere are some examples:\n\n```rust,ignore\n# use regex::Regex;\nlet re = Regex::new(r\"\\d+\").unwrap();\nlet haystack = \"a111b222c\";\n\nassert!(haystack.contains(&re));\nassert_eq!(haystack.find(&re), Some(1));\nassert_eq!(haystack.match_indices(&re).collect::<Vec<_>>(),\n           vec![(1, \"111\"), (5, \"222\")]);\nassert_eq!(haystack.split(&re).collect::<Vec<_>>(), vec![\"a\", \"b\", \"c\"]);\n```" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2531 ~ regex[3103]::re_unicode::Regex::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Match"), item_id: DefId(DefId(0:2511 ~ regex[3103]::re_unicode::Match)), kind: Struct, docs: "Match represents a single match of a regex in a haystack.\n\nThe lifetime parameter `'t` refers to the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:2513 ~ regex[3103]::re_unicode::Match::text)), kind: StructField, docs: "" }, Item { name: Some("start"), item_id: DefId(DefId(0:2514 ~ regex[3103]::re_unicode::Match::start)), kind: StructField, docs: "" }, Item { name: Some("end"), item_id: DefId(DefId(0:2515 ~ regex[3103]::re_unicode::Match::end)), kind: StructField, docs: "" }] })
Add function: fn regex::re_unicode::escape(&str) -> std::string::String
visibility: Some(Public)
analyse struct: Item { name: Some("SetMatchesIter"), item_id: DefId(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), kind: Struct, docs: "A borrowed iterator over the set of matches from a regex set.\n\nThe lifetime `'a` refers to the lifetime of a `SetMatches` value.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2467 ~ regex[3103]::re_set::bytes::SetMatchesIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatchesIntoIter"), item_id: DefId(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), kind: Struct, docs: "An owned iterator over the set of matches from a regex set.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2461 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatches"), item_id: DefId(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), kind: Struct, docs: "A set of matches returned by a regex set." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("matched_any"), item_id: DefId(DefId(0:2453 ~ regex[3103]::re_set::bytes::SetMatches::matched_any)), kind: StructField, docs: "" }, Item { name: Some("matches"), item_id: DefId(DefId(0:2454 ~ regex[3103]::re_set::bytes::SetMatches::matches)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSet"), item_id: DefId(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), kind: Struct, docs: "Match multiple (possibly overlapping) regular expressions in a single scan.\n\nA regex set corresponds to the union of two or more regular expressions.\nThat is, a regex set will match text where at least one of its\nconstituent regular expressions matches. A regex set as its formulated here\nprovides a touch more power: it will also report *which* regular\nexpressions in the set match. Indeed, this is the key difference between\nregex sets and a single `Regex` with many alternates, since only one\nalternate can match at a time.\n\nFor example, consider regular expressions to match email addresses and\ndomains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\nregex set is constructed from those regexes, then searching the text\n`foo@example.com` will report both regexes as matching. Of course, one\ncould accomplish this by compiling each regex on its own and doing two\nsearches over the text. The key advantage of using a regex set is that it\nwill report the matching regexes using a *single pass through the text*.\nIf one has hundreds or thousands of regexes to match repeatedly (like a URL\nrouter for a complex web application or a user agent matcher), then a regex\nset can realize huge performance gains.\n\n# Example\n\nThis shows how the above two regexes (for matching email addresses and\ndomains) might work:\n\n ```rust\n # use regex::bytes::RegexSet;\n let set = RegexSet::new(&[\n     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n     r\"[a-z]+\\.(com|org|net)\",\n ]).unwrap();\n\n // Ask whether any regexes in the set match.\n assert!(set.is_match(b\"foo@example.com\"));\n\n // Identify which regexes in the set match.\n let matches: Vec<_> = set.matches(b\"foo@example.com\").into_iter().collect();\n assert_eq!(vec![0, 1], matches);\n\n // Try again, but with text that only matches one of the regexes.\n let matches: Vec<_> = set.matches(b\"example.com\").into_iter().collect();\n assert_eq!(vec![1], matches);\n\n // Try again, but with text that doesn't match any regex in the set.\n let matches: Vec<_> = set.matches(b\"example\").into_iter().collect();\n assert!(matches.is_empty());\n ```\n\nNote that it would be possible to adapt the above example to using `Regex`\nwith an expression like:\n\n```text\n(?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n```\n\nAfter a match, one could then inspect the capture groups to figure out\nwhich alternates matched. The problem is that it is hard to make this\napproach scale when there are many regexes since the overlap between each\nalternate isn't always obvious to reason about.\n\n# Limitations\n\nRegex sets are limited to answering the following two questions:\n\n1. Does any regex in the set match?\n2. If so, which regexes in the set match?\n\nAs with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\ninstead of (2) since the matching engines can stop after the first match\nis found.\n\nYou cannot directly extract [`Match`][crate::Match] or\n[`Captures`][crate::Captures] objects from a regex set. If you need these\noperations, the recommended approach is to compile each pattern in the set\nindependently and scan the exact same input a second time with those\nindependently compiled patterns:\n\n```rust\nuse regex::{Regex, RegexSet};\n\nlet patterns = [\"foo\", \"bar\"];\n// Both patterns will match different ranges of this string.\nlet text = \"barfoo\";\n\n// Compile a set matching any of our patterns.\nlet set = RegexSet::new(&patterns).unwrap();\n// Compile each pattern independently.\nlet regexes: Vec<_> = set.patterns().iter()\n    .map(|pat| Regex::new(pat).unwrap())\n    .collect();\n\n// Match against the whole set first and identify the individual\n// matching patterns.\nlet matches: Vec<&str> = set.matches(text).into_iter()\n    // Dereference the match index to get the corresponding\n    // compiled pattern.\n    .map(|match_idx| &regexes[match_idx])\n    // To get match locations or any other info, we then have to search\n    // the exact same text again, using our separately-compiled pattern.\n    .map(|pat| pat.find(text).unwrap().as_str())\n    .collect();\n\n// Matches arrive in the order the constituent patterns were declared,\n// not the order they appear in the input.\nassert_eq!(vec![\"foo\", \"bar\"], matches);\n```\n\n# Performance\n\nA `RegexSet` has the same performance characteristics as `Regex`. Namely,\nsearch takes `O(mn)` time, where `m` is proportional to the size of the\nregex set and `n` is proportional to the length of the search text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2449 ~ regex[3103]::re_set::bytes::RegexSet::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatchesIter"), item_id: DefId(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), kind: Struct, docs: "A borrowed iterator over the set of matches from a regex set.\n\nThe lifetime `'a` refers to the lifetime of a `SetMatches` value.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2379 ~ regex[3103]::re_set::unicode::SetMatchesIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatchesIntoIter"), item_id: DefId(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), kind: Struct, docs: "An owned iterator over the set of matches from a regex set.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2373 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatches"), item_id: DefId(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), kind: Struct, docs: "A set of matches returned by a regex set." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("matched_any"), item_id: DefId(DefId(0:2365 ~ regex[3103]::re_set::unicode::SetMatches::matched_any)), kind: StructField, docs: "" }, Item { name: Some("matches"), item_id: DefId(DefId(0:2366 ~ regex[3103]::re_set::unicode::SetMatches::matches)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSet"), item_id: DefId(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), kind: Struct, docs: "Match multiple (possibly overlapping) regular expressions in a single scan.\n\nA regex set corresponds to the union of two or more regular expressions.\nThat is, a regex set will match text where at least one of its\nconstituent regular expressions matches. A regex set as its formulated here\nprovides a touch more power: it will also report *which* regular\nexpressions in the set match. Indeed, this is the key difference between\nregex sets and a single `Regex` with many alternates, since only one\nalternate can match at a time.\n\nFor example, consider regular expressions to match email addresses and\ndomains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\nregex set is constructed from those regexes, then searching the text\n`foo@example.com` will report both regexes as matching. Of course, one\ncould accomplish this by compiling each regex on its own and doing two\nsearches over the text. The key advantage of using a regex set is that it\nwill report the matching regexes using a *single pass through the text*.\nIf one has hundreds or thousands of regexes to match repeatedly (like a URL\nrouter for a complex web application or a user agent matcher), then a regex\nset can realize huge performance gains.\n\n# Example\n\nThis shows how the above two regexes (for matching email addresses and\ndomains) might work:\n\n ```rust\n # use regex::RegexSet;\n let set = RegexSet::new(&[\n     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n     r\"[a-z]+\\.(com|org|net)\",\n ]).unwrap();\n\n // Ask whether any regexes in the set match.\n assert!(set.is_match(\"foo@example.com\"));\n\n // Identify which regexes in the set match.\n let matches: Vec<_> = set.matches(\"foo@example.com\").into_iter().collect();\n assert_eq!(vec![0, 1], matches);\n\n // Try again, but with text that only matches one of the regexes.\n let matches: Vec<_> = set.matches(\"example.com\").into_iter().collect();\n assert_eq!(vec![1], matches);\n\n // Try again, but with text that doesn't match any regex in the set.\n let matches: Vec<_> = set.matches(\"example\").into_iter().collect();\n assert!(matches.is_empty());\n ```\n\nNote that it would be possible to adapt the above example to using `Regex`\nwith an expression like:\n\n```text\n(?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n```\n\nAfter a match, one could then inspect the capture groups to figure out\nwhich alternates matched. The problem is that it is hard to make this\napproach scale when there are many regexes since the overlap between each\nalternate isn't always obvious to reason about.\n\n# Limitations\n\nRegex sets are limited to answering the following two questions:\n\n1. Does any regex in the set match?\n2. If so, which regexes in the set match?\n\nAs with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\ninstead of (2) since the matching engines can stop after the first match\nis found.\n\nYou cannot directly extract [`Match`][crate::Match] or\n[`Captures`][crate::Captures] objects from a regex set. If you need these\noperations, the recommended approach is to compile each pattern in the set\nindependently and scan the exact same input a second time with those\nindependently compiled patterns:\n\n```rust\nuse regex::{Regex, RegexSet};\n\nlet patterns = [\"foo\", \"bar\"];\n// Both patterns will match different ranges of this string.\nlet text = \"barfoo\";\n\n// Compile a set matching any of our patterns.\nlet set = RegexSet::new(&patterns).unwrap();\n// Compile each pattern independently.\nlet regexes: Vec<_> = set.patterns().iter()\n    .map(|pat| Regex::new(pat).unwrap())\n    .collect();\n\n// Match against the whole set first and identify the individual\n// matching patterns.\nlet matches: Vec<&str> = set.matches(text).into_iter()\n    // Dereference the match index to get the corresponding\n    // compiled pattern.\n    .map(|match_idx| &regexes[match_idx])\n    // To get match locations or any other info, we then have to search\n    // the exact same text again, using our separately-compiled pattern.\n    .map(|pat| pat.find(text).unwrap().as_str())\n    .collect();\n\n// Matches arrive in the order the constituent patterns were declared,\n// not the order they appear in the input.\nassert_eq!(vec![\"foo\", \"bar\"], matches);\n```\n\n# Performance\n\nA `RegexSet` has the same performance characteristics as `Regex`. Namely,\nsearch takes `O(mn)` time, where `m` is proportional to the size of the\nregex set and `n` is proportional to the length of the search text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2361 ~ regex[3103]::re_set::unicode::RegexSet::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("NoExpand"), item_id: DefId(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), kind: Struct, docs: "`NoExpand` indicates literal byte string replacement.\n\nIt can be used with `replace` and `replace_all` to do a literal byte string\nreplacement without expanding `$name` to their corresponding capture\ngroups. This can be both convenient (to avoid escaping `$`, for example)\nand performant (since capture groups don't need to be found).\n\n`'t` is the lifetime of the literal text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2291 ~ regex[3103]::re_bytes::NoExpand::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("ReplacerRef"), item_id: DefId(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), kind: Struct, docs: "By-reference adaptor for a `Replacer`\n\nReturned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref)." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], default: None, synthetic: false } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2283 ~ regex[3103]::re_bytes::ReplacerRef::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SubCaptureMatches"), item_id: DefId(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), kind: Struct, docs: "An iterator that yields all capturing matches in the order in which they\nappear in the regex.\n\nIf a particular capture group didn't participate in the match, then `None`\nis yielded for that capture. The first match always corresponds to the\noverall match of the regex.\n\nThe lifetime `'c` corresponds to the lifetime of the `Captures` value, and\nthe lifetime `'t` corresponds to the originally matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("caps"), item_id: DefId(DefId(0:2269 ~ regex[3103]::re_bytes::SubCaptureMatches::caps)), kind: StructField, docs: "" }, Item { name: Some("it"), item_id: DefId(DefId(0:2270 ~ regex[3103]::re_bytes::SubCaptureMatches::it)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Captures"), item_id: DefId(DefId(0:944 ~ regex[3103]::re_bytes::Captures)), kind: Struct, docs: "Captures represents a group of captured byte strings for a single match.\n\nThe 0th capture always corresponds to the entire match. Each subsequent\nindex corresponds to the next capture group in the regex. If a capture\ngroup is named, then the matched byte string is *also* available via the\n`name` method. (Note that the 0th capture is always unnamed and so must be\naccessed with the `get` method.)\n\nPositions returned from a capture group are always byte indices.\n\n`'t` is the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:946 ~ regex[3103]::re_bytes::Captures::text)), kind: StructField, docs: "" }, Item { name: Some("locs"), item_id: DefId(DefId(0:947 ~ regex[3103]::re_bytes::Captures::locs)), kind: StructField, docs: "" }, Item { name: Some("named_groups"), item_id: DefId(DefId(0:948 ~ regex[3103]::re_bytes::Captures::named_groups)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureLocations"), item_id: DefId(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), kind: Struct, docs: "CaptureLocations is a low level representation of the raw offsets of each\nsubmatch.\n\nYou can think of this as a lower level\n[`Captures`](struct.Captures.html), where this type does not support\nnamed capturing groups directly and it does not borrow the text that these\noffsets were matched on.\n\nPrimarily, this type is useful when using the lower level `Regex` APIs\nsuch as `read_captures`, which permits amortizing the allocation in which\ncapture match locations are stored.\n\nIn order to build a value of this type, you'll need to call the\n`capture_locations` method on the `Regex` being used to execute the search.\nThe value returned can then be reused in subsequent searches.\n\n# Example\n\nThis example shows how to create and use `CaptureLocations` in a search.\n\n```\nuse regex::bytes::Regex;\n\nlet re = Regex::new(r\"(?<first>\\w+)\\s+(?<last>\\w+)\").unwrap();\nlet mut locs = re.capture_locations();\nlet m = re.captures_read(&mut locs, b\"Bruce Springsteen\").unwrap();\nassert_eq!(0..17, m.range());\nassert_eq!(Some((0, 17)), locs.get(0));\nassert_eq!(Some((0, 5)), locs.get(1));\nassert_eq!(Some((6, 17)), locs.get(2));\n\n// Asking for an invalid capture group always returns None.\nassert_eq!(None, locs.get(3));\nassert_eq!(None, locs.get(34973498648));\nassert_eq!(None, locs.get(9944060567225171988));\n```" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2261 ~ regex[3103]::re_bytes::CaptureLocations::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureNames"), item_id: DefId(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), kind: Struct, docs: "An iterator over the names of all possible captures.\n\n`None` indicates an unnamed capture; the first element (capture 0, the\nwhole matched region) is always unnamed.\n\n`'r` is the lifetime of the compiled regular expression." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2252 ~ regex[3103]::re_bytes::CaptureNames::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SplitN"), item_id: DefId(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), kind: Struct, docs: "Yields at most `N` substrings delimited by a regular expression match.\n\nThe last substring will be whatever remains after splitting.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the byte string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("splits"), item_id: DefId(DefId(0:2243 ~ regex[3103]::re_bytes::SplitN::splits)), kind: StructField, docs: "" }, Item { name: Some("n"), item_id: DefId(DefId(0:2244 ~ regex[3103]::re_bytes::SplitN::n)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Split"), item_id: DefId(DefId(0:2231 ~ regex[3103]::re_bytes::Split)), kind: Struct, docs: "Yields all substrings delimited by a regular expression match.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the byte string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("finder"), item_id: DefId(DefId(0:2234 ~ regex[3103]::re_bytes::Split::finder)), kind: StructField, docs: "" }, Item { name: Some("last"), item_id: DefId(DefId(0:2235 ~ regex[3103]::re_bytes::Split::last)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureMatches"), item_id: DefId(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), kind: Struct, docs: "An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.\n\nThe iterator stops when no more matches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched byte string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2226 ~ regex[3103]::re_bytes::CaptureMatches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Matches"), item_id: DefId(DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), kind: Struct, docs: "An iterator over all non-overlapping matches for a particular string.\n\nThe iterator yields a tuple of integers corresponding to the start and end\nof the match. The indices are byte offsets. The iterator stops when no more\nmatches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched byte string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2217 ~ regex[3103]::re_bytes::Matches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Regex"), item_id: DefId(DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), kind: Struct, docs: "A compiled regular expression for matching arbitrary bytes.\n\nIt can be used to search, split or replace text. All searching is done with\nan implicit `.*?` at the beginning and end of an expression. To force an\nexpression to match the whole string (or a prefix or a suffix), you must\nuse an anchor like `^` or `$` (or `\\A` and `\\z`).\n\nLike the `Regex` type in the parent module, matches with this regex return\nbyte offsets into the search text. **Unlike** the parent `Regex` type,\nthese byte offsets may not correspond to UTF-8 sequence boundaries since\nthe regexes in this module can match arbitrary bytes." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2210 ~ regex[3103]::re_bytes::Regex::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Match"), item_id: DefId(DefId(0:2190 ~ regex[3103]::re_bytes::Match)), kind: Struct, docs: "Match represents a single match of a regex in a haystack.\n\nThe lifetime parameter `'t` refers to the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:2192 ~ regex[3103]::re_bytes::Match::text)), kind: StructField, docs: "" }, Item { name: Some("start"), item_id: DefId(DefId(0:2193 ~ regex[3103]::re_bytes::Match::start)), kind: StructField, docs: "" }, Item { name: Some("end"), item_id: DefId(DefId(0:2194 ~ regex[3103]::re_bytes::Match::end)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSetBuilder"), item_id: DefId(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), kind: Struct, docs: "A configurable builder for a set of regular expressions.\n\nA builder can be used to configure how the regexes are built, for example,\nby setting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2187 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSetBuilder"), item_id: DefId(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), kind: Struct, docs: "A configurable builder for a set of regular expressions.\n\nA builder can be used to configure how the regexes are built, for example,\nby setting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2162 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexBuilder"), item_id: DefId(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), kind: Struct, docs: "A configurable builder for a regular expression.\n\nA builder can be used to configure how the regex is built, for example, by\nsetting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2137 ~ regex[3103]::re_builder::unicode::RegexBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexBuilder"), item_id: DefId(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), kind: Struct, docs: "A configurable builder for a regular expression.\n\nA builder can be used to configure how the regex is built, for example, by\nsetting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2114 ~ regex[3103]::re_builder::bytes::RegexBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("InstRanges"), item_id: DefId(DefId(0:2063 ~ regex[3103]::prog::InstRanges)), kind: Struct, docs: "Representation of the Ranges instruction." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("goto"), item_id: DefId(DefId(0:2064 ~ regex[3103]::prog::InstRanges::goto)), kind: StructField, docs: "The next location to execute in the program if this instruction\nsucceeds." }, Item { name: Some("ranges"), item_id: DefId(DefId(0:2065 ~ regex[3103]::prog::InstRanges::ranges)), kind: StructField, docs: "The set of Unicode scalar value ranges to test." }] })
analyse struct: Item { name: Some("Program"), item_id: DefId(DefId(0:1963 ~ regex[3103]::prog::Program)), kind: Struct, docs: "Program is a sequence of instructions and various facts about thos\ninstructions." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("insts"), item_id: DefId(DefId(0:1964 ~ regex[3103]::prog::Program::insts)), kind: StructField, docs: "A sequence of instructions that represents an NFA." }, Item { name: Some("matches"), item_id: DefId(DefId(0:1965 ~ regex[3103]::prog::Program::matches)), kind: StructField, docs: "Pointers to each Match instruction in the sequence.\n\nThis is always length 1 unless this program represents a regex set." }, Item { name: Some("captures"), item_id: DefId(DefId(0:1966 ~ regex[3103]::prog::Program::captures)), kind: StructField, docs: "The ordered sequence of all capture groups extracted from the AST.\nUnnamed groups are `None`." }, Item { name: Some("capture_name_idx"), item_id: DefId(DefId(0:1967 ~ regex[3103]::prog::Program::capture_name_idx)), kind: StructField, docs: "Pointers to all named capture groups into `captures`." }, Item { name: Some("static_captures_len"), item_id: DefId(DefId(0:1968 ~ regex[3103]::prog::Program::static_captures_len)), kind: StructField, docs: "If the number of capture groups is the same for all possible matches,\nthen this is that number." }, Item { name: Some("start"), item_id: DefId(DefId(0:1969 ~ regex[3103]::prog::Program::start)), kind: StructField, docs: "A pointer to the start instruction. This can vary depending on how\nthe program was compiled. For example, programs for use with the DFA\nengine have a `.*?` inserted at the beginning of unanchored regular\nexpressions. The actual starting point of the program is after the\n`.*?`." }, Item { name: Some("byte_classes"), item_id: DefId(DefId(0:1970 ~ regex[3103]::prog::Program::byte_classes)), kind: StructField, docs: "A set of equivalence classes for discriminating bytes in the compiled\nprogram." }, Item { name: Some("only_utf8"), item_id: DefId(DefId(0:1971 ~ regex[3103]::prog::Program::only_utf8)), kind: StructField, docs: "When true, this program can only match valid UTF-8." }, Item { name: Some("is_bytes"), item_id: DefId(DefId(0:1972 ~ regex[3103]::prog::Program::is_bytes)), kind: StructField, docs: "When true, this program uses byte range instructions instead of Unicode\nrange instructions." }, Item { name: Some("is_dfa"), item_id: DefId(DefId(0:1973 ~ regex[3103]::prog::Program::is_dfa)), kind: StructField, docs: "When true, the program is compiled for DFA matching. For example, this\nimplies `is_bytes` and also inserts a preceding `.*?` for unanchored\nregexes." }, Item { name: Some("is_reverse"), item_id: DefId(DefId(0:1974 ~ regex[3103]::prog::Program::is_reverse)), kind: StructField, docs: "When true, the program matches text in reverse (for use only in the\nDFA)." }, Item { name: Some("is_anchored_start"), item_id: DefId(DefId(0:1975 ~ regex[3103]::prog::Program::is_anchored_start)), kind: StructField, docs: "Whether the regex must match from the start of the input." }, Item { name: Some("is_anchored_end"), item_id: DefId(DefId(0:1976 ~ regex[3103]::prog::Program::is_anchored_end)), kind: StructField, docs: "Whether the regex must match at the end of the input." }, Item { name: Some("has_unicode_word_boundary"), item_id: DefId(DefId(0:1977 ~ regex[3103]::prog::Program::has_unicode_word_boundary)), kind: StructField, docs: "Whether this program contains a Unicode word boundary instruction." }, Item { name: Some("prefixes"), item_id: DefId(DefId(0:1978 ~ regex[3103]::prog::Program::prefixes)), kind: StructField, docs: "A possibly empty machine for very quickly matching prefix literals." }, Item { name: Some("dfa_size_limit"), item_id: DefId(DefId(0:1979 ~ regex[3103]::prog::Program::dfa_size_limit)), kind: StructField, docs: "A limit on the size of the cache that the DFA is allowed to use while\nmatching.\n\nThe cache limit specifies approximately how much space we're willing to\ngive to the state cache. Once the state cache exceeds the size, it is\nwiped and all states must be re-computed.\n\nNote that this value does not impact correctness. It can be set to 0\nand the DFA will run just fine. (It will only ever store exactly one\nstate in the cache, and will likely run very slowly, but it will work.)\n\nAlso note that this limit is *per thread of execution*. That is,\nif the same regex is used to search text across multiple threads\nsimultaneously, then the DFA cache is not shared. Instead, copies are\nmade." }] })
analyse struct: Item { name: Some("LiteralSearcher"), item_id: DefId(DefId(0:1844 ~ regex[3103]::literal::imp::LiteralSearcher)), kind: Struct, docs: "A prefix extracted from a compiled regular expression.\n\nA regex prefix is a set of literal strings that *must* be matched at the\nbeginning of a regex in order for the entire regex to match. Similarly\nfor a regex suffix." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("complete"), item_id: DefId(DefId(0:1845 ~ regex[3103]::literal::imp::LiteralSearcher::complete)), kind: StructField, docs: "" }, Item { name: Some("lcp"), item_id: DefId(DefId(0:1846 ~ regex[3103]::literal::imp::LiteralSearcher::lcp)), kind: StructField, docs: "" }, Item { name: Some("lcs"), item_id: DefId(DefId(0:1847 ~ regex[3103]::literal::imp::LiteralSearcher::lcs)), kind: StructField, docs: "" }, Item { name: Some("matcher"), item_id: DefId(DefId(0:1848 ~ regex[3103]::literal::imp::LiteralSearcher::matcher)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Char"), item_id: DefId(DefId(0:1826 ~ regex[3103]::input::Char)), kind: Struct, docs: "An inline representation of `Option<char>`.\n\nThis eliminates the need to do case analysis on `Option<char>` to determine\nordinality with other characters.\n\n(The `Option<char>` is not related to encoding. Instead, it is used in the\nmatching engines to represent the beginning and ending boundaries of the\nsearch text.)" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:1828 ~ regex[3103]::input::Char::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CharInput"), item_id: DefId(DefId(0:1802 ~ regex[3103]::input::CharInput)), kind: Struct, docs: "An input reader over characters." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1804 ~ regex[3103]::input::CharInput::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:1805 ~ regex[3103]::input::CharInput::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("InputAt"), item_id: DefId(DefId(0:1792 ~ regex[3103]::input::InputAt)), kind: Struct, docs: "Represents a location in the input." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("pos"), item_id: DefId(DefId(0:1793 ~ regex[3103]::input::InputAt::pos)), kind: StructField, docs: "" }, Item { name: Some("c"), item_id: DefId(DefId(0:1794 ~ regex[3103]::input::InputAt::c)), kind: StructField, docs: "" }, Item { name: Some("byte"), item_id: DefId(DefId(0:1795 ~ regex[3103]::input::InputAt::byte)), kind: StructField, docs: "" }, Item { name: Some("len"), item_id: DefId(DefId(0:1796 ~ regex[3103]::input::InputAt::len)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("ExecBuilder"), item_id: DefId(DefId(0:369 ~ regex[3103]::exec::ExecBuilder)), kind: Struct, docs: "Facilitates the construction of an executor by exposing various knobs\nto control how a regex is executed and what kinds of resources it's\npermitted to use." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("options"), item_id: DefId(DefId(0:370 ~ regex[3103]::exec::ExecBuilder::options)), kind: StructField, docs: "" }, Item { name: Some("match_type"), item_id: DefId(DefId(0:371 ~ regex[3103]::exec::ExecBuilder::match_type)), kind: StructField, docs: "" }, Item { name: Some("bytes"), item_id: DefId(DefId(0:372 ~ regex[3103]::exec::ExecBuilder::bytes)), kind: StructField, docs: "" }, Item { name: Some("only_utf8"), item_id: DefId(DefId(0:373 ~ regex[3103]::exec::ExecBuilder::only_utf8)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Exec"), item_id: DefId(DefId(0:1659 ~ regex[3103]::exec::Exec)), kind: Struct, docs: "`Exec` manages the execution of a regular expression.\n\nIn particular, this manages the various compiled forms of a single regular\nexpression and the choice of which matching engine to use to execute a\nregular expression." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("ro"), item_id: DefId(DefId(0:1660 ~ regex[3103]::exec::Exec::ro)), kind: StructField, docs: "All read only state." }, Item { name: Some("pool"), item_id: DefId(DefId(0:1661 ~ regex[3103]::exec::Exec::pool)), kind: StructField, docs: "A pool of reusable values for the various matching engines.\n\nNote that boxing this value is not strictly necessary, but it is an\neasy way to ensure that T does not bloat the stack sized used by a pool\nin the case where T is big. And this turns out to be the case at the\ntime of writing for regex's use of this pool. At the time of writing,\nthe size of a Regex on the stack is 856 bytes. Boxing this value\nreduces that size to 16 bytes." }] })
analyse struct: Item { name: Some("Compiler"), item_id: DefId(DefId(0:86 ~ regex[3103]::compile::Compiler)), kind: Struct, docs: "A compiler translates a regular expression AST to a sequence of\ninstructions. The sequence of instructions represents an NFA." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("insts"), item_id: DefId(DefId(0:87 ~ regex[3103]::compile::Compiler::insts)), kind: StructField, docs: "" }, Item { name: Some("compiled"), item_id: DefId(DefId(0:88 ~ regex[3103]::compile::Compiler::compiled)), kind: StructField, docs: "" }, Item { name: Some("capture_name_idx"), item_id: DefId(DefId(0:89 ~ regex[3103]::compile::Compiler::capture_name_idx)), kind: StructField, docs: "" }, Item { name: Some("num_exprs"), item_id: DefId(DefId(0:90 ~ regex[3103]::compile::Compiler::num_exprs)), kind: StructField, docs: "" }, Item { name: Some("size_limit"), item_id: DefId(DefId(0:91 ~ regex[3103]::compile::Compiler::size_limit)), kind: StructField, docs: "" }, Item { name: Some("suffix_cache"), item_id: DefId(DefId(0:92 ~ regex[3103]::compile::Compiler::suffix_cache)), kind: StructField, docs: "" }, Item { name: Some("utf8_seqs"), item_id: DefId(DefId(0:93 ~ regex[3103]::compile::Compiler::utf8_seqs)), kind: StructField, docs: "" }, Item { name: Some("byte_classes"), item_id: DefId(DefId(0:94 ~ regex[3103]::compile::Compiler::byte_classes)), kind: StructField, docs: "" }, Item { name: Some("extra_inst_bytes"), item_id: DefId(DefId(0:95 ~ regex[3103]::compile::Compiler::extra_inst_bytes)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatchesIter"), item_id: DefId(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), kind: Struct, docs: "A borrowed iterator over the set of matches from a regex set.\n\nThe lifetime `'a` refers to the lifetime of a `SetMatches` value.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2467 ~ regex[3103]::re_set::bytes::SetMatchesIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatchesIntoIter"), item_id: DefId(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), kind: Struct, docs: "An owned iterator over the set of matches from a regex set.\n\nThis will always produces matches in ascending order of index, where the\nindex corresponds to the index of the regex that matched with respect to\nits position when initially building the set." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2461 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SetMatches"), item_id: DefId(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), kind: Struct, docs: "A set of matches returned by a regex set." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("matched_any"), item_id: DefId(DefId(0:2453 ~ regex[3103]::re_set::bytes::SetMatches::matched_any)), kind: StructField, docs: "" }, Item { name: Some("matches"), item_id: DefId(DefId(0:2454 ~ regex[3103]::re_set::bytes::SetMatches::matches)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSet"), item_id: DefId(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), kind: Struct, docs: "Match multiple (possibly overlapping) regular expressions in a single scan.\n\nA regex set corresponds to the union of two or more regular expressions.\nThat is, a regex set will match text where at least one of its\nconstituent regular expressions matches. A regex set as its formulated here\nprovides a touch more power: it will also report *which* regular\nexpressions in the set match. Indeed, this is the key difference between\nregex sets and a single `Regex` with many alternates, since only one\nalternate can match at a time.\n\nFor example, consider regular expressions to match email addresses and\ndomains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\nregex set is constructed from those regexes, then searching the text\n`foo@example.com` will report both regexes as matching. Of course, one\ncould accomplish this by compiling each regex on its own and doing two\nsearches over the text. The key advantage of using a regex set is that it\nwill report the matching regexes using a *single pass through the text*.\nIf one has hundreds or thousands of regexes to match repeatedly (like a URL\nrouter for a complex web application or a user agent matcher), then a regex\nset can realize huge performance gains.\n\n# Example\n\nThis shows how the above two regexes (for matching email addresses and\ndomains) might work:\n\n ```rust\n # use regex::bytes::RegexSet;\n let set = RegexSet::new(&[\n     r\"[a-z]+@[a-z]+\\.(com|org|net)\",\n     r\"[a-z]+\\.(com|org|net)\",\n ]).unwrap();\n\n // Ask whether any regexes in the set match.\n assert!(set.is_match(b\"foo@example.com\"));\n\n // Identify which regexes in the set match.\n let matches: Vec<_> = set.matches(b\"foo@example.com\").into_iter().collect();\n assert_eq!(vec![0, 1], matches);\n\n // Try again, but with text that only matches one of the regexes.\n let matches: Vec<_> = set.matches(b\"example.com\").into_iter().collect();\n assert_eq!(vec![1], matches);\n\n // Try again, but with text that doesn't match any regex in the set.\n let matches: Vec<_> = set.matches(b\"example\").into_iter().collect();\n assert!(matches.is_empty());\n ```\n\nNote that it would be possible to adapt the above example to using `Regex`\nwith an expression like:\n\n```text\n(?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n```\n\nAfter a match, one could then inspect the capture groups to figure out\nwhich alternates matched. The problem is that it is hard to make this\napproach scale when there are many regexes since the overlap between each\nalternate isn't always obvious to reason about.\n\n# Limitations\n\nRegex sets are limited to answering the following two questions:\n\n1. Does any regex in the set match?\n2. If so, which regexes in the set match?\n\nAs with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\ninstead of (2) since the matching engines can stop after the first match\nis found.\n\nYou cannot directly extract [`Match`][crate::Match] or\n[`Captures`][crate::Captures] objects from a regex set. If you need these\noperations, the recommended approach is to compile each pattern in the set\nindependently and scan the exact same input a second time with those\nindependently compiled patterns:\n\n```rust\nuse regex::{Regex, RegexSet};\n\nlet patterns = [\"foo\", \"bar\"];\n// Both patterns will match different ranges of this string.\nlet text = \"barfoo\";\n\n// Compile a set matching any of our patterns.\nlet set = RegexSet::new(&patterns).unwrap();\n// Compile each pattern independently.\nlet regexes: Vec<_> = set.patterns().iter()\n    .map(|pat| Regex::new(pat).unwrap())\n    .collect();\n\n// Match against the whole set first and identify the individual\n// matching patterns.\nlet matches: Vec<&str> = set.matches(text).into_iter()\n    // Dereference the match index to get the corresponding\n    // compiled pattern.\n    .map(|match_idx| &regexes[match_idx])\n    // To get match locations or any other info, we then have to search\n    // the exact same text again, using our separately-compiled pattern.\n    .map(|pat| pat.find(text).unwrap().as_str())\n    .collect();\n\n// Matches arrive in the order the constituent patterns were declared,\n// not the order they appear in the input.\nassert_eq!(vec![\"foo\", \"bar\"], matches);\n```\n\n# Performance\n\nA `RegexSet` has the same performance characteristics as `Regex`. Namely,\nsearch takes `O(mn)` time, where `m` is proportional to the size of the\nregex set and `n` is proportional to the length of the search text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2449 ~ regex[3103]::re_set::bytes::RegexSet::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("NoExpand"), item_id: DefId(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), kind: Struct, docs: "`NoExpand` indicates literal byte string replacement.\n\nIt can be used with `replace` and `replace_all` to do a literal byte string\nreplacement without expanding `$name` to their corresponding capture\ngroups. This can be both convenient (to avoid escaping `$`, for example)\nand performant (since capture groups don't need to be found).\n\n`'t` is the lifetime of the literal text." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2291 ~ regex[3103]::re_bytes::NoExpand::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("ReplacerRef"), item_id: DefId(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), kind: Struct, docs: "By-reference adaptor for a `Replacer`\n\nReturned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref)." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], default: None, synthetic: false } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2283 ~ regex[3103]::re_bytes::ReplacerRef::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SubCaptureMatches"), item_id: DefId(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), kind: Struct, docs: "An iterator that yields all capturing matches in the order in which they\nappear in the regex.\n\nIf a particular capture group didn't participate in the match, then `None`\nis yielded for that capture. The first match always corresponds to the\noverall match of the regex.\n\nThe lifetime `'c` corresponds to the lifetime of the `Captures` value, and\nthe lifetime `'t` corresponds to the originally matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("caps"), item_id: DefId(DefId(0:2269 ~ regex[3103]::re_bytes::SubCaptureMatches::caps)), kind: StructField, docs: "" }, Item { name: Some("it"), item_id: DefId(DefId(0:2270 ~ regex[3103]::re_bytes::SubCaptureMatches::it)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Captures"), item_id: DefId(DefId(0:944 ~ regex[3103]::re_bytes::Captures)), kind: Struct, docs: "Captures represents a group of captured byte strings for a single match.\n\nThe 0th capture always corresponds to the entire match. Each subsequent\nindex corresponds to the next capture group in the regex. If a capture\ngroup is named, then the matched byte string is *also* available via the\n`name` method. (Note that the 0th capture is always unnamed and so must be\naccessed with the `get` method.)\n\nPositions returned from a capture group are always byte indices.\n\n`'t` is the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:946 ~ regex[3103]::re_bytes::Captures::text)), kind: StructField, docs: "" }, Item { name: Some("locs"), item_id: DefId(DefId(0:947 ~ regex[3103]::re_bytes::Captures::locs)), kind: StructField, docs: "" }, Item { name: Some("named_groups"), item_id: DefId(DefId(0:948 ~ regex[3103]::re_bytes::Captures::named_groups)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureLocations"), item_id: DefId(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), kind: Struct, docs: "CaptureLocations is a low level representation of the raw offsets of each\nsubmatch.\n\nYou can think of this as a lower level\n[`Captures`](struct.Captures.html), where this type does not support\nnamed capturing groups directly and it does not borrow the text that these\noffsets were matched on.\n\nPrimarily, this type is useful when using the lower level `Regex` APIs\nsuch as `read_captures`, which permits amortizing the allocation in which\ncapture match locations are stored.\n\nIn order to build a value of this type, you'll need to call the\n`capture_locations` method on the `Regex` being used to execute the search.\nThe value returned can then be reused in subsequent searches.\n\n# Example\n\nThis example shows how to create and use `CaptureLocations` in a search.\n\n```\nuse regex::bytes::Regex;\n\nlet re = Regex::new(r\"(?<first>\\w+)\\s+(?<last>\\w+)\").unwrap();\nlet mut locs = re.capture_locations();\nlet m = re.captures_read(&mut locs, b\"Bruce Springsteen\").unwrap();\nassert_eq!(0..17, m.range());\nassert_eq!(Some((0, 17)), locs.get(0));\nassert_eq!(Some((0, 5)), locs.get(1));\nassert_eq!(Some((6, 17)), locs.get(2));\n\n// Asking for an invalid capture group always returns None.\nassert_eq!(None, locs.get(3));\nassert_eq!(None, locs.get(34973498648));\nassert_eq!(None, locs.get(9944060567225171988));\n```" }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2261 ~ regex[3103]::re_bytes::CaptureLocations::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureNames"), item_id: DefId(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), kind: Struct, docs: "An iterator over the names of all possible captures.\n\n`None` indicates an unnamed capture; the first element (capture 0, the\nwhole matched region) is always unnamed.\n\n`'r` is the lifetime of the compiled regular expression." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2252 ~ regex[3103]::re_bytes::CaptureNames::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("SplitN"), item_id: DefId(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), kind: Struct, docs: "Yields at most `N` substrings delimited by a regular expression match.\n\nThe last substring will be whatever remains after splitting.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the byte string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("splits"), item_id: DefId(DefId(0:2243 ~ regex[3103]::re_bytes::SplitN::splits)), kind: StructField, docs: "" }, Item { name: Some("n"), item_id: DefId(DefId(0:2244 ~ regex[3103]::re_bytes::SplitN::n)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Split"), item_id: DefId(DefId(0:2231 ~ regex[3103]::re_bytes::Split)), kind: Struct, docs: "Yields all substrings delimited by a regular expression match.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the byte string being split." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("finder"), item_id: DefId(DefId(0:2234 ~ regex[3103]::re_bytes::Split::finder)), kind: StructField, docs: "" }, Item { name: Some("last"), item_id: DefId(DefId(0:2235 ~ regex[3103]::re_bytes::Split::last)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("CaptureMatches"), item_id: DefId(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), kind: Struct, docs: "An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression.\n\nThe iterator stops when no more matches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched byte string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2226 ~ regex[3103]::re_bytes::CaptureMatches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Matches"), item_id: DefId(DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), kind: Struct, docs: "An iterator over all non-overlapping matches for a particular string.\n\nThe iterator yields a tuple of integers corresponding to the start and end\nof the match. The indices are byte offsets. The iterator stops when no more\nmatches can be found.\n\n`'r` is the lifetime of the compiled regular expression and `'t` is the\nlifetime of the matched byte string." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2217 ~ regex[3103]::re_bytes::Matches::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Regex"), item_id: DefId(DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), kind: Struct, docs: "A compiled regular expression for matching arbitrary bytes.\n\nIt can be used to search, split or replace text. All searching is done with\nan implicit `.*?` at the beginning and end of an expression. To force an\nexpression to match the whole string (or a prefix or a suffix), you must\nuse an anchor like `^` or `$` (or `\\A` and `\\z`).\n\nLike the `Regex` type in the parent module, matches with this regex return\nbyte offsets into the search text. **Unlike** the parent `Regex` type,\nthese byte offsets may not correspond to UTF-8 sequence boundaries since\nthe regexes in this module can match arbitrary bytes." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2210 ~ regex[3103]::re_bytes::Regex::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("Match"), item_id: DefId(DefId(0:2190 ~ regex[3103]::re_bytes::Match)), kind: Struct, docs: "Match represents a single match of a regex in a haystack.\n\nThe lifetime parameter `'t` refers to the lifetime of the matched text." }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }, fields: [Item { name: Some("text"), item_id: DefId(DefId(0:2192 ~ regex[3103]::re_bytes::Match::text)), kind: StructField, docs: "" }, Item { name: Some("start"), item_id: DefId(DefId(0:2193 ~ regex[3103]::re_bytes::Match::start)), kind: StructField, docs: "" }, Item { name: Some("end"), item_id: DefId(DefId(0:2194 ~ regex[3103]::re_bytes::Match::end)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexSetBuilder"), item_id: DefId(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), kind: Struct, docs: "A configurable builder for a set of regular expressions.\n\nA builder can be used to configure how the regexes are built, for example,\nby setting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2162 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder::0)), kind: StructField, docs: "" }] })
analyse struct: Item { name: Some("RegexBuilder"), item_id: DefId(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), kind: Struct, docs: "A configurable builder for a regular expression.\n\nA builder can be used to configure how the regex is built, for example, by\nsetting the default flags (which can be overridden in the expression\nitself) or setting various limits." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:2114 ~ regex[3103]::re_builder::bytes::RegexBuilder::0)), kind: StructField, docs: "" }] })
==== run after krate ====
bounds to facts ignore lifetime: Lifetime("'a")
bounds to facts ignore lifetime: Lifetime("'a")
ignore const: GenericParamDef { name: "N", def_id: DefId(5:455 ~ alloc[2c7c]::boxed::{impl#29}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:463 ~ alloc[2c7c]::boxed::{impl#30}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:468 ~ alloc[2c7c]::boxed::{impl#31}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:468 ~ alloc[2c7c]::boxed::{impl#31}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'a")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'a")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'static")
bounds to facts ignore lifetime: Lifetime("'a")
bounds to facts ignore lifetime: Lifetime("'a")
ignore RegionPredicate: RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:455 ~ alloc[2c7c]::boxed::{impl#29}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:455 ~ alloc[2c7c]::boxed::{impl#29}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:463 ~ alloc[2c7c]::boxed::{impl#30}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(5:468 ~ alloc[2c7c]::boxed::{impl#31}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:236 ~ alloc[2c7c]::boxed::thin::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:212 ~ alloc[2c7c]::boxed::thin::ThinBox)), segments: [PathSegment { name: "ThinBox", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::boxed::thin::ThinBox")
type_def_id: Some(DefId(5:212 ~ alloc[2c7c]::boxed::thin::ThinBox))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:235 ~ alloc[2c7c]::boxed::thin::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::thin::ThinBox"
std::boxed::thin::ThinBox::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:237 ~ alloc[2c7c]::boxed::thin::{impl#6}::Target)), kind: AssocType, docs: "" }
"fn <std::boxed::thin::ThinBox::<T> as std::ops::Deref>::deref(&std::boxed::thin::ThinBox::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:639 ~ alloc[2c7c]::boxed::{impl#66})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7793 ~ alloc[2c7c]::string::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7794 ~ alloc[2c7c]::string::{impl#82}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7792 ~ alloc[2c7c]::string::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::string::String>>::eq(&str, &std::string::String) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::string::String>>::ne(&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7803 ~ alloc[2c7c]::string::{impl#84}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7804 ~ alloc[2c7c]::string::{impl#84}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7802 ~ alloc[2c7c]::string::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
[TypeContext] add candidate #2: &str => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
[TypeContext] add candidate #3: &mut &str => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #4: &&str => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #5: *&str => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[TypeContext] add candidate #6: *const &str => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
assoc types:
"fn <&str as std::cmp::PartialEq::<std::string::String>>::eq(&&str, &std::string::String) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::string::String>>::ne(&&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::string::String")
type_def_id: Some(DefId(5:7759 ~ alloc[2c7c]::string::String))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5941 ~ alloc[2c7c]::string::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::string::String"
std::string::String is not fuzzable
assoc types:
Target: str
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5942 ~ alloc[2c7c]::string::{impl#28}::Target)), kind: AssocType, docs: "" }
"fn <std::string::String as std::ops::Deref>::deref(&std::string::String) -> &str" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:5989 ~ alloc[2c7c]::string::{impl#49})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:730 ~ alloc[2c7c]::boxed::{impl#85}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:729 ~ alloc[2c7c]::boxed::{impl#85})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:718 ~ alloc[2c7c]::boxed::{impl#84}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:717 ~ alloc[2c7c]::boxed::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: regex::Replacer
impl for: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("alloc::string::String")
type_def_id: Some(DefId(5:7759 ~ alloc[2c7c]::string::String))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})
is_local_impl: true
is_external_type: true
type_name: "std::string::String"
std::string::String is not fuzzable
assoc types:
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1327 ~ regex[3103]::re_unicode::{impl#33}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::Replacer
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("alloc::string::String")
type_def_id: Some(DefId(5:7759 ~ alloc[2c7c]::string::String))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})
is_local_impl: true
is_external_type: true
type_name: "std::string::String"
&std::string::String is not fuzzable
assoc types:
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8161 ~ std[d8a0]::ffi::os_str::{impl#77}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8162 ~ std[d8a0]::ffi::os_str::{impl#77}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9074 ~ std[d8a0]::path::{impl#178}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9075 ~ std[d8a0]::path::{impl#178}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9073 ~ std[d8a0]::path::{impl#178})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8958 ~ std[d8a0]::path::{impl#135}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8959 ~ std[d8a0]::path::{impl#135}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8957 ~ std[d8a0]::path::{impl#135})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9118 ~ std[d8a0]::path::{impl#191}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9119 ~ std[d8a0]::path::{impl#191}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9117 ~ std[d8a0]::path::{impl#191})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9042 ~ std[d8a0]::path::{impl#166}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9041 ~ std[d8a0]::path::{impl#166})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8945 ~ std[d8a0]::path::{impl#131}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8944 ~ std[d8a0]::path::{impl#131})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8177 ~ std[d8a0]::ffi::os_str::{impl#81}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8178 ~ std[d8a0]::ffi::os_str::{impl#81}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9105 ~ std[d8a0]::path::{impl#187}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9104 ~ std[d8a0]::path::{impl#187})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5406 ~ std[d8a0]::path::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<std::borrow::Cow::<'_, std::path::Path>>>::from(std::borrow::Cow::<'_, std::path::Path>) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::path::Path>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2192 ~ std[d8a0]::ffi::os_str::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::from(std::borrow::Cow::<'_, std::ffi::OsStr>) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9111 ~ std[d8a0]::path::{impl#189}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9110 ~ std[d8a0]::path::{impl#189})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8185 ~ std[d8a0]::ffi::os_str::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8186 ~ std[d8a0]::ffi::os_str::{impl#83}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8951 ~ std[d8a0]::path::{impl#133}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8950 ~ std[d8a0]::path::{impl#133})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8169 ~ std[d8a0]::ffi::os_str::{impl#79}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8170 ~ std[d8a0]::ffi::os_str::{impl#79}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9082 ~ std[d8a0]::path::{impl#180}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9083 ~ std[d8a0]::path::{impl#180}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9081 ~ std[d8a0]::path::{impl#180})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9048 ~ std[d8a0]::path::{impl#168}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9047 ~ std[d8a0]::path::{impl#168})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8966 ~ std[d8a0]::path::{impl#137}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8967 ~ std[d8a0]::path::{impl#137}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8965 ~ std[d8a0]::path::{impl#137})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9126 ~ std[d8a0]::path::{impl#193}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9127 ~ std[d8a0]::path::{impl#193}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9125 ~ std[d8a0]::path::{impl#193})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:647 ~ alloc[2c7c]::boxed::{impl#68}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:646 ~ alloc[2c7c]::boxed::{impl#68})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7813 ~ alloc[2c7c]::string::{impl#86}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7814 ~ alloc[2c7c]::string::{impl#86}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7812 ~ alloc[2c7c]::string::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7823 ~ alloc[2c7c]::string::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7824 ~ alloc[2c7c]::string::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7822 ~ alloc[2c7c]::string::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("B")])
impl generics: Generics { params: [GenericParamDef { name: "B", def_id: DefId(5:803 ~ alloc[2c7c]::borrow::{impl#4}::B), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("B"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: QPath(QPathData { assoc: PathSegment { name: "Owned", args: AngleBracketed { args: [], constraints: [] } }, self_type: Generic("B"), should_show_cast: true, trait_: Some(Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }) }), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("B"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(5:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:802 ~ alloc[2c7c]::borrow::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::borrow::Cow"
std::borrow::Cow::<'_, B> is not fuzzable
assoc types:
Target: B
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:804 ~ alloc[2c7c]::borrow::{impl#4}::Target)), kind: AssocType, docs: "" }
"fn <std::borrow::Cow::<'_, B> as std::ops::Deref>::deref(&std::borrow::Cow::<'_, B>) -> &B" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:444 ~ alloc[2c7c]::boxed::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:443 ~ alloc[2c7c]::boxed::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<std::borrow::Cow::<'_, [T]>>>::from(std::borrow::Cow::<'_, [T]>) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, [T]>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4827 ~ alloc[2c7c]::ffi::c_str::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>>>::from(std::borrow::Cow::<'_, std::ffi::CStr>) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:448 ~ alloc[2c7c]::boxed::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'_, str>) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:743 ~ alloc[2c7c]::boxed::{impl#89}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:744 ~ alloc[2c7c]::boxed::{impl#89}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:742 ~ alloc[2c7c]::boxed::{impl#89})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'b, str>) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'b, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:739 ~ alloc[2c7c]::boxed::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:740 ~ alloc[2c7c]::boxed::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:738 ~ alloc[2c7c]::boxed::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'b, str>) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'b, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1028 ~ regex[3103]::re_bytes::{impl#34}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Slice(Primitive(U8)))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(5:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34})
is_local_impl: true
is_external_type: true
type_name: "std::borrow::Cow"
&std::borrow::Cow::<'_, [u8]> is not fuzzable
assoc types:
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Primitive(U8))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1024 ~ regex[3103]::re_bytes::{impl#33}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Slice(Primitive(U8)))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(5:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33})
is_local_impl: true
is_external_type: true
type_name: "std::borrow::Cow"
std::borrow::Cow::<'_, [u8]> is not fuzzable
assoc types:
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1338 ~ regex[3103]::re_unicode::{impl#36}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::Replacer
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Primitive(Str))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(5:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36})
is_local_impl: true
is_external_type: true
type_name: "std::borrow::Cow"
&std::borrow::Cow::<'_, str> is not fuzzable
assoc types:
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1334 ~ regex[3103]::re_unicode::{impl#35}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::Replacer
impl for: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(5:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35})
is_local_impl: true
is_external_type: true
type_name: "std::borrow::Cow"
std::borrow::Cow::<'_, str> is not fuzzable
assoc types:
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7679 ~ alloc[2c7c]::ffi::c_str::CString)), segments: [PathSegment { name: "CString", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::ffi::c_str::CString")
type_def_id: Some(DefId(5:7679 ~ alloc[2c7c]::ffi::c_str::CString))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:4811 ~ alloc[2c7c]::ffi::c_str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CString"
std::ffi::CString is not fuzzable
assoc types:
Target: std::ffi::CStr
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:4812 ~ alloc[2c7c]::ffi::c_str::{impl#3}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::CString as std::ops::Deref>::deref(&std::ffi::CString) -> &std::ffi::CStr" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4835 ~ alloc[2c7c]::ffi::c_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<std::ffi::CString>>::from(std::ffi::CString) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<std::ffi::CString> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:304 ~ alloc[2c7c]::boxed::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:303 ~ alloc[2c7c]::boxed::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn std::boxed::Box::<T>::new(T) -> std::boxed::Box::<T>" is filtered.
"fn std::boxed::Box::<T>::new_uninit() -> std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>>" is filtered.
"fn std::boxed::Box::<T>::new_zeroed() -> std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>>" is filtered.
"fn std::boxed::Box::<T>::pin(T) -> std::pin::Pin::<std::boxed::Box::<T>>" is filtered.
"fn std::boxed::Box::<T>::try_new(T) -> std::result::Result::<std::boxed::Box::<T>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<T>::try_new_uninit() -> std::result::Result::<std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<T>::try_new_zeroed() -> std::result::Result::<std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>>, std::alloc::AllocError>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:313 ~ alloc[2c7c]::boxed::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:314 ~ alloc[2c7c]::boxed::{impl#1}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:312 ~ alloc[2c7c]::boxed::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn std::boxed::Box::<T, A>::new_in(T, A) -> std::boxed::Box::<T, A>" is filtered.
"fn std::boxed::Box::<T, A>::try_new_in(T, A) -> std::result::Result::<std::boxed::Box::<T, A>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<T, A>::new_uninit_in(A) -> std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>" is filtered.
"fn std::boxed::Box::<T, A>::try_new_uninit_in(A) -> std::result::Result::<std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<T, A>::new_zeroed_in(A) -> std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>" is filtered.
"fn std::boxed::Box::<T, A>::try_new_zeroed_in(A) -> std::result::Result::<std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<T, A>::pin_in(T, A) -> std::pin::Pin::<std::boxed::Box::<T, A>>" is filtered.
"fn std::boxed::Box::<T, A>::into_boxed_slice(std::boxed::Box::<T, A>) -> std::boxed::Box::<[T], A>" is filtered.
"fn std::boxed::Box::<T, A>::into_inner(std::boxed::Box::<T, A>) -> T" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:326 ~ alloc[2c7c]::boxed::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:325 ~ alloc[2c7c]::boxed::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn std::boxed::Box::<[T]>::new_uninit_slice(usize) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>" is filtered.
"fn std::boxed::Box::<[T]>::new_zeroed_slice(usize) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>" is filtered.
"fn std::boxed::Box::<[T]>::try_new_uninit_slice(usize) -> std::result::Result::<std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<[T]>::try_new_zeroed_slice(usize) -> std::result::Result::<std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>, std::alloc::AllocError>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:332 ~ alloc[2c7c]::boxed::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:333 ~ alloc[2c7c]::boxed::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:331 ~ alloc[2c7c]::boxed::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T], A> is not fuzzable
assoc types:
"fn std::boxed::Box::<[T], A>::new_uninit_slice_in(usize, A) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>" is filtered.
"fn std::boxed::Box::<[T], A>::new_zeroed_slice_in(usize, A) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }, Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:337 ~ alloc[2c7c]::boxed::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:338 ~ alloc[2c7c]::boxed::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:336 ~ alloc[2c7c]::boxed::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A> is not fuzzable
assoc types:
"fn std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>::assume_init(std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>) -> std::boxed::Box::<T, A>" is filtered.
"fn std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>::write(std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>, T) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:342 ~ alloc[2c7c]::boxed::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:343 ~ alloc[2c7c]::boxed::{impl#5}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } })), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:341 ~ alloc[2c7c]::boxed::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A> is not fuzzable
assoc types:
"fn std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>::assume_init(std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>) -> std::boxed::Box::<[T], A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:346 ~ alloc[2c7c]::boxed::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:345 ~ alloc[2c7c]::boxed::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn std::boxed::Box::<T>::from_raw(*T) -> std::boxed::Box::<T>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:349 ~ alloc[2c7c]::boxed::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:350 ~ alloc[2c7c]::boxed::{impl#7}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:348 ~ alloc[2c7c]::boxed::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn std::boxed::Box::<T, A>::from_raw_in(*T, A) -> std::boxed::Box::<T, A>" is filtered.
"fn std::boxed::Box::<T, A>::into_raw(std::boxed::Box::<T, A>) -> *T" is filtered.
"fn std::boxed::Box::<T, A>::into_raw_with_allocator(std::boxed::Box::<T, A>) -> (*T ,A)" is filtered.
"fn std::boxed::Box::<T, A>::allocator(&std::boxed::Box::<T, A>) -> &A" is filtered.
"fn std::boxed::Box::<T, A>::leak(std::boxed::Box::<T, A>) -> &'a mut T" is filtered.
"fn std::boxed::Box::<T, A>::into_pin(std::boxed::Box::<T, A>) -> std::pin::Pin::<std::boxed::Box::<T, A>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:472 ~ alloc[2c7c]::boxed::{impl#32}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:471 ~ alloc[2c7c]::boxed::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A> is not fuzzable
assoc types:
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::result::Result::<std::boxed::Box::<T, A>, std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>>" is filtered.
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast_unchecked(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:478 ~ alloc[2c7c]::boxed::{impl#33}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:477 ~ alloc[2c7c]::boxed::{impl#33})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A> is not fuzzable
assoc types:
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::result::Result::<std::boxed::Box::<T, A>, std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>>" is filtered.
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast_unchecked(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:484 ~ alloc[2c7c]::boxed::{impl#34}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:483 ~ alloc[2c7c]::boxed::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A> is not fuzzable
assoc types:
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::result::Result::<std::boxed::Box::<T, A>, std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>>" is filtered.
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast_unchecked(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("S")])
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(1:3215 ~ std[d8a0]::io::impls::{impl#6}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3682 ~ std[d8a0]::io::Seek)), segments: [PathSegment { name: "Seek", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: std::io::Seek
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("S"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Seek")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:3682 ~ std[d8a0]::io::Seek))
impl_def_id: DefId(1:3214 ~ std[d8a0]::io::impls::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<S> is not fuzzable
assoc types:
"fn <std::boxed::Box::<S> as std::io::Seek>::seek(&mut std::boxed::Box::<S>, std::io::SeekFrom) -> std::result::Result::<u64, std::io::Error>" is filtered.
"fn <std::boxed::Box::<S> as std::io::Seek>::stream_position(&mut std::boxed::Box::<S>) -> std::result::Result::<u64, std::io::Error>" is filtered.
Add std::io::Seek Provide Method. is_local=false
[Impl] add default impl: rewind
"fn <std::boxed::Box::<S> as std::io::Seek>::rewind(&mut std::boxed::Box::<S>) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: stream_len
"fn <std::boxed::Box::<S> as std::io::Seek>::stream_len(&mut std::boxed::Box::<S>) -> std::result::Result::<u64, std::io::Error>" is filtered.
[Impl] add default impl: seek_relative
"fn <std::boxed::Box::<S> as std::io::Seek>::seek_relative(&mut std::boxed::Box::<S>, i64) -> std::result::Result::<(), std::io::Error>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("W")])
impl generics: Generics { params: [GenericParamDef { name: "W", def_id: DefId(1:3207 ~ std[d8a0]::io::impls::{impl#5}::W), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("W"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3664 ~ std[d8a0]::io::Write)), segments: [PathSegment { name: "Write", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: std::io::Write
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("W"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Write")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:3664 ~ std[d8a0]::io::Write))
impl_def_id: DefId(1:3206 ~ std[d8a0]::io::impls::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<W> is not fuzzable
assoc types:
"fn <std::boxed::Box::<W> as std::io::Write>::write(&mut std::boxed::Box::<W>, &[u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<W> as std::io::Write>::write_vectored(&mut std::boxed::Box::<W>, &[std::io::IoSlice::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<W> as std::io::Write>::is_write_vectored(&std::boxed::Box::<W>) -> bool" is filtered.
"fn <std::boxed::Box::<W> as std::io::Write>::flush(&mut std::boxed::Box::<W>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <std::boxed::Box::<W> as std::io::Write>::write_all(&mut std::boxed::Box::<W>, &[u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <std::boxed::Box::<W> as std::io::Write>::write_fmt(&mut std::boxed::Box::<W>, std::fmt::Arguments::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
Add std::io::Write Provide Method. is_local=false
[Impl] add default impl: write_all_vectored
"fn <std::boxed::Box::<W> as std::io::Write>::write_all_vectored(&mut std::boxed::Box::<W>, &mut [std::io::IoSlice::<'_>]) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: by_ref
"fn <std::boxed::Box::<W> as std::io::Write>::by_ref(&mut std::boxed::Box::<W>) -> &mut std::boxed::Box::<W>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4984 ~ std[d8a0]::os::fd::raw::{impl#14}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:4944 ~ std[d8a0]::os::fd::raw::AsRawFd)), segments: [PathSegment { name: "AsRawFd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: std::os::fd::raw::AsRawFd
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::os::fd::raw::AsRawFd")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:4944 ~ std[d8a0]::os::fd::raw::AsRawFd))
impl_def_id: DefId(1:4983 ~ std[d8a0]::os::fd::raw::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T> as std::os::fd::raw::AsRawFd>::as_raw_fd(&std::boxed::Box::<T>) -> i32" is filtered.
Add std::os::fd::raw::AsRawFd Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5406 ~ std[d8a0]::path::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<std::borrow::Cow::<'_, std::path::Path>>>::from(std::borrow::Cow::<'_, std::path::Path>) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::path::Path>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2190 ~ std[d8a0]::ffi::os_str::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<&std::ffi::OsStr>>::from(&std::ffi::OsStr) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2196 ~ std[d8a0]::ffi::os_str::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<std::ffi::OsString>>::from(std::ffi::OsString) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<std::ffi::OsString> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5410 ~ std[d8a0]::path::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<std::path::PathBuf>>::from(std::path::PathBuf) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<std::path::PathBuf> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2192 ~ std[d8a0]::ffi::os_str::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::from(std::borrow::Cow::<'_, std::ffi::OsStr>) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5404 ~ std[d8a0]::path::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<&std::path::Path>>::from(&std::path::Path) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<&std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:5068 ~ std[d8a0]::os::fd::owned::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:5025 ~ std[d8a0]::os::fd::owned::AsFd)), segments: [PathSegment { name: "AsFd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: std::os::fd::owned::AsFd
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::os::fd::owned::AsFd")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:5025 ~ std[d8a0]::os::fd::owned::AsFd))
impl_def_id: DefId(1:5067 ~ std[d8a0]::os::fd::owned::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T> as std::os::fd::owned::AsFd>::as_fd(&std::boxed::Box::<T>) -> std::os::fd::owned::BorrowedFd::<'_>" is filtered.
Add std::os::fd::owned::AsFd Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:5412 ~ std[d8a0]::path::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:2198 ~ std[d8a0]::ffi::os_str::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:2224 ~ std[d8a0]::ffi::os_str::{impl#38})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::default::Default>::default() -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("B")])
impl generics: Generics { params: [GenericParamDef { name: "B", def_id: DefId(1:3219 ~ std[d8a0]::io::impls::{impl#7}::B), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("B"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3692 ~ std[d8a0]::io::BufRead)), segments: [PathSegment { name: "BufRead", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: std::io::BufRead
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::BufRead")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:3692 ~ std[d8a0]::io::BufRead))
impl_def_id: DefId(1:3218 ~ std[d8a0]::io::impls::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<B> is not fuzzable
assoc types:
"fn <std::boxed::Box::<B> as std::io::BufRead>::fill_buf(&mut std::boxed::Box::<B>) -> std::result::Result::<&[u8], std::io::Error>" is filtered.
"fn <std::boxed::Box::<B> as std::io::BufRead>::consume(&mut std::boxed::Box::<B>, usize) -> ()" is filtered.
"fn <std::boxed::Box::<B> as std::io::BufRead>::read_until(&mut std::boxed::Box::<B>, u8, &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<B> as std::io::BufRead>::read_line(&mut std::boxed::Box::<B>, &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
Add std::io::BufRead Provide Method. is_local=false
[Impl] add default impl: has_data_left
"fn <std::boxed::Box::<B> as std::io::BufRead>::has_data_left(&mut std::boxed::Box::<B>) -> std::result::Result::<bool, std::io::Error>" is filtered.
[Impl] add default impl: skip_until
"fn <std::boxed::Box::<B> as std::io::BufRead>::skip_until(&mut std::boxed::Box::<B>, u8) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: split
"fn <std::boxed::Box::<B> as std::io::BufRead>::split(std::boxed::Box::<B>, u8) -> std::io::Split::<std::boxed::Box::<B>>" is filtered.
[Impl] add default impl: lines
"fn <std::boxed::Box::<B> as std::io::BufRead>::lines(std::boxed::Box::<B>) -> std::io::Lines::<std::boxed::Box::<B>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "R", def_id: DefId(1:3197 ~ std[d8a0]::io::impls::{impl#4}::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3607 ~ std[d8a0]::io::Read)), segments: [PathSegment { name: "Read", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: std::io::Read
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("R"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Read")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:3607 ~ std[d8a0]::io::Read))
impl_def_id: DefId(1:3196 ~ std[d8a0]::io::impls::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<R> is not fuzzable
assoc types:
"fn <std::boxed::Box::<R> as std::io::Read>::read(&mut std::boxed::Box::<R>, &mut [u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::read_buf(&mut std::boxed::Box::<R>, std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::read_vectored(&mut std::boxed::Box::<R>, &mut [std::io::IoSliceMut::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::is_read_vectored(&std::boxed::Box::<R>) -> bool" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::read_to_end(&mut std::boxed::Box::<R>, &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::read_to_string(&mut std::boxed::Box::<R>, &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::read_exact(&mut std::boxed::Box::<R>, &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <std::boxed::Box::<R> as std::io::Read>::read_buf_exact(&mut std::boxed::Box::<R>, std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
Add std::io::Read Provide Method. is_local=false
[Impl] add default impl: by_ref
"fn <std::boxed::Box::<R> as std::io::Read>::by_ref(&mut std::boxed::Box::<R>) -> &mut std::boxed::Box::<R>" is filtered.
[Impl] add default impl: bytes
"fn <std::boxed::Box::<R> as std::io::Read>::bytes(std::boxed::Box::<R>) -> std::io::Bytes::<std::boxed::Box::<R>>" is filtered.
[Impl] add default impl: chain
"fn <std::boxed::Box::<R> as std::io::Read>::chain(std::boxed::Box::<R>, R) -> std::io::Chain::<std::boxed::Box::<R>, R>" is filtered.
[Impl] add default impl: take
"fn <std::boxed::Box::<R> as std::io::Read>::take(std::boxed::Box::<R>, u64) -> std::io::Take::<std::boxed::Box::<R>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:660 ~ alloc[2c7c]::boxed::{impl#71}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:661 ~ alloc[2c7c]::boxed::{impl#71}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(5:659 ~ alloc[2c7c]::boxed::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::borrow::BorrowMut::<T>>::borrow_mut(&mut std::boxed::Box::<T, A>) -> &mut T" is filtered.
Add std::borrow::BorrowMut::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:591 ~ alloc[2c7c]::boxed::{impl#55}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:592 ~ alloc[2c7c]::boxed::{impl#55}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3309 ~ core[b693]::marker::Unsize)), segments: [PathSegment { name: "Unsize", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::unsize::DispatchFromDyn
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::unsize::DispatchFromDyn")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3867 ~ core[b693]::ops::unsize::DispatchFromDyn))
impl_def_id: DefId(5:590 ~ alloc[2c7c]::boxed::{impl#55})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
Add std::ops::unsize::DispatchFromDyn::<std::boxed::Box::<U>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("I"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:517 ~ alloc[2c7c]::boxed::{impl#42}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:518 ~ alloc[2c7c]::boxed::{impl#42}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("I")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:516 ~ alloc[2c7c]::boxed::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:601 ~ alloc[2c7c]::boxed::{impl#58}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:602 ~ alloc[2c7c]::boxed::{impl#58}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:603 ~ alloc[2c7c]::boxed::{impl#58}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:600 ~ alloc[2c7c]::boxed::{impl#58})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:605 ~ alloc[2c7c]::boxed::{impl#59}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:606 ~ alloc[2c7c]::boxed::{impl#59}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:607 ~ alloc[2c7c]::boxed::{impl#59}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:604 ~ alloc[2c7c]::boxed::{impl#59})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("I")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:598 ~ alloc[2c7c]::boxed::{impl#57}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:599 ~ alloc[2c7c]::boxed::{impl#57}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:597 ~ alloc[2c7c]::boxed::{impl#57})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:587 ~ alloc[2c7c]::boxed::{impl#54}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:588 ~ alloc[2c7c]::boxed::{impl#54}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:589 ~ alloc[2c7c]::boxed::{impl#54}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3309 ~ core[b693]::marker::Unsize)), segments: [PathSegment { name: "Unsize", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::unsize::CoerceUnsized
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::unsize::CoerceUnsized")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3830 ~ core[b693]::ops::unsize::CoerceUnsized))
impl_def_id: DefId(5:586 ~ alloc[2c7c]::boxed::{impl#54})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Add std::ops::unsize::CoerceUnsized::<std::boxed::Box::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:360 ~ alloc[2c7c]::boxed::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:361 ~ alloc[2c7c]::boxed::{impl#8}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::drop::Drop
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::drop::Drop")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3580 ~ core[b693]::ops::drop::Drop))
impl_def_id: DefId(5:359 ~ alloc[2c7c]::boxed::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:636 ~ alloc[2c7c]::boxed::{impl#65}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:635 ~ alloc[2c7c]::boxed::{impl#65})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("I"))])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:594 ~ alloc[2c7c]::boxed::{impl#56}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:593 ~ alloc[2c7c]::boxed::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:643 ~ alloc[2c7c]::boxed::{impl#67}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:642 ~ alloc[2c7c]::boxed::{impl#67})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:639 ~ alloc[2c7c]::boxed::{impl#66})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:632 ~ alloc[2c7c]::boxed::{impl#64}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:631 ~ alloc[2c7c]::boxed::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:647 ~ alloc[2c7c]::boxed::{impl#68}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:646 ~ alloc[2c7c]::boxed::{impl#68})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:628 ~ alloc[2c7c]::boxed::{impl#63})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:381 ~ alloc[2c7c]::boxed::{impl#14}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:382 ~ alloc[2c7c]::boxed::{impl#14}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:380 ~ alloc[2c7c]::boxed::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::cmp::PartialEq>::eq(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> bool" is filtered.
"fn <std::boxed::Box::<T, A> as std::cmp::PartialEq>::ne(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "Args", def_id: DefId(5:568 ~ alloc[2c7c]::boxed::{impl#51}::Args), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:569 ~ alloc[2c7c]::boxed::{impl#51}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:570 ~ alloc[2c7c]::boxed::{impl#51}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Args"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3424 ~ core[b693]::ops::async_function::AsyncFnOnce)), segments: [PathSegment { name: "AsyncFnOnce", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::async_function::AsyncFnOnce
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::async_function::AsyncFnOnce")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3424 ~ core[b693]::ops::async_function::AsyncFnOnce))
impl_def_id: DefId(5:567 ~ alloc[2c7c]::boxed::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
CallOnceFuture: <F as std::ops::async_function::AsyncFnOnce::<Args>>::CallOnceFuture
Output: <F as std::ops::async_function::AsyncFnOnce::<Args>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:571 ~ alloc[2c7c]::boxed::{impl#51}::Output)), kind: AssocType, docs: "" }
not covered item Item { name: Some("CallOnceFuture"), item_id: DefId(DefId(5:572 ~ alloc[2c7c]::boxed::{impl#51}::CallOnceFuture)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<F, A> as std::ops::async_function::AsyncFnOnce::<Args>>::async_call_once(std::boxed::Box::<F, A>, Args) -> <std::boxed::Box::<F, A> as std::ops::async_function::AsyncFnOnce::<Args>>::CallOnceFuture" is filtered.
Add std::ops::async_function::AsyncFnOnce::<Args> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:498 ~ alloc[2c7c]::boxed::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:499 ~ alloc[2c7c]::boxed::{impl#37}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::fmt::Pointer
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Pointer")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:10675 ~ core[b693]::fmt::Pointer))
impl_def_id: DefId(5:497 ~ alloc[2c7c]::boxed::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "F", def_id: DefId(5:689 ~ alloc[2c7c]::boxed::{impl#77}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:690 ~ alloc[2c7c]::boxed::{impl#77}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:45483 ~ core[b693]::future::future::Future)), segments: [PathSegment { name: "Future", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32876 ~ core[b693]::marker::Unpin)), segments: [PathSegment { name: "Unpin", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::future::future::Future
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::future::future::Future")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:45483 ~ core[b693]::future::future::Future))
impl_def_id: DefId(5:688 ~ alloc[2c7c]::boxed::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
Output: <F as std::future::future::Future>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:691 ~ alloc[2c7c]::boxed::{impl#77}::Output)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<F, A> as std::future::future::Future>::poll(std::pin::Pin::<&mut std::boxed::Box::<F, A>>, &mut std::task::wake::Context::<'_>) -> std::task::poll::Poll::<<std::boxed::Box::<F, A> as std::future::future::Future>::Output>" is filtered.
Add std::future::future::Future Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:747 ~ alloc[2c7c]::boxed::{impl#90}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::error::Error
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::error::Error")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3153 ~ core[b693]::error::Error))
impl_def_id: DefId(5:746 ~ alloc[2c7c]::boxed::{impl#90})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T> as std::error::Error>::description(&std::boxed::Box::<T>) -> &str" is filtered.
"fn <std::boxed::Box::<T> as std::error::Error>::cause(&std::boxed::Box::<T>) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)>" is filtered.
"fn <std::boxed::Box::<T> as std::error::Error>::source(&std::boxed::Box::<T>) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'static\")))>" is filtered.
"fn <std::boxed::Box::<T> as std::error::Error>::provide(&'b std::boxed::Box::<T>, &mut std::error::Request::<'b>) -> ()" is filtered.
Add std::error::Error Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:502 ~ alloc[2c7c]::boxed::{impl#38}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:503 ~ alloc[2c7c]::boxed::{impl#38}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:501 ~ alloc[2c7c]::boxed::{impl#38})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:504 ~ alloc[2c7c]::boxed::{impl#38}::Target)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<T, A> as std::ops::Deref>::deref(&std::boxed::Box::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:406 ~ alloc[2c7c]::boxed::{impl#19}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:407 ~ alloc[2c7c]::boxed::{impl#19}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10886 ~ core[b693]::hash::Hasher)), segments: [PathSegment { name: "Hasher", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hasher
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hasher")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:10886 ~ core[b693]::hash::Hasher))
impl_def_id: DefId(5:405 ~ alloc[2c7c]::boxed::{impl#19})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::finish(&std::boxed::Box::<T, A>) -> u64" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write(&mut std::boxed::Box::<T, A>, &[u8]) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_u8(&mut std::boxed::Box::<T, A>, u8) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_u16(&mut std::boxed::Box::<T, A>, u16) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_u32(&mut std::boxed::Box::<T, A>, u32) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_u64(&mut std::boxed::Box::<T, A>, u64) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_u128(&mut std::boxed::Box::<T, A>, u128) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_usize(&mut std::boxed::Box::<T, A>, usize) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_i8(&mut std::boxed::Box::<T, A>, i8) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_i16(&mut std::boxed::Box::<T, A>, i16) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_i32(&mut std::boxed::Box::<T, A>, i32) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_i64(&mut std::boxed::Box::<T, A>, i64) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_i128(&mut std::boxed::Box::<T, A>, i128) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_isize(&mut std::boxed::Box::<T, A>, isize) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_length_prefix(&mut std::boxed::Box::<T, A>, usize) -> ()" is filtered.
"fn <std::boxed::Box::<T, A> as std::hash::Hasher>::write_str(&mut std::boxed::Box::<T, A>, &str) -> ()" is filtered.
Add std::hash::Hasher Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("I"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:539 ~ alloc[2c7c]::boxed::{impl#45}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:540 ~ alloc[2c7c]::boxed::{impl#45}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator)), segments: [PathSegment { name: "DoubleEndedIterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::double_ended::DoubleEndedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("I")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::double_ended::DoubleEndedIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator))
impl_def_id: DefId(5:538 ~ alloc[2c7c]::boxed::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("S")])
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:694 ~ alloc[2c7c]::boxed::{impl#78}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:4528 ~ core[b693]::async_iter::async_iter::AsyncIterator)), segments: [PathSegment { name: "AsyncIterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32876 ~ core[b693]::marker::Unpin)), segments: [PathSegment { name: "Unpin", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::async_iter::async_iter::AsyncIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("S"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::async_iter::async_iter::AsyncIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:4528 ~ core[b693]::async_iter::async_iter::AsyncIterator))
impl_def_id: DefId(5:693 ~ alloc[2c7c]::boxed::{impl#78})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<S> is not fuzzable
assoc types:
Item: <S as std::async_iter::async_iter::AsyncIterator>::Item
not covered item Item { name: Some("Item"), item_id: DefId(DefId(5:695 ~ alloc[2c7c]::boxed::{impl#78}::Item)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<S> as std::async_iter::async_iter::AsyncIterator>::poll_next(std::pin::Pin::<&mut std::boxed::Box::<S>>, &mut std::task::wake::Context::<'_>) -> std::task::poll::Poll::<std::option::Option::<<std::boxed::Box::<S> as std::async_iter::async_iter::AsyncIterator>::Item>>" is filtered.
"fn <std::boxed::Box::<S> as std::async_iter::async_iter::AsyncIterator>::size_hint(&std::boxed::Box::<S>) -> (usize ,std::option::Option::<usize>)" is filtered.
Add std::async_iter::async_iter::AsyncIterator Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:494 ~ alloc[2c7c]::boxed::{impl#36}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:495 ~ alloc[2c7c]::boxed::{impl#36}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(5:493 ~ alloc[2c7c]::boxed::{impl#36})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4825 ~ alloc[2c7c]::ffi::c_str::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<&std::ffi::CStr>>::from(&std::ffi::CStr) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<&std::ffi::CStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:710 ~ alloc[2c7c]::boxed::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "E", def_id: DefId(5:711 ~ alloc[2c7c]::boxed::{impl#82}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), Outlives(Lifetime("'a"))], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:709 ~ alloc[2c7c]::boxed::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<E>>::from(E) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<E> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:425 ~ alloc[2c7c]::boxed::{impl#20}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:424 ~ alloc[2c7c]::boxed::{impl#20})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T> as std::convert::From::<T>>::from(T) -> std::boxed::Box::<T>" is filtered.
Add std::convert::From::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:5989 ~ alloc[2c7c]::string::{impl#49})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:441 ~ alloc[2c7c]::boxed::{impl#24}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:440 ~ alloc[2c7c]::boxed::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<&[T]>>::from(&[T]) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<&[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:444 ~ alloc[2c7c]::boxed::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:443 ~ alloc[2c7c]::boxed::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<std::borrow::Cow::<'_, [T]>>>::from(std::borrow::Cow::<'_, [T]>) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, [T]>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:714 ~ alloc[2c7c]::boxed::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "E", def_id: DefId(5:715 ~ alloc[2c7c]::boxed::{impl#83}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), Outlives(Lifetime("'a"))], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:713 ~ alloc[2c7c]::boxed::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<E>>::from(E) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<E> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4827 ~ alloc[2c7c]::ffi::c_str::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>>>::from(std::borrow::Cow::<'_, std::ffi::CStr>) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Primitive(U8)), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:451 ~ alloc[2c7c]::boxed::{impl#28}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Primitive(U8))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:450 ~ alloc[2c7c]::boxed::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[u8], A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[u8], A> as std::convert::From::<std::boxed::Box::<str, A>>>::from(std::boxed::Box::<str, A>) -> std::boxed::Box::<[u8], A>" is filtered.
Add std::convert::From::<std::boxed::Box::<str, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:446 ~ alloc[2c7c]::boxed::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:454 ~ alloc[2c7c]::boxed::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:455 ~ alloc[2c7c]::boxed::{impl#29}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:453 ~ alloc[2c7c]::boxed::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<[T;N]>>::from([T;N]) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<[T;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:448 ~ alloc[2c7c]::boxed::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'_, str>) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7481 ~ alloc[2c7c]::vec::{impl#39}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:7482 ~ alloc[2c7c]::vec::{impl#39}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:7480 ~ alloc[2c7c]::vec::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T], A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T], A> as std::convert::From::<std::vec::Vec::<T, A>>>::from(std::vec::Vec::<T, A>) -> std::boxed::Box::<[T], A>" is filtered.
Add std::convert::From::<std::vec::Vec::<T, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:743 ~ alloc[2c7c]::boxed::{impl#89}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:744 ~ alloc[2c7c]::boxed::{impl#89}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:742 ~ alloc[2c7c]::boxed::{impl#89})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'b, str>) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'b, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:736 ~ alloc[2c7c]::boxed::{impl#87}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:735 ~ alloc[2c7c]::boxed::{impl#87})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:730 ~ alloc[2c7c]::boxed::{impl#85}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:729 ~ alloc[2c7c]::boxed::{impl#85})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4835 ~ alloc[2c7c]::ffi::c_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<std::ffi::CString>>::from(std::ffi::CString) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<std::ffi::CString> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:733 ~ alloc[2c7c]::boxed::{impl#86}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:732 ~ alloc[2c7c]::boxed::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:739 ~ alloc[2c7c]::boxed::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:740 ~ alloc[2c7c]::boxed::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:738 ~ alloc[2c7c]::boxed::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'b, str>) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'b, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:718 ~ alloc[2c7c]::boxed::{impl#84}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:717 ~ alloc[2c7c]::boxed::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:664 ~ alloc[2c7c]::boxed::{impl#72}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:665 ~ alloc[2c7c]::boxed::{impl#72}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:663 ~ alloc[2c7c]::boxed::{impl#72})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::convert::AsRef::<T>>::as_ref(&std::boxed::Box::<T, A>) -> &T" is filtered.
Add std::convert::AsRef::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:672 ~ alloc[2c7c]::boxed::{impl#74}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:673 ~ alloc[2c7c]::boxed::{impl#74}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(5:671 ~ alloc[2c7c]::boxed::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Add std::marker::Unpin Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("I"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:549 ~ alloc[2c7c]::boxed::{impl#47}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:550 ~ alloc[2c7c]::boxed::{impl#47}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator)), segments: [PathSegment { name: "FusedIterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("I")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(5:548 ~ alloc[2c7c]::boxed::{impl#47})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:507 ~ alloc[2c7c]::boxed::{impl#39}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:508 ~ alloc[2c7c]::boxed::{impl#39}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::DerefMut
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::DerefMut")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3564 ~ core[b693]::ops::deref::DerefMut))
impl_def_id: DefId(5:506 ~ alloc[2c7c]::boxed::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::ops::DerefMut>::deref_mut(&mut std::boxed::Box::<T, A>) -> &mut T" is filtered.
Add std::ops::DerefMut Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:490 ~ alloc[2c7c]::boxed::{impl#35}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:491 ~ alloc[2c7c]::boxed::{impl#35}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Display
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(5:489 ~ alloc[2c7c]::boxed::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "Args", def_id: DefId(5:575 ~ alloc[2c7c]::boxed::{impl#52}::Args), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:576 ~ alloc[2c7c]::boxed::{impl#52}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:577 ~ alloc[2c7c]::boxed::{impl#52}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Args"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3419 ~ core[b693]::ops::async_function::AsyncFnMut)), segments: [PathSegment { name: "AsyncFnMut", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::async_function::AsyncFnMut
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::async_function::AsyncFnMut")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3419 ~ core[b693]::ops::async_function::AsyncFnMut))
impl_def_id: DefId(5:574 ~ alloc[2c7c]::boxed::{impl#52})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
CallRefFuture: <F as std::ops::async_function::AsyncFnMut::<Args>>::CallRefFuture<'a>
not covered item Item { name: Some("CallRefFuture"), item_id: DefId(DefId(5:578 ~ alloc[2c7c]::boxed::{impl#52}::CallRefFuture)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<F, A> as std::ops::async_function::AsyncFnMut::<Args>>::async_call_mut(&mut std::boxed::Box::<F, A>, Args) -> <std::boxed::Box::<F, A> as std::ops::async_function::AsyncFnMut::<Args>>::CallRefFuture<'_>" is filtered.
Add std::ops::async_function::AsyncFnMut::<Args> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:386 ~ alloc[2c7c]::boxed::{impl#15}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:387 ~ alloc[2c7c]::boxed::{impl#15}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:385 ~ alloc[2c7c]::boxed::{impl#15})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::cmp::PartialOrd>::partial_cmp(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
"fn <std::boxed::Box::<T, A> as std::cmp::PartialOrd>::lt(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> bool" is filtered.
"fn <std::boxed::Box::<T, A> as std::cmp::PartialOrd>::le(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> bool" is filtered.
"fn <std::boxed::Box::<T, A> as std::cmp::PartialOrd>::ge(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> bool" is filtered.
"fn <std::boxed::Box::<T, A> as std::cmp::PartialOrd>::gt(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> bool" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "Args", def_id: DefId(5:563 ~ alloc[2c7c]::boxed::{impl#50}::Args), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:564 ~ alloc[2c7c]::boxed::{impl#50}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:565 ~ alloc[2c7c]::boxed::{impl#50}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Args"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3586 ~ core[b693]::ops::function::Fn)), segments: [PathSegment { name: "Fn", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::function::Fn
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::function::Fn")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3586 ~ core[b693]::ops::function::Fn))
impl_def_id: DefId(5:562 ~ alloc[2c7c]::boxed::{impl#50})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<F, A> as std::ops::function::Fn::<Args>>::call(&std::boxed::Box::<F, A>, Args) -> <std::boxed::Box::<F, A> as std::ops::function::FnOnce::<Args>>::Output" is filtered.
Add std::ops::function::Fn::<Args> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Array(Generic("T"), "N")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:462 ~ alloc[2c7c]::boxed::{impl#30}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:463 ~ alloc[2c7c]::boxed::{impl#30}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Array(Generic("T"), "N"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:461 ~ alloc[2c7c]::boxed::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T;N]> is not fuzzable
assoc types:
Error: std::boxed::Box::<[T]>
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:464 ~ alloc[2c7c]::boxed::{impl#30}::Error)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::boxed::Box::<[T]>>>::try_from(std::boxed::Box::<[T]>) -> std::result::Result::<std::boxed::Box::<[T;N]>, <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::boxed::Box::<[T]>>>::Error>" is filtered.
Add std::convert::TryFrom::<std::boxed::Box::<[T]>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Array(Generic("T"), "N")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:467 ~ alloc[2c7c]::boxed::{impl#31}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:468 ~ alloc[2c7c]::boxed::{impl#31}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Array(Generic("T"), "N"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:466 ~ alloc[2c7c]::boxed::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T;N]> is not fuzzable
assoc types:
Error: std::vec::Vec::<T>
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:469 ~ alloc[2c7c]::boxed::{impl#31}::Error)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::vec::Vec::<T>>>::try_from(std::vec::Vec::<T>) -> std::result::Result::<std::boxed::Box::<[T;N]>, <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::vec::Vec::<T>>>::Error>" is filtered.
Add std::convert::TryFrom::<std::vec::Vec::<T>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:668 ~ alloc[2c7c]::boxed::{impl#73}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:669 ~ alloc[2c7c]::boxed::{impl#73}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::convert::AsMut
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(5:667 ~ alloc[2c7c]::boxed::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::convert::AsMut::<T>>::as_mut(&mut std::boxed::Box::<T, A>) -> &mut T" is filtered.
Add std::convert::AsMut::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "Args", def_id: DefId(5:552 ~ alloc[2c7c]::boxed::{impl#48}::Args), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:553 ~ alloc[2c7c]::boxed::{impl#48}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:554 ~ alloc[2c7c]::boxed::{impl#48}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Args"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::function::FnOnce
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::function::FnOnce")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3592 ~ core[b693]::ops::function::FnOnce))
impl_def_id: DefId(5:551 ~ alloc[2c7c]::boxed::{impl#48})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
Output: <F as std::ops::function::FnOnce::<Args>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:555 ~ alloc[2c7c]::boxed::{impl#48}::Output)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<F, A> as std::ops::function::FnOnce::<Args>>::call_once(std::boxed::Box::<F, A>, Args) -> <std::boxed::Box::<F, A> as std::ops::function::FnOnce::<Args>>::Output" is filtered.
Add std::ops::function::FnOnce::<Args> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:378 ~ alloc[2c7c]::boxed::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:374 ~ alloc[2c7c]::boxed::{impl#12}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:375 ~ alloc[2c7c]::boxed::{impl#12}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:373 ~ alloc[2c7c]::boxed::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:651 ~ alloc[2c7c]::boxed::{impl#69}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:652 ~ alloc[2c7c]::boxed::{impl#69}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:650 ~ alloc[2c7c]::boxed::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:4833 ~ alloc[2c7c]::ffi::c_str::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:394 ~ alloc[2c7c]::boxed::{impl#16}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:395 ~ alloc[2c7c]::boxed::{impl#16}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(5:393 ~ alloc[2c7c]::boxed::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::cmp::Ord>::cmp(&std::boxed::Box::<T, A>, &std::boxed::Box::<T, A>) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::boxed::Box::<T, A> as std::cmp::Ord>::max(std::boxed::Box::<T, A>, std::boxed::Box::<T, A>) -> std::boxed::Box::<T, A>" is filtered.
[Impl] add default impl: min
"fn <std::boxed::Box::<T, A> as std::cmp::Ord>::min(std::boxed::Box::<T, A>, std::boxed::Box::<T, A>) -> std::boxed::Box::<T, A>" is filtered.
[Impl] add default impl: clamp
"fn <std::boxed::Box::<T, A> as std::cmp::Ord>::clamp(std::boxed::Box::<T, A>, std::boxed::Box::<T, A>, std::boxed::Box::<T, A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:656 ~ alloc[2c7c]::boxed::{impl#70}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:657 ~ alloc[2c7c]::boxed::{impl#70}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(5:655 ~ alloc[2c7c]::boxed::{impl#70})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::borrow::Borrow::<T>>::borrow(&std::boxed::Box::<T, A>) -> &T" is filtered.
Add std::borrow::Borrow::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "Args", def_id: DefId(5:582 ~ alloc[2c7c]::boxed::{impl#53}::Args), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:583 ~ alloc[2c7c]::boxed::{impl#53}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:584 ~ alloc[2c7c]::boxed::{impl#53}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Args"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3416 ~ core[b693]::ops::async_function::AsyncFn)), segments: [PathSegment { name: "AsyncFn", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::async_function::AsyncFn
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::async_function::AsyncFn")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3416 ~ core[b693]::ops::async_function::AsyncFn))
impl_def_id: DefId(5:581 ~ alloc[2c7c]::boxed::{impl#53})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<F, A> as std::ops::async_function::AsyncFn::<Args>>::async_call(&std::boxed::Box::<F, A>, Args) -> <std::boxed::Box::<F, A> as std::ops::async_function::AsyncFnMut::<Args>>::CallRefFuture<'_>" is filtered.
Add std::ops::async_function::AsyncFn::<Args> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:615 ~ alloc[2c7c]::boxed::{impl#61}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:616 ~ alloc[2c7c]::boxed::{impl#61}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:617 ~ alloc[2c7c]::boxed::{impl#61}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:614 ~ alloc[2c7c]::boxed::{impl#61})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:622 ~ alloc[2c7c]::boxed::{impl#62}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:623 ~ alloc[2c7c]::boxed::{impl#62}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:624 ~ alloc[2c7c]::boxed::{impl#62}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:621 ~ alloc[2c7c]::boxed::{impl#62})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("I")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:609 ~ alloc[2c7c]::boxed::{impl#60}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:610 ~ alloc[2c7c]::boxed::{impl#60}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:608 ~ alloc[2c7c]::boxed::{impl#60})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:367 ~ alloc[2c7c]::boxed::{impl#10}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:366 ~ alloc[2c7c]::boxed::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::default::Default>::default() -> std::boxed::Box::<[T]>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:4856 ~ alloc[2c7c]::ffi::c_str::{impl#23})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::default::Default>::default() -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:370 ~ alloc[2c7c]::boxed::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::default::Default>::default() -> std::boxed::Box::<str>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:364 ~ alloc[2c7c]::boxed::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3142 ~ core[b693]::default::Default)), segments: [PathSegment { name: "Default", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:363 ~ alloc[2c7c]::boxed::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T> as std::default::Default>::default() -> std::boxed::Box::<T>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("I"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:544 ~ alloc[2c7c]::boxed::{impl#46}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:545 ~ alloc[2c7c]::boxed::{impl#46}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8446 ~ core[b693]::iter::traits::exact_size::ExactSizeIterator)), segments: [PathSegment { name: "ExactSizeIterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::exact_size::ExactSizeIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("I")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::exact_size::ExactSizeIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8446 ~ core[b693]::iter::traits::exact_size::ExactSizeIterator))
impl_def_id: DefId(5:543 ~ alloc[2c7c]::boxed::{impl#46})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:401 ~ alloc[2c7c]::boxed::{impl#18}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:402 ~ alloc[2c7c]::boxed::{impl#18}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(5:400 ~ alloc[2c7c]::boxed::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<T, A> as std::hash::Hash>::hash(&std::boxed::Box::<T, A>, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::boxed::Box::<T, A> as std::hash::Hash>::hash_slice(&[std::boxed::Box::<T, A>], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "Args", def_id: DefId(5:558 ~ alloc[2c7c]::boxed::{impl#49}::Args), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:559 ~ alloc[2c7c]::boxed::{impl#49}::F), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:560 ~ alloc[2c7c]::boxed::{impl#49}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Args"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3589 ~ core[b693]::ops::function::FnMut)), segments: [PathSegment { name: "FnMut", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::function::FnMut
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("F")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::function::FnMut")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3589 ~ core[b693]::ops::function::FnMut))
impl_def_id: DefId(5:557 ~ alloc[2c7c]::boxed::{impl#49})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<F, A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<F, A> as std::ops::function::FnMut::<Args>>::call_mut(&mut std::boxed::Box::<F, A>, Args) -> <std::boxed::Box::<F, A> as std::ops::function::FnOnce::<Args>>::Output" is filtered.
Add std::ops::function::FnMut::<Args> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("G"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "G", def_id: DefId(5:675 ~ alloc[2c7c]::boxed::{impl#75}::G), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "R", def_id: DefId(5:676 ~ alloc[2c7c]::boxed::{impl#75}::R), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:677 ~ alloc[2c7c]::boxed::{impl#75}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("G"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3533 ~ core[b693]::ops::coroutine::Coroutine)), segments: [PathSegment { name: "Coroutine", args: AngleBracketed { args: [Type(Generic("R"))], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32876 ~ core[b693]::marker::Unpin)), segments: [PathSegment { name: "Unpin", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::coroutine::Coroutine
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("G")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::coroutine::Coroutine")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3533 ~ core[b693]::ops::coroutine::Coroutine))
impl_def_id: DefId(5:674 ~ alloc[2c7c]::boxed::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<G, A> is not fuzzable
assoc types:
Yield: <G as std::ops::coroutine::Coroutine::<R>>::Yield
Return: <G as std::ops::coroutine::Coroutine::<R>>::Return
not covered item Item { name: Some("Yield"), item_id: DefId(DefId(5:678 ~ alloc[2c7c]::boxed::{impl#75}::Yield)), kind: AssocType, docs: "" }
not covered item Item { name: Some("Return"), item_id: DefId(DefId(5:679 ~ alloc[2c7c]::boxed::{impl#75}::Return)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<G, A> as std::ops::coroutine::Coroutine::<R>>::resume(std::pin::Pin::<&mut std::boxed::Box::<G, A>>, R) -> std::ops::coroutine::CoroutineState::<<std::boxed::Box::<G, A> as std::ops::coroutine::Coroutine::<R>>::Yield, <std::boxed::Box::<G, A> as std::ops::coroutine::Coroutine::<R>>::Return>" is filtered.
Add std::ops::coroutine::Coroutine::<R> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:511 ~ alloc[2c7c]::boxed::{impl#40}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:512 ~ alloc[2c7c]::boxed::{impl#40}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::DerefPure
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::DerefPure")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3569 ~ core[b693]::ops::deref::DerefPure))
impl_def_id: DefId(5:510 ~ alloc[2c7c]::boxed::{impl#40})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Add std::ops::DerefPure Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:398 ~ alloc[2c7c]::boxed::{impl#17}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:399 ~ alloc[2c7c]::boxed::{impl#17}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(5:397 ~ alloc[2c7c]::boxed::{impl#17})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:6292 ~ alloc[2c7c]::sync::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:6293 ~ alloc[2c7c]::sync::{impl#29}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:6105 ~ alloc[2c7c]::sync::Arc)), segments: [PathSegment { name: "Arc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::sync::Arc")
type_def_id: Some(DefId(5:6105 ~ alloc[2c7c]::sync::Arc))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:6291 ~ alloc[2c7c]::sync::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::sync::Arc"
std::sync::Arc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:6294 ~ alloc[2c7c]::sync::{impl#29}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::Arc::<T, A> as std::ops::Deref>::deref(&std::sync::Arc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:898 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:899 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:883 ~ alloc[2c7c]::collections::binary_heap::PeekMut)), segments: [PathSegment { name: "PeekMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::collections::binary_heap::PeekMut")
type_def_id: Some(DefId(5:883 ~ alloc[2c7c]::collections::binary_heap::PeekMut))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:897 ~ alloc[2c7c]::collections::binary_heap::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::collections::binary_heap::PeekMut"
std::collections::binary_heap::PeekMut::<'_, T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:900 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::collections::binary_heap::PeekMut::<'_, T, A> as std::ops::Deref>::deref(&std::collections::binary_heap::PeekMut::<'_, T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8072 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8073 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8074 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8060 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8061 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8062 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8054 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8055 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8056 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7330 ~ alloc[2c7c]::vec::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:7331 ~ alloc[2c7c]::vec::{impl#8}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7185 ~ alloc[2c7c]::vec::Vec)), segments: [PathSegment { name: "Vec", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::vec::Vec")
type_def_id: Some(DefId(5:7185 ~ alloc[2c7c]::vec::Vec))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:7329 ~ alloc[2c7c]::vec::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::vec::Vec"
std::vec::Vec::<T, A> is not fuzzable
assoc types:
Target: [T]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:7332 ~ alloc[2c7c]::vec::{impl#8}::Target)), kind: AssocType, docs: "" }
"fn <std::vec::Vec::<T, A> as std::ops::Deref>::deref(&std::vec::Vec::<T, A>) -> &[T]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7481 ~ alloc[2c7c]::vec::{impl#39}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:7482 ~ alloc[2c7c]::vec::{impl#39}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:7480 ~ alloc[2c7c]::vec::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T], A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T], A> as std::convert::From::<std::vec::Vec::<T, A>>>::from(std::vec::Vec::<T, A>) -> std::boxed::Box::<[T], A>" is filtered.
Add std::convert::From::<std::vec::Vec::<T, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Array(Generic("T"), "N")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:467 ~ alloc[2c7c]::boxed::{impl#31}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:468 ~ alloc[2c7c]::boxed::{impl#31}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Array(Generic("T"), "N"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:466 ~ alloc[2c7c]::boxed::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T;N]> is not fuzzable
assoc types:
Error: std::vec::Vec::<T>
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:469 ~ alloc[2c7c]::boxed::{impl#31}::Error)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::vec::Vec::<T>>>::try_from(std::vec::Vec::<T>) -> std::result::Result::<std::boxed::Box::<[T;N]>, <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::vec::Vec::<T>>>::Error>" is filtered.
Add std::convert::TryFrom::<std::vec::Vec::<T>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(U8)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: Path { path: Path { res: Def(Struct, DefId(5:7185 ~ alloc[2c7c]::vec::Vec)), segments: [PathSegment { name: "Vec", args: AngleBracketed { args: [Type(Primitive(U8))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("alloc::vec::Vec")
type_def_id: Some(DefId(5:7185 ~ alloc[2c7c]::vec::Vec))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1020 ~ regex[3103]::re_bytes::{impl#32})
is_local_impl: true
is_external_type: true
type_name: "std::vec::Vec"
std::vec::Vec::<u8> is not fuzzable
assoc types:
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1017 ~ regex[3103]::re_bytes::{impl#31}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7185 ~ alloc[2c7c]::vec::Vec)), segments: [PathSegment { name: "Vec", args: AngleBracketed { args: [Type(Primitive(U8))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("alloc::vec::Vec")
type_def_id: Some(DefId(5:7185 ~ alloc[2c7c]::vec::Vec))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1016 ~ regex[3103]::re_bytes::{impl#31})
is_local_impl: true
is_external_type: true
type_name: "std::vec::Vec"
&std::vec::Vec::<u8> is not fuzzable
assoc types:
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5150 ~ alloc[2c7c]::rc::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:5151 ~ alloc[2c7c]::rc::{impl#25}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:4981 ~ alloc[2c7c]::rc::Rc)), segments: [PathSegment { name: "Rc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::rc::Rc")
type_def_id: Some(DefId(5:4981 ~ alloc[2c7c]::rc::Rc))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5149 ~ alloc[2c7c]::rc::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::rc::Rc"
std::rc::Rc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5152 ~ alloc[2c7c]::rc::{impl#25}::Target)), kind: AssocType, docs: "" }
"fn <std::rc::Rc::<T, A> as std::ops::Deref>::deref(&std::rc::Rc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5393 ~ alloc[2c7c]::rc::{impl#79}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:5394 ~ alloc[2c7c]::rc::{impl#79}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7747 ~ alloc[2c7c]::rc::UniqueRc)), segments: [PathSegment { name: "UniqueRc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::rc::UniqueRc")
type_def_id: Some(DefId(5:7747 ~ alloc[2c7c]::rc::UniqueRc))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5392 ~ alloc[2c7c]::rc::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::rc::UniqueRc"
std::rc::UniqueRc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5395 ~ alloc[2c7c]::rc::{impl#79}::Target)), kind: AssocType, docs: "" }
"fn <std::rc::UniqueRc::<T, A> as std::ops::Deref>::deref(&std::rc::UniqueRc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:2424 ~ regex[3103]::re_set::bytes::{impl#5})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:2430 ~ regex[3103]::re_set::bytes::{impl#7})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::double_ended::DoubleEndedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::double_ended::DoubleEndedIterator")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator))
impl_def_id: DefId(0:2428 ~ regex[3103]::re_set::bytes::{impl#6})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2459 ~ regex[3103]::re_set::bytes::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2462 ~ regex[3103]::re_set::bytes::{impl#16})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: None
impl_def_id: DefId(0:1231 ~ regex[3103]::re_unicode::{impl#18})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureLocations"
regex::CaptureLocations is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2567 ~ regex[3103]::re_unicode::{impl#50})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::CaptureLocations")
type_def_id: Some(DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2565 ~ regex[3103]::re_unicode::{impl#49})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureLocations"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: None
impl_def_id: DefId(0:2170 ~ regex[3103]::re_builder::set_unicode::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexSetBuilder"
regex::RegexSetBuilder is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::RegexSetBuilder")
type_def_id: Some(DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2188 ~ regex[3103]::re_builder::set_unicode::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexSetBuilder"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:816 ~ regex[3103]::re_bytes::{impl#0}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: None
impl_def_id: DefId(0:815 ~ regex[3103]::re_bytes::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
regex::bytes::Match::<'_> is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2191 ~ regex[3103]::re_bytes::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2821 ~ core[b693]::clone::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2820 ~ core[b693]::clone::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2198 ~ regex[3103]::re_bytes::{impl#38}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2197 ~ regex[3103]::re_bytes::{impl#38})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:825 ~ regex[3103]::re_bytes::{impl#1}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:824 ~ regex[3103]::re_bytes::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Usize)])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:828 ~ regex[3103]::re_bytes::{impl#2}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "ops", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::ops::range::Range")
type_def_id: Some(DefId(2:40163 ~ core[b693]::ops::range::Range))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(0:827 ~ regex[3103]::re_bytes::{impl#2})
is_local_impl: true
is_external_type: true
type_name: "std::ops::range::Range"
std::ops::range::Range::<usize> is not fuzzable
assoc types:
Add std::convert::From::<regex::bytes::Match::<'t>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2206 ~ regex[3103]::re_bytes::{impl#41}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(0:2205 ~ regex[3103]::re_bytes::{impl#41})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
regex::bytes::Match::<'_> is not fuzzable
assoc types:
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <regex::bytes::Match::<'_> as std::cmp::PartialEq>::ne(&regex::bytes::Match::<'_>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2204 ~ regex[3103]::re_bytes::{impl#40}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(0:2203 ~ regex[3103]::re_bytes::{impl#40})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
regex::bytes::Match::<'_> is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2196 ~ regex[3103]::re_bytes::{impl#37}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(0:2195 ~ regex[3103]::re_bytes::{impl#37})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
regex::bytes::Match::<'_> is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2201 ~ regex[3103]::re_bytes::{impl#39}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("regex::bytes::Match")
type_def_id: Some(DefId(0:2190 ~ regex[3103]::re_bytes::Match))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(0:2200 ~ regex[3103]::re_bytes::{impl#39})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Match"
regex::bytes::Match::<'_> is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2536 ~ regex[3103]::re_unicode::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1202 ~ regex[3103]::re_unicode::{impl#11}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:1201 ~ regex[3103]::re_unicode::{impl#11})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2542 ~ regex[3103]::re_unicode::{impl#46}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2541 ~ regex[3103]::re_unicode::{impl#46})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1212 ~ regex[3103]::re_unicode::{impl#13}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:1211 ~ regex[3103]::re_unicode::{impl#13})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2539 ~ regex[3103]::re_unicode::{impl#45}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2538 ~ regex[3103]::re_unicode::{impl#45})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1210 ~ regex[3103]::re_unicode::{impl#12}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::exact_size::ExactSizeIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::exact_size::ExactSizeIterator")
type_full_name: Some("regex::CaptureNames")
type_def_id: Some(DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames))
trait_def_id: Some(DefId(2:8446 ~ core[b693]::iter::traits::exact_size::ExactSizeIterator))
impl_def_id: DefId(0:1209 ~ regex[3103]::re_unicode::{impl#12})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2290 ~ regex[3103]::re_bytes::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1038 ~ regex[3103]::re_bytes::{impl#36}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::NoExpand"
regex::bytes::NoExpand::<'_> is fuzzable
[TypeContext] add candidate #7: NoExpand::<'_> => Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #8: &mut NoExpand::<'_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #9: &NoExpand::<'_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #10: *NoExpand::<'_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #11: *const NoExpand::<'_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
assoc types:
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2293 ~ regex[3103]::re_bytes::{impl#54}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2292 ~ regex[3103]::re_bytes::{impl#54})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2296 ~ regex[3103]::re_bytes::{impl#55}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::NoExpand")
type_def_id: Some(DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2295 ~ regex[3103]::re_bytes::{impl#55})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::NoExpand"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2232 ~ regex[3103]::re_bytes::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2233 ~ regex[3103]::re_bytes::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:916 ~ regex[3103]::re_bytes::{impl#15}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:917 ~ regex[3103]::re_bytes::{impl#15}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:915 ~ regex[3103]::re_bytes::{impl#15})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2237 ~ regex[3103]::re_bytes::{impl#45}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2238 ~ regex[3103]::re_bytes::{impl#45}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2236 ~ regex[3103]::re_bytes::{impl#45})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:911 ~ regex[3103]::re_bytes::{impl#14}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:912 ~ regex[3103]::re_bytes::{impl#14}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::Split")
type_def_id: Some(DefId(0:2231 ~ regex[3103]::re_bytes::Split))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:910 ~ regex[3103]::re_bytes::{impl#14})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Split"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)), segments: [PathSegment { name: "RefUnwindSafe", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2602 ~ regex[3103]::re_unicode::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2603 ~ regex[3103]::re_unicode::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1318 ~ regex[3103]::re_unicode::{impl#31}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:1319 ~ regex[3103]::re_unicode::{impl#31}::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(0:1311 ~ regex[3103]::re_unicode::Replacer)), segments: [PathSegment { name: "Replacer", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe), Outlives(Lifetime("'a"))], default: None, synthetic: false } }], where_predicates: [] }
impl trait: regex::Replacer
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})
is_local_impl: true
is_external_type: false
type_name: "regex::ReplacerRef"
regex::ReplacerRef::<'_, R> is not fuzzable
assoc types:
bounds to facts ignore lifetime: Lifetime("'a")
bounds to facts ignore lifetime: Lifetime("'a")
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
bounds to facts ignore lifetime: Lifetime("'a")
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2606 ~ regex[3103]::re_unicode::{impl#55}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2607 ~ regex[3103]::re_unicode::{impl#55}::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "$crate", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "fmt", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::ReplacerRef")
type_def_id: Some(DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2605 ~ regex[3103]::re_unicode::{impl#55})
is_local_impl: true
is_external_type: false
type_name: "regex::ReplacerRef"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2554 ~ regex[3103]::re_unicode::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2555 ~ regex[3103]::re_unicode::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2559 ~ regex[3103]::re_unicode::{impl#48}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2560 ~ regex[3103]::re_unicode::{impl#48}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2558 ~ regex[3103]::re_unicode::{impl#48})
is_local_impl: true
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1228 ~ regex[3103]::re_unicode::{impl#17}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1229 ~ regex[3103]::re_unicode::{impl#17}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:1227 ~ regex[3103]::re_unicode::{impl#17})
is_local_impl: true
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1222 ~ regex[3103]::re_unicode::{impl#16}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1223 ~ regex[3103]::re_unicode::{impl#16}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::SplitN")
type_def_id: Some(DefId(0:2553 ~ regex[3103]::re_unicode::SplitN))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:1221 ~ regex[3103]::re_unicode::{impl#16})
is_local_impl: true
is_external_type: false
type_name: "regex::SplitN"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: None
impl_def_id: DefId(0:2395 ~ regex[3103]::re_set::bytes::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexSet"
regex::bytes::RegexSet is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2450 ~ regex[3103]::re_set::bytes::{impl#13})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(0:2408 ~ regex[3103]::re_set::bytes::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexSet"
regex::bytes::RegexSet is not fuzzable
assoc types:
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::RegexSet")
type_def_id: Some(DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2443 ~ regex[3103]::re_set::bytes::{impl#12})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexSet"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)), segments: [PathSegment { name: "RefUnwindSafe", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2281 ~ regex[3103]::re_bytes::ReplacerRef::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2282 ~ regex[3103]::re_bytes::ReplacerRef::R), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("R"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1007 ~ regex[3103]::re_bytes::{impl#29}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:1008 ~ regex[3103]::re_bytes::{impl#29}::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(0:1000 ~ regex[3103]::re_bytes::Replacer)), segments: [PathSegment { name: "Replacer", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe), Outlives(Lifetime("'a"))], default: None, synthetic: false } }], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
regex::bytes::ReplacerRef::<'_, R> is not fuzzable
assoc types:
bounds to facts ignore lifetime: Lifetime("'a")
bounds to facts ignore lifetime: Lifetime("'a")
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
bounds to facts ignore lifetime: Lifetime("'a")
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("R")])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2285 ~ regex[3103]::re_bytes::{impl#53}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "R", def_id: DefId(0:2286 ~ regex[3103]::re_bytes::{impl#53}::R), kind: Type { bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "$crate", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "fmt", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Type(Generic("R"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::ReplacerRef")
type_def_id: Some(DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2284 ~ regex[3103]::re_bytes::{impl#53})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::ReplacerRef"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2224 ~ regex[3103]::re_bytes::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2225 ~ regex[3103]::re_bytes::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:902 ~ regex[3103]::re_bytes::{impl#12}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:903 ~ regex[3103]::re_bytes::{impl#12}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:901 ~ regex[3103]::re_bytes::{impl#12})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2228 ~ regex[3103]::re_bytes::{impl#44}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2229 ~ regex[3103]::re_bytes::{impl#44}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2227 ~ regex[3103]::re_bytes::{impl#44})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:908 ~ regex[3103]::re_bytes::{impl#13}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:909 ~ regex[3103]::re_bytes::{impl#13}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::CaptureMatches")
type_def_id: Some(DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:907 ~ regex[3103]::re_bytes::{impl#13})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: None
impl_def_id: DefId(0:2322 ~ regex[3103]::re_set::unicode::{impl#2})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatches"
regex::SetMatches is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(0:2327 ~ regex[3103]::re_set::unicode::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2332 ~ regex[3103]::re_set::unicode::{impl#4}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(0:2331 ~ regex[3103]::re_set::unicode::{impl#4})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2369 ~ regex[3103]::re_set::unicode::{impl#15})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::SetMatches")
type_def_id: Some(DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2367 ~ regex[3103]::re_set::unicode::{impl#14})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: None
impl_def_id: DefId(0:2099 ~ regex[3103]::re_builder::bytes::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
regex::bytes::RegexBuilder is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::RegexBuilder")
type_def_id: Some(DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2115 ~ regex[3103]::re_builder::bytes::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexBuilder"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5954 ~ alloc[2c7c]::string::{impl#32}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: alloc::string::ToString
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::string::ToString")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(5:5951 ~ alloc[2c7c]::string::ToString))
impl_def_id: DefId(5:5953 ~ alloc[2c7c]::string::{impl#32})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Error"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:332 ~ regex[3103]::error::{impl#2})
is_local_impl: true
is_external_type: false
type_name: "regex::Error"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(0:330 ~ regex[3103]::error::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::Error"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::error::Error
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::error::Error")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:3153 ~ core[b693]::error::Error))
impl_def_id: DefId(0:328 ~ regex[3103]::error::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::Error"
regex::Error is not fuzzable
assoc types:
Add std::error::Error Provide Method. is_local=false
[Impl] add default impl: source
"fn <regex::Error as std::error::Error>::source(&regex::Error) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'static\")))>" is filtered.
[Impl] add default impl: cause
"fn <regex::Error as std::error::Error>::cause(&regex::Error) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)>" is filtered.
[Impl] add default impl: provide
"fn <regex::Error as std::error::Error>::provide(&'a regex::Error, &mut std::error::Request::<'a>) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:1654 ~ regex[3103]::error::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "regex::Error"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(0:1656 ~ regex[3103]::error::{impl#4})
is_local_impl: true
is_external_type: false
type_name: "regex::Error"
regex::Error is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("regex::Error")
type_def_id: Some(DefId(0:1645 ~ regex[3103]::error::Error))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(0:1657 ~ regex[3103]::error::{impl#5})
is_local_impl: true
is_external_type: false
type_name: "regex::Error"
regex::Error is not fuzzable
assoc types:
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <regex::Error as std::cmp::PartialEq>::ne(&regex::Error, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2611 ~ regex[3103]::re_unicode::NoExpand::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2617 ~ regex[3103]::re_unicode::{impl#57}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2616 ~ regex[3103]::re_unicode::{impl#57})
is_local_impl: true
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1348 ~ regex[3103]::re_unicode::{impl#38}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::Replacer
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38})
is_local_impl: true
is_external_type: false
type_name: "regex::NoExpand"
regex::NoExpand::<'_> is fuzzable
[TypeContext] add candidate #12: NoExpand::<'_> => Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #13: &mut NoExpand::<'_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #14: &NoExpand::<'_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #15: *NoExpand::<'_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #16: *const NoExpand::<'_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
assoc types:
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2614 ~ regex[3103]::re_unicode::{impl#56}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::NoExpand")
type_def_id: Some(DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2613 ~ regex[3103]::re_unicode::{impl#56})
is_local_impl: true
is_external_type: false
type_name: "regex::NoExpand"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1122 ~ regex[3103]::re_unicode::{impl#0}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: None
impl_def_id: DefId(0:1121 ~ regex[3103]::re_unicode::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
regex::Match::<'_> is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2512 ~ regex[3103]::re_unicode::Match::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2821 ~ core[b693]::clone::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2820 ~ core[b693]::clone::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Match"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1131 ~ regex[3103]::re_unicode::{impl#1}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:1130 ~ regex[3103]::re_unicode::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2527 ~ regex[3103]::re_unicode::{impl#43}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(0:2526 ~ regex[3103]::re_unicode::{impl#43})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
regex::Match::<'_> is not fuzzable
assoc types:
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <regex::Match::<'_> as std::cmp::PartialEq>::ne(&regex::Match::<'_>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2519 ~ regex[3103]::re_unicode::{impl#40}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2518 ~ regex[3103]::re_unicode::{impl#40})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2517 ~ regex[3103]::re_unicode::{impl#39}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(0:2516 ~ regex[3103]::re_unicode::{impl#39})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
regex::Match::<'_> is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2525 ~ regex[3103]::re_unicode::{impl#42}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(0:2524 ~ regex[3103]::re_unicode::{impl#42})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
regex::Match::<'_> is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:2522 ~ regex[3103]::re_unicode::{impl#41}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("regex::Match")
type_def_id: Some(DefId(0:2511 ~ regex[3103]::re_unicode::Match))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(0:2521 ~ regex[3103]::re_unicode::{impl#41})
is_local_impl: true
is_external_type: false
type_name: "regex::Match"
regex::Match::<'_> is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1134 ~ regex[3103]::re_unicode::{impl#2}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: BorrowedRef { lifetime: Some(Lifetime("'t")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(0:1133 ~ regex[3103]::re_unicode::{impl#2})
is_local_impl: true
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Add std::convert::From::<regex::Match::<'t>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Usize)])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1137 ~ regex[3103]::re_unicode::{impl#3}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "ops", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::ops::range::Range")
type_def_id: Some(DefId(2:40163 ~ core[b693]::ops::range::Range))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(0:1136 ~ regex[3103]::re_unicode::{impl#3})
is_local_impl: true
is_external_type: true
type_name: "std::ops::range::Range"
std::ops::range::Range::<usize> is not fuzzable
assoc types:
Add std::convert::From::<regex::Match::<'t>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: None
impl_def_id: DefId(0:2145 ~ regex[3103]::re_builder::set_bytes::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
regex::bytes::RegexSetBuilder is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::RegexSetBuilder")
type_def_id: Some(DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2163 ~ regex[3103]::re_builder::set_bytes::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::RegexSetBuilder"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2251 ~ regex[3103]::re_bytes::CaptureNames::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:938 ~ regex[3103]::re_bytes::{impl#20}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:937 ~ regex[3103]::re_bytes::{impl#20})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:936 ~ regex[3103]::re_bytes::{impl#19}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::exact_size::ExactSizeIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::exact_size::ExactSizeIterator")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:8446 ~ core[b693]::iter::traits::exact_size::ExactSizeIterator))
impl_def_id: DefId(0:935 ~ regex[3103]::re_bytes::{impl#19})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2254 ~ regex[3103]::re_bytes::{impl#47}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2253 ~ regex[3103]::re_bytes::{impl#47})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2257 ~ regex[3103]::re_bytes::{impl#48}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2256 ~ regex[3103]::re_bytes::{impl#48})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:928 ~ regex[3103]::re_bytes::{impl#18}::'r), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'r"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::CaptureNames")
type_def_id: Some(DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:927 ~ regex[3103]::re_bytes::{impl#18})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureNames"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2593 ~ regex[3103]::re_unicode::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2594 ~ regex[3103]::re_unicode::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1303 ~ regex[3103]::re_unicode::{impl#29}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1304 ~ regex[3103]::re_unicode::{impl#29}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:1302 ~ regex[3103]::re_unicode::{impl#29})
is_local_impl: true
is_external_type: false
type_name: "regex::Matches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2597 ~ regex[3103]::re_unicode::{impl#54}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2598 ~ regex[3103]::re_unicode::{impl#54}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2596 ~ regex[3103]::re_unicode::{impl#54})
is_local_impl: true
is_external_type: false
type_name: "regex::Matches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1309 ~ regex[3103]::re_unicode::{impl#30}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1310 ~ regex[3103]::re_unicode::{impl#30}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::Matches")
type_def_id: Some(DefId(0:2591 ~ regex[3103]::re_unicode::Matches))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:1308 ~ regex[3103]::re_unicode::{impl#30})
is_local_impl: true
is_external_type: false
type_name: "regex::Matches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2215 ~ regex[3103]::re_bytes::Matches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2216 ~ regex[3103]::re_bytes::Matches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:893 ~ regex[3103]::re_bytes::{impl#10}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:894 ~ regex[3103]::re_bytes::{impl#10}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:892 ~ regex[3103]::re_bytes::{impl#10})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2219 ~ regex[3103]::re_bytes::{impl#43}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2220 ~ regex[3103]::re_bytes::{impl#43}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2218 ~ regex[3103]::re_bytes::{impl#43})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:899 ~ regex[3103]::re_bytes::{impl#11}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:900 ~ regex[3103]::re_bytes::{impl#11}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::Matches")
type_def_id: Some(DefId(0:2213 ~ regex[3103]::re_bytes::Matches))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:898 ~ regex[3103]::re_bytes::{impl#11})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Matches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: None
impl_def_id: DefId(0:2307 ~ regex[3103]::re_set::unicode::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexSet"
regex::RegexSet is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2362 ~ regex[3103]::re_set::unicode::{impl#13})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2355 ~ regex[3103]::re_set::unicode::{impl#12})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexSet"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("regex::RegexSet")
type_def_id: Some(DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(0:2320 ~ regex[3103]::re_set::unicode::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexSet"
regex::RegexSet is not fuzzable
assoc types:
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: None
impl_def_id: DefId(0:2410 ~ regex[3103]::re_set::bytes::{impl#2})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatches"
regex::bytes::SetMatches is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2455 ~ regex[3103]::re_set::bytes::{impl#14})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(0:2415 ~ regex[3103]::re_set::bytes::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2420 ~ regex[3103]::re_set::bytes::{impl#4}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(0:2419 ~ regex[3103]::re_set::bytes::{impl#4})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::SetMatches")
type_def_id: Some(DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2457 ~ regex[3103]::re_set::bytes::{impl#15})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2545 ~ regex[3103]::re_unicode::Split::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2546 ~ regex[3103]::re_unicode::Split::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Split"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2550 ~ regex[3103]::re_unicode::{impl#47}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2551 ~ regex[3103]::re_unicode::{impl#47}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2549 ~ regex[3103]::re_unicode::{impl#47})
is_local_impl: true
is_external_type: false
type_name: "regex::Split"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1219 ~ regex[3103]::re_unicode::{impl#15}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1220 ~ regex[3103]::re_unicode::{impl#15}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:1218 ~ regex[3103]::re_unicode::{impl#15})
is_local_impl: true
is_external_type: false
type_name: "regex::Split"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1214 ~ regex[3103]::re_unicode::{impl#14}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1215 ~ regex[3103]::re_unicode::{impl#14}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::Split")
type_def_id: Some(DefId(0:2544 ~ regex[3103]::re_unicode::Split))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:1213 ~ regex[3103]::re_unicode::{impl#14})
is_local_impl: true
is_external_type: false
type_name: "regex::Split"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: None
impl_def_id: DefId(0:1148 ~ regex[3103]::re_unicode::{impl#8})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
regex::Regex is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: None
impl_def_id: DefId(0:1176 ~ regex[3103]::re_unicode::{impl#9})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
regex::Regex is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: None
impl_def_id: DefId(0:1193 ~ regex[3103]::re_unicode::{impl#10})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
regex::Regex is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5954 ~ alloc[2c7c]::string::{impl#32}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: alloc::string::ToString
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::string::ToString")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(5:5951 ~ alloc[2c7c]::string::ToString))
impl_def_id: DefId(5:5953 ~ alloc[2c7c]::string::{impl#32})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(0:1139 ~ regex[3103]::re_unicode::{impl#4})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2532 ~ regex[3103]::re_unicode::{impl#44})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::str::traits::FromStr
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::traits::FromStr")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:13397 ~ core[b693]::str::traits::FromStr))
impl_def_id: DefId(0:1145 ~ regex[3103]::re_unicode::{impl#7})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
regex::Regex is not fuzzable
assoc types:
Err: regex::Error
not covered item Item { name: Some("Err"), item_id: DefId(DefId(0:1146 ~ regex[3103]::re_unicode::{impl#7}::Err)), kind: AssocType, docs: "" }
Add std::str::FromStr Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::Regex")
type_def_id: Some(DefId(0:2529 ~ regex[3103]::re_unicode::Regex))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:1141 ~ regex[3103]::re_unicode::{impl#5})
is_local_impl: true
is_external_type: false
type_name: "regex::Regex"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:950 ~ regex[3103]::re_bytes::{impl#22}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: None
impl_def_id: DefId(0:949 ~ regex[3103]::re_bytes::{impl#22})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Captures"
regex::bytes::Captures::<'_> is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:945 ~ regex[3103]::re_bytes::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:983 ~ regex[3103]::re_bytes::{impl#26}::'t), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'i", def_id: DefId(0:984 ~ regex[3103]::re_bytes::{impl#26}::'i), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:982 ~ regex[3103]::re_bytes::{impl#26})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Captures"
regex::bytes::Captures::<'_> is not fuzzable
assoc types:
Output: [u8]
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:985 ~ regex[3103]::re_bytes::{impl#26}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<&'i str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:960 ~ regex[3103]::re_bytes::{impl#23}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:959 ~ regex[3103]::re_bytes::{impl#23})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Captures"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:977 ~ regex[3103]::re_bytes::{impl#25}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:976 ~ regex[3103]::re_bytes::{impl#25})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Captures"
regex::bytes::Captures::<'_> is not fuzzable
assoc types:
Output: [u8]
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:978 ~ regex[3103]::re_bytes::{impl#25}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<usize> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2570 ~ regex[3103]::re_unicode::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2571 ~ regex[3103]::re_unicode::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:1288 ~ regex[3103]::re_unicode::{impl#25}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1289 ~ regex[3103]::re_unicode::{impl#25}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::exact_size::ExactSizeIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::exact_size::ExactSizeIterator")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:8446 ~ core[b693]::iter::traits::exact_size::ExactSizeIterator))
impl_def_id: DefId(0:1287 ~ regex[3103]::re_unicode::{impl#25})
is_local_impl: true
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:1279 ~ regex[3103]::re_unicode::{impl#24}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1280 ~ regex[3103]::re_unicode::{impl#24}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:1278 ~ regex[3103]::re_unicode::{impl#24})
is_local_impl: true
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2579 ~ regex[3103]::re_unicode::{impl#52}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2580 ~ regex[3103]::re_unicode::{impl#52}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2578 ~ regex[3103]::re_unicode::{impl#52})
is_local_impl: true
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2575 ~ regex[3103]::re_unicode::{impl#51}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2576 ~ regex[3103]::re_unicode::{impl#51}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2574 ~ regex[3103]::re_unicode::{impl#51})
is_local_impl: true
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:1291 ~ regex[3103]::re_unicode::{impl#26}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1292 ~ regex[3103]::re_unicode::{impl#26}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::SubCaptureMatches")
type_def_id: Some(DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:1290 ~ regex[3103]::re_unicode::{impl#26})
is_local_impl: true
is_external_type: false
type_name: "regex::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2241 ~ regex[3103]::re_bytes::SplitN::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2242 ~ regex[3103]::re_bytes::SplitN::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:919 ~ regex[3103]::re_bytes::{impl#16}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:920 ~ regex[3103]::re_bytes::{impl#16}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:918 ~ regex[3103]::re_bytes::{impl#16})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2246 ~ regex[3103]::re_bytes::{impl#46}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2247 ~ regex[3103]::re_bytes::{impl#46}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2245 ~ regex[3103]::re_bytes::{impl#46})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:925 ~ regex[3103]::re_bytes::{impl#17}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:926 ~ regex[3103]::re_bytes::{impl#17}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::SplitN")
type_def_id: Some(DefId(0:2240 ~ regex[3103]::re_bytes::SplitN))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:924 ~ regex[3103]::re_bytes::{impl#17})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SplitN"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2378 ~ regex[3103]::re_set::unicode::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2352 ~ regex[3103]::re_set::unicode::{impl#10}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:2351 ~ regex[3103]::re_set::unicode::{impl#10})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2349 ~ regex[3103]::re_set::unicode::{impl#9}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::double_ended::DoubleEndedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::double_ended::DoubleEndedIterator")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator))
impl_def_id: DefId(0:2348 ~ regex[3103]::re_set::unicode::{impl#9})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2384 ~ regex[3103]::re_set::unicode::{impl#18}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2383 ~ regex[3103]::re_set::unicode::{impl#18})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2381 ~ regex[3103]::re_set::unicode::{impl#17}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2380 ~ regex[3103]::re_set::unicode::{impl#17})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2344 ~ regex[3103]::re_set::unicode::{impl#8}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::SetMatchesIter")
type_def_id: Some(DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:2343 ~ regex[3103]::re_set::unicode::{impl#8})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: None
impl_def_id: DefId(0:2122 ~ regex[3103]::re_builder::unicode::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexBuilder"
regex::RegexBuilder is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::RegexBuilder")
type_def_id: Some(DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2138 ~ regex[3103]::re_builder::unicode::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "regex::RegexBuilder"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2584 ~ regex[3103]::re_unicode::CaptureMatches::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2585 ~ regex[3103]::re_unicode::CaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1294 ~ regex[3103]::re_unicode::{impl#27}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1295 ~ regex[3103]::re_unicode::{impl#27}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:1293 ~ regex[3103]::re_unicode::{impl#27})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:2588 ~ regex[3103]::re_unicode::{impl#53}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2589 ~ regex[3103]::re_unicode::{impl#53}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2587 ~ regex[3103]::re_unicode::{impl#53})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'r", def_id: DefId(0:1300 ~ regex[3103]::re_unicode::{impl#28}::'r), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:1301 ~ regex[3103]::re_unicode::{impl#28}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'r")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::CaptureMatches")
type_def_id: Some(DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:1299 ~ regex[3103]::re_unicode::{impl#28})
is_local_impl: true
is_external_type: false
type_name: "regex::CaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:2342 ~ regex[3103]::re_set::unicode::{impl#7})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:2336 ~ regex[3103]::re_set::unicode::{impl#5})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2374 ~ regex[3103]::re_set::unicode::{impl#16})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::double_ended::DoubleEndedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter)), segments: [PathSegment { name: "SetMatchesIntoIter", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::double_ended::DoubleEndedIterator")
type_full_name: Some("regex::SetMatchesIntoIter")
type_def_id: Some(DefId(0:2371 ~ regex[3103]::re_set::unicode::SetMatchesIntoIter))
trait_def_id: Some(DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator))
impl_def_id: DefId(0:2340 ~ regex[3103]::re_set::unicode::{impl#6})
is_local_impl: true
is_external_type: false
type_name: "regex::SetMatchesIntoIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: None
impl_def_id: DefId(0:940 ~ regex[3103]::re_bytes::{impl#21})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
regex::bytes::CaptureLocations is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2262 ~ regex[3103]::re_bytes::{impl#49})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::CaptureLocations")
type_def_id: Some(DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2264 ~ regex[3103]::re_bytes::{impl#50})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::CaptureLocations"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2267 ~ regex[3103]::re_bytes::SubCaptureMatches::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2268 ~ regex[3103]::re_bytes::SubCaptureMatches::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2276 ~ regex[3103]::re_bytes::{impl#52}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2277 ~ regex[3103]::re_bytes::{impl#52}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2275 ~ regex[3103]::re_bytes::{impl#52})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:991 ~ regex[3103]::re_bytes::{impl#27}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:992 ~ regex[3103]::re_bytes::{impl#27}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:990 ~ regex[3103]::re_bytes::{impl#27})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:2272 ~ regex[3103]::re_bytes::{impl#51}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:2273 ~ regex[3103]::re_bytes::{impl#51}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2271 ~ regex[3103]::re_bytes::{impl#51})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'c", def_id: DefId(0:998 ~ regex[3103]::re_bytes::{impl#28}::'c), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'t", def_id: DefId(0:999 ~ regex[3103]::re_bytes::{impl#28}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'c")), Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::SubCaptureMatches")
type_def_id: Some(DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:997 ~ regex[3103]::re_bytes::{impl#28})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SubCaptureMatches"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1241 ~ regex[3103]::re_unicode::{impl#19}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: None
impl_def_id: DefId(0:1240 ~ regex[3103]::re_unicode::{impl#19})
is_local_impl: true
is_external_type: false
type_name: "regex::Captures"
regex::Captures::<'_> is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1236 ~ regex[3103]::re_unicode::Captures::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::Captures"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1251 ~ regex[3103]::re_unicode::{impl#20}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:1250 ~ regex[3103]::re_unicode::{impl#20})
is_local_impl: true
is_external_type: false
type_name: "regex::Captures"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1265 ~ regex[3103]::re_unicode::{impl#22}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:1264 ~ regex[3103]::re_unicode::{impl#22})
is_local_impl: true
is_external_type: false
type_name: "regex::Captures"
regex::Captures::<'_> is not fuzzable
assoc types:
Output: str
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:1266 ~ regex[3103]::re_unicode::{impl#22}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<usize> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1271 ~ regex[3103]::re_unicode::{impl#23}::'t), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'i", def_id: DefId(0:1272 ~ regex[3103]::re_unicode::{impl#23}::'i), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:1270 ~ regex[3103]::re_unicode::{impl#23})
is_local_impl: true
is_external_type: false
type_name: "regex::Captures"
regex::Captures::<'_> is not fuzzable
assoc types:
Output: str
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:1273 ~ regex[3103]::re_unicode::{impl#23}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<&'i str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: None
impl_def_id: DefId(0:839 ~ regex[3103]::re_bytes::{impl#7})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
regex::bytes::Regex is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: None
impl_def_id: DefId(0:867 ~ regex[3103]::re_bytes::{impl#8})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
regex::bytes::Regex is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: None
impl_def_id: DefId(0:884 ~ regex[3103]::re_bytes::{impl#9})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
regex::bytes::Regex is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5954 ~ alloc[2c7c]::string::{impl#32}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: alloc::string::ToString
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::string::ToString")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(5:5951 ~ alloc[2c7c]::string::ToString))
impl_def_id: DefId(5:5953 ~ alloc[2c7c]::string::{impl#32})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::str::traits::FromStr
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::traits::FromStr")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:13397 ~ core[b693]::str::traits::FromStr))
impl_def_id: DefId(0:836 ~ regex[3103]::re_bytes::{impl#6})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
regex::bytes::Regex is not fuzzable
assoc types:
Err: regex::Error
not covered item Item { name: Some("Err"), item_id: DefId(DefId(0:837 ~ regex[3103]::re_bytes::{impl#6}::Err)), kind: AssocType, docs: "" }
Add std::str::FromStr Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:832 ~ regex[3103]::re_bytes::{impl#4})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2211 ~ regex[3103]::re_bytes::{impl#42})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("regex::bytes::Regex")
type_def_id: Some(DefId(0:2208 ~ regex[3103]::re_bytes::Regex))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(0:830 ~ regex[3103]::re_bytes::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Regex"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2466 ~ regex[3103]::re_set::bytes::SetMatchesIter::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:8330 ~ core[b693]::iter::traits::collect::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("I"))
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2469 ~ regex[3103]::re_set::bytes::{impl#17}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:2468 ~ regex[3103]::re_set::bytes::{impl#17})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2472 ~ regex[3103]::re_set::bytes::{impl#18}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:2471 ~ regex[3103]::re_set::bytes::{impl#18})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2437 ~ regex[3103]::re_set::bytes::{impl#9}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::double_ended::DoubleEndedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::double_ended::DoubleEndedIterator")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator))
impl_def_id: DefId(0:2436 ~ regex[3103]::re_set::bytes::{impl#9})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2440 ~ regex[3103]::re_set::bytes::{impl#10}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::marker::FusedIterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::marker::FusedIterator")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator))
impl_def_id: DefId(0:2439 ~ regex[3103]::re_set::bytes::{impl#10})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:2432 ~ regex[3103]::re_set::bytes::{impl#8}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("regex::bytes::SetMatchesIter")
type_def_id: Some(DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(0:2431 ~ regex[3103]::re_set::bytes::{impl#8})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::SetMatchesIter"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:222 ~ miniz_oxide[68e8]::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<miniz_oxide::StreamResult>>::from(miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:224 ~ miniz_oxide[68e8]::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<&miniz_oxide::StreamResult>>::from(&miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<&miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2519 ~ aho_corasick[9659]::util::primitives::{impl#54}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:2518 ~ aho_corasick[9659]::util::primitives::{impl#54})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: T
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:2520 ~ aho_corasick[9659]::util::primitives::{impl#54}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<aho_corasick::util::primitives::PatternID>>::index(&[T], aho_corasick::util::primitives::PatternID) -> &T" is filtered.
Add std::ops::Index::<aho_corasick::util::primitives::PatternID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2523 ~ aho_corasick[9659]::util::primitives::{impl#55}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:2522 ~ aho_corasick[9659]::util::primitives::{impl#55})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<aho_corasick::util::primitives::PatternID>>::index_mut(&mut [T], aho_corasick::util::primitives::PatternID) -> &mut T" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::primitives::PatternID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:1524 ~ aho_corasick[9659]::util::search::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Output: str
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:1525 ~ aho_corasick[9659]::util::search::{impl#7}::Output)), kind: AssocType, docs: "" }
"fn <str as std::ops::Index::<aho_corasick::util::search::Span>>::index(&str, aho_corasick::util::search::Span) -> &str" is filtered.
Add std::ops::Index::<aho_corasick::util::search::Span> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:1519 ~ aho_corasick[9659]::util::search::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
Output: [u8]
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:1520 ~ aho_corasick[9659]::util::search::{impl#5}::Output)), kind: AssocType, docs: "" }
"fn <[u8] as std::ops::Index::<aho_corasick::util::search::Span>>::index(&[u8], aho_corasick::util::search::Span) -> &[u8]" is filtered.
Add std::ops::Index::<aho_corasick::util::search::Span> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:1522 ~ aho_corasick[9659]::util::search::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn <[u8] as std::ops::IndexMut::<aho_corasick::util::search::Span>>::index_mut(&mut [u8], aho_corasick::util::search::Span) -> &mut [u8]" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::search::Span> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:1405 ~ aho_corasick[9659]::util::primitives::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:1404 ~ aho_corasick[9659]::util::primitives::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: T
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:1406 ~ aho_corasick[9659]::util::primitives::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<aho_corasick::util::primitives::SmallIndex>>::index(&[T], aho_corasick::util::primitives::SmallIndex) -> &T" is filtered.
Add std::ops::Index::<aho_corasick::util::primitives::SmallIndex> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:1409 ~ aho_corasick[9659]::util::primitives::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:1408 ~ aho_corasick[9659]::util::primitives::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<aho_corasick::util::primitives::SmallIndex>>::index_mut(&mut [T], aho_corasick::util::primitives::SmallIndex) -> &mut T" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::primitives::SmallIndex> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2618 ~ aho_corasick[9659]::util::primitives::{impl#82}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:2617 ~ aho_corasick[9659]::util::primitives::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: T
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:2619 ~ aho_corasick[9659]::util::primitives::{impl#82}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<aho_corasick::util::primitives::StateID>>::index(&[T], aho_corasick::util::primitives::StateID) -> &T" is filtered.
Add std::ops::Index::<aho_corasick::util::primitives::StateID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2622 ~ aho_corasick[9659]::util::primitives::{impl#83}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:2621 ~ aho_corasick[9659]::util::primitives::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<aho_corasick::util::primitives::StateID>>::index_mut(&mut [T], aho_corasick::util::primitives::StateID) -> &mut T" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::primitives::StateID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:5268 ~ core[b693]::ffi::c_str::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::PartialOrd>::partial_cmp(&std::ffi::CStr, &std::ffi::CStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::CStr as std::cmp::PartialOrd>::lt(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::CStr as std::cmp::PartialOrd>::le(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::CStr as std::cmp::PartialOrd>::gt(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::CStr as std::cmp::PartialOrd>::ge(&std::ffi::CStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:41118 ~ core[b693]::ffi::c_str::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::hash::Hash>::hash(&std::ffi::CStr, &mut __H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::ffi::CStr as std::hash::Hash>::hash_slice(&[std::ffi::CStr], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:5242 ~ core[b693]::ffi::c_str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Output: std::ffi::CStr
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:5273 ~ core[b693]::ffi::c_str::{impl#11}::Output)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::ops::Index::<std::ops::range::RangeFrom::<usize>>>::index(&std::ffi::CStr, std::ops::range::RangeFrom::<usize>) -> &std::ffi::CStr" is filtered.
Add std::ops::Index::<std::ops::range::RangeFrom::<usize>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:5267 ~ core[b693]::ffi::c_str::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:5265 ~ core[b693]::ffi::c_str::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::PartialEq>::eq(&std::ffi::CStr, &std::ffi::CStr) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::CStr as std::cmp::PartialEq>::ne(&std::ffi::CStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:5244 ~ core[b693]::ffi::c_str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
&std::ffi::CStr is not fuzzable
assoc types:
"fn <&std::ffi::CStr as std::default::Default>::default() -> &std::ffi::CStr" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:5270 ~ core[b693]::ffi::c_str::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::Ord>::cmp(&std::ffi::CStr, &std::ffi::CStr) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::ffi::CStr as std::cmp::Ord>::max(std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
[Impl] add default impl: min
"fn <std::ffi::CStr as std::cmp::Ord>::min(std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
[Impl] add default impl: clamp
"fn <std::ffi::CStr as std::cmp::Ord>::clamp(std::ffi::CStr, std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:5275 ~ core[b693]::ffi::c_str::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::convert::AsRef::<std::ffi::CStr>>::as_ref(&std::ffi::CStr) -> &std::ffi::CStr" is filtered.
Add std::convert::AsRef::<std::ffi::CStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: None
impl_def_id: DefId(2:5249 ~ core[b693]::ffi::c_str::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn std::ffi::CStr::from_ptr(*const i8) -> &'a std::ffi::CStr" is filtered.
"fn std::ffi::CStr::from_bytes_until_nul(&[u8]) -> std::result::Result::<&std::ffi::CStr, std::ffi::FromBytesUntilNulError>" is filtered.
"fn std::ffi::CStr::from_bytes_with_nul(&[u8]) -> std::result::Result::<&std::ffi::CStr, std::ffi::FromBytesWithNulError>" is filtered.
"fn std::ffi::CStr::from_bytes_with_nul_unchecked(&[u8]) -> &std::ffi::CStr" is filtered.
"fn std::ffi::CStr::as_ptr(&std::ffi::CStr) -> *const i8" is filtered.
"fn std::ffi::CStr::count_bytes(&std::ffi::CStr) -> usize" is filtered.
"fn std::ffi::CStr::is_empty(&std::ffi::CStr) -> bool" is filtered.
"fn std::ffi::CStr::to_bytes(&std::ffi::CStr) -> &[u8]" is filtered.
"fn std::ffi::CStr::to_bytes_with_nul(&std::ffi::CStr) -> &[u8]" is filtered.
"fn std::ffi::CStr::bytes(&std::ffi::CStr) -> std::ffi::Bytes::<'_>" is filtered.
"fn std::ffi::CStr::to_str(&std::ffi::CStr) -> std::result::Result::<&str, std::str::error::Utf8Error>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: None
impl_def_id: DefId(5:4883 ~ alloc[2c7c]::ffi::c_str::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn std::ffi::CStr::to_string_lossy(&std::ffi::CStr) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::ffi::CStr::into_c_string(std::boxed::Box::<std::ffi::CStr>) -> std::ffi::CString" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4825 ~ alloc[2c7c]::ffi::c_str::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<&std::ffi::CStr>>::from(&std::ffi::CStr) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<&std::ffi::CStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4827 ~ alloc[2c7c]::ffi::c_str::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>>>::from(std::borrow::Cow::<'_, std::ffi::CStr>) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:4835 ~ alloc[2c7c]::ffi::c_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::convert::From::<std::ffi::CString>>::from(std::ffi::CString) -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::convert::From::<std::ffi::CString> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:4833 ~ alloc[2c7c]::ffi::c_str::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:4856 ~ alloc[2c7c]::ffi::c_str::{impl#23})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::CStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::CStr> as std::default::Default>::default() -> std::boxed::Box::<std::ffi::CStr>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:4872 ~ alloc[2c7c]::ffi::c_str::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Owned: std::ffi::CString
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:4873 ~ alloc[2c7c]::ffi::c_str::{impl#30}::Owned)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::borrow::ToOwned>::to_owned(&std::ffi::CStr) -> std::ffi::CString" is filtered.
"fn <std::ffi::CStr as std::borrow::ToOwned>::clone_into(&std::ffi::CStr, &mut std::ffi::CString) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:472 ~ alloc[2c7c]::boxed::{impl#32}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:471 ~ alloc[2c7c]::boxed::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A> is not fuzzable
assoc types:
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::result::Result::<std::boxed::Box::<T, A>, std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>>" is filtered.
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast_unchecked(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:478 ~ alloc[2c7c]::boxed::{impl#33}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:477 ~ alloc[2c7c]::boxed::{impl#33})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A> is not fuzzable
assoc types:
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::result::Result::<std::boxed::Box::<T, A>, std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>>" is filtered.
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast_unchecked(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:484 ~ alloc[2c7c]::boxed::{impl#34}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:483 ~ alloc[2c7c]::boxed::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: "Any", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A> is not fuzzable
assoc types:
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::result::Result::<std::boxed::Box::<T, A>, std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>>" is filtered.
"fn std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>::downcast_unchecked(std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3957 ~ core[b693]::any::Any)), segments: [PathSegment { name: \"Any\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None), A>) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9214 ~ core[b693]::option::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: None
impl_def_id: DefId(2:9213 ~ core[b693]::option::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn std::option::Option::<T>::is_some(&std::option::Option::<T>) -> bool" is filtered.
"fn std::option::Option::<T>::is_some_and(std::option::Option::<T>, impl GenericParamMap { inner: {\"impl\": [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: \"FnOnce\", args: Parenthesized { inputs: [Generic(\"T\")], output: Some(Primitive(Bool)) } }] }]}, generic_defs: [\"impl\"], type_pred: [] }) -> bool" is filtered.
"fn std::option::Option::<T>::is_none(&std::option::Option::<T>) -> bool" is filtered.
"fn std::option::Option::<T>::is_none_or(std::option::Option::<T>, impl GenericParamMap { inner: {\"impl\": [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: \"FnOnce\", args: Parenthesized { inputs: [Generic(\"T\")], output: Some(Primitive(Bool)) } }] }]}, generic_defs: [\"impl\"], type_pred: [] }) -> bool" is filtered.
"fn std::option::Option::<T>::as_ref(&std::option::Option::<T>) -> std::option::Option::<&T>" is filtered.
"fn std::option::Option::<T>::as_mut(&mut std::option::Option::<T>) -> std::option::Option::<&mut T>" is filtered.
"fn std::option::Option::<T>::as_pin_ref(std::pin::Pin::<&std::option::Option::<T>>) -> std::option::Option::<std::pin::Pin::<&T>>" is filtered.
"fn std::option::Option::<T>::as_pin_mut(std::pin::Pin::<&mut std::option::Option::<T>>) -> std::option::Option::<std::pin::Pin::<&mut T>>" is filtered.
"fn std::option::Option::<T>::as_slice(&std::option::Option::<T>) -> &[T]" is filtered.
"fn std::option::Option::<T>::as_mut_slice(&mut std::option::Option::<T>) -> &mut [T]" is filtered.
"fn std::option::Option::<T>::expect(std::option::Option::<T>, &str) -> T" is filtered.
"fn std::option::Option::<T>::unwrap(std::option::Option::<T>) -> T" is filtered.
"fn std::option::Option::<T>::unwrap_or(std::option::Option::<T>, T) -> T" is filtered.
"fn std::option::Option::<T>::unwrap_or_else(std::option::Option::<T>, F) -> T" is filtered.
"fn std::option::Option::<T>::unwrap_or_default(std::option::Option::<T>) -> T" is filtered.
"fn std::option::Option::<T>::unwrap_unchecked(std::option::Option::<T>) -> T" is filtered.
"fn std::option::Option::<T>::map(std::option::Option::<T>, F) -> std::option::Option::<U>" is filtered.
"fn std::option::Option::<T>::inspect(std::option::Option::<T>, F) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::map_or(std::option::Option::<T>, U, F) -> U" is filtered.
"fn std::option::Option::<T>::map_or_else(std::option::Option::<T>, D, F) -> U" is filtered.
"fn std::option::Option::<T>::ok_or(std::option::Option::<T>, E) -> std::result::Result::<T, E>" is filtered.
"fn std::option::Option::<T>::ok_or_else(std::option::Option::<T>, F) -> std::result::Result::<T, E>" is filtered.
"fn std::option::Option::<T>::as_deref(&std::option::Option::<T>) -> std::option::Option::<&<T as std::ops::Deref>::Target>" is filtered.
"fn std::option::Option::<T>::as_deref_mut(&mut std::option::Option::<T>) -> std::option::Option::<&mut <T as std::ops::Deref>::Target>" is filtered.
"fn std::option::Option::<T>::iter(&std::option::Option::<T>) -> std::option::Iter::<'_, T>" is filtered.
"fn std::option::Option::<T>::iter_mut(&mut std::option::Option::<T>) -> std::option::IterMut::<'_, T>" is filtered.
"fn std::option::Option::<T>::and(std::option::Option::<T>, std::option::Option::<U>) -> std::option::Option::<U>" is filtered.
"fn std::option::Option::<T>::and_then(std::option::Option::<T>, F) -> std::option::Option::<U>" is filtered.
"fn std::option::Option::<T>::filter(std::option::Option::<T>, P) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::or(std::option::Option::<T>, std::option::Option::<T>) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::or_else(std::option::Option::<T>, F) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::xor(std::option::Option::<T>, std::option::Option::<T>) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::insert(&mut std::option::Option::<T>, T) -> &mut T" is filtered.
"fn std::option::Option::<T>::get_or_insert(&mut std::option::Option::<T>, T) -> &mut T" is filtered.
"fn std::option::Option::<T>::get_or_insert_default(&mut std::option::Option::<T>) -> &mut T" is filtered.
"fn std::option::Option::<T>::get_or_insert_with(&mut std::option::Option::<T>, F) -> &mut T" is filtered.
"fn std::option::Option::<T>::take(&mut std::option::Option::<T>) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::take_if(&mut std::option::Option::<T>, P) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::replace(&mut std::option::Option::<T>, T) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<T>::zip(std::option::Option::<T>, std::option::Option::<U>) -> std::option::Option::<(T ,U)>" is filtered.
"fn std::option::Option::<T>::zip_with(std::option::Option::<T>, std::option::Option::<U>, F) -> std::option::Option::<R>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Tuple([Generic("T"), Generic("U")])])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9281 ~ core[b693]::option::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:9282 ~ core[b693]::option::{impl#1}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Tuple([Generic("T"), Generic("U")]))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: None
impl_def_id: DefId(2:9280 ~ core[b693]::option::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<(T ,U)> is not fuzzable
assoc types:
"fn std::option::Option::<(T ,U)>::unzip(std::option::Option::<(T ,U)>) -> (std::option::Option::<T> ,std::option::Option::<U>)" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: None, mutability: Not, type_: Generic("T") }])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9285 ~ core[b693]::option::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: None, mutability: Not, type_: Generic("T") })], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: None
impl_def_id: DefId(2:9284 ~ core[b693]::option::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<&T> is not fuzzable
assoc types:
"fn std::option::Option::<&T>::copied(std::option::Option::<&T>) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<&T>::cloned(std::option::Option::<&T>) -> std::option::Option::<T>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: None, mutability: Mut, type_: Generic("T") }])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9289 ~ core[b693]::option::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: None, mutability: Mut, type_: Generic("T") })], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: None
impl_def_id: DefId(2:9288 ~ core[b693]::option::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<&mut T> is not fuzzable
assoc types:
"fn std::option::Option::<&mut T>::copied(std::option::Option::<&mut T>) -> std::option::Option::<T>" is filtered.
"fn std::option::Option::<&mut T>::cloned(std::option::Option::<&mut T>) -> std::option::Option::<T>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9293 ~ core[b693]::option::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9294 ~ core[b693]::option::{impl#4}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: None
impl_def_id: DefId(2:9292 ~ core[b693]::option::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
std::option::Option::<std::result::Result::<T, E>> is not fuzzable
assoc types:
"fn std::option::Option::<std::result::Result::<T, E>>::transpose(std::option::Option::<std::result::Result::<T, E>>) -> std::result::Result::<std::option::Option::<T>, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9430 ~ core[b693]::option::{impl#43}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: None
impl_def_id: DefId(2:9429 ~ core[b693]::option::{impl#43})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<std::option::Option::<T>> is not fuzzable
assoc types:
"fn std::option::Option::<std::option::Option::<T>>::flatten(std::option::Option::<std::option::Option::<T>>) -> std::option::Option::<T>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("V")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(2:9409 ~ core[b693]::option::{impl#38}::A), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(2:9410 ~ core[b693]::option::{impl#38}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator)), segments: [PathSegment { name: "FromIterator", args: AngleBracketed { args: [Type(Generic("A"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("V"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(2:9408 ~ core[b693]::option::{impl#38})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Generic("T") }])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:9330 ~ core[b693]::option::{impl#12}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:9331 ~ core[b693]::option::{impl#12}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Generic("T") })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:9329 ~ core[b693]::option::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<&mut T> is not fuzzable
assoc types:
"fn <std::option::Option::<&mut T> as std::convert::From::<&mut std::option::Option::<T>>>::from(&'a mut std::option::Option::<T>) -> std::option::Option::<&'a mut T>" is filtered.
Add std::convert::From::<&'a mut std::option::Option::<T>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9323 ~ core[b693]::option::{impl#10}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:9322 ~ core[b693]::option::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::convert::From::<T>>::from(T) -> std::option::Option::<T>" is filtered.
Add std::convert::From::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Generic("T") }])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:9326 ~ core[b693]::option::{impl#11}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:9327 ~ core[b693]::option::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Generic("T") })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:9325 ~ core[b693]::option::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<&T> is not fuzzable
assoc types:
"fn <std::option::Option::<&T> as std::convert::From::<&std::option::Option::<T>>>::from(&'a std::option::Option::<T>) -> std::option::Option::<&'a T>" is filtered.
Add std::convert::From::<&'a std::option::Option::<T>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42588 ~ core[b693]::option::{impl#44}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(2:42587 ~ core[b693]::option::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9339 ~ core[b693]::option::{impl#15}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:9338 ~ core[b693]::option::{impl#15})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::cmp::PartialOrd>::partial_cmp(&std::option::Option::<T>, &std::option::Option::<T>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::option::Option::<T> as std::cmp::PartialOrd>::lt(&std::option::Option::<T>, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::option::Option::<T> as std::cmp::PartialOrd>::le(&std::option::Option::<T>, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::option::Option::<T> as std::cmp::PartialOrd>::gt(&std::option::Option::<T>, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::option::Option::<T> as std::cmp::PartialOrd>::ge(&std::option::Option::<T>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:8307 ~ core[b693]::iter::traits::accum::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:8308 ~ core[b693]::iter::traits::accum::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8280 ~ core[b693]::iter::traits::accum::Product)), segments: [PathSegment { name: "Product", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::accum::Product
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::accum::Product")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:8280 ~ core[b693]::iter::traits::accum::Product))
impl_def_id: DefId(2:8306 ~ core[b693]::iter::traits::accum::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9334 ~ core[b693]::option::{impl#13}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:9333 ~ core[b693]::option::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42596 ~ core[b693]::option::{impl#47}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:42595 ~ core[b693]::option::{impl#47})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::hash::Hash>::hash(&std::option::Option::<T>, &mut __H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::option::Option::<T> as std::hash::Hash>::hash_slice(&[std::option::Option::<T>], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:32742 ~ core[b693]::convert::Infallible)), segments: [PathSegment { name: "Infallible", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9427 ~ core[b693]::option::{impl#42}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::Residual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:32742 ~ core[b693]::convert::Infallible)), segments: [PathSegment { name: "Infallible", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::Residual")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3796 ~ core[b693]::ops::try_trait::Residual))
impl_def_id: DefId(2:9426 ~ core[b693]::option::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
std::option::Option::<std::convert::Infallible> is not fuzzable
assoc types:
TryType: std::option::Option::<T>
not covered item Item { name: Some("TryType"), item_id: DefId(DefId(2:9428 ~ core[b693]::option::{impl#42}::TryType)), kind: AssocType, docs: "" }
Add std::ops::try_trait::Residual::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9306 ~ core[b693]::option::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:9305 ~ core[b693]::option::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:9311 ~ core[b693]::option::{impl#8}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:9312 ~ core[b693]::option::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:9310 ~ core[b693]::option::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:9317 ~ core[b693]::option::{impl#9}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:9318 ~ core[b693]::option::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:9316 ~ core[b693]::option::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42593 ~ core[b693]::option::{impl#46}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:42592 ~ core[b693]::option::{impl#46})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42590 ~ core[b693]::option::{impl#45}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:42589 ~ core[b693]::option::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9299 ~ core[b693]::option::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(2:9298 ~ core[b693]::option::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9336 ~ core[b693]::option::{impl#14}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:9335 ~ core[b693]::option::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::cmp::PartialEq>::eq(&std::option::Option::<T>, &std::option::Option::<T>) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::option::Option::<T> as std::cmp::PartialEq>::ne(&std::option::Option::<T>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9303 ~ core[b693]::option::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:9302 ~ core[b693]::option::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::default::Default>::default() -> std::option::Option::<T>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9342 ~ core[b693]::option::{impl#16}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:9341 ~ core[b693]::option::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::cmp::Ord>::cmp(&std::option::Option::<T>, &std::option::Option::<T>) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::option::Option::<T> as std::cmp::Ord>::max(std::option::Option::<T>, std::option::Option::<T>) -> std::option::Option::<T>" is filtered.
[Impl] add default impl: min
"fn <std::option::Option::<T> as std::cmp::Ord>::min(std::option::Option::<T>, std::option::Option::<T>) -> std::option::Option::<T>" is filtered.
[Impl] add default impl: clamp
"fn <std::option::Option::<T> as std::cmp::Ord>::clamp(std::option::Option::<T>, std::option::Option::<T>, std::option::Option::<T>) -> std::option::Option::<T>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9424 ~ core[b693]::option::{impl#41}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:9423 ~ core[b693]::option::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<()>>>::from_residual(std::ops::try_trait::Yeet::<()>) -> std::option::Option::<T>" is filtered.
Add std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<()>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9421 ~ core[b693]::option::{impl#40}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:9420 ~ core[b693]::option::{impl#40})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::ops::try_trait::FromResidual>::from_residual(std::option::Option::<std::convert::Infallible>) -> std::option::Option::<T>" is filtered.
Add std::ops::try_trait::FromResidual Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:8301 ~ core[b693]::iter::traits::accum::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:8302 ~ core[b693]::iter::traits::accum::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum)), segments: [PathSegment { name: "Sum", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::accum::Sum
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::accum::Sum")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum))
impl_def_id: DefId(2:8300 ~ core[b693]::iter::traits::accum::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9415 ~ core[b693]::option::{impl#39}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::Try
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::Try")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3785 ~ core[b693]::ops::try_trait::Try))
impl_def_id: DefId(2:9414 ~ core[b693]::option::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
Output: T
Residual: std::option::Option::<std::convert::Infallible>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:9416 ~ core[b693]::option::{impl#39}::Output)), kind: AssocType, docs: "" }
not covered item Item { name: Some("Residual"), item_id: DefId(DefId(2:9417 ~ core[b693]::option::{impl#39}::Residual)), kind: AssocType, docs: "" }
"fn <std::option::Option::<T> as std::ops::try_trait::Try>::from_output(<std::option::Option::<T> as std::ops::try_trait::Try>::Output) -> std::option::Option::<T>" is filtered.
"fn <std::option::Option::<T> as std::ops::try_trait::Try>::branch(std::option::Option::<T>) -> std::ops::control_flow::ControlFlow::<<std::option::Option::<T> as std::ops::try_trait::Try>::Residual, <std::option::Option::<T> as std::ops::try_trait::Try>::Output>" is filtered.
Add std::ops::try_trait::Try Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4904 ~ core[b693]::cell::{impl#45}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:4897 ~ core[b693]::cell::RefMut)), segments: [PathSegment { name: "RefMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::RefMut")
type_def_id: Some(DefId(2:4897 ~ core[b693]::cell::RefMut))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:4903 ~ core[b693]::cell::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::cell::RefMut"
std::cell::RefMut::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:4905 ~ core[b693]::cell::{impl#45}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::RefMut::<'_, T> as std::ops::Deref>::deref(&std::cell::RefMut::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:710 ~ alloc[2c7c]::boxed::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "E", def_id: DefId(5:711 ~ alloc[2c7c]::boxed::{impl#82}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), Outlives(Lifetime("'a"))], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:709 ~ alloc[2c7c]::boxed::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<E>>::from(E) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<E> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:714 ~ alloc[2c7c]::boxed::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "E", def_id: DefId(5:715 ~ alloc[2c7c]::boxed::{impl#83}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), Outlives(Lifetime("'a"))], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:713 ~ alloc[2c7c]::boxed::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<E>>::from(E) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<E> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:743 ~ alloc[2c7c]::boxed::{impl#89}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:744 ~ alloc[2c7c]::boxed::{impl#89}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:742 ~ alloc[2c7c]::boxed::{impl#89})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'b, str>) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'b, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:736 ~ alloc[2c7c]::boxed::{impl#87}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:735 ~ alloc[2c7c]::boxed::{impl#87})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:730 ~ alloc[2c7c]::boxed::{impl#85}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:729 ~ alloc[2c7c]::boxed::{impl#85})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:733 ~ alloc[2c7c]::boxed::{impl#86}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:732 ~ alloc[2c7c]::boxed::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:739 ~ alloc[2c7c]::boxed::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:740 ~ alloc[2c7c]::boxed::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:738 ~ alloc[2c7c]::boxed::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'b, str>) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'b, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:718 ~ alloc[2c7c]::boxed::{impl#84}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:717 ~ alloc[2c7c]::boxed::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:946 ~ core[b693]::num::nonzero::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:945 ~ core[b693]::num::nonzero::{impl#8})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:957 ~ core[b693]::num::nonzero::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:34630 ~ core[b693]::ops::bit::BitOr)), segments: [PathSegment { name: "BitOr", args: AngleBracketed { args: [], constraints: [AssocItemConstraint { assoc: PathSegment { name: "Output", args: AngleBracketed { args: [], constraints: [] } }, kind: Equality { term: Type(Generic("T")) } }] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::bit::BitOr
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::bit::BitOr")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(2:34630 ~ core[b693]::ops::bit::BitOr))
impl_def_id: DefId(2:956 ~ core[b693]::num::nonzero::{impl#11})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Usize)])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:828 ~ regex[3103]::re_bytes::{impl#2}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "ops", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::ops::range::Range")
type_def_id: Some(DefId(2:40163 ~ core[b693]::ops::range::Range))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(0:827 ~ regex[3103]::re_bytes::{impl#2})
is_local_impl: true
is_external_type: true
type_name: "std::ops::range::Range"
std::ops::range::Range::<usize> is not fuzzable
assoc types:
Add std::convert::From::<regex::bytes::Match::<'t>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Usize)])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1137 ~ regex[3103]::re_unicode::{impl#3}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "ops", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::ops::range::Range")
type_def_id: Some(DefId(2:40163 ~ core[b693]::ops::range::Range))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(0:1136 ~ regex[3103]::re_unicode::{impl#3})
is_local_impl: true
is_external_type: true
type_name: "std::ops::range::Range"
std::ops::range::Range::<usize> is not fuzzable
assoc types:
Add std::convert::From::<regex::Match::<'t>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4847 ~ core[b693]::cell::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:4841 ~ core[b693]::cell::Ref)), segments: [PathSegment { name: "Ref", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::Ref")
type_def_id: Some(DefId(2:4841 ~ core[b693]::cell::Ref))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:4846 ~ core[b693]::cell::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::cell::Ref"
std::cell::Ref::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:4848 ~ core[b693]::cell::{impl#37}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::Ref::<'_, T> as std::ops::Deref>::deref(&std::cell::Ref::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:1974 ~ core[b693]::mem::manually_drop::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop)), segments: [PathSegment { name: "ManuallyDrop", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::mem::manually_drop::ManuallyDrop")
type_def_id: Some(DefId(2:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:1973 ~ core[b693]::mem::manually_drop::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::mem::manually_drop::ManuallyDrop"
std::mem::manually_drop::ManuallyDrop::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:1975 ~ core[b693]::mem::manually_drop::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::mem::manually_drop::ManuallyDrop::<T> as std::ops::Deref>::deref(&std::mem::manually_drop::ManuallyDrop::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9424 ~ core[b693]::option::{impl#41}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::option::Option")
type_def_id: Some(DefId(2:42580 ~ core[b693]::option::Option))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:9423 ~ core[b693]::option::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::option::Option"
[fuzzable_call_type] generic type = "T"
std::option::Option::<T> is not fuzzable
assoc types:
"fn <std::option::Option::<T> as std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<()>>>::from_residual(std::ops::try_trait::Yeet::<()>) -> std::option::Option::<T>" is filtered.
Add std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<()>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10100 ~ core[b693]::result::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10101 ~ core[b693]::result::{impl#28}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:10102 ~ core[b693]::result::{impl#28}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:10099 ~ core[b693]::result::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, F> is not fuzzable
assoc types:
"fn <std::result::Result::<T, F> as std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>>>::from_residual(std::ops::try_trait::Yeet::<E>) -> std::result::Result::<T, F>" is filtered.
Add std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:41177 ~ core[b693]::ffi::va_list::{impl#8}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:41176 ~ core[b693]::ffi::va_list::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5333 ~ core[b693]::ffi::va_list::{impl#6}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(2:5332 ~ core[b693]::ffi::va_list::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5336 ~ core[b693]::ffi::va_list::{impl#7}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::drop::Drop
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::drop::Drop")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(2:3580 ~ core[b693]::ops::drop::Drop))
impl_def_id: DefId(2:5335 ~ core[b693]::ffi::va_list::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5305 ~ core[b693]::ffi::va_list::{impl#0}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(2:5304 ~ core[b693]::ffi::va_list::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::as_va_list(&'a mut std::ffi::va_list::VaListImpl::<'_>) -> std::ffi::va_list::VaList::<'a, 'f>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5325 ~ core[b693]::ffi::va_list::{impl#5}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(2:5324 ~ core[b693]::ffi::va_list::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::arg(&mut std::ffi::va_list::VaListImpl::<'_>) -> T" is filtered.
"fn std::ffi::va_list::VaListImpl::<'_>::with_copy(&std::ffi::va_list::VaListImpl::<'_>, F) -> R" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9928 ~ core[b693]::result::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9929 ~ core[b693]::result::{impl#0}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9927 ~ core[b693]::result::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn std::result::Result::<T, E>::is_ok(&std::result::Result::<T, E>) -> bool" is filtered.
"fn std::result::Result::<T, E>::is_ok_and(std::result::Result::<T, E>, impl GenericParamMap { inner: {\"impl\": [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: \"FnOnce\", args: Parenthesized { inputs: [Generic(\"T\")], output: Some(Primitive(Bool)) } }] }]}, generic_defs: [\"impl\"], type_pred: [] }) -> bool" is filtered.
"fn std::result::Result::<T, E>::is_err(&std::result::Result::<T, E>) -> bool" is filtered.
"fn std::result::Result::<T, E>::is_err_and(std::result::Result::<T, E>, impl GenericParamMap { inner: {\"impl\": [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: \"FnOnce\", args: Parenthesized { inputs: [Generic(\"E\")], output: Some(Primitive(Bool)) } }] }]}, generic_defs: [\"impl\"], type_pred: [] }) -> bool" is filtered.
"fn std::result::Result::<T, E>::ok(std::result::Result::<T, E>) -> std::option::Option::<T>" is filtered.
"fn std::result::Result::<T, E>::err(std::result::Result::<T, E>) -> std::option::Option::<E>" is filtered.
"fn std::result::Result::<T, E>::as_ref(&std::result::Result::<T, E>) -> std::result::Result::<&T, &E>" is filtered.
"fn std::result::Result::<T, E>::as_mut(&mut std::result::Result::<T, E>) -> std::result::Result::<&mut T, &mut E>" is filtered.
"fn std::result::Result::<T, E>::map(std::result::Result::<T, E>, F) -> std::result::Result::<U, E>" is filtered.
"fn std::result::Result::<T, E>::map_or(std::result::Result::<T, E>, U, F) -> U" is filtered.
"fn std::result::Result::<T, E>::map_or_else(std::result::Result::<T, E>, D, F) -> U" is filtered.
"fn std::result::Result::<T, E>::map_err(std::result::Result::<T, E>, O) -> std::result::Result::<T, F>" is filtered.
"fn std::result::Result::<T, E>::inspect(std::result::Result::<T, E>, F) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<T, E>::inspect_err(std::result::Result::<T, E>, F) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<T, E>::as_deref(&std::result::Result::<T, E>) -> std::result::Result::<&<T as std::ops::Deref>::Target, &E>" is filtered.
"fn std::result::Result::<T, E>::as_deref_mut(&mut std::result::Result::<T, E>) -> std::result::Result::<&mut <T as std::ops::Deref>::Target, &mut E>" is filtered.
"fn std::result::Result::<T, E>::iter(&std::result::Result::<T, E>) -> std::result::Iter::<'_, T>" is filtered.
"fn std::result::Result::<T, E>::iter_mut(&mut std::result::Result::<T, E>) -> std::result::IterMut::<'_, T>" is filtered.
"fn std::result::Result::<T, E>::expect(std::result::Result::<T, E>, &str) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_or_default(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::expect_err(std::result::Result::<T, E>, &str) -> E" is filtered.
"fn std::result::Result::<T, E>::unwrap_err(std::result::Result::<T, E>) -> E" is filtered.
"fn std::result::Result::<T, E>::into_ok(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::into_err(std::result::Result::<T, E>) -> E" is filtered.
"fn std::result::Result::<T, E>::and(std::result::Result::<T, E>, std::result::Result::<U, E>) -> std::result::Result::<U, E>" is filtered.
"fn std::result::Result::<T, E>::and_then(std::result::Result::<T, E>, F) -> std::result::Result::<U, E>" is filtered.
"fn std::result::Result::<T, E>::or(std::result::Result::<T, E>, std::result::Result::<T, F>) -> std::result::Result::<T, F>" is filtered.
"fn std::result::Result::<T, E>::or_else(std::result::Result::<T, E>, O) -> std::result::Result::<T, F>" is filtered.
"fn std::result::Result::<T, E>::unwrap_or(std::result::Result::<T, E>, T) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_or_else(std::result::Result::<T, E>, F) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_unchecked(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_err_unchecked(std::result::Result::<T, E>) -> E" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: None, mutability: Not, type_: Generic("T") }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9984 ~ core[b693]::result::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9985 ~ core[b693]::result::{impl#1}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: None, mutability: Not, type_: Generic("T") }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9983 ~ core[b693]::result::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<&T, E> is not fuzzable
assoc types:
"fn std::result::Result::<&T, E>::copied(std::result::Result::<&T, E>) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<&T, E>::cloned(std::result::Result::<&T, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: None, mutability: Mut, type_: Generic("T") }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9991 ~ core[b693]::result::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9992 ~ core[b693]::result::{impl#2}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: None, mutability: Mut, type_: Generic("T") }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9990 ~ core[b693]::result::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<&mut T, E> is not fuzzable
assoc types:
"fn std::result::Result::<&mut T, E>::copied(std::result::Result::<&mut T, E>) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<&mut T, E>::cloned(std::result::Result::<&mut T, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9998 ~ core[b693]::result::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9999 ~ core[b693]::result::{impl#3}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9997 ~ core[b693]::result::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<std::option::Option::<T>, E> is not fuzzable
assoc types:
"fn std::result::Result::<std::option::Option::<T>, E>::transpose(std::result::Result::<std::option::Option::<T>, E>) -> std::option::Option::<std::result::Result::<T, E>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10002 ~ core[b693]::result::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10003 ~ core[b693]::result::{impl#4}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:10001 ~ core[b693]::result::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<std::result::Result::<T, E>, E> is not fuzzable
assoc types:
"fn std::result::Result::<std::result::Result::<T, E>, E>::flatten(std::result::Result::<std::result::Result::<T, E>, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:5828 ~ std[d8a0]::process::{impl#61}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(1:5829 ~ std[d8a0]::process::{impl#61}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:5817 ~ std[d8a0]::process::Termination)), segments: [PathSegment { name: "Termination", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: std::process::Termination
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::process::Termination")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(1:5817 ~ std[d8a0]::process::Termination))
impl_def_id: DefId(1:5827 ~ std[d8a0]::process::{impl#61})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::process::Termination>::report(std::result::Result::<T, E>) -> std::process::ExitCode" is filtered.
Add std::process::Termination Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("V"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(2:10081 ~ core[b693]::result::{impl#25}::A), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10082 ~ core[b693]::result::{impl#25}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(2:10083 ~ core[b693]::result::{impl#25}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator)), segments: [PathSegment { name: "FromIterator", args: AngleBracketed { args: [Type(Generic("A"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("V")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(2:10080 ~ core[b693]::result::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42855 ~ core[b693]::result::{impl#30}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42856 ~ core[b693]::result::{impl#30}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(2:42854 ~ core[b693]::result::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42865 ~ core[b693]::result::{impl#33}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42866 ~ core[b693]::result::{impl#33}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:42864 ~ core[b693]::result::{impl#33})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::partial_cmp(&std::result::Result::<T, E>, &std::result::Result::<T, E>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::lt(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::le(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::gt(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::ge(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:8294 ~ core[b693]::iter::traits::accum::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:8295 ~ core[b693]::iter::traits::accum::{impl#1}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:8296 ~ core[b693]::iter::traits::accum::{impl#1}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8280 ~ core[b693]::iter::traits::accum::Product)), segments: [PathSegment { name: "Product", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::accum::Product
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::accum::Product")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8280 ~ core[b693]::iter::traits::accum::Product))
impl_def_id: DefId(2:8293 ~ core[b693]::iter::traits::accum::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42858 ~ core[b693]::result::{impl#31}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42859 ~ core[b693]::result::{impl#31}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:42857 ~ core[b693]::result::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42881 ~ core[b693]::result::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42882 ~ core[b693]::result::{impl#37}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:42880 ~ core[b693]::result::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::hash::Hash>::hash(&std::result::Result::<T, E>, &mut __H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::result::Result::<T, E> as std::hash::Hash>::hash_slice(&[std::result::Result::<T, E>], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:32742 ~ core[b693]::convert::Infallible)), segments: [PathSegment { name: "Infallible", args: AngleBracketed { args: [], constraints: [] } }] } }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10105 ~ core[b693]::result::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10106 ~ core[b693]::result::{impl#29}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::Residual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:32742 ~ core[b693]::convert::Infallible)), segments: [PathSegment { name: "Infallible", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::Residual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3796 ~ core[b693]::ops::try_trait::Residual))
impl_def_id: DefId(2:10104 ~ core[b693]::result::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<std::convert::Infallible, E> is not fuzzable
assoc types:
TryType: std::result::Result::<T, E>
not covered item Item { name: Some("TryType"), item_id: DefId(DefId(2:10107 ~ core[b693]::result::{impl#29}::TryType)), kind: AssocType, docs: "" }
Add std::ops::try_trait::Residual::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:10018 ~ core[b693]::result::{impl#7}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:10019 ~ core[b693]::result::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10020 ~ core[b693]::result::{impl#7}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:10017 ~ core[b693]::result::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:10025 ~ core[b693]::result::{impl#8}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:10026 ~ core[b693]::result::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10027 ~ core[b693]::result::{impl#8}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:10024 ~ core[b693]::result::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10012 ~ core[b693]::result::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10013 ~ core[b693]::result::{impl#6}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:10011 ~ core[b693]::result::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42877 ~ core[b693]::result::{impl#36}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42878 ~ core[b693]::result::{impl#36}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:42876 ~ core[b693]::result::{impl#36})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42869 ~ core[b693]::result::{impl#34}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42870 ~ core[b693]::result::{impl#34}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:42868 ~ core[b693]::result::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10007 ~ core[b693]::result::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10008 ~ core[b693]::result::{impl#5}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(2:10006 ~ core[b693]::result::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42861 ~ core[b693]::result::{impl#32}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42862 ~ core[b693]::result::{impl#32}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:42860 ~ core[b693]::result::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::cmp::PartialEq>::eq(&std::result::Result::<T, E>, &std::result::Result::<T, E>) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::result::Result::<T, E> as std::cmp::PartialEq>::ne(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42873 ~ core[b693]::result::{impl#35}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42874 ~ core[b693]::result::{impl#35}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:42872 ~ core[b693]::result::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::cmp::Ord>::cmp(&std::result::Result::<T, E>, &std::result::Result::<T, E>) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::result::Result::<T, E> as std::cmp::Ord>::max(std::result::Result::<T, E>, std::result::Result::<T, E>) -> std::result::Result::<T, E>" is filtered.
[Impl] add default impl: min
"fn <std::result::Result::<T, E> as std::cmp::Ord>::min(std::result::Result::<T, E>, std::result::Result::<T, E>) -> std::result::Result::<T, E>" is filtered.
[Impl] add default impl: clamp
"fn <std::result::Result::<T, E> as std::cmp::Ord>::clamp(std::result::Result::<T, E>, std::result::Result::<T, E>, std::result::Result::<T, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10095 ~ core[b693]::result::{impl#27}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10096 ~ core[b693]::result::{impl#27}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:10097 ~ core[b693]::result::{impl#27}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:10094 ~ core[b693]::result::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, F> is not fuzzable
assoc types:
"fn <std::result::Result::<T, F> as std::ops::try_trait::FromResidual::<std::result::Result::<std::convert::Infallible, E>>>::from_residual(std::result::Result::<std::convert::Infallible, E>) -> std::result::Result::<T, F>" is filtered.
Add std::ops::try_trait::FromResidual::<std::result::Result::<std::convert::Infallible, E>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10100 ~ core[b693]::result::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10101 ~ core[b693]::result::{impl#28}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:10102 ~ core[b693]::result::{impl#28}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:10099 ~ core[b693]::result::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, F> is not fuzzable
assoc types:
"fn <std::result::Result::<T, F> as std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>>>::from_residual(std::ops::try_trait::Yeet::<E>) -> std::result::Result::<T, F>" is filtered.
Add std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:8287 ~ core[b693]::iter::traits::accum::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:8288 ~ core[b693]::iter::traits::accum::{impl#0}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:8289 ~ core[b693]::iter::traits::accum::{impl#0}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum)), segments: [PathSegment { name: "Sum", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::accum::Sum
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::accum::Sum")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum))
impl_def_id: DefId(2:8286 ~ core[b693]::iter::traits::accum::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10088 ~ core[b693]::result::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10089 ~ core[b693]::result::{impl#26}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::Try
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::Try")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3785 ~ core[b693]::ops::try_trait::Try))
impl_def_id: DefId(2:10087 ~ core[b693]::result::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Output: T
Residual: std::result::Result::<std::convert::Infallible, E>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:10090 ~ core[b693]::result::{impl#26}::Output)), kind: AssocType, docs: "" }
not covered item Item { name: Some("Residual"), item_id: DefId(DefId(2:10091 ~ core[b693]::result::{impl#26}::Residual)), kind: AssocType, docs: "" }
"fn <std::result::Result::<T, E> as std::ops::try_trait::Try>::from_output(<std::result::Result::<T, E> as std::ops::try_trait::Try>::Output) -> std::result::Result::<T, E>" is filtered.
"fn <std::result::Result::<T, E> as std::ops::try_trait::Try>::branch(std::result::Result::<T, E>) -> std::ops::control_flow::ControlFlow::<<std::result::Result::<T, E> as std::ops::try_trait::Try>::Residual, <std::result::Result::<T, E> as std::ops::try_trait::Try>::Output>" is filtered.
Add std::ops::try_trait::Try Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:222 ~ miniz_oxide[68e8]::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<miniz_oxide::StreamResult>>::from(miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:224 ~ miniz_oxide[68e8]::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<&miniz_oxide::StreamResult>>::from(&miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<&miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }, Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:337 ~ alloc[2c7c]::boxed::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:338 ~ alloc[2c7c]::boxed::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:336 ~ alloc[2c7c]::boxed::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A> is not fuzzable
assoc types:
"fn std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>::assume_init(std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>) -> std::boxed::Box::<T, A>" is filtered.
"fn std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>::write(std::boxed::Box::<std::mem::maybe_uninit::MaybeUninit::<T>, A>, T) -> std::boxed::Box::<T, A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Output: std::ffi::CStr
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:5273 ~ core[b693]::ffi::c_str::{impl#11}::Output)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::ops::Index::<std::ops::range::RangeFrom::<usize>>>::index(&std::ffi::CStr, std::ops::range::RangeFrom::<usize>) -> &std::ffi::CStr" is filtered.
Add std::ops::Index::<std::ops::range::RangeFrom::<usize>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("Ptr")])
impl generics: Generics { params: [GenericParamDef { name: "Ptr", def_id: DefId(2:9693 ~ core[b693]::pin::{impl#13}::Ptr), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Ptr"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:42704 ~ core[b693]::pin::Pin)), segments: [PathSegment { name: "Pin", args: AngleBracketed { args: [Type(Generic("Ptr"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::pin::Pin")
type_def_id: Some(DefId(2:42704 ~ core[b693]::pin::Pin))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:9692 ~ core[b693]::pin::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::pin::Pin"
std::pin::Pin::<Ptr> is not fuzzable
assoc types:
Target: <Ptr as std::ops::Deref>::Target
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:9694 ~ core[b693]::pin::{impl#13}::Target)), kind: AssocType, docs: "" }
"fn <std::pin::Pin::<Ptr> as std::ops::Deref>::deref(&std::pin::Pin::<Ptr>) -> &<Ptr as std::ops::Deref>::Target" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4629 ~ core[b693]::cell::lazy::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:4630 ~ core[b693]::cell::lazy::{impl#2}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:4613 ~ core[b693]::cell::lazy::LazyCell)), segments: [PathSegment { name: "LazyCell", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::lazy::LazyCell")
type_def_id: Some(DefId(2:4613 ~ core[b693]::cell::lazy::LazyCell))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:4628 ~ core[b693]::cell::lazy::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::cell::lazy::LazyCell"
std::cell::lazy::LazyCell::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:4631 ~ core[b693]::cell::lazy::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::lazy::LazyCell::<T, F> as std::ops::Deref>::deref(&std::cell::lazy::LazyCell::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9505 ~ core[b693]::panic::unwind_safe::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:9504 ~ core[b693]::panic::unwind_safe::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Add std::panic::unwind_safe::UnwindSafe Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9528 ~ core[b693]::panic::unwind_safe::{impl#22}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::deref::DerefMut
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::DerefMut")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:3564 ~ core[b693]::ops::deref::DerefMut))
impl_def_id: DefId(2:9527 ~ core[b693]::panic::unwind_safe::{impl#22})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::ops::DerefMut>::deref_mut(&mut std::panic::unwind_safe::AssertUnwindSafe::<T>) -> &mut T" is filtered.
Add std::ops::DerefMut Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9536 ~ core[b693]::panic::unwind_safe::{impl#24}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:9535 ~ core[b693]::panic::unwind_safe::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("S")])
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(2:9547 ~ core[b693]::panic::unwind_safe::{impl#27}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:4528 ~ core[b693]::async_iter::async_iter::AsyncIterator)), segments: [PathSegment { name: "AsyncIterator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::async_iter::async_iter::AsyncIterator
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("S"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::async_iter::async_iter::AsyncIterator")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:4528 ~ core[b693]::async_iter::async_iter::AsyncIterator))
impl_def_id: DefId(2:9546 ~ core[b693]::panic::unwind_safe::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<S> is not fuzzable
assoc types:
Item: <S as std::async_iter::async_iter::AsyncIterator>::Item
not covered item Item { name: Some("Item"), item_id: DefId(DefId(2:9548 ~ core[b693]::panic::unwind_safe::{impl#27}::Item)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<S> as std::async_iter::async_iter::AsyncIterator>::poll_next(std::pin::Pin::<&mut std::panic::unwind_safe::AssertUnwindSafe::<S>>, &mut std::task::wake::Context::<'_>) -> std::task::poll::Poll::<std::option::Option::<<S as std::async_iter::async_iter::AsyncIterator>::Item>>" is filtered.
"fn <std::panic::unwind_safe::AssertUnwindSafe::<S> as std::async_iter::async_iter::AsyncIterator>::size_hint(&std::panic::unwind_safe::AssertUnwindSafe::<S>) -> (usize ,std::option::Option::<usize>)" is filtered.
Add std::async_iter::async_iter::AsyncIterator Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "F", def_id: DefId(2:9542 ~ core[b693]::panic::unwind_safe::{impl#26}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:45483 ~ core[b693]::future::future::Future)), segments: [PathSegment { name: "Future", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::future::future::Future
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::future::future::Future")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:45483 ~ core[b693]::future::future::Future))
impl_def_id: DefId(2:9541 ~ core[b693]::panic::unwind_safe::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<F> is not fuzzable
assoc types:
Output: <F as std::future::future::Future>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:9543 ~ core[b693]::panic::unwind_safe::{impl#26}::Output)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<F> as std::future::future::Future>::poll(std::pin::Pin::<&mut std::panic::unwind_safe::AssertUnwindSafe::<F>>, &mut std::task::wake::Context::<'_>) -> std::task::poll::Poll::<<std::panic::unwind_safe::AssertUnwindSafe::<F> as std::future::future::Future>::Output>" is filtered.
Add std::future::future::Future Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "R", def_id: DefId(2:9531 ~ core[b693]::panic::unwind_safe::{impl#23}::R), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:9532 ~ core[b693]::panic::unwind_safe::{impl#23}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("R")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::function::FnOnce
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::function::FnOnce")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:3592 ~ core[b693]::ops::function::FnOnce))
impl_def_id: DefId(2:9530 ~ core[b693]::panic::unwind_safe::{impl#23})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<F> is not fuzzable
assoc types:
Output: R
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:9533 ~ core[b693]::panic::unwind_safe::{impl#23}::Output)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<F> as std::ops::function::FnOnce::Fn(<unknown>) -> <unknown>>::call_once(std::panic::unwind_safe::AssertUnwindSafe::<F>, ()) -> R" is filtered.
Add std::ops::function::FnOnce::Fn(<unknown>) -> <unknown> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9539 ~ core[b693]::panic::unwind_safe::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3142 ~ core[b693]::default::Default)), segments: [PathSegment { name: "Default", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:9538 ~ core[b693]::panic::unwind_safe::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::default::Default>::default() -> std::panic::unwind_safe::AssertUnwindSafe::<T>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9524 ~ core[b693]::panic::unwind_safe::{impl#21}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:9523 ~ core[b693]::panic::unwind_safe::{impl#21})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:9525 ~ core[b693]::panic::unwind_safe::{impl#21}::Target)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::ops::Deref>::deref(&std::panic::unwind_safe::AssertUnwindSafe::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9509 ~ core[b693]::panic::unwind_safe::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:9508 ~ core[b693]::panic::unwind_safe::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Add std::panic::unwind_safe::RefUnwindSafe Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:5309 ~ core[b693]::ffi::va_list::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'f", def_id: DefId(2:5310 ~ core[b693]::ffi::va_list::{impl#1}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:41179 ~ core[b693]::ffi::va_list::VaList)), segments: [PathSegment { name: "VaList", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::ffi::va_list::VaList")
type_def_id: Some(DefId(2:41179 ~ core[b693]::ffi::va_list::VaList))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:5308 ~ core[b693]::ffi::va_list::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaList"
std::ffi::va_list::VaList::<'_, '_> is not fuzzable
assoc types:
Target: std::ffi::va_list::VaListImpl::<'f>
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:5311 ~ core[b693]::ffi::va_list::{impl#1}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::va_list::VaList::<'_, '_> as std::ops::Deref>::deref(&std::ffi::va_list::VaList::<'_, '_>) -> &std::ffi::va_list::VaListImpl::<'f>" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7055 ~ std[d8a0]::sync::rwlock::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9461 ~ std[d8a0]::sync::rwlock::MappedRwLockReadGuard)), segments: [PathSegment { name: "MappedRwLockReadGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::MappedRwLockReadGuard")
type_def_id: Some(DefId(1:9461 ~ std[d8a0]::sync::rwlock::MappedRwLockReadGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7054 ~ std[d8a0]::sync::rwlock::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::MappedRwLockReadGuard"
std::sync::rwlock::MappedRwLockReadGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7056 ~ std[d8a0]::sync::rwlock::{impl#28}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::MappedRwLockReadGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::MappedRwLockReadGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9023 ~ std[d8a0]::path::{impl#159})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9021 ~ std[d8a0]::path::{impl#158})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9053 ~ std[d8a0]::path::{impl#170})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8933 ~ std[d8a0]::path::{impl#127}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8932 ~ std[d8a0]::path::{impl#127})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9030 ~ std[d8a0]::path::{impl#162}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9029 ~ std[d8a0]::path::{impl#162})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::eq(&std::path::Path, &&'a std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9074 ~ std[d8a0]::path::{impl#178}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9075 ~ std[d8a0]::path::{impl#178}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9073 ~ std[d8a0]::path::{impl#178})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:5560 ~ std[d8a0]::path::{impl#68})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq>::eq(&std::path::Path, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8958 ~ std[d8a0]::path::{impl#135}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8959 ~ std[d8a0]::path::{impl#135}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8957 ~ std[d8a0]::path::{impl#135})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8923 ~ std[d8a0]::path::{impl#123})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9042 ~ std[d8a0]::path::{impl#166}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9041 ~ std[d8a0]::path::{impl#166})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9033 ~ std[d8a0]::path::{impl#163}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9032 ~ std[d8a0]::path::{impl#163})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9090 ~ std[d8a0]::path::{impl#182}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9089 ~ std[d8a0]::path::{impl#182})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8945 ~ std[d8a0]::path::{impl#131}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8944 ~ std[d8a0]::path::{impl#131})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9065 ~ std[d8a0]::path::{impl#175}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9064 ~ std[d8a0]::path::{impl#175})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::eq(&std::ffi::OsStr, &&'a std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9062 ~ std[d8a0]::path::{impl#174}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9061 ~ std[d8a0]::path::{impl#174})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: None
impl_def_id: DefId(1:5485 ~ std[d8a0]::path::{impl#63})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn std::path::Path::new(&S) -> &std::path::Path" is filtered.
"fn std::path::Path::as_os_str(&std::path::Path) -> &std::ffi::OsStr" is filtered.
"fn std::path::Path::as_mut_os_str(&mut std::path::Path) -> &mut std::ffi::OsStr" is filtered.
"fn std::path::Path::to_str(&std::path::Path) -> std::option::Option::<&str>" is filtered.
"fn std::path::Path::to_string_lossy(&std::path::Path) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::path::Path::to_path_buf(&std::path::Path) -> std::path::PathBuf" is filtered.
"fn std::path::Path::is_absolute(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_relative(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::has_root(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::parent(&std::path::Path) -> std::option::Option::<&std::path::Path>" is filtered.
"fn std::path::Path::ancestors(&std::path::Path) -> std::path::Ancestors::<'_>" is filtered.
"fn std::path::Path::file_name(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::strip_prefix(&std::path::Path, P) -> std::result::Result::<&std::path::Path, std::path::StripPrefixError>" is filtered.
"fn std::path::Path::starts_with(&std::path::Path, P) -> bool" is filtered.
"fn std::path::Path::ends_with(&std::path::Path, P) -> bool" is filtered.
"fn std::path::Path::file_stem(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::file_prefix(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::extension(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::join(&std::path::Path, P) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_file_name(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_extension(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_added_extension(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::components(&std::path::Path) -> std::path::Components::<'_>" is filtered.
"fn std::path::Path::iter(&std::path::Path) -> std::path::Iter::<'_>" is filtered.
"fn std::path::Path::display(&std::path::Path) -> std::path::Display::<'_>" is filtered.
"fn std::path::Path::metadata(&std::path::Path) -> std::result::Result::<std::fs::Metadata, std::io::Error>" is filtered.
"fn std::path::Path::symlink_metadata(&std::path::Path) -> std::result::Result::<std::fs::Metadata, std::io::Error>" is filtered.
"fn std::path::Path::canonicalize(&std::path::Path) -> std::result::Result::<std::path::PathBuf, std::io::Error>" is filtered.
"fn std::path::Path::read_link(&std::path::Path) -> std::result::Result::<std::path::PathBuf, std::io::Error>" is filtered.
"fn std::path::Path::read_dir(&std::path::Path) -> std::result::Result::<std::fs::ReadDir, std::io::Error>" is filtered.
"fn std::path::Path::exists(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::try_exists(&std::path::Path) -> std::result::Result::<bool, std::io::Error>" is filtered.
"fn std::path::Path::is_file(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_dir(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_symlink(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::into_path_buf(std::boxed::Box::<std::path::Path>) -> std::path::PathBuf" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5406 ~ std[d8a0]::path::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<std::borrow::Cow::<'_, std::path::Path>>>::from(std::borrow::Cow::<'_, std::path::Path>) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::path::Path>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5410 ~ std[d8a0]::path::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<std::path::PathBuf>>::from(std::path::PathBuf) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<std::path::PathBuf> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5404 ~ std[d8a0]::path::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<&std::path::Path>>::from(&std::path::Path) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<&std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(1:5467 ~ std[d8a0]::path::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
Owned: std::path::PathBuf
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:5468 ~ std[d8a0]::path::{impl#56}::Owned)), kind: AssocType, docs: "" }
"fn <std::path::Path as std::borrow::ToOwned>::to_owned(&std::path::Path) -> std::path::PathBuf" is filtered.
"fn <std::path::Path as std::borrow::ToOwned>::clone_into(&std::path::Path, &mut std::path::PathBuf) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:5551 ~ std[d8a0]::path::{impl#65})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5572 ~ std[d8a0]::path::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::path::Path>>::as_ref(&std::ffi::OsStr) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5549 ~ std[d8a0]::path::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::path::Path) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5570 ~ std[d8a0]::path::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::path::Path>>::as_ref(&std::path::Path) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5578 ~ std[d8a0]::path::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::path::Path>>::as_ref(&str) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:5568 ~ std[d8a0]::path::{impl#72})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::Ord>::cmp(&std::path::Path, &std::path::Path) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::path::Path as std::cmp::Ord>::max(std::path::Path, std::path::Path) -> std::path::Path" is filtered.
[Impl] add default impl: min
"fn <std::path::Path as std::cmp::Ord>::min(std::path::Path, std::path::Path) -> std::path::Path" is filtered.
[Impl] add default impl: clamp
"fn <std::path::Path as std::cmp::Ord>::clamp(std::path::Path, std::path::Path, std::path::Path) -> std::path::Path" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8927 ~ std[d8a0]::path::{impl#125})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8939 ~ std[d8a0]::path::{impl#129}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8938 ~ std[d8a0]::path::{impl#129})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8951 ~ std[d8a0]::path::{impl#133}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8950 ~ std[d8a0]::path::{impl#133})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9096 ~ std[d8a0]::path::{impl#184}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9095 ~ std[d8a0]::path::{impl#184})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9068 ~ std[d8a0]::path::{impl#176}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9067 ~ std[d8a0]::path::{impl#176})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9039 ~ std[d8a0]::path::{impl#165}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9038 ~ std[d8a0]::path::{impl#165})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9036 ~ std[d8a0]::path::{impl#164}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9035 ~ std[d8a0]::path::{impl#164})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::partial_cmp(&std::path::Path, &&'a std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9082 ~ std[d8a0]::path::{impl#180}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9083 ~ std[d8a0]::path::{impl#180}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9081 ~ std[d8a0]::path::{impl#180})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9048 ~ std[d8a0]::path::{impl#168}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9047 ~ std[d8a0]::path::{impl#168})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8966 ~ std[d8a0]::path::{impl#137}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8967 ~ std[d8a0]::path::{impl#137}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8965 ~ std[d8a0]::path::{impl#137})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9025 ~ std[d8a0]::path::{impl#160})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9071 ~ std[d8a0]::path::{impl#177}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9070 ~ std[d8a0]::path::{impl#177})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::partial_cmp(&std::ffi::OsStr, &&'a std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9027 ~ std[d8a0]::path::{impl#161})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:5566 ~ std[d8a0]::path::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd>::partial_cmp(&std::path::Path, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9057 ~ std[d8a0]::path::{impl#172})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:5412 ~ std[d8a0]::path::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:5590 ~ std[d8a0]::path::{impl#81}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(1:5589 ~ std[d8a0]::path::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:5562 ~ std[d8a0]::path::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::hash::Hash>::hash(&std::path::Path, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::path::Path as std::hash::Hash>::hash_slice(&[std::path::Path], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:5565 ~ std[d8a0]::path::{impl#70})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:326 ~ alloc[2c7c]::boxed::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:325 ~ alloc[2c7c]::boxed::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn std::boxed::Box::<[T]>::new_uninit_slice(usize) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>" is filtered.
"fn std::boxed::Box::<[T]>::new_zeroed_slice(usize) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>" is filtered.
"fn std::boxed::Box::<[T]>::try_new_uninit_slice(usize) -> std::result::Result::<std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>, std::alloc::AllocError>" is filtered.
"fn std::boxed::Box::<[T]>::try_new_zeroed_slice(usize) -> std::result::Result::<std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>]>, std::alloc::AllocError>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:332 ~ alloc[2c7c]::boxed::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:333 ~ alloc[2c7c]::boxed::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:331 ~ alloc[2c7c]::boxed::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T], A> is not fuzzable
assoc types:
"fn std::boxed::Box::<[T], A>::new_uninit_slice_in(usize, A) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>" is filtered.
"fn std::boxed::Box::<[T], A>::new_zeroed_slice_in(usize, A) -> std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:342 ~ alloc[2c7c]::boxed::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:343 ~ alloc[2c7c]::boxed::{impl#5}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Path { path: Path { res: Def(Union, DefId(2:31199 ~ core[b693]::mem::maybe_uninit::MaybeUninit)), segments: [PathSegment { name: "MaybeUninit", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } })), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: None
impl_def_id: DefId(5:341 ~ alloc[2c7c]::boxed::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A> is not fuzzable
assoc types:
"fn std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>::assume_init(std::boxed::Box::<[std::mem::maybe_uninit::MaybeUninit::<T>], A>) -> std::boxed::Box::<[T], A>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::Write
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Write")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3664 ~ std[d8a0]::io::Write))
impl_def_id: DefId(1:3237 ~ std[d8a0]::io::impls::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: &mut [u8]
&mut [u8] is not fuzzable
assoc types:
"fn <&mut [u8] as std::io::Write>::write(&mut &mut [u8], &[u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::write_vectored(&mut &mut [u8], &[std::io::IoSlice::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::is_write_vectored(&&mut [u8]) -> bool" is filtered.
"fn <&mut [u8] as std::io::Write>::write_all(&mut &mut [u8], &[u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::flush(&mut &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
Add std::io::Write Provide Method. is_local=false
[Impl] add default impl: write_all_vectored
"fn <&mut [u8] as std::io::Write>::write_all_vectored(&mut &mut [u8], &mut [std::io::IoSlice::<'_>]) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: write_fmt
"fn <&mut [u8] as std::io::Write>::write_fmt(&mut &mut [u8], std::fmt::Arguments::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: by_ref
"fn <&mut [u8] as std::io::Write>::by_ref(&mut &mut [u8]) -> &mut &mut [u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Path { path: Path { res: Def(Enum, DefId(2:40484 ~ core[b693]::ascii::ascii_char::AsciiChar)), segments: [PathSegment { name: "AsciiChar", args: AngleBracketed { args: [], constraints: [] } }] } })
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:4441 ~ core[b693]::ascii::ascii_char::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[std::ascii::ascii_char::AsciiChar] is not fuzzable
assoc types:
"fn [std::ascii::ascii_char::AsciiChar]::as_str(&[std::ascii::ascii_char::AsciiChar]) -> &str" is filtered.
"fn [std::ascii::ascii_char::AsciiChar]::as_bytes(&[std::ascii::ascii_char::AsciiChar]) -> &[u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12907 ~ core[b693]::slice::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:12908 ~ core[b693]::slice::{impl#1}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Array(Generic("T"), "N"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12906 ~ core[b693]::slice::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[[T;N]] is not fuzzable
assoc types:
"fn [[T;N]]::as_flattened(&[[T;N]]) -> &[T]" is filtered.
"fn [[T;N]]::as_flattened_mut(&mut [[T;N]]) -> &mut [T]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(F32))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12911 ~ core[b693]::slice::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [f32]
[f32] is not fuzzable
assoc types:
"fn [f32]::sort_floats(&mut [f32]) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(F64))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12913 ~ core[b693]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [f64]
[f64] is not fuzzable
assoc types:
"fn [f64]::sort_floats(&mut [f64]) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12703 ~ core[b693]::slice::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12702 ~ core[b693]::slice::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn [T]::len(&[T]) -> usize" is filtered.
"fn [T]::is_empty(&[T]) -> bool" is filtered.
"fn [T]::first(&[T]) -> std::option::Option::<&T>" is filtered.
"fn [T]::first_mut(&mut [T]) -> std::option::Option::<&mut T>" is filtered.
"fn [T]::split_first(&[T]) -> std::option::Option::<(&T ,&[T])>" is filtered.
"fn [T]::split_first_mut(&mut [T]) -> std::option::Option::<(&mut T ,&mut [T])>" is filtered.
"fn [T]::split_last(&[T]) -> std::option::Option::<(&T ,&[T])>" is filtered.
"fn [T]::split_last_mut(&mut [T]) -> std::option::Option::<(&mut T ,&mut [T])>" is filtered.
"fn [T]::last(&[T]) -> std::option::Option::<&T>" is filtered.
"fn [T]::last_mut(&mut [T]) -> std::option::Option::<&mut T>" is filtered.
"fn [T]::first_chunk(&[T]) -> std::option::Option::<&[T;N]>" is filtered.
"fn [T]::first_chunk_mut(&mut [T]) -> std::option::Option::<&mut [T;N]>" is filtered.
"fn [T]::split_first_chunk(&[T]) -> std::option::Option::<(&[T;N] ,&[T])>" is filtered.
"fn [T]::split_first_chunk_mut(&mut [T]) -> std::option::Option::<(&mut [T;N] ,&mut [T])>" is filtered.
"fn [T]::split_last_chunk(&[T]) -> std::option::Option::<(&[T] ,&[T;N])>" is filtered.
"fn [T]::split_last_chunk_mut(&mut [T]) -> std::option::Option::<(&mut [T] ,&mut [T;N])>" is filtered.
"fn [T]::last_chunk(&[T]) -> std::option::Option::<&[T;N]>" is filtered.
"fn [T]::last_chunk_mut(&mut [T]) -> std::option::Option::<&mut [T;N]>" is filtered.
"fn [T]::get(&[T], I) -> std::option::Option::<&<I as std::slice::index::SliceIndex::<[T]>>::Output>" is filtered.
"fn [T]::get_mut(&mut [T], I) -> std::option::Option::<&mut <I as std::slice::index::SliceIndex::<[T]>>::Output>" is filtered.
"fn [T]::get_unchecked(&[T], I) -> &<I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
"fn [T]::get_unchecked_mut(&mut [T], I) -> &mut <I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
"fn [T]::as_ptr(&[T]) -> *const T" is filtered.
"fn [T]::as_mut_ptr(&mut [T]) -> *T" is filtered.
"fn [T]::as_ptr_range(&[T]) -> std::ops::range::Range::<*const T>" is filtered.
"fn [T]::as_mut_ptr_range(&mut [T]) -> std::ops::range::Range::<*T>" is filtered.
"fn [T]::swap(&mut [T], usize, usize) -> ()" is filtered.
"fn [T]::swap_unchecked(&mut [T], usize, usize) -> ()" is filtered.
"fn [T]::reverse(&mut [T]) -> ()" is filtered.
"fn [T]::iter(&[T]) -> std::slice::iter::Iter::<'_, T>" is filtered.
"fn [T]::iter_mut(&mut [T]) -> std::slice::iter::IterMut::<'_, T>" is filtered.
"fn [T]::windows(&[T], usize) -> std::slice::iter::Windows::<'_, T>" is filtered.
"fn [T]::chunks(&[T], usize) -> std::slice::iter::Chunks::<'_, T>" is filtered.
"fn [T]::chunks_mut(&mut [T], usize) -> std::slice::iter::ChunksMut::<'_, T>" is filtered.
"fn [T]::chunks_exact(&[T], usize) -> std::slice::iter::ChunksExact::<'_, T>" is filtered.
"fn [T]::chunks_exact_mut(&mut [T], usize) -> std::slice::iter::ChunksExactMut::<'_, T>" is filtered.
"fn [T]::as_chunks_unchecked(&[T]) -> &[[T;N]]" is filtered.
"fn [T]::as_chunks(&[T]) -> (&[[T;N]] ,&[T])" is filtered.
"fn [T]::as_rchunks(&[T]) -> (&[T] ,&[[T;N]])" is filtered.
"fn [T]::array_chunks(&[T]) -> std::slice::iter::ArrayChunks::<'_, T, <const>>" is filtered.
"fn [T]::as_chunks_unchecked_mut(&mut [T]) -> &mut [[T;N]]" is filtered.
"fn [T]::as_chunks_mut(&mut [T]) -> (&mut [[T;N]] ,&mut [T])" is filtered.
"fn [T]::as_rchunks_mut(&mut [T]) -> (&mut [T] ,&mut [[T;N]])" is filtered.
"fn [T]::array_chunks_mut(&mut [T]) -> std::slice::iter::ArrayChunksMut::<'_, T, <const>>" is filtered.
"fn [T]::array_windows(&[T]) -> std::slice::iter::ArrayWindows::<'_, T, <const>>" is filtered.
"fn [T]::rchunks(&[T], usize) -> std::slice::iter::RChunks::<'_, T>" is filtered.
"fn [T]::rchunks_mut(&mut [T], usize) -> std::slice::iter::RChunksMut::<'_, T>" is filtered.
"fn [T]::rchunks_exact(&[T], usize) -> std::slice::iter::RChunksExact::<'_, T>" is filtered.
"fn [T]::rchunks_exact_mut(&mut [T], usize) -> std::slice::iter::RChunksExactMut::<'_, T>" is filtered.
"fn [T]::chunk_by(&[T], F) -> std::slice::iter::ChunkBy::<'_, T, F>" is filtered.
"fn [T]::chunk_by_mut(&mut [T], F) -> std::slice::iter::ChunkByMut::<'_, T, F>" is filtered.
"fn [T]::split_at(&[T], usize) -> (&[T] ,&[T])" is filtered.
"fn [T]::split_at_mut(&mut [T], usize) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::split_at_unchecked(&[T], usize) -> (&[T] ,&[T])" is filtered.
"fn [T]::split_at_mut_unchecked(&mut [T], usize) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::split_at_checked(&[T], usize) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::split_at_mut_checked(&mut [T], usize) -> std::option::Option::<(&mut [T] ,&mut [T])>" is filtered.
"fn [T]::split(&[T], F) -> std::slice::iter::Split::<'_, T, F>" is filtered.
"fn [T]::split_mut(&mut [T], F) -> std::slice::iter::SplitMut::<'_, T, F>" is filtered.
"fn [T]::split_inclusive(&[T], F) -> std::slice::iter::SplitInclusive::<'_, T, F>" is filtered.
"fn [T]::split_inclusive_mut(&mut [T], F) -> std::slice::iter::SplitInclusiveMut::<'_, T, F>" is filtered.
"fn [T]::rsplit(&[T], F) -> std::slice::iter::RSplit::<'_, T, F>" is filtered.
"fn [T]::rsplit_mut(&mut [T], F) -> std::slice::iter::RSplitMut::<'_, T, F>" is filtered.
"fn [T]::splitn(&[T], usize, F) -> std::slice::iter::SplitN::<'_, T, F>" is filtered.
"fn [T]::splitn_mut(&mut [T], usize, F) -> std::slice::iter::SplitNMut::<'_, T, F>" is filtered.
"fn [T]::rsplitn(&[T], usize, F) -> std::slice::iter::RSplitN::<'_, T, F>" is filtered.
"fn [T]::rsplitn_mut(&mut [T], usize, F) -> std::slice::iter::RSplitNMut::<'_, T, F>" is filtered.
"fn [T]::split_once(&[T], F) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::rsplit_once(&[T], F) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::contains(&[T], &T) -> bool" is filtered.
"fn [T]::starts_with(&[T], &[T]) -> bool" is filtered.
"fn [T]::ends_with(&[T], &[T]) -> bool" is filtered.
"fn [T]::strip_prefix(&[T], &P) -> std::option::Option::<&[T]>" is filtered.
"fn [T]::strip_suffix(&[T], &P) -> std::option::Option::<&[T]>" is filtered.
"fn [T]::binary_search(&[T], &T) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::binary_search_by(&'a [T], F) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::binary_search_by_key(&'a [T], &B, F) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::sort_unstable(&mut [T]) -> ()" is filtered.
"fn [T]::sort_unstable_by(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_unstable_by_key(&mut [T], F) -> ()" is filtered.
"fn [T]::select_nth_unstable(&mut [T], usize) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::select_nth_unstable_by(&mut [T], usize, F) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::select_nth_unstable_by_key(&mut [T], usize, F) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::partition_dedup(&mut [T]) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::partition_dedup_by(&mut [T], F) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::partition_dedup_by_key(&mut [T], F) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::rotate_left(&mut [T], usize) -> ()" is filtered.
"fn [T]::rotate_right(&mut [T], usize) -> ()" is filtered.
"fn [T]::fill(&mut [T], T) -> ()" is filtered.
"fn [T]::fill_with(&mut [T], F) -> ()" is filtered.
"fn [T]::clone_from_slice(&mut [T], &[T]) -> ()" is filtered.
"fn [T]::copy_from_slice(&mut [T], &[T]) -> ()" is filtered.
"fn [T]::copy_within(&mut [T], R, usize) -> ()" is filtered.
"fn [T]::swap_with_slice(&mut [T], &mut [T]) -> ()" is filtered.
"fn [T]::align_to(&[T]) -> (&[T] ,&[U] ,&[T])" is filtered.
"fn [T]::align_to_mut(&mut [T]) -> (&mut [T] ,&mut [U] ,&mut [T])" is filtered.
"fn [T]::as_simd(&[T]) -> (&[T] ,&[std::core_simd::vector::Simd::<T, <const>>] ,&[T])" is filtered.
"fn [T]::as_simd_mut(&mut [T]) -> (&mut [T] ,&mut [std::core_simd::vector::Simd::<T, <const>>] ,&mut [T])" is filtered.
"fn [T]::is_sorted(&[T]) -> bool" is filtered.
"fn [T]::is_sorted_by(&'a [T], F) -> bool" is filtered.
"fn [T]::is_sorted_by_key(&'a [T], F) -> bool" is filtered.
"fn [T]::partition_point(&[T], P) -> usize" is filtered.
"fn [T]::take(&mut &'a [T], R) -> std::option::Option::<&'a [T]>" is filtered.
"fn [T]::take_mut(&mut &'a mut [T], R) -> std::option::Option::<&'a mut [T]>" is filtered.
"fn [T]::take_first(&mut &'a [T]) -> std::option::Option::<&'a T>" is filtered.
"fn [T]::take_first_mut(&mut &'a mut [T]) -> std::option::Option::<&'a mut T>" is filtered.
"fn [T]::take_last(&mut &'a [T]) -> std::option::Option::<&'a T>" is filtered.
"fn [T]::take_last_mut(&mut &'a mut [T]) -> std::option::Option::<&'a mut T>" is filtered.
"fn [T]::get_many_unchecked_mut(&mut [T], [usize;N]) -> [&mut T;N]" is filtered.
"fn [T]::get_many_mut(&mut [T], [usize;N]) -> std::result::Result::<[&mut T;N], std::slice::GetManyMutError::<<const>>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:11412 ~ core[b693]::slice::ascii::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::is_ascii(&[u8]) -> bool" is filtered.
"fn [u8]::as_ascii(&[u8]) -> std::option::Option::<&[std::ascii::ascii_char::AsciiChar]>" is filtered.
"fn [u8]::as_ascii_unchecked(&[u8]) -> &[std::ascii::ascii_char::AsciiChar]" is filtered.
"fn [u8]::eq_ignore_ascii_case(&[u8], &[u8]) -> bool" is filtered.
"fn [u8]::make_ascii_uppercase(&mut [u8]) -> ()" is filtered.
"fn [u8]::make_ascii_lowercase(&mut [u8]) -> ()" is filtered.
"fn [u8]::escape_ascii(&[u8]) -> std::slice::ascii::EscapeAscii::<'_>" is filtered.
"fn [u8]::trim_ascii_start(&[u8]) -> &[u8]" is filtered.
"fn [u8]::trim_ascii_end(&[u8]) -> &[u8]" is filtered.
"fn [u8]::trim_ascii(&[u8]) -> &[u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:13662 ~ core[b693]::str::lossy::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::utf8_chunks(&[u8]) -> std::str::lossy::Utf8Chunks::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5522 ~ alloc[2c7c]::slice::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(5:5521 ~ alloc[2c7c]::slice::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn [T]::sort(&mut [T]) -> ()" is filtered.
"fn [T]::sort_by(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_by_key(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_by_cached_key(&mut [T], F) -> ()" is filtered.
"fn [T]::to_vec(&[T]) -> std::vec::Vec::<T>" is filtered.
"fn [T]::to_vec_in(&[T], A) -> std::vec::Vec::<T, A>" is filtered.
"fn [T]::into_vec(std::boxed::Box::<[T], A>) -> std::vec::Vec::<T, A>" is filtered.
"fn [T]::repeat(&[T], usize) -> std::vec::Vec::<T>" is filtered.
"fn [T]::concat(&[T]) -> <[T] as std::slice::Concat::<Item>>::Output" is filtered.
"fn [T]::join(&[T], Separator) -> <[T] as std::slice::Join::<Separator>>::Output" is filtered.
"fn [T]::connect(&[T], Separator) -> <[T] as std::slice::Join::<Separator>>::Output" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(5:5548 ~ alloc[2c7c]::slice::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::to_ascii_uppercase(&[u8]) -> std::vec::Vec::<u8>" is filtered.
"fn [u8]::to_ascii_lowercase(&[u8]) -> std::vec::Vec::<u8>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:3889 ~ std[d8a0]::net::socket_addr::{impl#13}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: std::net::socket_addr::ToSocketAddrs
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Path { path: Path { res: Def(Enum, DefId(2:42520 ~ core[b693]::net::socket_addr::SocketAddr)), segments: [PathSegment { name: "SocketAddr", args: AngleBracketed { args: [], constraints: [] } }] } }) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::net::socket_addr::ToSocketAddrs")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3856 ~ std[d8a0]::net::socket_addr::ToSocketAddrs))
impl_def_id: DefId(1:3888 ~ std[d8a0]::net::socket_addr::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[std::net::SocketAddr] is not fuzzable
assoc types:
Iter: std::iter::adapters::cloned::Cloned::<std::slice::iter::Iter::<'a, std::net::SocketAddr>>
not covered item Item { name: Some("Iter"), item_id: DefId(DefId(1:3890 ~ std[d8a0]::net::socket_addr::{impl#13}::Iter)), kind: AssocType, docs: "" }
"fn <&[std::net::SocketAddr] as std::net::ToSocketAddrs>::to_socket_addrs(&&[std::net::SocketAddr]) -> std::result::Result::<<&'a [std::net::SocketAddr] as std::net::ToSocketAddrs>::Iter, std::io::Error>" is filtered.
Add std::net::ToSocketAddrs Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(1:2259 ~ std[d8a0]::ffi::os_str::{impl#51}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::ffi::OsString
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:2260 ~ std[d8a0]::ffi::os_str::{impl#51}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&std::ffi::OsStr>>::join(&[S], &std::ffi::OsStr) -> std::ffi::OsString" is filtered.
Add std::slice::Join::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::BufRead
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::BufRead")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3692 ~ std[d8a0]::io::BufRead))
impl_def_id: DefId(1:3234 ~ std[d8a0]::io::impls::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
[TypeContext] add candidate #17: &mut &[u8] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) } }
[TypeContext] add candidate #18: &&[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) } }
[TypeContext] add candidate #19: *&[u8] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })
[TypeContext] add candidate #20: *const &[u8] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })
assoc types:
"fn <&[u8] as std::io::BufRead>::fill_buf(&mut &[u8]) -> std::result::Result::<&[u8], std::io::Error>" is filtered.
"fn <&[u8] as std::io::BufRead>::consume(&mut &[u8], usize) -> ()" is filtered.
Add std::io::BufRead Provide Method. is_local=false
[Impl] add default impl: has_data_left
"fn <&[u8] as std::io::BufRead>::has_data_left(&mut &[u8]) -> std::result::Result::<bool, std::io::Error>" is filtered.
[Impl] add default impl: read_until
"fn <&[u8] as std::io::BufRead>::read_until(&mut &[u8], u8, &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: skip_until
"fn <&[u8] as std::io::BufRead>::skip_until(&mut &[u8], u8) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: read_line
"fn <&[u8] as std::io::BufRead>::read_line(&mut &[u8], &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: split
"fn <&[u8] as std::io::BufRead>::split(&[u8], u8) -> std::io::Split::<&[u8]>" is filtered.
[Impl] add default impl: lines
"fn <&[u8] as std::io::BufRead>::lines(&[u8]) -> std::io::Lines::<&[u8]>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::Read
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Read")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3607 ~ std[d8a0]::io::Read))
impl_def_id: DefId(1:3224 ~ std[d8a0]::io::impls::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
assoc types:
"fn <&[u8] as std::io::Read>::read(&mut &[u8], &mut [u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_buf(&mut &[u8], std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_vectored(&mut &[u8], &mut [std::io::IoSliceMut::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::is_read_vectored(&&[u8]) -> bool" is filtered.
"fn <&[u8] as std::io::Read>::read_exact(&mut &[u8], &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_buf_exact(&mut &[u8], std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_to_end(&mut &[u8], &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_to_string(&mut &[u8], &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
Add std::io::Read Provide Method. is_local=false
[Impl] add default impl: by_ref
"fn <&[u8] as std::io::Read>::by_ref(&mut &[u8]) -> &mut &[u8]" is filtered.
[Impl] add default impl: bytes
"fn <&[u8] as std::io::Read>::bytes(&[u8]) -> std::io::Bytes::<&[u8]>" is filtered.
[Impl] add default impl: chain
"fn <&[u8] as std::io::Read>::chain(&[u8], R) -> std::io::Chain::<&[u8], R>" is filtered.
[Impl] add default impl: take
"fn <&[u8] as std::io::Read>::take(&[u8], u64) -> std::io::Take::<&[u8]>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::ascii::AsciiExt
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::ascii::AsciiExt")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:646 ~ std[d8a0]::ascii::AsciiExt))
impl_def_id: DefId(1:659 ~ std[d8a0]::ascii::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
Owned: std::vec::Vec::<u8>
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:660 ~ std[d8a0]::ascii::{impl#2}::Owned)), kind: AssocType, docs: "" }
"fn <[u8] as std::ascii::AsciiExt>::is_ascii(&[u8]) -> bool" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::to_ascii_uppercase(&[u8]) -> <[u8] as std::ascii::AsciiExt>::Owned" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::to_ascii_lowercase(&[u8]) -> <[u8] as std::ascii::AsciiExt>::Owned" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::eq_ignore_ascii_case(&[u8], &[u8]) -> bool" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::make_ascii_uppercase(&mut [u8]) -> ()" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::make_ascii_lowercase(&mut [u8]) -> ()" is filtered.
Add std::ascii::AsciiExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11475 ~ core[b693]::slice::cmp::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:11474 ~ core[b693]::slice::cmp::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialOrd>::partial_cmp(&[T], &[T]) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <[T] as std::cmp::PartialOrd>::lt(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <[T] as std::cmp::PartialOrd>::le(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <[T] as std::cmp::PartialOrd>::gt(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <[T] as std::cmp::PartialOrd>::ge(&[T], &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:13570 ~ core[b693]::str::pattern::{impl#24}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(2:13571 ~ core[b693]::str::pattern::{impl#24}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::str::pattern::Pattern
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Slice(Primitive(Char)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::pattern::Pattern")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:13443 ~ core[b693]::str::pattern::Pattern))
impl_def_id: DefId(2:13569 ~ core[b693]::str::pattern::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[char] is fuzzable
[TypeContext] add candidate #21: &[char] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }
[TypeContext] add candidate #22: &mut &[char] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) } }
[TypeContext] add candidate #23: &&[char] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) } }
[TypeContext] add candidate #24: *&[char] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) })
[TypeContext] add candidate #25: *const &[char] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) })
assoc types:
Searcher: std::str::pattern::CharSliceSearcher::<'a, 'b>
not covered item Item { name: Some("Searcher"), item_id: DefId(DefId(2:45083 ~ core[b693]::str::pattern::{impl#24}::Searcher)), kind: AssocType, docs: "" }
"fn <&[char] as std::str::pattern::Pattern::<'_>>::into_searcher(&[char], &'a str) -> std::str::pattern::CharSliceSearcher::<'a, 'b>" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_contained_in(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_prefix_of(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::strip_prefix_of(&[char], &'a str) -> std::option::Option::<&'a str>" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_suffix_of(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::strip_suffix_of(&[char], &'a str) -> std::option::Option::<&'a str>" is filtered.
Add std::str::pattern::Pattern::<'a> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:32841 ~ core[b693]::marker::{impl#35}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:32840 ~ core[b693]::marker::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10972 ~ core[b693]::hash::impls::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:10971 ~ core[b693]::hash::impls::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::hash::Hash>::hash(&[T], &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <[T] as std::hash::Hash>::hash_slice(&[[T]], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:11729 ~ core[b693]::slice::iter::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:11730 ~ core[b693]::slice::iter::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:11728 ~ core[b693]::slice::iter::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:11735 ~ core[b693]::slice::iter::{impl#2}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:11736 ~ core[b693]::slice::iter::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:11734 ~ core[b693]::slice::iter::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2824 ~ core[b693]::clone::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2823 ~ core[b693]::clone::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::clone::CloneToUninit>::clone_to_uninit(&[T], *[T]) -> ()" is filtered.
Add std::clone::CloneToUninit Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2827 ~ core[b693]::clone::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2826 ~ core[b693]::clone::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::clone::CloneToUninit>::clone_to_uninit(&[T], *[T]) -> ()" is filtered.
Add std::clone::CloneToUninit Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10802 ~ core[b693]::fmt::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:10801 ~ core[b693]::fmt::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:32929 ~ core[b693]::marker::{impl#93}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32908 ~ core[b693]::marker::ConstParamTy)), segments: [PathSegment { name: "ConstParamTy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::marker::ConstParamTy
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::ConstParamTy")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:32908 ~ core[b693]::marker::ConstParamTy))
impl_def_id: DefId(2:32928 ~ core[b693]::marker::{impl#93})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::marker::ConstParamTy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11527 ~ core[b693]::slice::index::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "I", def_id: DefId(2:11528 ~ core[b693]::slice::index::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(2:11526 ~ core[b693]::slice::index::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<I>>::index_mut(&mut [T], I) -> &mut <I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
Add std::ops::IndexMut::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11522 ~ core[b693]::slice::index::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "I", def_id: DefId(2:11523 ~ core[b693]::slice::index::{impl#0}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:11521 ~ core[b693]::slice::index::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: <I as std::slice::index::SliceIndex::<[T]>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:11524 ~ core[b693]::slice::index::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<I>>::index(&[T], I) -> &<I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
Add std::ops::Index::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11470 ~ core[b693]::slice::cmp::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:11469 ~ core[b693]::slice::cmp::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3114 ~ core[b693]::convert::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::AsMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(2:3113 ~ core[b693]::convert::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::convert::AsMut::<[T]>>::as_mut(&mut [T]) -> &mut [T]" is filtered.
Add std::convert::AsMut::<[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12934 ~ core[b693]::slice::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::slice::SlicePattern
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::slice::SlicePattern")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:12930 ~ core[b693]::slice::SlicePattern))
impl_def_id: DefId(2:12933 ~ core[b693]::slice::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Item: T
not covered item Item { name: Some("Item"), item_id: DefId(DefId(2:12935 ~ core[b693]::slice::{impl#8}::Item)), kind: AssocType, docs: "" }
"fn <[T] as std::slice::SlicePattern>::as_slice(&[T]) -> &[<[T] as std::slice::SlicePattern>::Item]" is filtered.
Add std::slice::SlicePattern Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4123 ~ core[b693]::array::equality::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4124 ~ core[b693]::array::equality::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4122 ~ core[b693]::array::equality::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::eq(&&mut [T], &[U;N]) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::ne(&&mut [T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4099 ~ core[b693]::array::equality::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4100 ~ core[b693]::array::equality::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4098 ~ core[b693]::array::equality::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::eq(&[T], &[U;N]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::ne(&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4111 ~ core[b693]::array::equality::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4112 ~ core[b693]::array::equality::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4110 ~ core[b693]::array::equality::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::eq(&&[T], &[U;N]) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::ne(&&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11465 ~ core[b693]::slice::cmp::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:11466 ~ core[b693]::slice::cmp::{impl#0}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:11464 ~ core[b693]::slice::cmp::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U]>>::eq(&[T], &[U]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U]>>::ne(&[T], &[U]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12928 ~ core[b693]::slice::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:12927 ~ core[b693]::slice::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::default::Default>::default() -> &mut [T]" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12925 ~ core[b693]::slice::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:12924 ~ core[b693]::slice::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::default::Default>::default() -> &[T]" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11472 ~ core[b693]::slice::cmp::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:11471 ~ core[b693]::slice::cmp::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::Ord>::cmp(&[T], &[T]) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <[T] as std::cmp::Ord>::max([T], [T]) -> [T]" is filtered.
[Impl] add default impl: min
"fn <[T] as std::cmp::Ord>::min([T], [T]) -> [T]" is filtered.
[Impl] add default impl: clamp
"fn <[T] as std::cmp::Ord>::clamp([T], [T], [T]) -> [T]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11727 ~ core[b693]::slice::iter::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(2:11726 ~ core[b693]::slice::iter::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3111 ~ core[b693]::convert::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:3110 ~ core[b693]::convert::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::convert::AsRef::<[T]>>::as_ref(&[T]) -> &[T]" is filtered.
Add std::convert::AsRef::<[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:13877 ~ core[b693]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<[u8]>>::as_ref(&str) -> &[u8]" is filtered.
Add std::convert::AsRef::<[u8]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:601 ~ alloc[2c7c]::boxed::{impl#58}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:602 ~ alloc[2c7c]::boxed::{impl#58}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:603 ~ alloc[2c7c]::boxed::{impl#58}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:600 ~ alloc[2c7c]::boxed::{impl#58})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:605 ~ alloc[2c7c]::boxed::{impl#59}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:606 ~ alloc[2c7c]::boxed::{impl#59}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:607 ~ alloc[2c7c]::boxed::{impl#59}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:604 ~ alloc[2c7c]::boxed::{impl#59})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("I")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:598 ~ alloc[2c7c]::boxed::{impl#57}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:599 ~ alloc[2c7c]::boxed::{impl#57}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(5:597 ~ alloc[2c7c]::boxed::{impl#57})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("I"))])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:594 ~ alloc[2c7c]::boxed::{impl#56}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:593 ~ alloc[2c7c]::boxed::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8072 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8073 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8074 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8060 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8061 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8062 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8054 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8055 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8056 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:441 ~ alloc[2c7c]::boxed::{impl#24}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:440 ~ alloc[2c7c]::boxed::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<&[T]>>::from(&[T]) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<&[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:444 ~ alloc[2c7c]::boxed::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:443 ~ alloc[2c7c]::boxed::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<std::borrow::Cow::<'_, [T]>>>::from(std::borrow::Cow::<'_, [T]>) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, [T]>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Primitive(U8)), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:451 ~ alloc[2c7c]::boxed::{impl#28}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Primitive(U8))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:450 ~ alloc[2c7c]::boxed::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[u8], A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[u8], A> as std::convert::From::<std::boxed::Box::<str, A>>>::from(std::boxed::Box::<str, A>) -> std::boxed::Box::<[u8], A>" is filtered.
Add std::convert::From::<std::boxed::Box::<str, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:454 ~ alloc[2c7c]::boxed::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:455 ~ alloc[2c7c]::boxed::{impl#29}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:453 ~ alloc[2c7c]::boxed::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<[T;N]>>::from([T;N]) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<[T;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7481 ~ alloc[2c7c]::vec::{impl#39}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:7482 ~ alloc[2c7c]::vec::{impl#39}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:7480 ~ alloc[2c7c]::vec::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T], A> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T], A> as std::convert::From::<std::vec::Vec::<T, A>>>::from(std::vec::Vec::<T, A>) -> std::boxed::Box::<[T], A>" is filtered.
Add std::convert::From::<std::vec::Vec::<T, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5681 ~ alloc[2c7c]::str::{impl#1}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5680 ~ alloc[2c7c]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5682 ~ alloc[2c7c]::str::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&str>>::join(&[S], &str) -> std::string::String" is filtered.
Add std::slice::Join::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5566 ~ alloc[2c7c]::slice::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5567 ~ alloc[2c7c]::slice::{impl#3}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5568 ~ alloc[2c7c]::slice::{impl#3}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&T>>::join(&[V], &T) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5572 ~ alloc[2c7c]::slice::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5573 ~ alloc[2c7c]::slice::{impl#4}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5571 ~ alloc[2c7c]::slice::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5574 ~ alloc[2c7c]::slice::{impl#4}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&[T]>>::join(&[V], &[T]) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:651 ~ alloc[2c7c]::boxed::{impl#69}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:652 ~ alloc[2c7c]::boxed::{impl#69}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:650 ~ alloc[2c7c]::boxed::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5677 ~ alloc[2c7c]::str::{impl#0}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(5:5676 ~ alloc[2c7c]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5678 ~ alloc[2c7c]::str::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Concat::<str>>::concat(&[S]) -> std::string::String" is filtered.
Add std::slice::Concat::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5560 ~ alloc[2c7c]::slice::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5561 ~ alloc[2c7c]::slice::{impl#2}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(5:5559 ~ alloc[2c7c]::slice::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5562 ~ alloc[2c7c]::slice::{impl#2}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Concat::<T>>::concat(&[V]) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Concat::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:615 ~ alloc[2c7c]::boxed::{impl#61}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:616 ~ alloc[2c7c]::boxed::{impl#61}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:617 ~ alloc[2c7c]::boxed::{impl#61}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:614 ~ alloc[2c7c]::boxed::{impl#61})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:622 ~ alloc[2c7c]::boxed::{impl#62}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "I", def_id: DefId(5:623 ~ alloc[2c7c]::boxed::{impl#62}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:624 ~ alloc[2c7c]::boxed::{impl#62}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:621 ~ alloc[2c7c]::boxed::{impl#62})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("I")), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(5:609 ~ alloc[2c7c]::boxed::{impl#60}::I), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:610 ~ alloc[2c7c]::boxed::{impl#60}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("I"))), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:608 ~ alloc[2c7c]::boxed::{impl#60})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:367 ~ alloc[2c7c]::boxed::{impl#10}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:366 ~ alloc[2c7c]::boxed::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::default::Default>::default() -> std::boxed::Box::<[T]>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5598 ~ alloc[2c7c]::slice::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:5597 ~ alloc[2c7c]::slice::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Owned: std::vec::Vec::<T>
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:5599 ~ alloc[2c7c]::slice::{impl#9}::Owned)), kind: AssocType, docs: "" }
"fn <[T] as std::borrow::ToOwned>::to_owned(&[T]) -> std::vec::Vec::<T>" is filtered.
"fn <[T] as std::borrow::ToOwned>::clone_into(&[T], &mut std::vec::Vec::<T>) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2519 ~ aho_corasick[9659]::util::primitives::{impl#54}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:2518 ~ aho_corasick[9659]::util::primitives::{impl#54})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: T
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:2520 ~ aho_corasick[9659]::util::primitives::{impl#54}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<aho_corasick::util::primitives::PatternID>>::index(&[T], aho_corasick::util::primitives::PatternID) -> &T" is filtered.
Add std::ops::Index::<aho_corasick::util::primitives::PatternID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2618 ~ aho_corasick[9659]::util::primitives::{impl#82}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:2617 ~ aho_corasick[9659]::util::primitives::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: T
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:2619 ~ aho_corasick[9659]::util::primitives::{impl#82}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<aho_corasick::util::primitives::StateID>>::index(&[T], aho_corasick::util::primitives::StateID) -> &T" is filtered.
Add std::ops::Index::<aho_corasick::util::primitives::StateID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:1519 ~ aho_corasick[9659]::util::search::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
Output: [u8]
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:1520 ~ aho_corasick[9659]::util::search::{impl#5}::Output)), kind: AssocType, docs: "" }
"fn <[u8] as std::ops::Index::<aho_corasick::util::search::Span>>::index(&[u8], aho_corasick::util::search::Span) -> &[u8]" is filtered.
Add std::ops::Index::<aho_corasick::util::search::Span> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:1405 ~ aho_corasick[9659]::util::primitives::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:1404 ~ aho_corasick[9659]::util::primitives::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: T
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:1406 ~ aho_corasick[9659]::util::primitives::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<aho_corasick::util::primitives::SmallIndex>>::index(&[T], aho_corasick::util::primitives::SmallIndex) -> &T" is filtered.
Add std::ops::Index::<aho_corasick::util::primitives::SmallIndex> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:1522 ~ aho_corasick[9659]::util::search::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn <[u8] as std::ops::IndexMut::<aho_corasick::util::search::Span>>::index_mut(&mut [u8], aho_corasick::util::search::Span) -> &mut [u8]" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::search::Span> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2622 ~ aho_corasick[9659]::util::primitives::{impl#83}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:2621 ~ aho_corasick[9659]::util::primitives::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<aho_corasick::util::primitives::StateID>>::index_mut(&mut [T], aho_corasick::util::primitives::StateID) -> &mut T" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::primitives::StateID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:2523 ~ aho_corasick[9659]::util::primitives::{impl#55}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:2522 ~ aho_corasick[9659]::util::primitives::{impl#55})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<aho_corasick::util::primitives::PatternID>>::index_mut(&mut [T], aho_corasick::util::primitives::PatternID) -> &mut T" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::primitives::PatternID> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(21:1409 ~ aho_corasick[9659]::util::primitives::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(21:1408 ~ aho_corasick[9659]::util::primitives::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<aho_corasick::util::primitives::SmallIndex>>::index_mut(&mut [T], aho_corasick::util::primitives::SmallIndex) -> &mut T" is filtered.
Add std::ops::IndexMut::<aho_corasick::util::primitives::SmallIndex> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1013 ~ regex[3103]::re_bytes::{impl#30}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::bytes::Replacer
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::bytes::Replacer")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(0:1000 ~ regex[3103]::re_bytes::Replacer))
impl_def_id: DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30})
is_local_impl: true
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
assoc types:
Add regex::bytes::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:632 ~ alloc[2c7c]::boxed::{impl#64}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:631 ~ alloc[2c7c]::boxed::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:628 ~ alloc[2c7c]::boxed::{impl#63})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9023 ~ std[d8a0]::path::{impl#159})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9021 ~ std[d8a0]::path::{impl#158})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8161 ~ std[d8a0]::ffi::os_str::{impl#77}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8162 ~ std[d8a0]::ffi::os_str::{impl#77}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8983 ~ std[d8a0]::path::{impl#143})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::eq(&std::ffi::OsStr, &str) -> bool" is filtered.
Add std::cmp::PartialEq::<str> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9030 ~ std[d8a0]::path::{impl#162}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9029 ~ std[d8a0]::path::{impl#162})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::eq(&std::path::Path, &&'a std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8145 ~ std[d8a0]::ffi::os_str::{impl#73}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8146 ~ std[d8a0]::ffi::os_str::{impl#73}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8993 ~ std[d8a0]::path::{impl#147}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8992 ~ std[d8a0]::path::{impl#147})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2228 ~ std[d8a0]::ffi::os_str::{impl#40})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq>::eq(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9118 ~ std[d8a0]::path::{impl#191}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9119 ~ std[d8a0]::path::{impl#191}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9117 ~ std[d8a0]::path::{impl#191})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9033 ~ std[d8a0]::path::{impl#163}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9032 ~ std[d8a0]::path::{impl#163})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&str, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9065 ~ std[d8a0]::path::{impl#175}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9064 ~ std[d8a0]::path::{impl#175})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::eq(&std::ffi::OsStr, &&'a std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8129 ~ std[d8a0]::ffi::os_str::{impl#69}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8130 ~ std[d8a0]::ffi::os_str::{impl#69}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9062 ~ std[d8a0]::path::{impl#174}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9061 ~ std[d8a0]::path::{impl#174})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8177 ~ std[d8a0]::ffi::os_str::{impl#81}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8178 ~ std[d8a0]::ffi::os_str::{impl#81}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9105 ~ std[d8a0]::path::{impl#187}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9104 ~ std[d8a0]::path::{impl#187})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: None
impl_def_id: DefId(1:2167 ~ std[d8a0]::ffi::os_str::{impl#23})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn std::ffi::OsStr::new(&S) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::from_encoded_bytes_unchecked(&[u8]) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::to_str(&std::ffi::OsStr) -> std::option::Option::<&str>" is filtered.
"fn std::ffi::OsStr::to_string_lossy(&std::ffi::OsStr) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::ffi::OsStr::to_os_string(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::is_empty(&std::ffi::OsStr) -> bool" is filtered.
"fn std::ffi::OsStr::len(&std::ffi::OsStr) -> usize" is filtered.
"fn std::ffi::OsStr::into_os_string(std::boxed::Box::<std::ffi::OsStr>) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::as_encoded_bytes(&std::ffi::OsStr) -> &[u8]" is filtered.
"fn std::ffi::OsStr::slice_encoded_bytes(&std::ffi::OsStr, R) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::make_ascii_lowercase(&mut std::ffi::OsStr) -> ()" is filtered.
"fn std::ffi::OsStr::make_ascii_uppercase(&mut std::ffi::OsStr) -> ()" is filtered.
"fn std::ffi::OsStr::to_ascii_lowercase(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::to_ascii_uppercase(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::is_ascii(&std::ffi::OsStr) -> bool" is filtered.
"fn std::ffi::OsStr::eq_ignore_ascii_case(&std::ffi::OsStr, S) -> bool" is filtered.
"fn std::ffi::OsStr::display(&std::ffi::OsStr) -> std::ffi::Display::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2190 ~ std[d8a0]::ffi::os_str::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<&std::ffi::OsStr>>::from(&std::ffi::OsStr) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2196 ~ std[d8a0]::ffi::os_str::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<std::ffi::OsString>>::from(std::ffi::OsString) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<std::ffi::OsString> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2192 ~ std[d8a0]::ffi::os_str::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::from(std::borrow::Cow::<'_, std::ffi::OsStr>) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(1:2265 ~ std[d8a0]::ffi::os_str::{impl#53})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
Owned: std::ffi::OsString
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:2266 ~ std[d8a0]::ffi::os_str::{impl#53}::Owned)), kind: AssocType, docs: "" }
"fn <std::ffi::OsStr as std::borrow::ToOwned>::to_owned(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn <std::ffi::OsStr as std::borrow::ToOwned>::clone_into(&std::ffi::OsStr, &mut std::ffi::OsString) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:2249 ~ std[d8a0]::ffi::os_str::{impl#48})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:2269 ~ std[d8a0]::ffi::os_str::{impl#54})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::ffi::OsStr) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&str) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5572 ~ std[d8a0]::path::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::path::Path>>::as_ref(&std::ffi::OsStr) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5549 ~ std[d8a0]::path::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::path::Path) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:2243 ~ std[d8a0]::ffi::os_str::{impl#46})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::Ord>::cmp(&std::ffi::OsStr, &std::ffi::OsStr) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::ffi::OsStr as std::cmp::Ord>::max(std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
[Impl] add default impl: min
"fn <std::ffi::OsStr as std::cmp::Ord>::min(std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
[Impl] add default impl: clamp
"fn <std::ffi::OsStr as std::cmp::Ord>::clamp(std::ffi::OsStr, std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9111 ~ std[d8a0]::path::{impl#189}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9110 ~ std[d8a0]::path::{impl#189})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8185 ~ std[d8a0]::ffi::os_str::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8186 ~ std[d8a0]::ffi::os_str::{impl#83}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:2235 ~ std[d8a0]::ffi::os_str::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::lt(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::le(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::gt(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::ge(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::partial_cmp(&std::ffi::OsStr, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<str> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8987 ~ std[d8a0]::path::{impl#145})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8169 ~ std[d8a0]::ffi::os_str::{impl#79}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8170 ~ std[d8a0]::ffi::os_str::{impl#79}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9068 ~ std[d8a0]::path::{impl#176}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9067 ~ std[d8a0]::path::{impl#176})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8153 ~ std[d8a0]::ffi::os_str::{impl#75}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8154 ~ std[d8a0]::ffi::os_str::{impl#75}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9039 ~ std[d8a0]::path::{impl#165}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9038 ~ std[d8a0]::path::{impl#165})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9036 ~ std[d8a0]::path::{impl#164}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9035 ~ std[d8a0]::path::{impl#164})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::partial_cmp(&std::path::Path, &&'a std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8137 ~ std[d8a0]::ffi::os_str::{impl#71}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8138 ~ std[d8a0]::ffi::os_str::{impl#71}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9025 ~ std[d8a0]::path::{impl#160})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8999 ~ std[d8a0]::path::{impl#149}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8998 ~ std[d8a0]::path::{impl#149})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9071 ~ std[d8a0]::path::{impl#177}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9070 ~ std[d8a0]::path::{impl#177})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::partial_cmp(&std::ffi::OsStr, &&'a std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9027 ~ std[d8a0]::path::{impl#161})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9126 ~ std[d8a0]::path::{impl#193}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9127 ~ std[d8a0]::path::{impl#193}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9125 ~ std[d8a0]::path::{impl#193})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2221 ~ std[d8a0]::ffi::os_str::{impl#37}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Error: std::str::error::Utf8Error
not covered item Item { name: Some("Error"), item_id: DefId(DefId(1:2222 ~ std[d8a0]::ffi::os_str::{impl#37}::Error)), kind: AssocType, docs: "" }
"fn <&str as std::convert::TryFrom::<&std::ffi::OsStr>>::try_from(&'a std::ffi::OsStr) -> std::result::Result::<&'a str, <&'a str as std::convert::TryFrom::<&'a std::ffi::OsStr>>::Error>" is filtered.
Add std::convert::TryFrom::<&'a std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:2198 ~ std[d8a0]::ffi::os_str::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::os::unix::ffi::os_str::OsStrExt
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::os::unix::ffi::os_str::OsStrExt")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:4124 ~ std[d8a0]::os::unix::ffi::os_str::OsStrExt))
impl_def_id: DefId(1:4127 ~ std[d8a0]::os::unix::ffi::os_str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::os::unix::ffi::os_str::OsStrExt>::from_bytes(&[u8]) -> &std::ffi::OsStr" is filtered.
"fn <std::ffi::OsStr as std::os::unix::ffi::os_str::OsStrExt>::as_bytes(&std::ffi::OsStr) -> &[u8]" is filtered.
Add std::os::unix::ffi::os_str::OsStrExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(1:2259 ~ std[d8a0]::ffi::os_str::{impl#51}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::ffi::OsString
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:2260 ~ std[d8a0]::ffi::os_str::{impl#51}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&std::ffi::OsStr>>::join(&[S], &std::ffi::OsStr) -> std::ffi::OsString" is filtered.
Add std::slice::Join::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:2224 ~ std[d8a0]::ffi::os_str::{impl#38})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::default::Default>::default() -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:2226 ~ std[d8a0]::ffi::os_str::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::default::Default>::default() -> &std::ffi::OsStr" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:2246 ~ std[d8a0]::ffi::os_str::{impl#47})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::hash::Hash>::hash(&std::ffi::OsStr, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::ffi::OsStr as std::hash::Hash>::hash_slice(&[std::ffi::OsStr], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:2234 ~ std[d8a0]::ffi::os_str::{impl#43})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8933 ~ std[d8a0]::path::{impl#127}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8932 ~ std[d8a0]::path::{impl#127})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8983 ~ std[d8a0]::path::{impl#143})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8993 ~ std[d8a0]::path::{impl#147}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8992 ~ std[d8a0]::path::{impl#147})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8923 ~ std[d8a0]::path::{impl#123})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:5367 ~ std[d8a0]::path::PathBuf)), segments: [PathSegment { name: "PathBuf", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::path::PathBuf")
type_def_id: Some(DefId(1:5367 ~ std[d8a0]::path::PathBuf))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:5438 ~ std[d8a0]::path::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::path::PathBuf"
std::path::PathBuf is not fuzzable
assoc types:
Target: std::path::Path
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:5439 ~ std[d8a0]::path::{impl#44}::Target)), kind: AssocType, docs: "" }
"fn <std::path::PathBuf as std::ops::Deref>::deref(&std::path::PathBuf) -> &std::path::Path" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:5410 ~ std[d8a0]::path::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::path::Path> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::path::Path> as std::convert::From::<std::path::PathBuf>>::from(std::path::PathBuf) -> std::boxed::Box::<std::path::Path>" is filtered.
Add std::convert::From::<std::path::PathBuf> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8927 ~ std[d8a0]::path::{impl#125})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8939 ~ std[d8a0]::path::{impl#129}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8938 ~ std[d8a0]::path::{impl#129})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8987 ~ std[d8a0]::path::{impl#145})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8999 ~ std[d8a0]::path::{impl#149}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8998 ~ std[d8a0]::path::{impl#149})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7059 ~ std[d8a0]::sync::rwlock::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9466 ~ std[d8a0]::sync::rwlock::MappedRwLockWriteGuard)), segments: [PathSegment { name: "MappedRwLockWriteGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::MappedRwLockWriteGuard")
type_def_id: Some(DefId(1:9466 ~ std[d8a0]::sync::rwlock::MappedRwLockWriteGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7058 ~ std[d8a0]::sync::rwlock::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::MappedRwLockWriteGuard"
std::sync::rwlock::MappedRwLockWriteGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7060 ~ std[d8a0]::sync::rwlock::{impl#29}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::MappedRwLockWriteGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::MappedRwLockWriteGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4123 ~ core[b693]::array::equality::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4124 ~ core[b693]::array::equality::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4122 ~ core[b693]::array::equality::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::eq(&&mut [T], &[U;N]) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::ne(&&mut [T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4099 ~ core[b693]::array::equality::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4100 ~ core[b693]::array::equality::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4098 ~ core[b693]::array::equality::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::eq(&[T], &[U;N]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::ne(&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4111 ~ core[b693]::array::equality::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4112 ~ core[b693]::array::equality::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4110 ~ core[b693]::array::equality::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::eq(&&[T], &[U;N]) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::ne(&&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Slice(Generic("T"))])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:454 ~ alloc[2c7c]::boxed::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:455 ~ alloc[2c7c]::boxed::{impl#29}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:453 ~ alloc[2c7c]::boxed::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T]> is not fuzzable
assoc types:
"fn <std::boxed::Box::<[T]> as std::convert::From::<[T;N]>>::from([T;N]) -> std::boxed::Box::<[T]>" is filtered.
Add std::convert::From::<[T;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Array(Generic("T"), "N")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:462 ~ alloc[2c7c]::boxed::{impl#30}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:463 ~ alloc[2c7c]::boxed::{impl#30}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Array(Generic("T"), "N"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:461 ~ alloc[2c7c]::boxed::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T;N]> is not fuzzable
assoc types:
Error: std::boxed::Box::<[T]>
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:464 ~ alloc[2c7c]::boxed::{impl#30}::Error)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::boxed::Box::<[T]>>>::try_from(std::boxed::Box::<[T]>) -> std::result::Result::<std::boxed::Box::<[T;N]>, <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::boxed::Box::<[T]>>>::Error>" is filtered.
Add std::convert::TryFrom::<std::boxed::Box::<[T]>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Array(Generic("T"), "N")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:467 ~ alloc[2c7c]::boxed::{impl#31}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(5:468 ~ alloc[2c7c]::boxed::{impl#31}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Array(Generic("T"), "N"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:466 ~ alloc[2c7c]::boxed::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<[T;N]> is not fuzzable
assoc types:
Error: std::vec::Vec::<T>
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:469 ~ alloc[2c7c]::boxed::{impl#31}::Error)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::vec::Vec::<T>>>::try_from(std::vec::Vec::<T>) -> std::result::Result::<std::boxed::Box::<[T;N]>, <std::boxed::Box::<[T;N]> as std::convert::TryFrom::<std::vec::Vec::<T>>>::Error>" is filtered.
Add std::convert::TryFrom::<std::vec::Vec::<T>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5566 ~ alloc[2c7c]::slice::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5567 ~ alloc[2c7c]::slice::{impl#3}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5568 ~ alloc[2c7c]::slice::{impl#3}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&T>>::join(&[V], &T) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:3661 ~ std[d8a0]::io::{impl#11}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:8510 ~ std[d8a0]::io::IoSlice)), segments: [PathSegment { name: "IoSlice", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::io::IoSlice")
type_def_id: Some(DefId(1:8510 ~ std[d8a0]::io::IoSlice))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:3660 ~ std[d8a0]::io::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::io::IoSlice"
std::io::IoSlice::<'_> is not fuzzable
assoc types:
Target: [u8]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:3662 ~ std[d8a0]::io::{impl#11}::Target)), kind: AssocType, docs: "" }
"fn <std::io::IoSlice::<'_> as std::ops::Deref>::deref(&std::io::IoSlice::<'_>) -> &[u8]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6096 ~ std[d8a0]::sync::lazy_lock::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(1:6097 ~ std[d8a0]::sync::lazy_lock::{impl#3}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:6075 ~ std[d8a0]::sync::lazy_lock::LazyLock)), segments: [PathSegment { name: "LazyLock", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::lazy_lock::LazyLock")
type_def_id: Some(DefId(1:6075 ~ std[d8a0]::sync::lazy_lock::LazyLock))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6095 ~ std[d8a0]::sync::lazy_lock::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::sync::lazy_lock::LazyLock"
std::sync::lazy_lock::LazyLock::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6098 ~ std[d8a0]::sync::lazy_lock::{impl#3}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::lazy_lock::LazyLock::<T, F> as std::ops::Deref>::deref(&std::sync::lazy_lock::LazyLock::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9053 ~ std[d8a0]::path::{impl#170})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8145 ~ std[d8a0]::ffi::os_str::{impl#73}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8146 ~ std[d8a0]::ffi::os_str::{impl#73}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9090 ~ std[d8a0]::path::{impl#182}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9089 ~ std[d8a0]::path::{impl#182})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2149 ~ std[d8a0]::ffi::os_str::{impl#16}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8129 ~ std[d8a0]::ffi::os_str::{impl#69}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8130 ~ std[d8a0]::ffi::os_str::{impl#69}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:2089 ~ std[d8a0]::ffi::os_str::OsString)), segments: [PathSegment { name: "OsString", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::ffi::os_str::OsString")
type_def_id: Some(DefId(1:2089 ~ std[d8a0]::ffi::os_str::OsString))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:2128 ~ std[d8a0]::ffi::os_str::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsString"
std::ffi::OsString is not fuzzable
assoc types:
Target: std::ffi::OsStr
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:2129 ~ std[d8a0]::ffi::os_str::{impl#7}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::OsString as std::ops::Deref>::deref(&std::ffi::OsString) -> &std::ffi::OsStr" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:2196 ~ std[d8a0]::ffi::os_str::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<std::ffi::OsStr> is not fuzzable
assoc types:
"fn <std::boxed::Box::<std::ffi::OsStr> as std::convert::From::<std::ffi::OsString>>::from(std::ffi::OsString) -> std::boxed::Box::<std::ffi::OsStr>" is filtered.
Add std::convert::From::<std::ffi::OsString> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9096 ~ std[d8a0]::path::{impl#184}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9095 ~ std[d8a0]::path::{impl#184})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8153 ~ std[d8a0]::ffi::os_str::{impl#75}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8154 ~ std[d8a0]::ffi::os_str::{impl#75}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8137 ~ std[d8a0]::ffi::os_str::{impl#71}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8138 ~ std[d8a0]::ffi::os_str::{impl#71}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9057 ~ std[d8a0]::path::{impl#172})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6654 ~ std[d8a0]::sync::mutex::{impl#12}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9423 ~ std[d8a0]::sync::mutex::MutexGuard)), segments: [PathSegment { name: "MutexGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::mutex::MutexGuard")
type_def_id: Some(DefId(1:9423 ~ std[d8a0]::sync::mutex::MutexGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6653 ~ std[d8a0]::sync::mutex::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::sync::mutex::MutexGuard"
std::sync::mutex::MutexGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6655 ~ std[d8a0]::sync::mutex::{impl#12}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::mutex::MutexGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::mutex::MutexGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3098 ~ core[b693]::convert::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3097 ~ core[b693]::convert::{impl#5})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6933 ~ std[d8a0]::sync::reentrant_lock::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:6905 ~ std[d8a0]::sync::reentrant_lock::ReentrantLockGuard)), segments: [PathSegment { name: "ReentrantLockGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::reentrant_lock::ReentrantLockGuard")
type_def_id: Some(DefId(1:6905 ~ std[d8a0]::sync::reentrant_lock::ReentrantLockGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6932 ~ std[d8a0]::sync::reentrant_lock::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::sync::reentrant_lock::ReentrantLockGuard"
std::sync::reentrant_lock::ReentrantLockGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6934 ~ std[d8a0]::sync::reentrant_lock::{impl#11}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::reentrant_lock::ReentrantLockGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::reentrant_lock::ReentrantLockGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6685 ~ std[d8a0]::sync::mutex::{impl#18}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9428 ~ std[d8a0]::sync::mutex::MappedMutexGuard)), segments: [PathSegment { name: "MappedMutexGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::mutex::MappedMutexGuard")
type_def_id: Some(DefId(1:9428 ~ std[d8a0]::sync::mutex::MappedMutexGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6684 ~ std[d8a0]::sync::mutex::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::sync::mutex::MappedMutexGuard"
std::sync::mutex::MappedMutexGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6686 ~ std[d8a0]::sync::mutex::{impl#18}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::mutex::MappedMutexGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::mutex::MappedMutexGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:977 ~ regex[3103]::re_bytes::{impl#25}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:976 ~ regex[3103]::re_bytes::{impl#25})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Captures"
regex::bytes::Captures::<'_> is not fuzzable
assoc types:
Output: [u8]
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:978 ~ regex[3103]::re_bytes::{impl#25}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<usize> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1265 ~ regex[3103]::re_unicode::{impl#22}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:1264 ~ regex[3103]::re_unicode::{impl#22})
is_local_impl: true
is_external_type: false
type_name: "regex::Captures"
regex::Captures::<'_> is not fuzzable
assoc types:
Output: str
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:1266 ~ regex[3103]::re_unicode::{impl#22}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<usize> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7048 ~ std[d8a0]::sync::rwlock::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9456 ~ std[d8a0]::sync::rwlock::RwLockWriteGuard)), segments: [PathSegment { name: "RwLockWriteGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::RwLockWriteGuard")
type_def_id: Some(DefId(1:9456 ~ std[d8a0]::sync::rwlock::RwLockWriteGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7047 ~ std[d8a0]::sync::rwlock::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::RwLockWriteGuard"
std::sync::rwlock::RwLockWriteGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7049 ~ std[d8a0]::sync::rwlock::{impl#26}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::RwLockWriteGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::RwLockWriteGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:3642 ~ std[d8a0]::io::{impl#5}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:3625 ~ std[d8a0]::io::IoSliceMut)), segments: [PathSegment { name: "IoSliceMut", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::io::IoSliceMut")
type_def_id: Some(DefId(1:3625 ~ std[d8a0]::io::IoSliceMut))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:3641 ~ std[d8a0]::io::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::io::IoSliceMut"
std::io::IoSliceMut::<'_> is not fuzzable
assoc types:
Target: [u8]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:3643 ~ std[d8a0]::io::{impl#5}::Target)), kind: AssocType, docs: "" }
"fn <std::io::IoSliceMut::<'_> as std::ops::Deref>::deref(&std::io::IoSliceMut::<'_>) -> &[u8]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::eq(&std::ffi::OsStr, &str) -> bool" is filtered.
Add std::cmp::PartialEq::<str> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&str, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2149 ~ std[d8a0]::ffi::os_str::{impl#16}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&str) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5578 ~ std[d8a0]::path::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::path::Path>>::as_ref(&str) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::partial_cmp(&std::ffi::OsStr, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<str> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2221 ~ std[d8a0]::ffi::os_str::{impl#37}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Error: std::str::error::Utf8Error
not covered item Item { name: Some("Error"), item_id: DefId(DefId(1:2222 ~ std[d8a0]::ffi::os_str::{impl#37}::Error)), kind: AssocType, docs: "" }
"fn <&str as std::convert::TryFrom::<&std::ffi::OsStr>>::try_from(&'a std::ffi::OsStr) -> std::result::Result::<&'a str, <&'a str as std::convert::TryFrom::<&'a std::ffi::OsStr>>::Error>" is filtered.
Add std::convert::TryFrom::<&'a std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::net::socket_addr::ToSocketAddrs
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::net::socket_addr::ToSocketAddrs")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3856 ~ std[d8a0]::net::socket_addr::ToSocketAddrs))
impl_def_id: DefId(1:3885 ~ std[d8a0]::net::socket_addr::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Iter: std::vec::into_iter::IntoIter::<std::net::SocketAddr>
not covered item Item { name: Some("Iter"), item_id: DefId(DefId(1:3886 ~ std[d8a0]::net::socket_addr::{impl#12}::Iter)), kind: AssocType, docs: "" }
"fn <str as std::net::ToSocketAddrs>::to_socket_addrs(&str) -> std::result::Result::<std::vec::into_iter::IntoIter::<std::net::SocketAddr>, std::io::Error>" is filtered.
Add std::net::ToSocketAddrs Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::ascii::AsciiExt
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::ascii::AsciiExt")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:646 ~ std[d8a0]::ascii::AsciiExt))
impl_def_id: DefId(1:661 ~ std[d8a0]::ascii::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Owned: std::string::String
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:662 ~ std[d8a0]::ascii::{impl#3}::Owned)), kind: AssocType, docs: "" }
"fn <str as std::ascii::AsciiExt>::is_ascii(&str) -> bool" is filtered.
"fn <str as std::ascii::AsciiExt>::to_ascii_uppercase(&str) -> <str as std::ascii::AsciiExt>::Owned" is filtered.
"fn <str as std::ascii::AsciiExt>::to_ascii_lowercase(&str) -> <str as std::ascii::AsciiExt>::Owned" is filtered.
"fn <str as std::ascii::AsciiExt>::eq_ignore_ascii_case(&str, &str) -> bool" is filtered.
"fn <str as std::ascii::AsciiExt>::make_ascii_uppercase(&mut str) -> ()" is filtered.
"fn <str as std::ascii::AsciiExt>::make_ascii_lowercase(&mut str) -> ()" is filtered.
Add std::ascii::AsciiExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:13307 ~ core[b693]::str::traits::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialOrd>::partial_cmp(&str, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <str as std::cmp::PartialOrd>::lt(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <str as std::cmp::PartialOrd>::le(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <str as std::cmp::PartialOrd>::gt(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <str as std::cmp::PartialOrd>::ge(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::error::Error
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::error::Error")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3153 ~ core[b693]::error::Error))
impl_def_id: DefId(2:13883 ~ core[b693]::str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Add std::error::Error Provide Method. is_local=false
[Impl] add default impl: source
"fn <&str as std::error::Error>::source(&&str) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'static\")))>" is filtered.
[Impl] add default impl: description
"fn <&str as std::error::Error>::description(&&str) -> &str" is filtered.
[Impl] add default impl: cause
"fn <&str as std::error::Error>::cause(&&str) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)>" is filtered.
[Impl] add default impl: provide
"fn <&str as std::error::Error>::provide(&'a &str, &mut std::error::Request::<'a>) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:13592 ~ core[b693]::str::pattern::{impl#31}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(2:13593 ~ core[b693]::str::pattern::{impl#31}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::str::pattern::Pattern
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::pattern::Pattern")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:13443 ~ core[b693]::str::pattern::Pattern))
impl_def_id: DefId(2:13591 ~ core[b693]::str::pattern::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Searcher: std::str::pattern::StrSearcher::<'a, 'b>
not covered item Item { name: Some("Searcher"), item_id: DefId(DefId(2:13594 ~ core[b693]::str::pattern::{impl#31}::Searcher)), kind: AssocType, docs: "" }
"fn <&str as std::str::pattern::Pattern::<'_>>::into_searcher(&str, &'a str) -> std::str::pattern::StrSearcher::<'a, 'b>" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_prefix_of(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_contained_in(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::strip_prefix_of(&str, &'a str) -> std::option::Option::<&'a str>" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_suffix_of(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::strip_suffix_of(&str, &'a str) -> std::option::Option::<&'a str>" is filtered.
Add std::str::pattern::Pattern::<'a> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:32835 ~ core[b693]::marker::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:10962 ~ core[b693]::hash::impls::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::hash::Hash>::hash(&str, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <str as std::hash::Hash>::hash_slice(&[str], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(2:10771 ~ core[b693]::fmt::{impl#17})
is_local_impl: false
is_external_type: true
type_name: "std::str"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:10767 ~ core[b693]::fmt::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::ConstParamTy
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::ConstParamTy")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:32908 ~ core[b693]::marker::ConstParamTy))
impl_def_id: DefId(2:32923 ~ core[b693]::marker::{impl#90})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::marker::ConstParamTy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:13314 ~ core[b693]::str::traits::{impl#5}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::IndexMut
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(2:13313 ~ core[b693]::str::traits::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::ops::IndexMut::<I>>::index_mut(&mut str, I) -> &mut <I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
Add std::ops::IndexMut::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:13310 ~ core[b693]::str::traits::{impl#4}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::Index
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:13309 ~ core[b693]::str::traits::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Output: <I as std::slice::index::SliceIndex::<str>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:13311 ~ core[b693]::str::traits::{impl#4}::Output)), kind: AssocType, docs: "" }
"fn <str as std::ops::Index::<I>>::index(&str, I) -> &<I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
Add std::ops::Index::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:13306 ~ core[b693]::str::traits::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsMut
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(2:3118 ~ core[b693]::convert::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsMut::<str>>::as_mut(&mut str) -> &mut str" is filtered.
Add std::convert::AsMut::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:13304 ~ core[b693]::str::traits::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq>::eq(&str, &str) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:13881 ~ core[b693]::str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&mut str is not fuzzable
assoc types:
"fn <&mut str as std::default::Default>::default() -> &mut str" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:13879 ~ core[b693]::str::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::default::Default>::default() -> &str" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:13302 ~ core[b693]::str::traits::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::Ord>::cmp(&str, &str) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <str as std::cmp::Ord>::max(str, str) -> str" is filtered.
[Impl] add default impl: min
"fn <str as std::cmp::Ord>::min(str, str) -> str" is filtered.
[Impl] add default impl: clamp
"fn <str as std::cmp::Ord>::clamp(str, str, str) -> str" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:13877 ~ core[b693]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<[u8]>>::as_ref(&str) -> &[u8]" is filtered.
Add std::convert::AsRef::<[u8]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:3116 ~ core[b693]::convert::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<str>>::as_ref(&str) -> &str" is filtered.
Add std::convert::AsRef::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:636 ~ alloc[2c7c]::boxed::{impl#65}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:635 ~ alloc[2c7c]::boxed::{impl#65})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(5:643 ~ alloc[2c7c]::boxed::{impl#67}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:642 ~ alloc[2c7c]::boxed::{impl#67})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:639 ~ alloc[2c7c]::boxed::{impl#66})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:632 ~ alloc[2c7c]::boxed::{impl#64}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:631 ~ alloc[2c7c]::boxed::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:647 ~ alloc[2c7c]::boxed::{impl#68}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:646 ~ alloc[2c7c]::boxed::{impl#68})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(5:628 ~ alloc[2c7c]::boxed::{impl#63})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7793 ~ alloc[2c7c]::string::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7794 ~ alloc[2c7c]::string::{impl#82}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7792 ~ alloc[2c7c]::string::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::string::String>>::eq(&str, &std::string::String) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::string::String>>::ne(&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7813 ~ alloc[2c7c]::string::{impl#86}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7814 ~ alloc[2c7c]::string::{impl#86}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7812 ~ alloc[2c7c]::string::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7823 ~ alloc[2c7c]::string::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7824 ~ alloc[2c7c]::string::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7822 ~ alloc[2c7c]::string::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7803 ~ alloc[2c7c]::string::{impl#84}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7804 ~ alloc[2c7c]::string::{impl#84}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7802 ~ alloc[2c7c]::string::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::string::String>>::eq(&&str, &std::string::String) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::string::String>>::ne(&&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Primitive(Str)
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: None
impl_def_id: DefId(2:13742 ~ core[b693]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn str::len(&str) -> usize" is filtered.
"fn str::is_empty(&str) -> bool" is filtered.
"fn str::is_char_boundary(&str, usize) -> bool" is filtered.
"fn str::floor_char_boundary(&str, usize) -> usize" is filtered.
"fn str::ceil_char_boundary(&str, usize) -> usize" is filtered.
"fn str::as_bytes(&str) -> &[u8]" is filtered.
"fn str::as_bytes_mut(&mut str) -> &mut [u8]" is filtered.
"fn str::as_ptr(&str) -> *const u8" is filtered.
"fn str::as_mut_ptr(&mut str) -> *u8" is filtered.
"fn str::get(&str, I) -> std::option::Option::<&<I as std::slice::index::SliceIndex::<str>>::Output>" is filtered.
"fn str::get_mut(&mut str, I) -> std::option::Option::<&mut <I as std::slice::index::SliceIndex::<str>>::Output>" is filtered.
"fn str::get_unchecked(&str, I) -> &<I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
"fn str::get_unchecked_mut(&mut str, I) -> &mut <I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
"fn str::slice_unchecked(&str, usize, usize) -> &str" is filtered.
"fn str::slice_mut_unchecked(&mut str, usize, usize) -> &mut str" is filtered.
"fn str::split_at(&str, usize) -> (&str ,&str)" is filtered.
"fn str::split_at_mut(&mut str, usize) -> (&mut str ,&mut str)" is filtered.
"fn str::split_at_checked(&str, usize) -> std::option::Option::<(&str ,&str)>" is filtered.
"fn str::split_at_mut_checked(&mut str, usize) -> std::option::Option::<(&mut str ,&mut str)>" is filtered.
"fn str::chars(&str) -> std::str::iter::Chars::<'_>" is filtered.
"fn str::char_indices(&str) -> std::str::iter::CharIndices::<'_>" is filtered.
"fn str::bytes(&str) -> std::str::iter::Bytes::<'_>" is filtered.
"fn str::split_whitespace(&str) -> std::str::iter::SplitWhitespace::<'_>" is filtered.
"fn str::split_ascii_whitespace(&str) -> std::str::iter::SplitAsciiWhitespace::<'_>" is filtered.
"fn str::lines(&str) -> std::str::iter::Lines::<'_>" is filtered.
"fn str::lines_any(&str) -> std::str::iter::LinesAny::<'_>" is filtered.
"fn str::encode_utf16(&str) -> std::str::iter::EncodeUtf16::<'_>" is filtered.
"fn str::contains(&'a str, P) -> bool" is filtered.
"fn str::starts_with(&'a str, P) -> bool" is filtered.
"fn str::ends_with(&'a str, P) -> bool" is filtered.
"fn str::find(&'a str, P) -> std::option::Option::<usize>" is filtered.
"fn str::rfind(&'a str, P) -> std::option::Option::<usize>" is filtered.
"fn str::split(&'a str, P) -> std::str::iter::Split::<'a, P>" is filtered.
"fn str::split_inclusive(&'a str, P) -> std::str::iter::SplitInclusive::<'a, P>" is filtered.
"fn str::rsplit(&'a str, P) -> std::str::iter::RSplit::<'a, P>" is filtered.
"fn str::split_terminator(&'a str, P) -> std::str::iter::SplitTerminator::<'a, P>" is filtered.
"fn str::rsplit_terminator(&'a str, P) -> std::str::iter::RSplitTerminator::<'a, P>" is filtered.
"fn str::splitn(&'a str, usize, P) -> std::str::iter::SplitN::<'a, P>" is filtered.
"fn str::rsplitn(&'a str, usize, P) -> std::str::iter::RSplitN::<'a, P>" is filtered.
"fn str::split_once(&'a str, P) -> std::option::Option::<(&'a str ,&'a str)>" is filtered.
"fn str::rsplit_once(&'a str, P) -> std::option::Option::<(&'a str ,&'a str)>" is filtered.
"fn str::matches(&'a str, P) -> std::str::iter::Matches::<'a, P>" is filtered.
"fn str::rmatches(&'a str, P) -> std::str::iter::RMatches::<'a, P>" is filtered.
"fn str::match_indices(&'a str, P) -> std::str::iter::MatchIndices::<'a, P>" is filtered.
"fn str::rmatch_indices(&'a str, P) -> std::str::iter::RMatchIndices::<'a, P>" is filtered.
"fn str::trim(&str) -> &str" is filtered.
"fn str::trim_start(&str) -> &str" is filtered.
"fn str::trim_end(&str) -> &str" is filtered.
"fn str::trim_left(&str) -> &str" is filtered.
"fn str::trim_right(&str) -> &str" is filtered.
"fn str::trim_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_start_matches(&'a str, P) -> &'a str" is filtered.
"fn str::strip_prefix(&'a str, P) -> std::option::Option::<&'a str>" is filtered.
"fn str::strip_suffix(&'a str, P) -> std::option::Option::<&'a str>" is filtered.
"fn str::trim_end_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_left_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_right_matches(&'a str, P) -> &'a str" is filtered.
"fn str::parse(&str) -> std::result::Result::<F, <F as std::str::FromStr>::Err>" is filtered.
"fn str::is_ascii(&str) -> bool" is filtered.
"fn str::as_ascii(&str) -> std::option::Option::<&[std::ascii::ascii_char::AsciiChar]>" is filtered.
"fn str::eq_ignore_ascii_case(&str, &str) -> bool" is filtered.
"fn str::make_ascii_uppercase(&mut str) -> ()" is filtered.
"fn str::make_ascii_lowercase(&mut str) -> ()" is filtered.
"fn str::trim_ascii_start(&str) -> &str" is filtered.
"fn str::trim_ascii_end(&str) -> &str" is filtered.
"fn str::trim_ascii(&str) -> &str" is filtered.
"fn str::escape_debug(&str) -> std::str::iter::EscapeDebug::<'_>" is filtered.
"fn str::escape_default(&str) -> std::str::iter::EscapeDefault::<'_>" is filtered.
"fn str::escape_unicode(&str) -> std::str::iter::EscapeUnicode::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Primitive(Str)
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: None
impl_def_id: DefId(5:5701 ~ alloc[2c7c]::str::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn str::into_boxed_bytes(std::boxed::Box::<str>) -> std::boxed::Box::<[u8]>" is filtered.
"fn str::replace(&'a str, P, &str) -> std::string::String" is filtered.
"fn str::replacen(&'a str, P, &str, usize) -> std::string::String" is filtered.
"fn str::to_lowercase(&str) -> std::string::String" is filtered.
"fn str::to_uppercase(&str) -> std::string::String" is filtered.
"fn str::into_string(std::boxed::Box::<str>) -> std::string::String" is filtered.
"fn str::repeat(&str, usize) -> std::string::String" is filtered.
"fn str::to_ascii_uppercase(&str) -> std::string::String" is filtered.
"fn str::to_ascii_lowercase(&str) -> std::string::String" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:5989 ~ alloc[2c7c]::string::{impl#49})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<std::string::String>>::from(std::string::String) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:446 ~ alloc[2c7c]::boxed::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:448 ~ alloc[2c7c]::boxed::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::convert::From::<std::borrow::Cow::<'_, str>>>::from(std::borrow::Cow::<'_, str>) -> std::boxed::Box::<str>" is filtered.
Add std::convert::From::<std::borrow::Cow::<'_, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:736 ~ alloc[2c7c]::boxed::{impl#87}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:735 ~ alloc[2c7c]::boxed::{impl#87})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:733 ~ alloc[2c7c]::boxed::{impl#86}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a"))))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(5:732 ~ alloc[2c7c]::boxed::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))> is not fuzzable
assoc types:
"fn <std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))> as std::convert::From::<&str>>::from(&str) -> std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: \"Sync\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: \"Send\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'a\")))>" is filtered.
Add std::convert::From::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5681 ~ alloc[2c7c]::str::{impl#1}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5680 ~ alloc[2c7c]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5682 ~ alloc[2c7c]::str::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&str>>::join(&[S], &str) -> std::string::String" is filtered.
Add std::slice::Join::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(5:378 ~ alloc[2c7c]::boxed::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5677 ~ alloc[2c7c]::str::{impl#0}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(5:5676 ~ alloc[2c7c]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5678 ~ alloc[2c7c]::str::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Concat::<str>>::concat(&[S]) -> std::string::String" is filtered.
Add std::slice::Concat::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Primitive(Str)])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:370 ~ alloc[2c7c]::boxed::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<str> is not fuzzable
assoc types:
"fn <std::boxed::Box::<str> as std::default::Default>::default() -> std::boxed::Box::<str>" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:5697 ~ alloc[2c7c]::str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Owned: std::string::String
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:5698 ~ alloc[2c7c]::str::{impl#4}::Owned)), kind: AssocType, docs: "" }
"fn <str as std::borrow::ToOwned>::to_owned(&str) -> std::string::String" is filtered.
"fn <str as std::borrow::ToOwned>::clone_into(&str, &mut std::string::String) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(21:1524 ~ aho_corasick[9659]::util::search::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Output: str
not covered item Item { name: Some("Output"), item_id: DefId(DefId(21:1525 ~ aho_corasick[9659]::util::search::{impl#7}::Output)), kind: AssocType, docs: "" }
"fn <str as std::ops::Index::<aho_corasick::util::search::Span>>::index(&str, aho_corasick::util::search::Span) -> &str" is filtered.
Add std::ops::Index::<aho_corasick::util::search::Span> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:983 ~ regex[3103]::re_bytes::{impl#26}::'t), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'i", def_id: DefId(0:984 ~ regex[3103]::re_bytes::{impl#26}::'i), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::bytes::Captures")
type_def_id: Some(DefId(0:944 ~ regex[3103]::re_bytes::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:982 ~ regex[3103]::re_bytes::{impl#26})
is_local_impl: true
is_external_type: false
type_name: "regex::bytes::Captures"
regex::bytes::Captures::<'_> is not fuzzable
assoc types:
Output: [u8]
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:985 ~ regex[3103]::re_bytes::{impl#26}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<&'i str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(0:1323 ~ regex[3103]::re_unicode::{impl#32}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: regex::Replacer
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("regex::Replacer")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(0:1311 ~ regex[3103]::re_unicode::Replacer))
impl_def_id: DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})
is_local_impl: true
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Add regex::Replacer Provide Method. is_local=true
[Impl] add default impl: by_ref
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1134 ~ regex[3103]::re_unicode::{impl#2}::'t), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::From
impl for: BorrowedRef { lifetime: Some(Lifetime("'t")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(0:1133 ~ regex[3103]::re_unicode::{impl#2})
is_local_impl: true
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Add std::convert::From::<regex::Match::<'t>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'t", def_id: DefId(0:1271 ~ regex[3103]::re_unicode::{impl#23}::'t), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'i", def_id: DefId(0:1272 ~ regex[3103]::re_unicode::{impl#23}::'i), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'t"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("regex::Captures")
type_def_id: Some(DefId(0:1235 ~ regex[3103]::re_unicode::Captures))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(0:1270 ~ regex[3103]::re_unicode::{impl#23})
is_local_impl: true
is_external_type: false
type_name: "regex::Captures"
regex::Captures::<'_> is not fuzzable
assoc types:
Output: str
not covered item Item { name: Some("Output"), item_id: DefId(DefId(0:1273 ~ regex[3103]::re_unicode::{impl#23}::Output)), kind: AssocType, docs: "" }
Add std::ops::Index::<&'i str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7044 ~ std[d8a0]::sync::rwlock::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9451 ~ std[d8a0]::sync::rwlock::RwLockReadGuard)), segments: [PathSegment { name: "RwLockReadGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::RwLockReadGuard")
type_def_id: Some(DefId(1:9451 ~ std[d8a0]::sync::rwlock::RwLockReadGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7043 ~ std[d8a0]::sync::rwlock::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::RwLockReadGuard"
std::sync::rwlock::RwLockReadGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7045 ~ std[d8a0]::sync::rwlock::{impl#25}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::RwLockReadGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::RwLockReadGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<

visibility: ModVisibity { crate_name: "regex", inner: {"regex::bytes": Public, "regex::re_builder::bytes": Public, "regex::pikevm": Restricted(DefId(0:0 ~ regex[3103])), "regex::input": Restricted(DefId(0:0 ~ regex[3103])), "regex::expand": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_set::unicode": Public, "regex::literal::imp": Restricted(DefId(0:616 ~ regex[3103]::literal)), "regex::dfa": Restricted(DefId(0:0 ~ regex[3103])), "regex::internal": Public, "regex::re_builder::unicode": Public, "regex::re_builder": Restricted(DefId(0:0 ~ regex[3103])), "regex::error": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_builder::set_bytes": Public, "regex::pool": Restricted(DefId(0:0 ~ regex[3103])), "regex::literal": Restricted(DefId(0:0 ~ regex[3103])), "regex::compile": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_trait": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_bytes": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_set": Restricted(DefId(0:0 ~ regex[3103])), "regex": Public, "regex::utf8": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_set::bytes": Public, "regex::exec": Restricted(DefId(0:0 ~ regex[3103])), "regex::prog": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_unicode": Restricted(DefId(0:0 ~ regex[3103])), "regex::sparse": Restricted(DefId(0:0 ~ regex[3103])), "regex::backtrack": Restricted(DefId(0:0 ~ regex[3103])), "regex::re_builder::set_unicode": Public, "regex::find_byte": Restricted(DefId(0:0 ~ regex[3103]))} }

type alloc::rc::UniqueRc implement 1 traits: 
DefId(5:5392 ~ alloc[2c7c]::rc::{impl#79}): impl std::ops::Deref for std::rc::UniqueRc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::sync::rwlock::MappedRwLockWriteGuard implement 1 traits: 
DefId(1:7058 ~ std[d8a0]::sync::rwlock::{impl#29}): impl std::ops::Deref for std::sync::rwlock::MappedRwLockWriteGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::bytes::Split implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:915 ~ regex[3103]::re_bytes::{impl#15}): impl std::iter::traits::marker::FusedIterator for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2236 ~ regex[3103]::re_bytes::{impl#45}): impl std::fmt::Debug for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:910 ~ regex[3103]::re_bytes::{impl#14}): impl std::iter::traits::iterator::Iterator for regex::bytes::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::RegexSet implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::RegexSet
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::RegexSet
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::RegexSet
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2362 ~ regex[3103]::re_set::unicode::{impl#13}): impl std::clone::Clone for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2355 ~ regex[3103]::re_set::unicode::{impl#12}): impl std::fmt::Debug for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2320 ~ regex[3103]::re_set::unicode::{impl#1}): impl std::default::Default for regex::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::NoExpand implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2616 ~ regex[3103]::re_unicode::{impl#57}): impl std::fmt::Debug for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}): impl regex::Replacer for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2613 ~ regex[3103]::re_unicode::{impl#56}): impl std::clone::Clone for regex::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::Matches implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:892 ~ regex[3103]::re_bytes::{impl#10}): impl std::iter::traits::iterator::Iterator for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2218 ~ regex[3103]::re_bytes::{impl#43}): impl std::fmt::Debug for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:898 ~ regex[3103]::re_bytes::{impl#11}): impl std::iter::traits::marker::FusedIterator for regex::bytes::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::Matches implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1302 ~ regex[3103]::re_unicode::{impl#29}): impl std::iter::traits::iterator::Iterator for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2596 ~ regex[3103]::re_unicode::{impl#54}): impl std::fmt::Debug for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1308 ~ regex[3103]::re_unicode::{impl#30}): impl std::iter::traits::marker::FusedIterator for regex::Matches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::pin::Pin implement 1 traits: 
DefId(2:9692 ~ core[b693]::pin::{impl#13}): impl std::ops::Deref for std::pin::Pin::<Ptr>
bounds: GenericParamMap { inner: {"Ptr": []}, generic_defs: ["Ptr"], type_pred: [(Generic("Ptr"), [Path { res: Def(Trait, DefId(2:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::io::IoSlice implement 1 traits: 
DefId(1:3660 ~ std[d8a0]::io::{impl#11}): impl std::ops::Deref for std::io::IoSlice::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::rc::Rc implement 1 traits: 
DefId(5:5149 ~ alloc[2c7c]::rc::{impl#25}): impl std::ops::Deref for std::rc::Rc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::sync::rwlock::MappedRwLockReadGuard implement 1 traits: 
DefId(1:7054 ~ std[d8a0]::sync::rwlock::{impl#28}): impl std::ops::Deref for std::sync::rwlock::MappedRwLockReadGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::ffi::os_str::OsStr implement 60 traits: 
DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9117 ~ std[d8a0]::path::{impl#191}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9104 ~ std[d8a0]::path::{impl#187}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9110 ~ std[d8a0]::path::{impl#189}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9125 ~ std[d8a0]::path::{impl#193}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9023 ~ std[d8a0]::path::{impl#159}): impl std::cmp::PartialEq::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9032 ~ std[d8a0]::path::{impl#163}): impl std::cmp::PartialEq::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9064 ~ std[d8a0]::path::{impl#175}): impl std::cmp::PartialEq::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5572 ~ std[d8a0]::path::{impl#74}): impl std::convert::AsRef::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9038 ~ std[d8a0]::path::{impl#165}): impl std::cmp::PartialOrd::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9070 ~ std[d8a0]::path::{impl#177}): impl std::cmp::PartialOrd::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9027 ~ std[d8a0]::path::{impl#161}): impl std::cmp::PartialOrd::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9023 ~ std[d8a0]::path::{impl#159}): impl std::cmp::PartialEq::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8983 ~ std[d8a0]::path::{impl#143}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41}): impl std::cmp::PartialEq::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8992 ~ std[d8a0]::path::{impl#147}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2228 ~ std[d8a0]::ffi::os_str::{impl#40}): impl std::cmp::PartialEq for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9117 ~ std[d8a0]::path::{impl#191}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9032 ~ std[d8a0]::path::{impl#163}): impl std::cmp::PartialEq::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9064 ~ std[d8a0]::path::{impl#175}): impl std::cmp::PartialEq::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9104 ~ std[d8a0]::path::{impl#187}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2265 ~ std[d8a0]::ffi::os_str::{impl#53}): impl std::borrow::ToOwned for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2249 ~ std[d8a0]::ffi::os_str::{impl#48}): impl std::fmt::Debug for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2269 ~ std[d8a0]::ffi::os_str::{impl#54}): impl std::convert::AsRef::<std::ffi::OsStr> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5572 ~ std[d8a0]::path::{impl#74}): impl std::convert::AsRef::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2243 ~ std[d8a0]::ffi::os_str::{impl#46}): impl std::cmp::Ord for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9110 ~ std[d8a0]::path::{impl#189}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2235 ~ std[d8a0]::ffi::os_str::{impl#44}): impl std::cmp::PartialOrd for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45}): impl std::cmp::PartialOrd::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8987 ~ std[d8a0]::path::{impl#145}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9038 ~ std[d8a0]::path::{impl#165}): impl std::cmp::PartialOrd::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8998 ~ std[d8a0]::path::{impl#149}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9070 ~ std[d8a0]::path::{impl#177}): impl std::cmp::PartialOrd::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9027 ~ std[d8a0]::path::{impl#161}): impl std::cmp::PartialOrd::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9125 ~ std[d8a0]::path::{impl#193}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:4127 ~ std[d8a0]::os::unix::ffi::os_str::{impl#1}): impl std::os::unix::ffi::os_str::OsStrExt for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2226 ~ std[d8a0]::ffi::os_str::{impl#39}): impl std::default::Default for &std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2246 ~ std[d8a0]::ffi::os_str::{impl#47}): impl std::hash::Hash for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2234 ~ std[d8a0]::ffi::os_str::{impl#43}): impl std::cmp::Eq for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8983 ~ std[d8a0]::path::{impl#143}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8992 ~ std[d8a0]::path::{impl#147}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8987 ~ std[d8a0]::path::{impl#145}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8998 ~ std[d8a0]::path::{impl#149}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41}): impl std::cmp::PartialEq::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45}): impl std::cmp::PartialOrd::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::Ref implement 1 traits: 
DefId(2:4846 ~ core[b693]::cell::{impl#37}): impl std::ops::Deref for std::cell::Ref::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ops::range::Range implement 4 traits: 
DefId(0:827 ~ regex[3103]::re_bytes::{impl#2}): impl std::convert::From::<regex::bytes::Match::<'t>> for std::ops::range::Range::<usize>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1136 ~ regex[3103]::re_unicode::{impl#3}): impl std::convert::From::<regex::Match::<'t>> for std::ops::range::Range::<usize>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:827 ~ regex[3103]::re_bytes::{impl#2}): impl std::convert::From::<regex::bytes::Match::<'t>> for std::ops::range::Range::<usize>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1136 ~ regex[3103]::re_unicode::{impl#3}): impl std::convert::From::<regex::Match::<'t>> for std::ops::range::Range::<usize>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::Regex implement 20 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:5953 ~ alloc[2c7c]::string::{impl#32}): impl std::string::ToString for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:836 ~ regex[3103]::re_bytes::{impl#6}): impl std::str::FromStr for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:832 ~ regex[3103]::re_bytes::{impl#4}): impl std::fmt::Debug for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2211 ~ regex[3103]::re_bytes::{impl#42}): impl std::clone::Clone for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:830 ~ regex[3103]::re_bytes::{impl#3}): impl std::fmt::Display for regex::bytes::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::SetMatchesIter implement 21 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2468 ~ regex[3103]::re_set::bytes::{impl#17}): impl std::clone::Clone for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2471 ~ regex[3103]::re_set::bytes::{impl#18}): impl std::fmt::Debug for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2436 ~ regex[3103]::re_set::bytes::{impl#9}): impl std::iter::traits::double_ended::DoubleEndedIterator for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2439 ~ regex[3103]::re_set::bytes::{impl#10}): impl std::iter::traits::marker::FusedIterator for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2431 ~ regex[3103]::re_set::bytes::{impl#8}): impl std::iter::traits::iterator::Iterator for regex::bytes::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::result::Result implement 25 traits: 
DefId(9:222 ~ miniz_oxide[68e8]::{impl#3}): impl std::convert::From::<miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(9:224 ~ miniz_oxide[68e8]::{impl#4}): impl std::convert::From::<&miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10099 ~ core[b693]::result::{impl#28}): impl std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> for std::result::Result::<T, F>
bounds: GenericParamMap { inner: {"T": [], "E": [], "F": []}, generic_defs: ["T", "E", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }])] }
DefId(1:5827 ~ std[d8a0]::process::{impl#61}): impl std::process::Termination for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:5817 ~ std[d8a0]::process::Termination)), segments: [PathSegment { name: "Termination", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10080 ~ core[b693]::result::{impl#25}): impl std::iter::traits::collect::FromIterator::<std::result::Result::<A, E>> for std::result::Result::<V, E>
bounds: GenericParamMap { inner: {"V": [], "A": [], "E": []}, generic_defs: ["A", "E", "V"], type_pred: [(Generic("V"), [Path { res: Def(Trait, DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator)), segments: [PathSegment { name: "FromIterator", args: AngleBracketed { args: [Type(Generic("A"))], constraints: [] } }] }])] }
DefId(2:42854 ~ core[b693]::result::{impl#30}): impl std::marker::Copy for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42864 ~ core[b693]::result::{impl#33}): impl std::cmp::PartialOrd for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8293 ~ core[b693]::iter::traits::accum::{impl#1}): impl std::iter::traits::accum::Product::<std::result::Result::<U, E>> for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": [], "U": []}, generic_defs: ["T", "U", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:8280 ~ core[b693]::iter::traits::accum::Product)), segments: [PathSegment { name: "Product", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:42857 ~ core[b693]::result::{impl#31}): impl std::marker::StructuralPartialEq for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:42880 ~ core[b693]::result::{impl#37}): impl std::hash::Hash for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10104 ~ core[b693]::result::{impl#29}): impl std::ops::try_trait::Residual::<T> for std::result::Result::<std::convert::Infallible, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:10017 ~ core[b693]::result::{impl#7}): impl std::iter::traits::collect::IntoIterator for &'a std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:10024 ~ core[b693]::result::{impl#8}): impl std::iter::traits::collect::IntoIterator for &'a mut std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:10011 ~ core[b693]::result::{impl#6}): impl std::iter::traits::collect::IntoIterator for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:42876 ~ core[b693]::result::{impl#36}): impl std::fmt::Debug for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42868 ~ core[b693]::result::{impl#34}): impl std::cmp::Eq for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10006 ~ core[b693]::result::{impl#5}): impl std::clone::Clone for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42860 ~ core[b693]::result::{impl#32}): impl std::cmp::PartialEq for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42872 ~ core[b693]::result::{impl#35}): impl std::cmp::Ord for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10094 ~ core[b693]::result::{impl#27}): impl std::ops::try_trait::FromResidual::<std::result::Result::<std::convert::Infallible, E>> for std::result::Result::<T, F>
bounds: GenericParamMap { inner: {"T": [], "E": [], "F": []}, generic_defs: ["T", "E", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }])] }
DefId(2:10099 ~ core[b693]::result::{impl#28}): impl std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> for std::result::Result::<T, F>
bounds: GenericParamMap { inner: {"T": [], "E": [], "F": []}, generic_defs: ["T", "E", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }])] }
DefId(2:8286 ~ core[b693]::iter::traits::accum::{impl#0}): impl std::iter::traits::accum::Sum::<std::result::Result::<U, E>> for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": [], "U": []}, generic_defs: ["T", "U", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum)), segments: [PathSegment { name: "Sum", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:10087 ~ core[b693]::result::{impl#26}): impl std::ops::try_trait::Try for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(9:222 ~ miniz_oxide[68e8]::{impl#3}): impl std::convert::From::<miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(9:224 ~ miniz_oxide[68e8]::{impl#4}): impl std::convert::From::<&miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::RegexBuilder implement 14 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2138 ~ regex[3103]::re_builder::unicode::{impl#1}): impl std::fmt::Debug for regex::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::SetMatches implement 19 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2455 ~ regex[3103]::re_set::bytes::{impl#14}): impl std::clone::Clone for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2415 ~ regex[3103]::re_set::bytes::{impl#3}): impl std::iter::traits::collect::IntoIterator for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2419 ~ regex[3103]::re_set::bytes::{impl#4}): impl std::iter::traits::collect::IntoIterator for &'a regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2457 ~ regex[3103]::re_set::bytes::{impl#15}): impl std::fmt::Debug for regex::bytes::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::slice implement 66 traits: 
DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &[T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(21:2518 ~ aho_corasick[9659]::util::primitives::{impl#54}): impl std::ops::Index::<aho_corasick::util::primitives::PatternID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:2522 ~ aho_corasick[9659]::util::primitives::{impl#55}): impl std::ops::IndexMut::<aho_corasick::util::primitives::PatternID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:1519 ~ aho_corasick[9659]::util::search::{impl#5}): impl std::ops::Index::<aho_corasick::util::search::Span> for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(21:1522 ~ aho_corasick[9659]::util::search::{impl#6}): impl std::ops::IndexMut::<aho_corasick::util::search::Span> for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(21:1404 ~ aho_corasick[9659]::util::primitives::{impl#1}): impl std::ops::Index::<aho_corasick::util::primitives::SmallIndex> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:1408 ~ aho_corasick[9659]::util::primitives::{impl#2}): impl std::ops::IndexMut::<aho_corasick::util::primitives::SmallIndex> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:2617 ~ aho_corasick[9659]::util::primitives::{impl#82}): impl std::ops::Index::<aho_corasick::util::primitives::StateID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:2621 ~ aho_corasick[9659]::util::primitives::{impl#83}): impl std::ops::IndexMut::<aho_corasick::util::primitives::StateID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:3237 ~ std[d8a0]::io::impls::{impl#10}): impl std::io::Write for &mut [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3888 ~ std[d8a0]::net::socket_addr::{impl#13}): impl std::net::ToSocketAddrs for &'a [std::net::SocketAddr]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51}): impl std::slice::Join::<&std::ffi::OsStr> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }])] }
DefId(1:3234 ~ std[d8a0]::io::impls::{impl#9}): impl std::io::BufRead for &[u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3224 ~ std[d8a0]::io::impls::{impl#8}): impl std::io::Read for &[u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:659 ~ std[d8a0]::ascii::{impl#2}): impl std::ascii::AsciiExt for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:11474 ~ core[b693]::slice::cmp::{impl#3}): impl std::cmp::PartialOrd for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:13569 ~ core[b693]::str::pattern::{impl#24}): impl std::str::pattern::Pattern::<'a> for &'b [char]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32840 ~ core[b693]::marker::{impl#35}): impl std::marker::StructuralPartialEq for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:10971 ~ core[b693]::hash::impls::{impl#4}): impl std::hash::Hash for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:11728 ~ core[b693]::slice::iter::{impl#1}): impl std::iter::traits::collect::IntoIterator for &'a [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:11734 ~ core[b693]::slice::iter::{impl#2}): impl std::iter::traits::collect::IntoIterator for &'a mut [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:2823 ~ core[b693]::clone::{impl#2}): impl std::clone::CloneToUninit for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2826 ~ core[b693]::clone::{impl#3}): impl std::clone::CloneToUninit for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10801 ~ core[b693]::fmt::{impl#26}): impl std::fmt::Debug for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:32928 ~ core[b693]::marker::{impl#93}): impl std::marker::ConstParamTy for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32908 ~ core[b693]::marker::ConstParamTy)), segments: [PathSegment { name: "ConstParamTy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:11526 ~ core[b693]::slice::index::{impl#1}): impl std::ops::IndexMut::<I> for [T]
bounds: GenericParamMap { inner: {"T": [], "I": []}, generic_defs: ["T", "I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(2:11521 ~ core[b693]::slice::index::{impl#0}): impl std::ops::Index::<I> for [T]
bounds: GenericParamMap { inner: {"T": [], "I": []}, generic_defs: ["T", "I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(2:11469 ~ core[b693]::slice::cmp::{impl#1}): impl std::cmp::Eq for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3113 ~ core[b693]::convert::{impl#9}): impl std::convert::AsMut::<[T]> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:12933 ~ core[b693]::slice::{impl#8}): impl std::slice::SlicePattern for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:4122 ~ core[b693]::array::equality::{impl#6}): impl std::cmp::PartialEq::<[U;N]> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4098 ~ core[b693]::array::equality::{impl#2}): impl std::cmp::PartialEq::<[U;N]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4110 ~ core[b693]::array::equality::{impl#4}): impl std::cmp::PartialEq::<[U;N]> for &[T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:11464 ~ core[b693]::slice::cmp::{impl#0}): impl std::cmp::PartialEq::<[U]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:12927 ~ core[b693]::slice::{impl#7}): impl std::default::Default for &mut [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:12924 ~ core[b693]::slice::{impl#6}): impl std::default::Default for &[T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:11471 ~ core[b693]::slice::cmp::{impl#2}): impl std::cmp::Ord for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:11726 ~ core[b693]::slice::iter::{impl#0}): impl std::iter::traits::iterator::Iterator for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3110 ~ core[b693]::convert::{impl#8}): impl std::convert::AsRef::<[T]> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &[T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:5680 ~ alloc[2c7c]::str::{impl#1}): impl std::slice::Join::<&str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3}): impl std::slice::Join::<&T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5571 ~ alloc[2c7c]::slice::{impl#4}): impl std::slice::Join::<&[T]> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5676 ~ alloc[2c7c]::str::{impl#0}): impl std::slice::Concat::<str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(5:5559 ~ alloc[2c7c]::slice::{impl#2}): impl std::slice::Concat::<T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5597 ~ alloc[2c7c]::slice::{impl#9}): impl std::borrow::ToOwned for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(21:2518 ~ aho_corasick[9659]::util::primitives::{impl#54}): impl std::ops::Index::<aho_corasick::util::primitives::PatternID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:2617 ~ aho_corasick[9659]::util::primitives::{impl#82}): impl std::ops::Index::<aho_corasick::util::primitives::StateID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:1519 ~ aho_corasick[9659]::util::search::{impl#5}): impl std::ops::Index::<aho_corasick::util::search::Span> for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(21:1404 ~ aho_corasick[9659]::util::primitives::{impl#1}): impl std::ops::Index::<aho_corasick::util::primitives::SmallIndex> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:1522 ~ aho_corasick[9659]::util::search::{impl#6}): impl std::ops::IndexMut::<aho_corasick::util::search::Span> for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(21:2621 ~ aho_corasick[9659]::util::primitives::{impl#83}): impl std::ops::IndexMut::<aho_corasick::util::primitives::StateID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:2522 ~ aho_corasick[9659]::util::primitives::{impl#55}): impl std::ops::IndexMut::<aho_corasick::util::primitives::PatternID> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(21:1408 ~ aho_corasick[9659]::util::primitives::{impl#2}): impl std::ops::IndexMut::<aho_corasick::util::primitives::SmallIndex> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}): impl regex::bytes::Replacer for &'a [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51}): impl std::slice::Join::<&std::ffi::OsStr> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }])] }
DefId(2:4122 ~ core[b693]::array::equality::{impl#6}): impl std::cmp::PartialEq::<[U;N]> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4098 ~ core[b693]::array::equality::{impl#2}): impl std::cmp::PartialEq::<[U;N]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4110 ~ core[b693]::array::equality::{impl#4}): impl std::cmp::PartialEq::<[U;N]> for &[T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3}): impl std::slice::Join::<&T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5680 ~ alloc[2c7c]::str::{impl#1}): impl std::slice::Join::<&str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(5:5676 ~ alloc[2c7c]::str::{impl#0}): impl std::slice::Concat::<str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }

type regex::bytes::Match implement 22 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2820 ~ core[b693]::clone::{impl#1}): impl std::clone::CloneToUninit for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2197 ~ regex[3103]::re_bytes::{impl#38}): impl std::clone::Clone for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:824 ~ regex[3103]::re_bytes::{impl#1}): impl std::fmt::Debug for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2205 ~ regex[3103]::re_bytes::{impl#41}): impl std::cmp::PartialEq for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2203 ~ regex[3103]::re_bytes::{impl#40}): impl std::marker::StructuralPartialEq for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2195 ~ regex[3103]::re_bytes::{impl#37}): impl std::marker::Copy for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2200 ~ regex[3103]::re_bytes::{impl#39}): impl std::cmp::Eq for regex::bytes::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::ffi::va_list::VaListImpl implement 3 traits: 
DefId(2:41176 ~ core[b693]::ffi::va_list::{impl#8}): impl std::fmt::Debug for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5332 ~ core[b693]::ffi::va_list::{impl#6}): impl std::clone::Clone for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5335 ~ core[b693]::ffi::va_list::{impl#7}): impl std::ops::drop::Drop for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::CaptureLocations implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2567 ~ regex[3103]::re_unicode::{impl#50}): impl std::fmt::Debug for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2565 ~ regex[3103]::re_unicode::{impl#49}): impl std::clone::Clone for regex::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::mem::manually_drop::ManuallyDrop implement 1 traits: 
DefId(2:1973 ~ core[b693]::mem::manually_drop::{impl#2}): impl std::ops::Deref for std::mem::manually_drop::ManuallyDrop::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::bytes::NoExpand implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}): impl regex::bytes::Replacer for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2292 ~ regex[3103]::re_bytes::{impl#54}): impl std::clone::Clone for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2295 ~ regex[3103]::re_bytes::{impl#55}): impl std::fmt::Debug for regex::bytes::NoExpand::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::RegexSetBuilder implement 14 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2163 ~ regex[3103]::re_builder::set_bytes::{impl#1}): impl std::fmt::Debug for regex::bytes::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::Split implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2549 ~ regex[3103]::re_unicode::{impl#47}): impl std::fmt::Debug for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1218 ~ regex[3103]::re_unicode::{impl#15}): impl std::iter::traits::marker::FusedIterator for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1213 ~ regex[3103]::re_unicode::{impl#14}): impl std::iter::traits::iterator::Iterator for regex::Split::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::rwlock::RwLockWriteGuard implement 1 traits: 
DefId(1:7047 ~ std[d8a0]::sync::rwlock::{impl#26}): impl std::ops::Deref for std::sync::rwlock::RwLockWriteGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::cell::RefMut implement 1 traits: 
DefId(2:4903 ~ core[b693]::cell::{impl#45}): impl std::ops::Deref for std::cell::RefMut::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::bytes::SetMatchesIntoIter implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2424 ~ regex[3103]::re_set::bytes::{impl#5}): impl std::iter::traits::iterator::Iterator for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2430 ~ regex[3103]::re_set::bytes::{impl#7}): impl std::iter::traits::marker::FusedIterator for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2428 ~ regex[3103]::re_set::bytes::{impl#6}): impl std::iter::traits::double_ended::DoubleEndedIterator for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2462 ~ regex[3103]::re_set::bytes::{impl#16}): impl std::fmt::Debug for regex::bytes::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::str implement 47 traits: 
DefId(5:7792 ~ alloc[2c7c]::string::{impl#82}): impl std::cmp::PartialEq::<std::string::String> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7802 ~ alloc[2c7c]::string::{impl#84}): impl std::cmp::PartialEq::<std::string::String> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7812 ~ alloc[2c7c]::string::{impl#86}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7822 ~ alloc[2c7c]::string::{impl#88}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1133 ~ regex[3103]::re_unicode::{impl#2}): impl std::convert::From::<regex::Match::<'t>> for &'t str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(21:1524 ~ aho_corasick[9659]::util::search::{impl#7}): impl std::ops::Index::<aho_corasick::util::search::Span> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5578 ~ std[d8a0]::path::{impl#77}): impl std::convert::AsRef::<std::path::Path> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13877 ~ core[b693]::str::{impl#1}): impl std::convert::AsRef::<[u8]> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42}): impl std::cmp::PartialEq::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56}): impl std::convert::AsRef::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37}): impl std::convert::TryFrom::<&'a std::ffi::OsStr> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14}): impl std::cmp::PartialEq::<std::ffi::OsString> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14}): impl std::cmp::PartialEq::<std::ffi::OsString> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42}): impl std::cmp::PartialEq::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56}): impl std::convert::AsRef::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5578 ~ std[d8a0]::path::{impl#77}): impl std::convert::AsRef::<std::path::Path> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37}): impl std::convert::TryFrom::<&'a std::ffi::OsStr> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3885 ~ std[d8a0]::net::socket_addr::{impl#12}): impl std::net::ToSocketAddrs for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:661 ~ std[d8a0]::ascii::{impl#3}): impl std::ascii::AsciiExt for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13307 ~ core[b693]::str::traits::{impl#3}): impl std::cmp::PartialOrd for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13883 ~ core[b693]::str::{impl#4}): impl std::error::Error for &str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13591 ~ core[b693]::str::pattern::{impl#31}): impl std::str::pattern::Pattern::<'a> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32835 ~ core[b693]::marker::{impl#32}): impl std::marker::StructuralPartialEq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10962 ~ core[b693]::hash::impls::{impl#2}): impl std::hash::Hash for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10771 ~ core[b693]::fmt::{impl#17}): impl std::fmt::Display for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10767 ~ core[b693]::fmt::{impl#16}): impl std::fmt::Debug for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32923 ~ core[b693]::marker::{impl#90}): impl std::marker::ConstParamTy for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13313 ~ core[b693]::str::traits::{impl#5}): impl std::ops::IndexMut::<I> for str
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(2:13309 ~ core[b693]::str::traits::{impl#4}): impl std::ops::Index::<I> for str
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(2:13306 ~ core[b693]::str::traits::{impl#2}): impl std::cmp::Eq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3118 ~ core[b693]::convert::{impl#11}): impl std::convert::AsMut::<str> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13304 ~ core[b693]::str::traits::{impl#1}): impl std::cmp::PartialEq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13881 ~ core[b693]::str::{impl#3}): impl std::default::Default for &mut str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13879 ~ core[b693]::str::{impl#2}): impl std::default::Default for &str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13302 ~ core[b693]::str::traits::{impl#0}): impl std::cmp::Ord for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13877 ~ core[b693]::str::{impl#1}): impl std::convert::AsRef::<[u8]> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3116 ~ core[b693]::convert::{impl#10}): impl std::convert::AsRef::<str> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7792 ~ alloc[2c7c]::string::{impl#82}): impl std::cmp::PartialEq::<std::string::String> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7812 ~ alloc[2c7c]::string::{impl#86}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7822 ~ alloc[2c7c]::string::{impl#88}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7802 ~ alloc[2c7c]::string::{impl#84}): impl std::cmp::PartialEq::<std::string::String> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5697 ~ alloc[2c7c]::str::{impl#4}): impl std::borrow::ToOwned for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(21:1524 ~ aho_corasick[9659]::util::search::{impl#7}): impl std::ops::Index::<aho_corasick::util::search::Span> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}): impl regex::Replacer for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1133 ~ regex[3103]::re_unicode::{impl#2}): impl std::convert::From::<regex::Match::<'t>> for &'t str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::RegexSet implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2450 ~ regex[3103]::re_set::bytes::{impl#13}): impl std::clone::Clone for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2408 ~ regex[3103]::re_set::bytes::{impl#1}): impl std::default::Default for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2443 ~ regex[3103]::re_set::bytes::{impl#12}): impl std::fmt::Debug for regex::bytes::RegexSet
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::borrow::Cow implement 5 traits: 
DefId(5:802 ~ alloc[2c7c]::borrow::{impl#4}): impl std::ops::Deref for std::borrow::Cow::<'_, B>
bounds: GenericParamMap { inner: {"B": []}, generic_defs: ["B"], type_pred: [(Generic("B"), [Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (QPath(QPathData { assoc: PathSegment { name: "Owned", args: AngleBracketed { args: [], constraints: [] } }, self_type: Generic("B"), should_show_cast: true, trait_: Some(Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }) }), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] }])] }
DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}): impl regex::bytes::Replacer for &'a std::borrow::Cow::<'a, [u8]>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}): impl regex::bytes::Replacer for std::borrow::Cow::<'a, [u8]>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}): impl regex::Replacer for &'a std::borrow::Cow::<'a, str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}): impl regex::Replacer for std::borrow::Cow::<'a, str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::SubCaptureMatches implement 21 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1287 ~ regex[3103]::re_unicode::{impl#25}): impl std::iter::traits::exact_size::ExactSizeIterator for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1278 ~ regex[3103]::re_unicode::{impl#24}): impl std::iter::traits::iterator::Iterator for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2578 ~ regex[3103]::re_unicode::{impl#52}): impl std::fmt::Debug for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2574 ~ regex[3103]::re_unicode::{impl#51}): impl std::clone::Clone for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1290 ~ regex[3103]::re_unicode::{impl#26}): impl std::iter::traits::marker::FusedIterator for regex::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::RegexSetBuilder implement 14 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2188 ~ regex[3103]::re_builder::set_unicode::{impl#1}): impl std::fmt::Debug for regex::RegexSetBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::RegexBuilder implement 14 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2115 ~ regex[3103]::re_builder::bytes::{impl#1}): impl std::fmt::Debug for regex::bytes::RegexBuilder
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::SplitN implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:918 ~ regex[3103]::re_bytes::{impl#16}): impl std::iter::traits::iterator::Iterator for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2245 ~ regex[3103]::re_bytes::{impl#46}): impl std::fmt::Debug for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:924 ~ regex[3103]::re_bytes::{impl#17}): impl std::iter::traits::marker::FusedIterator for regex::bytes::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::path::PathBuf implement 1 traits: 
DefId(1:5438 ~ std[d8a0]::path::{impl#44}): impl std::ops::Deref for std::path::PathBuf
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::CaptureMatches implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:901 ~ regex[3103]::re_bytes::{impl#12}): impl std::iter::traits::iterator::Iterator for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2227 ~ regex[3103]::re_bytes::{impl#44}): impl std::fmt::Debug for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:907 ~ regex[3103]::re_bytes::{impl#13}): impl std::iter::traits::marker::FusedIterator for regex::bytes::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::path::Path implement 55 traits: 
DefId(1:9073 ~ std[d8a0]::path::{impl#178}): impl std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8957 ~ std[d8a0]::path::{impl#135}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9041 ~ std[d8a0]::path::{impl#166}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8944 ~ std[d8a0]::path::{impl#131}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8950 ~ std[d8a0]::path::{impl#133}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9081 ~ std[d8a0]::path::{impl#180}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9047 ~ std[d8a0]::path::{impl#168}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8965 ~ std[d8a0]::path::{impl#137}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9021 ~ std[d8a0]::path::{impl#158}): impl std::cmp::PartialEq::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9053 ~ std[d8a0]::path::{impl#170}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8932 ~ std[d8a0]::path::{impl#127}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9029 ~ std[d8a0]::path::{impl#162}): impl std::cmp::PartialEq::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9073 ~ std[d8a0]::path::{impl#178}): impl std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5560 ~ std[d8a0]::path::{impl#68}): impl std::cmp::PartialEq for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8957 ~ std[d8a0]::path::{impl#135}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8923 ~ std[d8a0]::path::{impl#123}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9041 ~ std[d8a0]::path::{impl#166}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9089 ~ std[d8a0]::path::{impl#182}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8944 ~ std[d8a0]::path::{impl#131}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9061 ~ std[d8a0]::path::{impl#174}): impl std::cmp::PartialEq::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5467 ~ std[d8a0]::path::{impl#56}): impl std::borrow::ToOwned for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5551 ~ std[d8a0]::path::{impl#65}): impl std::fmt::Debug for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5549 ~ std[d8a0]::path::{impl#64}): impl std::convert::AsRef::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5570 ~ std[d8a0]::path::{impl#73}): impl std::convert::AsRef::<std::path::Path> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5568 ~ std[d8a0]::path::{impl#72}): impl std::cmp::Ord for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8927 ~ std[d8a0]::path::{impl#125}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8938 ~ std[d8a0]::path::{impl#129}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8950 ~ std[d8a0]::path::{impl#133}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9095 ~ std[d8a0]::path::{impl#184}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9067 ~ std[d8a0]::path::{impl#176}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9035 ~ std[d8a0]::path::{impl#164}): impl std::cmp::PartialOrd::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9081 ~ std[d8a0]::path::{impl#180}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9047 ~ std[d8a0]::path::{impl#168}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8965 ~ std[d8a0]::path::{impl#137}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9025 ~ std[d8a0]::path::{impl#160}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5566 ~ std[d8a0]::path::{impl#71}): impl std::cmp::PartialOrd for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9057 ~ std[d8a0]::path::{impl#172}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5589 ~ std[d8a0]::path::{impl#81}): impl std::iter::traits::collect::IntoIterator for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5562 ~ std[d8a0]::path::{impl#69}): impl std::hash::Hash for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5565 ~ std[d8a0]::path::{impl#70}): impl std::cmp::Eq for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9021 ~ std[d8a0]::path::{impl#158}): impl std::cmp::PartialEq::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9029 ~ std[d8a0]::path::{impl#162}): impl std::cmp::PartialEq::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9061 ~ std[d8a0]::path::{impl#174}): impl std::cmp::PartialEq::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5549 ~ std[d8a0]::path::{impl#64}): impl std::convert::AsRef::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9067 ~ std[d8a0]::path::{impl#176}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9035 ~ std[d8a0]::path::{impl#164}): impl std::cmp::PartialOrd::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9025 ~ std[d8a0]::path::{impl#160}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8932 ~ std[d8a0]::path::{impl#127}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8923 ~ std[d8a0]::path::{impl#123}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8927 ~ std[d8a0]::path::{impl#125}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8938 ~ std[d8a0]::path::{impl#129}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9053 ~ std[d8a0]::path::{impl#170}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9089 ~ std[d8a0]::path::{impl#182}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9095 ~ std[d8a0]::path::{impl#184}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9057 ~ std[d8a0]::path::{impl#172}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::ReplacerRef implement 15 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)), segments: [PathSegment { name: "RefUnwindSafe", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}): impl regex::Replacer for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": [Path { res: Def(Trait, DefId(0:1311 ~ regex[3103]::re_unicode::Replacer)), segments: [PathSegment { name: "Replacer", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]}, generic_defs: ["R"], type_pred: [] }
DefId(0:2605 ~ regex[3103]::re_unicode::{impl#55}): impl std::fmt::Debug for regex::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "$crate", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "fmt", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]}, generic_defs: ["R"], type_pred: [] }

type std::sync::rwlock::RwLockReadGuard implement 1 traits: 
DefId(1:7043 ~ std[d8a0]::sync::rwlock::{impl#25}): impl std::ops::Deref for std::sync::rwlock::RwLockReadGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::c_str::CStr implement 11 traits: 
DefId(2:5268 ~ core[b693]::ffi::c_str::{impl#9}): impl std::cmp::PartialOrd for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:41118 ~ core[b693]::ffi::c_str::{impl#18}): impl std::hash::Hash for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5242 ~ core[b693]::ffi::c_str::{impl#3}): impl std::fmt::Debug for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11}): impl std::ops::Index::<std::ops::range::RangeFrom::<usize>> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5267 ~ core[b693]::ffi::c_str::{impl#8}): impl std::cmp::Eq for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5265 ~ core[b693]::ffi::c_str::{impl#7}): impl std::cmp::PartialEq for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5244 ~ core[b693]::ffi::c_str::{impl#4}): impl std::default::Default for &std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5270 ~ core[b693]::ffi::c_str::{impl#10}): impl std::cmp::Ord for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5275 ~ core[b693]::ffi::c_str::{impl#12}): impl std::convert::AsRef::<std::ffi::CStr> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4872 ~ alloc[2c7c]::ffi::c_str::{impl#30}): impl std::borrow::ToOwned for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11}): impl std::ops::Index::<std::ops::range::RangeFrom::<usize>> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::sync::Arc implement 1 traits: 
DefId(5:6291 ~ alloc[2c7c]::sync::{impl#29}): impl std::ops::Deref for std::sync::Arc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::CaptureMatches implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1293 ~ regex[3103]::re_unicode::{impl#27}): impl std::iter::traits::iterator::Iterator for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2587 ~ regex[3103]::re_unicode::{impl#53}): impl std::fmt::Debug for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1299 ~ regex[3103]::re_unicode::{impl#28}): impl std::iter::traits::marker::FusedIterator for regex::CaptureMatches::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::CaptureLocations implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2262 ~ regex[3103]::re_bytes::{impl#49}): impl std::clone::Clone for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2264 ~ regex[3103]::re_bytes::{impl#50}): impl std::fmt::Debug for regex::bytes::CaptureLocations
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::Captures implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1250 ~ regex[3103]::re_unicode::{impl#20}): impl std::fmt::Debug for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1264 ~ regex[3103]::re_unicode::{impl#22}): impl std::ops::Index::<usize> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1270 ~ regex[3103]::re_unicode::{impl#23}): impl std::ops::Index::<&'i str> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1264 ~ regex[3103]::re_unicode::{impl#22}): impl std::ops::Index::<usize> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1270 ~ regex[3103]::re_unicode::{impl#23}): impl std::ops::Index::<&'i str> for regex::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::panic::unwind_safe::AssertUnwindSafe implement 9 traits: 
DefId(2:9504 ~ core[b693]::panic::unwind_safe::{impl#6}): impl std::panic::unwind_safe::UnwindSafe for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9527 ~ core[b693]::panic::unwind_safe::{impl#22}): impl std::ops::DerefMut for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9535 ~ core[b693]::panic::unwind_safe::{impl#24}): impl std::fmt::Debug for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9546 ~ core[b693]::panic::unwind_safe::{impl#27}): impl std::async_iter::async_iter::AsyncIterator for std::panic::unwind_safe::AssertUnwindSafe::<S>
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:4528 ~ core[b693]::async_iter::async_iter::AsyncIterator)), segments: [PathSegment { name: "AsyncIterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9541 ~ core[b693]::panic::unwind_safe::{impl#26}): impl std::future::future::Future for std::panic::unwind_safe::AssertUnwindSafe::<F>
bounds: GenericParamMap { inner: {"F": []}, generic_defs: ["F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:45483 ~ core[b693]::future::future::Future)), segments: [PathSegment { name: "Future", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9530 ~ core[b693]::panic::unwind_safe::{impl#23}): impl std::ops::function::FnOnce::Fn(<unknown>) -> <unknown> for std::panic::unwind_safe::AssertUnwindSafe::<F>
bounds: GenericParamMap { inner: {"R": [], "F": []}, generic_defs: ["R", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("R")) } }] }])] }
DefId(2:9538 ~ core[b693]::panic::unwind_safe::{impl#25}): impl std::default::Default for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3142 ~ core[b693]::default::Default)), segments: [PathSegment { name: "Default", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9523 ~ core[b693]::panic::unwind_safe::{impl#21}): impl std::ops::Deref for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9508 ~ core[b693]::panic::unwind_safe::{impl#8}): impl std::panic::unwind_safe::RefUnwindSafe for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }

type std::sync::lazy_lock::LazyLock implement 1 traits: 
DefId(1:6095 ~ std[d8a0]::sync::lazy_lock::{impl#3}): impl std::ops::Deref for std::sync::lazy_lock::LazyLock::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type alloc::boxed::Box implement 163 traits: 
DefId(5:639 ~ alloc[2c7c]::boxed::{impl#66}): impl std::iter::traits::collect::FromIterator::<std::string::String> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5989 ~ alloc[2c7c]::string::{impl#49}): impl std::convert::From::<std::string::String> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:729 ~ alloc[2c7c]::boxed::{impl#85}): impl std::convert::From::<std::string::String> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:717 ~ alloc[2c7c]::boxed::{impl#84}): impl std::convert::From::<std::string::String> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5406 ~ std[d8a0]::path::{impl#32}): impl std::convert::From::<std::borrow::Cow::<'_, std::path::Path>> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2192 ~ std[d8a0]::ffi::os_str::{impl#25}): impl std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:646 ~ alloc[2c7c]::boxed::{impl#68}): impl std::iter::traits::collect::FromIterator::<std::borrow::Cow::<'a, str>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:443 ~ alloc[2c7c]::boxed::{impl#25}): impl std::convert::From::<std::borrow::Cow::<'_, [T]>> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:4827 ~ alloc[2c7c]::ffi::c_str::{impl#10}): impl std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:448 ~ alloc[2c7c]::boxed::{impl#27}): impl std::convert::From::<std::borrow::Cow::<'_, str>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:742 ~ alloc[2c7c]::boxed::{impl#89}): impl std::convert::From::<std::borrow::Cow::<'b, str>> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:738 ~ alloc[2c7c]::boxed::{impl#88}): impl std::convert::From::<std::borrow::Cow::<'b, str>> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4835 ~ alloc[2c7c]::ffi::c_str::{impl#14}): impl std::convert::From::<std::ffi::CString> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3214 ~ std[d8a0]::io::impls::{impl#6}): impl std::io::Seek for std::boxed::Box::<S>
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:3682 ~ std[d8a0]::io::Seek)), segments: [PathSegment { name: "Seek", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:3206 ~ std[d8a0]::io::impls::{impl#5}): impl std::io::Write for std::boxed::Box::<W>
bounds: GenericParamMap { inner: {"W": []}, generic_defs: ["W"], type_pred: [(Generic("W"), [Path { res: Def(Trait, DefId(1:3664 ~ std[d8a0]::io::Write)), segments: [PathSegment { name: "Write", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:4983 ~ std[d8a0]::os::fd::raw::{impl#14}): impl std::os::fd::raw::AsRawFd for std::boxed::Box::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:4944 ~ std[d8a0]::os::fd::raw::AsRawFd)), segments: [PathSegment { name: "AsRawFd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:5406 ~ std[d8a0]::path::{impl#32}): impl std::convert::From::<std::borrow::Cow::<'_, std::path::Path>> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2190 ~ std[d8a0]::ffi::os_str::{impl#24}): impl std::convert::From::<&std::ffi::OsStr> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2196 ~ std[d8a0]::ffi::os_str::{impl#27}): impl std::convert::From::<std::ffi::OsString> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5410 ~ std[d8a0]::path::{impl#34}): impl std::convert::From::<std::path::PathBuf> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2192 ~ std[d8a0]::ffi::os_str::{impl#25}): impl std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5404 ~ std[d8a0]::path::{impl#31}): impl std::convert::From::<&std::path::Path> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5067 ~ std[d8a0]::os::fd::owned::{impl#28}): impl std::os::fd::owned::AsFd for std::boxed::Box::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:5025 ~ std[d8a0]::os::fd::owned::AsFd)), segments: [PathSegment { name: "AsFd", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:5412 ~ std[d8a0]::path::{impl#35}): impl std::clone::Clone for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2198 ~ std[d8a0]::ffi::os_str::{impl#28}): impl std::clone::Clone for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2224 ~ std[d8a0]::ffi::os_str::{impl#38}): impl std::default::Default for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3218 ~ std[d8a0]::io::impls::{impl#7}): impl std::io::BufRead for std::boxed::Box::<B>
bounds: GenericParamMap { inner: {"B": []}, generic_defs: ["B"], type_pred: [(Generic("B"), [Path { res: Def(Trait, DefId(1:3692 ~ std[d8a0]::io::BufRead)), segments: [PathSegment { name: "BufRead", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:3196 ~ std[d8a0]::io::impls::{impl#4}): impl std::io::Read for std::boxed::Box::<R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(1:3607 ~ std[d8a0]::io::Read)), segments: [PathSegment { name: "Read", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:659 ~ alloc[2c7c]::boxed::{impl#71}): impl std::borrow::BorrowMut::<T> for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:590 ~ alloc[2c7c]::boxed::{impl#55}): impl std::ops::unsize::DispatchFromDyn::<std::boxed::Box::<U>> for std::boxed::Box::<T>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3309 ~ core[b693]::marker::Unsize)), segments: [PathSegment { name: "Unsize", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("U"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:516 ~ alloc[2c7c]::boxed::{impl#42}): impl std::iter::traits::iterator::Iterator for std::boxed::Box::<I, A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:600 ~ alloc[2c7c]::boxed::{impl#58}): impl std::iter::traits::iterator::Iterator for &'a std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:604 ~ alloc[2c7c]::boxed::{impl#59}): impl std::iter::traits::iterator::Iterator for &'a mut std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:597 ~ alloc[2c7c]::boxed::{impl#57}): impl std::iter::traits::iterator::Iterator for std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:586 ~ alloc[2c7c]::boxed::{impl#54}): impl std::ops::unsize::CoerceUnsized::<std::boxed::Box::<U, A>> for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3309 ~ core[b693]::marker::Unsize)), segments: [PathSegment { name: "Unsize", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("U"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:359 ~ alloc[2c7c]::boxed::{impl#8}): impl std::ops::drop::Drop for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:635 ~ alloc[2c7c]::boxed::{impl#65}): impl std::iter::traits::collect::FromIterator::<&'a str> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:593 ~ alloc[2c7c]::boxed::{impl#56}): impl std::iter::traits::collect::FromIterator::<I> for std::boxed::Box::<[I]>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [] }
DefId(5:642 ~ alloc[2c7c]::boxed::{impl#67}): impl std::iter::traits::collect::FromIterator::<std::boxed::Box::<str, A>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {"A": []}, generic_defs: ["A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:639 ~ alloc[2c7c]::boxed::{impl#66}): impl std::iter::traits::collect::FromIterator::<std::string::String> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:631 ~ alloc[2c7c]::boxed::{impl#64}): impl std::iter::traits::collect::FromIterator::<&'a char> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:646 ~ alloc[2c7c]::boxed::{impl#68}): impl std::iter::traits::collect::FromIterator::<std::borrow::Cow::<'a, str>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:628 ~ alloc[2c7c]::boxed::{impl#63}): impl std::iter::traits::collect::FromIterator::<char> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:380 ~ alloc[2c7c]::boxed::{impl#14}): impl std::cmp::PartialEq for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:567 ~ alloc[2c7c]::boxed::{impl#51}): impl std::ops::async_function::AsyncFnOnce::<Args> for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"Args": [], "F": [], "A": []}, generic_defs: ["Args", "F", "A"], type_pred: [(Generic("Args"), [Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("F"), [Path { res: Def(Trait, DefId(2:3424 ~ core[b693]::ops::async_function::AsyncFnOnce)), segments: [PathSegment { name: "AsyncFnOnce", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:497 ~ alloc[2c7c]::boxed::{impl#37}): impl std::fmt::Pointer for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:688 ~ alloc[2c7c]::boxed::{impl#77}): impl std::future::future::Future for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"A": [], "F": []}, generic_defs: ["F", "A"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:45483 ~ core[b693]::future::future::Future)), segments: [PathSegment { name: "Future", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32876 ~ core[b693]::marker::Unpin)), segments: [PathSegment { name: "Unpin", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:746 ~ alloc[2c7c]::boxed::{impl#90}): impl std::error::Error for std::boxed::Box::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:501 ~ alloc[2c7c]::boxed::{impl#38}): impl std::ops::Deref for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:405 ~ alloc[2c7c]::boxed::{impl#19}): impl std::hash::Hasher for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10886 ~ core[b693]::hash::Hasher)), segments: [PathSegment { name: "Hasher", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:538 ~ alloc[2c7c]::boxed::{impl#45}): impl std::iter::traits::double_ended::DoubleEndedIterator for std::boxed::Box::<I, A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8393 ~ core[b693]::iter::traits::double_ended::DoubleEndedIterator)), segments: [PathSegment { name: "DoubleEndedIterator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:693 ~ alloc[2c7c]::boxed::{impl#78}): impl std::async_iter::async_iter::AsyncIterator for std::boxed::Box::<S>
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:4528 ~ core[b693]::async_iter::async_iter::AsyncIterator)), segments: [PathSegment { name: "AsyncIterator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32876 ~ core[b693]::marker::Unpin)), segments: [PathSegment { name: "Unpin", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:493 ~ alloc[2c7c]::boxed::{impl#36}): impl std::fmt::Debug for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:4825 ~ alloc[2c7c]::ffi::c_str::{impl#9}): impl std::convert::From::<&std::ffi::CStr> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:709 ~ alloc[2c7c]::boxed::{impl#82}): impl std::convert::From::<E> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {"E": []}, generic_defs: ["E"], type_pred: [(Generic("E"), [Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:424 ~ alloc[2c7c]::boxed::{impl#20}): impl std::convert::From::<T> for std::boxed::Box::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:5989 ~ alloc[2c7c]::string::{impl#49}): impl std::convert::From::<std::string::String> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:440 ~ alloc[2c7c]::boxed::{impl#24}): impl std::convert::From::<&[T]> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:443 ~ alloc[2c7c]::boxed::{impl#25}): impl std::convert::From::<std::borrow::Cow::<'_, [T]>> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:713 ~ alloc[2c7c]::boxed::{impl#83}): impl std::convert::From::<E> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {"E": []}, generic_defs: ["E"], type_pred: [(Generic("E"), [Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:4827 ~ alloc[2c7c]::ffi::c_str::{impl#10}): impl std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:450 ~ alloc[2c7c]::boxed::{impl#28}): impl std::convert::From::<std::boxed::Box::<str, A>> for std::boxed::Box::<[u8], A>
bounds: GenericParamMap { inner: {"A": []}, generic_defs: ["A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:446 ~ alloc[2c7c]::boxed::{impl#26}): impl std::convert::From::<&str> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:453 ~ alloc[2c7c]::boxed::{impl#29}): impl std::convert::From::<[T;N]> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:448 ~ alloc[2c7c]::boxed::{impl#27}): impl std::convert::From::<std::borrow::Cow::<'_, str>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7480 ~ alloc[2c7c]::vec::{impl#39}): impl std::convert::From::<std::vec::Vec::<T, A>> for std::boxed::Box::<[T], A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:742 ~ alloc[2c7c]::boxed::{impl#89}): impl std::convert::From::<std::borrow::Cow::<'b, str>> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:735 ~ alloc[2c7c]::boxed::{impl#87}): impl std::convert::From::<&str> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:729 ~ alloc[2c7c]::boxed::{impl#85}): impl std::convert::From::<std::string::String> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4835 ~ alloc[2c7c]::ffi::c_str::{impl#14}): impl std::convert::From::<std::ffi::CString> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:732 ~ alloc[2c7c]::boxed::{impl#86}): impl std::convert::From::<&str> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:738 ~ alloc[2c7c]::boxed::{impl#88}): impl std::convert::From::<std::borrow::Cow::<'b, str>> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:717 ~ alloc[2c7c]::boxed::{impl#84}): impl std::convert::From::<std::string::String> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:663 ~ alloc[2c7c]::boxed::{impl#72}): impl std::convert::AsRef::<T> for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:671 ~ alloc[2c7c]::boxed::{impl#74}): impl std::marker::Unpin for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:548 ~ alloc[2c7c]::boxed::{impl#47}): impl std::iter::traits::marker::FusedIterator for std::boxed::Box::<I, A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8806 ~ core[b693]::iter::traits::marker::FusedIterator)), segments: [PathSegment { name: "FusedIterator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:506 ~ alloc[2c7c]::boxed::{impl#39}): impl std::ops::DerefMut for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:489 ~ alloc[2c7c]::boxed::{impl#35}): impl std::fmt::Display for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:574 ~ alloc[2c7c]::boxed::{impl#52}): impl std::ops::async_function::AsyncFnMut::<Args> for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"Args": [], "F": [], "A": []}, generic_defs: ["Args", "F", "A"], type_pred: [(Generic("Args"), [Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("F"), [Path { res: Def(Trait, DefId(2:3419 ~ core[b693]::ops::async_function::AsyncFnMut)), segments: [PathSegment { name: "AsyncFnMut", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:385 ~ alloc[2c7c]::boxed::{impl#15}): impl std::cmp::PartialOrd for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:562 ~ alloc[2c7c]::boxed::{impl#50}): impl std::ops::function::Fn::<Args> for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"Args": [], "F": [], "A": []}, generic_defs: ["Args", "F", "A"], type_pred: [(Generic("Args"), [Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("F"), [Path { res: Def(Trait, DefId(2:3586 ~ core[b693]::ops::function::Fn)), segments: [PathSegment { name: "Fn", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:461 ~ alloc[2c7c]::boxed::{impl#30}): impl std::convert::TryFrom::<std::boxed::Box::<[T]>> for std::boxed::Box::<[T;N]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:466 ~ alloc[2c7c]::boxed::{impl#31}): impl std::convert::TryFrom::<std::vec::Vec::<T>> for std::boxed::Box::<[T;N]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:667 ~ alloc[2c7c]::boxed::{impl#73}): impl std::convert::AsMut::<T> for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:551 ~ alloc[2c7c]::boxed::{impl#48}): impl std::ops::function::FnOnce::<Args> for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"Args": [], "F": [], "A": []}, generic_defs: ["Args", "F", "A"], type_pred: [(Generic("Args"), [Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("F"), [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:378 ~ alloc[2c7c]::boxed::{impl#13}): impl std::clone::Clone for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:373 ~ alloc[2c7c]::boxed::{impl#12}): impl std::clone::Clone for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:650 ~ alloc[2c7c]::boxed::{impl#69}): impl std::clone::Clone for std::boxed::Box::<[T], A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:4833 ~ alloc[2c7c]::ffi::c_str::{impl#13}): impl std::clone::Clone for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:393 ~ alloc[2c7c]::boxed::{impl#16}): impl std::cmp::Ord for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:655 ~ alloc[2c7c]::boxed::{impl#70}): impl std::borrow::Borrow::<T> for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:581 ~ alloc[2c7c]::boxed::{impl#53}): impl std::ops::async_function::AsyncFn::<Args> for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"Args": [], "F": [], "A": []}, generic_defs: ["Args", "F", "A"], type_pred: [(Generic("Args"), [Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("F"), [Path { res: Def(Trait, DefId(2:3416 ~ core[b693]::ops::async_function::AsyncFn)), segments: [PathSegment { name: "AsyncFn", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:614 ~ alloc[2c7c]::boxed::{impl#61}): impl std::iter::traits::collect::IntoIterator for &'a std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:621 ~ alloc[2c7c]::boxed::{impl#62}): impl std::iter::traits::collect::IntoIterator for &'a mut std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:608 ~ alloc[2c7c]::boxed::{impl#60}): impl std::iter::traits::collect::IntoIterator for std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:366 ~ alloc[2c7c]::boxed::{impl#10}): impl std::default::Default for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:4856 ~ alloc[2c7c]::ffi::c_str::{impl#23}): impl std::default::Default for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:370 ~ alloc[2c7c]::boxed::{impl#11}): impl std::default::Default for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:363 ~ alloc[2c7c]::boxed::{impl#9}): impl std::default::Default for std::boxed::Box::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3142 ~ core[b693]::default::Default)), segments: [PathSegment { name: "Default", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:543 ~ alloc[2c7c]::boxed::{impl#46}): impl std::iter::traits::exact_size::ExactSizeIterator for std::boxed::Box::<I, A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8446 ~ core[b693]::iter::traits::exact_size::ExactSizeIterator)), segments: [PathSegment { name: "ExactSizeIterator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:400 ~ alloc[2c7c]::boxed::{impl#18}): impl std::hash::Hash for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:557 ~ alloc[2c7c]::boxed::{impl#49}): impl std::ops::function::FnMut::<Args> for std::boxed::Box::<F, A>
bounds: GenericParamMap { inner: {"Args": [], "F": [], "A": []}, generic_defs: ["Args", "F", "A"], type_pred: [(Generic("Args"), [Path { res: Def(Trait, DefId(2:32906 ~ core[b693]::marker::Tuple)), segments: [PathSegment { name: "Tuple", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("F"), [Path { res: Def(Trait, DefId(2:3589 ~ core[b693]::ops::function::FnMut)), segments: [PathSegment { name: "FnMut", args: AngleBracketed { args: [Type(Generic("Args"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:674 ~ alloc[2c7c]::boxed::{impl#75}): impl std::ops::coroutine::Coroutine::<R> for std::boxed::Box::<G, A>
bounds: GenericParamMap { inner: {"G": [], "R": [], "A": []}, generic_defs: ["G", "R", "A"], type_pred: [(Generic("G"), [Path { res: Def(Trait, DefId(2:3533 ~ core[b693]::ops::coroutine::Coroutine)), segments: [PathSegment { name: "Coroutine", args: AngleBracketed { args: [Type(Generic("R"))], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32876 ~ core[b693]::marker::Unpin)), segments: [PathSegment { name: "Unpin", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:510 ~ alloc[2c7c]::boxed::{impl#40}): impl std::ops::DerefPure for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:397 ~ alloc[2c7c]::boxed::{impl#17}): impl std::cmp::Eq for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:7480 ~ alloc[2c7c]::vec::{impl#39}): impl std::convert::From::<std::vec::Vec::<T, A>> for std::boxed::Box::<[T], A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:466 ~ alloc[2c7c]::boxed::{impl#31}): impl std::convert::TryFrom::<std::vec::Vec::<T>> for std::boxed::Box::<[T;N]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:4825 ~ alloc[2c7c]::ffi::c_str::{impl#9}): impl std::convert::From::<&std::ffi::CStr> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4827 ~ alloc[2c7c]::ffi::c_str::{impl#10}): impl std::convert::From::<std::borrow::Cow::<'_, std::ffi::CStr>> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4835 ~ alloc[2c7c]::ffi::c_str::{impl#14}): impl std::convert::From::<std::ffi::CString> for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4833 ~ alloc[2c7c]::ffi::c_str::{impl#13}): impl std::clone::Clone for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4856 ~ alloc[2c7c]::ffi::c_str::{impl#23}): impl std::default::Default for std::boxed::Box::<std::ffi::CStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:709 ~ alloc[2c7c]::boxed::{impl#82}): impl std::convert::From::<E> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {"E": []}, generic_defs: ["E"], type_pred: [(Generic("E"), [Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:713 ~ alloc[2c7c]::boxed::{impl#83}): impl std::convert::From::<E> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {"E": []}, generic_defs: ["E"], type_pred: [(Generic("E"), [Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:742 ~ alloc[2c7c]::boxed::{impl#89}): impl std::convert::From::<std::borrow::Cow::<'b, str>> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:735 ~ alloc[2c7c]::boxed::{impl#87}): impl std::convert::From::<&str> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:729 ~ alloc[2c7c]::boxed::{impl#85}): impl std::convert::From::<std::string::String> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:732 ~ alloc[2c7c]::boxed::{impl#86}): impl std::convert::From::<&str> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:738 ~ alloc[2c7c]::boxed::{impl#88}): impl std::convert::From::<std::borrow::Cow::<'b, str>> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:717 ~ alloc[2c7c]::boxed::{impl#84}): impl std::convert::From::<std::string::String> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5406 ~ std[d8a0]::path::{impl#32}): impl std::convert::From::<std::borrow::Cow::<'_, std::path::Path>> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5410 ~ std[d8a0]::path::{impl#34}): impl std::convert::From::<std::path::PathBuf> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5404 ~ std[d8a0]::path::{impl#31}): impl std::convert::From::<&std::path::Path> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5412 ~ std[d8a0]::path::{impl#35}): impl std::clone::Clone for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:600 ~ alloc[2c7c]::boxed::{impl#58}): impl std::iter::traits::iterator::Iterator for &'a std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:604 ~ alloc[2c7c]::boxed::{impl#59}): impl std::iter::traits::iterator::Iterator for &'a mut std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:597 ~ alloc[2c7c]::boxed::{impl#57}): impl std::iter::traits::iterator::Iterator for std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:593 ~ alloc[2c7c]::boxed::{impl#56}): impl std::iter::traits::collect::FromIterator::<I> for std::boxed::Box::<[I]>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [] }
DefId(5:440 ~ alloc[2c7c]::boxed::{impl#24}): impl std::convert::From::<&[T]> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:443 ~ alloc[2c7c]::boxed::{impl#25}): impl std::convert::From::<std::borrow::Cow::<'_, [T]>> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:450 ~ alloc[2c7c]::boxed::{impl#28}): impl std::convert::From::<std::boxed::Box::<str, A>> for std::boxed::Box::<[u8], A>
bounds: GenericParamMap { inner: {"A": []}, generic_defs: ["A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:453 ~ alloc[2c7c]::boxed::{impl#29}): impl std::convert::From::<[T;N]> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:7480 ~ alloc[2c7c]::vec::{impl#39}): impl std::convert::From::<std::vec::Vec::<T, A>> for std::boxed::Box::<[T], A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:650 ~ alloc[2c7c]::boxed::{impl#69}): impl std::clone::Clone for std::boxed::Box::<[T], A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:614 ~ alloc[2c7c]::boxed::{impl#61}): impl std::iter::traits::collect::IntoIterator for &'a std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:621 ~ alloc[2c7c]::boxed::{impl#62}): impl std::iter::traits::collect::IntoIterator for &'a mut std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:608 ~ alloc[2c7c]::boxed::{impl#60}): impl std::iter::traits::collect::IntoIterator for std::boxed::Box::<[I], A>
bounds: GenericParamMap { inner: {"I": [], "A": []}, generic_defs: ["I", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:366 ~ alloc[2c7c]::boxed::{impl#10}): impl std::default::Default for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:631 ~ alloc[2c7c]::boxed::{impl#64}): impl std::iter::traits::collect::FromIterator::<&'a char> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:628 ~ alloc[2c7c]::boxed::{impl#63}): impl std::iter::traits::collect::FromIterator::<char> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2190 ~ std[d8a0]::ffi::os_str::{impl#24}): impl std::convert::From::<&std::ffi::OsStr> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2196 ~ std[d8a0]::ffi::os_str::{impl#27}): impl std::convert::From::<std::ffi::OsString> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2192 ~ std[d8a0]::ffi::os_str::{impl#25}): impl std::convert::From::<std::borrow::Cow::<'_, std::ffi::OsStr>> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2198 ~ std[d8a0]::ffi::os_str::{impl#28}): impl std::clone::Clone for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2224 ~ std[d8a0]::ffi::os_str::{impl#38}): impl std::default::Default for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5410 ~ std[d8a0]::path::{impl#34}): impl std::convert::From::<std::path::PathBuf> for std::boxed::Box::<std::path::Path>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:453 ~ alloc[2c7c]::boxed::{impl#29}): impl std::convert::From::<[T;N]> for std::boxed::Box::<[T]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:461 ~ alloc[2c7c]::boxed::{impl#30}): impl std::convert::TryFrom::<std::boxed::Box::<[T]>> for std::boxed::Box::<[T;N]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:466 ~ alloc[2c7c]::boxed::{impl#31}): impl std::convert::TryFrom::<std::vec::Vec::<T>> for std::boxed::Box::<[T;N]>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:2196 ~ std[d8a0]::ffi::os_str::{impl#27}): impl std::convert::From::<std::ffi::OsString> for std::boxed::Box::<std::ffi::OsStr>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:635 ~ alloc[2c7c]::boxed::{impl#65}): impl std::iter::traits::collect::FromIterator::<&'a str> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:642 ~ alloc[2c7c]::boxed::{impl#67}): impl std::iter::traits::collect::FromIterator::<std::boxed::Box::<str, A>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {"A": []}, generic_defs: ["A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:639 ~ alloc[2c7c]::boxed::{impl#66}): impl std::iter::traits::collect::FromIterator::<std::string::String> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:631 ~ alloc[2c7c]::boxed::{impl#64}): impl std::iter::traits::collect::FromIterator::<&'a char> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:646 ~ alloc[2c7c]::boxed::{impl#68}): impl std::iter::traits::collect::FromIterator::<std::borrow::Cow::<'a, str>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:628 ~ alloc[2c7c]::boxed::{impl#63}): impl std::iter::traits::collect::FromIterator::<char> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5989 ~ alloc[2c7c]::string::{impl#49}): impl std::convert::From::<std::string::String> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:446 ~ alloc[2c7c]::boxed::{impl#26}): impl std::convert::From::<&str> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:448 ~ alloc[2c7c]::boxed::{impl#27}): impl std::convert::From::<std::borrow::Cow::<'_, str>> for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:735 ~ alloc[2c7c]::boxed::{impl#87}): impl std::convert::From::<&str> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:732 ~ alloc[2c7c]::boxed::{impl#86}): impl std::convert::From::<&str> for std::boxed::Box::<Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime("'a")))>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:378 ~ alloc[2c7c]::boxed::{impl#13}): impl std::clone::Clone for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:370 ~ alloc[2c7c]::boxed::{impl#11}): impl std::default::Default for std::boxed::Box::<str>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::CaptureNames implement 21 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1201 ~ regex[3103]::re_unicode::{impl#11}): impl std::iter::traits::iterator::Iterator for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2541 ~ regex[3103]::re_unicode::{impl#46}): impl std::fmt::Debug for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1211 ~ regex[3103]::re_unicode::{impl#13}): impl std::iter::traits::marker::FusedIterator for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2538 ~ regex[3103]::re_unicode::{impl#45}): impl std::clone::Clone for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1209 ~ regex[3103]::re_unicode::{impl#12}): impl std::iter::traits::exact_size::ExactSizeIterator for regex::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::ffi::os_str::OsString implement 1 traits: 
DefId(1:2128 ~ std[d8a0]::ffi::os_str::{impl#7}): impl std::ops::Deref for std::ffi::OsString
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::io::IoSliceMut implement 1 traits: 
DefId(1:3641 ~ std[d8a0]::io::{impl#5}): impl std::ops::Deref for std::io::IoSliceMut::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::SubCaptureMatches implement 20 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2275 ~ regex[3103]::re_bytes::{impl#52}): impl std::fmt::Debug for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:990 ~ regex[3103]::re_bytes::{impl#27}): impl std::iter::traits::iterator::Iterator for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2271 ~ regex[3103]::re_bytes::{impl#51}): impl std::clone::Clone for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:997 ~ regex[3103]::re_bytes::{impl#28}): impl std::iter::traits::marker::FusedIterator for regex::bytes::SubCaptureMatches::<'c, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::boxed::thin::ThinBox implement 1 traits: 
DefId(5:235 ~ alloc[2c7c]::boxed::thin::{impl#6}): impl std::ops::Deref for std::boxed::thin::ThinBox::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::vec::Vec implement 3 traits: 
DefId(5:7329 ~ alloc[2c7c]::vec::{impl#8}): impl std::ops::Deref for std::vec::Vec::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1020 ~ regex[3103]::re_bytes::{impl#32}): impl regex::bytes::Replacer for std::vec::Vec::<u8>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1016 ~ regex[3103]::re_bytes::{impl#31}): impl regex::bytes::Replacer for &'a std::vec::Vec::<u8>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::option::Option implement 24 traits: 
DefId(2:9408 ~ core[b693]::option::{impl#38}): impl std::iter::traits::collect::FromIterator::<std::option::Option::<A>> for std::option::Option::<V>
bounds: GenericParamMap { inner: {"V": [], "A": []}, generic_defs: ["A", "V"], type_pred: [(Generic("V"), [Path { res: Def(Trait, DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator)), segments: [PathSegment { name: "FromIterator", args: AngleBracketed { args: [Type(Generic("A"))], constraints: [] } }] }])] }
DefId(2:9329 ~ core[b693]::option::{impl#12}): impl std::convert::From::<&'a mut std::option::Option::<T>> for std::option::Option::<&'a mut T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9322 ~ core[b693]::option::{impl#10}): impl std::convert::From::<T> for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9325 ~ core[b693]::option::{impl#11}): impl std::convert::From::<&'a std::option::Option::<T>> for std::option::Option::<&'a T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:42587 ~ core[b693]::option::{impl#44}): impl std::marker::Copy for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9338 ~ core[b693]::option::{impl#15}): impl std::cmp::PartialOrd for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8306 ~ core[b693]::iter::traits::accum::{impl#3}): impl std::iter::traits::accum::Product::<std::option::Option::<U>> for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:8280 ~ core[b693]::iter::traits::accum::Product)), segments: [PathSegment { name: "Product", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:9333 ~ core[b693]::option::{impl#13}): impl std::marker::StructuralPartialEq for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:42595 ~ core[b693]::option::{impl#47}): impl std::hash::Hash for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9426 ~ core[b693]::option::{impl#42}): impl std::ops::try_trait::Residual::<T> for std::option::Option::<std::convert::Infallible>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9305 ~ core[b693]::option::{impl#7}): impl std::iter::traits::collect::IntoIterator for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9310 ~ core[b693]::option::{impl#8}): impl std::iter::traits::collect::IntoIterator for &'a std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9316 ~ core[b693]::option::{impl#9}): impl std::iter::traits::collect::IntoIterator for &'a mut std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:42592 ~ core[b693]::option::{impl#46}): impl std::fmt::Debug for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42589 ~ core[b693]::option::{impl#45}): impl std::cmp::Eq for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9298 ~ core[b693]::option::{impl#5}): impl std::clone::Clone for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9335 ~ core[b693]::option::{impl#14}): impl std::cmp::PartialEq for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9302 ~ core[b693]::option::{impl#6}): impl std::default::Default for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9341 ~ core[b693]::option::{impl#16}): impl std::cmp::Ord for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:9423 ~ core[b693]::option::{impl#41}): impl std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<()>> for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9420 ~ core[b693]::option::{impl#40}): impl std::ops::try_trait::FromResidual for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:8300 ~ core[b693]::iter::traits::accum::{impl#2}): impl std::iter::traits::accum::Sum::<std::option::Option::<U>> for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum)), segments: [PathSegment { name: "Sum", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:9414 ~ core[b693]::option::{impl#39}): impl std::ops::try_trait::Try for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:9423 ~ core[b693]::option::{impl#41}): impl std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<()>> for std::option::Option::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }

type std::sync::mutex::MappedMutexGuard implement 1 traits: 
DefId(1:6684 ~ std[d8a0]::sync::mutex::{impl#18}): impl std::ops::Deref for std::sync::mutex::MappedMutexGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::SetMatchesIter implement 21 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2351 ~ regex[3103]::re_set::unicode::{impl#10}): impl std::iter::traits::marker::FusedIterator for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2348 ~ regex[3103]::re_set::unicode::{impl#9}): impl std::iter::traits::double_ended::DoubleEndedIterator for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2383 ~ regex[3103]::re_set::unicode::{impl#18}): impl std::fmt::Debug for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2380 ~ regex[3103]::re_set::unicode::{impl#17}): impl std::clone::Clone for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2343 ~ regex[3103]::re_set::unicode::{impl#8}): impl std::iter::traits::iterator::Iterator for regex::SetMatchesIter::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::lazy::LazyCell implement 1 traits: 
DefId(2:4628 ~ core[b693]::cell::lazy::{impl#2}): impl std::ops::Deref for std::cell::lazy::LazyCell::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type alloc::ffi::c_str::CString implement 1 traits: 
DefId(5:4811 ~ alloc[2c7c]::ffi::c_str::{impl#3}): impl std::ops::Deref for std::ffi::CString
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::SetMatches implement 19 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::SetMatches
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::SetMatches
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::SetMatches
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::SetMatches
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2327 ~ regex[3103]::re_set::unicode::{impl#3}): impl std::iter::traits::collect::IntoIterator for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2331 ~ regex[3103]::re_set::unicode::{impl#4}): impl std::iter::traits::collect::IntoIterator for &'a regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2369 ~ regex[3103]::re_set::unicode::{impl#15}): impl std::fmt::Debug for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2367 ~ regex[3103]::re_set::unicode::{impl#14}): impl std::clone::Clone for regex::SetMatches
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::SplitN implement 17 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2558 ~ regex[3103]::re_unicode::{impl#48}): impl std::fmt::Debug for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1227 ~ regex[3103]::re_unicode::{impl#17}): impl std::iter::traits::marker::FusedIterator for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1221 ~ regex[3103]::re_unicode::{impl#16}): impl std::iter::traits::iterator::Iterator for regex::SplitN::<'r, 't>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::reentrant_lock::ReentrantLockGuard implement 1 traits: 
DefId(1:6932 ~ std[d8a0]::sync::reentrant_lock::{impl#11}): impl std::ops::Deref for std::sync::reentrant_lock::ReentrantLockGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::collections::binary_heap::PeekMut implement 1 traits: 
DefId(5:897 ~ alloc[2c7c]::collections::binary_heap::{impl#2}): impl std::ops::Deref for std::collections::binary_heap::PeekMut::<'_, T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::bytes::Captures implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:982 ~ regex[3103]::re_bytes::{impl#26}): impl std::ops::Index::<&'i str> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:959 ~ regex[3103]::re_bytes::{impl#23}): impl std::fmt::Debug for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:976 ~ regex[3103]::re_bytes::{impl#25}): impl std::ops::Index::<usize> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:976 ~ regex[3103]::re_bytes::{impl#25}): impl std::ops::Index::<usize> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:982 ~ regex[3103]::re_bytes::{impl#26}): impl std::ops::Index::<&'i str> for regex::bytes::Captures::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::Error implement 22 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::Error
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::Error
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::Error
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:5953 ~ alloc[2c7c]::string::{impl#32}): impl std::string::ToString for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::Error
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:332 ~ regex[3103]::error::{impl#2}): impl std::fmt::Debug for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:330 ~ regex[3103]::error::{impl#1}): impl std::fmt::Display for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:328 ~ regex[3103]::error::{impl#0}): impl std::error::Error for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1654 ~ regex[3103]::error::{impl#3}): impl std::clone::Clone for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1656 ~ regex[3103]::error::{impl#4}): impl std::marker::StructuralPartialEq for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1657 ~ regex[3103]::error::{impl#5}): impl std::cmp::PartialEq for regex::Error
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::ReplacerRef implement 15 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:3316 ~ core[b693]::marker::Sync)), segments: [PathSegment { name: "Sync", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:32818 ~ core[b693]::marker::Send)), segments: [PathSegment { name: "Send", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)), segments: [PathSegment { name: "RefUnwindSafe", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": []}, generic_defs: ["R"], type_pred: [(Generic("R"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}): impl regex::bytes::Replacer for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": [Path { res: Def(Trait, DefId(0:1000 ~ regex[3103]::re_bytes::Replacer)), segments: [PathSegment { name: "Replacer", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]}, generic_defs: ["R"], type_pred: [] }
DefId(0:2284 ~ regex[3103]::re_bytes::{impl#53}): impl std::fmt::Debug for regex::bytes::ReplacerRef::<'a, R>
bounds: GenericParamMap { inner: {"R": [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "$crate", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "fmt", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]}, generic_defs: ["R"], type_pred: [] }

type regex::Regex implement 20 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::Regex
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::Regex
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::Regex
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:5953 ~ alloc[2c7c]::string::{impl#32}): impl std::string::ToString for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::Regex
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1139 ~ regex[3103]::re_unicode::{impl#4}): impl std::fmt::Display for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2532 ~ regex[3103]::re_unicode::{impl#44}): impl std::clone::Clone for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1145 ~ regex[3103]::re_unicode::{impl#7}): impl std::str::FromStr for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1141 ~ regex[3103]::re_unicode::{impl#5}): impl std::fmt::Debug for regex::Regex
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::ffi::va_list::VaList implement 1 traits: 
DefId(2:5308 ~ core[b693]::ffi::va_list::{impl#1}): impl std::ops::Deref for std::ffi::va_list::VaList::<'a, 'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::Match implement 22 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2820 ~ core[b693]::clone::{impl#1}): impl std::clone::CloneToUninit for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::Match::<'t>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:1130 ~ regex[3103]::re_unicode::{impl#1}): impl std::fmt::Debug for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2526 ~ regex[3103]::re_unicode::{impl#43}): impl std::cmp::PartialEq for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2518 ~ regex[3103]::re_unicode::{impl#40}): impl std::clone::Clone for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2516 ~ regex[3103]::re_unicode::{impl#39}): impl std::marker::Copy for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2524 ~ regex[3103]::re_unicode::{impl#42}): impl std::marker::StructuralPartialEq for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2521 ~ regex[3103]::re_unicode::{impl#41}): impl std::cmp::Eq for regex::Match::<'t>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::string::String implement 3 traits: 
DefId(5:5941 ~ alloc[2c7c]::string::{impl#28}): impl std::ops::Deref for std::string::String
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}): impl regex::Replacer for std::string::String
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}): impl regex::Replacer for &'a std::string::String
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type regex::bytes::CaptureNames implement 21 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:937 ~ regex[3103]::re_bytes::{impl#20}): impl std::iter::traits::marker::FusedIterator for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:935 ~ regex[3103]::re_bytes::{impl#19}): impl std::iter::traits::exact_size::ExactSizeIterator for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2253 ~ regex[3103]::re_bytes::{impl#47}): impl std::clone::Clone for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2256 ~ regex[3103]::re_bytes::{impl#48}): impl std::fmt::Debug for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:927 ~ regex[3103]::re_bytes::{impl#18}): impl std::iter::traits::iterator::Iterator for regex::bytes::CaptureNames::<'r>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::mutex::MutexGuard implement 1 traits: 
DefId(1:6653 ~ std[d8a0]::sync::mutex::{impl#12}): impl std::ops::Deref for std::sync::mutex::MutexGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type regex::SetMatchesIntoIter implement 18 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8329 ~ core[b693]::iter::traits::collect::{impl#1}): impl std::iter::traits::collect::IntoIterator for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator)), segments: [PathSegment { name: "Iterator", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:2342 ~ regex[3103]::re_set::unicode::{impl#7}): impl std::iter::traits::marker::FusedIterator for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2336 ~ regex[3103]::re_set::unicode::{impl#5}): impl std::iter::traits::iterator::Iterator for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2374 ~ regex[3103]::re_set::unicode::{impl#16}): impl std::fmt::Debug for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:2340 ~ regex[3103]::re_set::unicode::{impl#6}): impl std::iter::traits::double_ended::DoubleEndedIterator for regex::SetMatchesIntoIter
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
Type Candidate #0: (1)*&[char]
Type Candidate #1: (1)regex::bytes::NoExpand::<'_>
Type Candidate #2: (14)&mut &str
Type Candidate #3: (1)&mut regex::bytes::NoExpand::<'_>
Type Candidate #4: (14)&&str
Type Candidate #5: (3)*&[u8]
Type Candidate #6: (3)*const &[u8]
Type Candidate #7: (14)*&str
Type Candidate #8: (1)*const regex::bytes::NoExpand::<'_>
Type Candidate #9: (4)&[u8]
Type Candidate #10: (1)regex::NoExpand::<'_>
Type Candidate #11: (1)&regex::NoExpand::<'_>
Type Candidate #12: (1)u8
Type Candidate #13: (1)*regex::bytes::NoExpand::<'_>
Type Candidate #14: (1)*regex::NoExpand::<'_>
Type Candidate #15: (1)*const regex::NoExpand::<'_>
Type Candidate #16: (14)*const &str
Type Candidate #17: (1)&mut &[char]
Type Candidate #18: (1)&&[char]
Type Candidate #19: (14)&str
Type Candidate #20: (1)&mut regex::NoExpand::<'_>
Type Candidate #21: (3)&mut &[u8]
Type Candidate #22: (3)&&[u8]
Type Candidate #23: (1)&[char]
Type Candidate #24: (1)*const &[char]
Type Candidate #25: (1)&regex::bytes::NoExpand::<'_>
unsupport function:
[ApiGraph] Resolve this function
fn regex::RegexSetBuilder::new(I) -> regex::RegexSetBuilder
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

[ApiGraph] Resolve this function
fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::replace_append(&mut regex::ReplacerRef::<'_, R>, &regex::Captures::<'_>, &mut std::string::String) -> ()
Where:
R: regex::Replacer + std::marker::Sized, 
Type Pred:

[ApiGraph] Resolve this function
fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::no_expansion(&mut regex::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
Where:
R: regex::Replacer + std::marker::Sized, 
Type Pred:

[ApiGraph] Resolve this function
fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::by_ref(&mut regex::ReplacerRef::<'_, R>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, R>>
Where:
R: regex::Replacer + std::marker::Sized, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::bytes::RegexSet::new(I) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

[ApiGraph] Resolve this function
fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::ReplacerRef::<'_, R>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
Where:
R: regex::bytes::Replacer + std::marker::Sized, 
Type Pred:

[ApiGraph] Resolve this function
fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
Where:
R: regex::bytes::Replacer + std::marker::Sized, 
Type Pred:

[ApiGraph] Resolve this function
fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::ReplacerRef::<'_, R>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, R>>
Where:
R: regex::bytes::Replacer + std::marker::Sized, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::bytes::RegexSetBuilder::new(I) -> regex::bytes::RegexSetBuilder
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

[ApiGraph] Resolve this function
fn regex::RegexSet::new(I) -> std::result::Result::<regex::RegexSet, regex::Error>
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

[ApiGraph] Resolve this function
fn regex::Regex::replace(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>
Where:
R: regex::Replacer, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::Regex::replace_all(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>
Where:
R: regex::Replacer, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::Regex::replacen(&regex::Regex, &str, usize, R) -> std::borrow::Cow::<'_, str>
Where:
R: regex::Replacer, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::bytes::Regex::replace(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>
Where:
R: regex::bytes::Replacer, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::bytes::Regex::replace_all(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>
Where:
R: regex::bytes::Replacer, 
Type Pred:

[ApiGraph] Resolve this function
fn regex::bytes::Regex::replacen(&regex::bytes::Regex, &[u8], usize, R) -> std::borrow::Cow::<'_, [u8]>
Where:
R: regex::bytes::Replacer, 
Type Pred:

=====Iteration #0=====
num of func: 191
num of reachable: 191
num of reachable type: 191
[Reachable]fn regex::escape(&str) -> std::string::String is reachable
[TypeContext] add candidate #26: String => Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #27: &mut String => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #28: &String => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #29: *String => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #30: *const String => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn <std::string::String as regex::Replacer>::no_expansion(&mut std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>> is reachable
[TypeContext] add candidate #31: Option::<Cow::<'_, str>> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #32: &mut Option::<Cow::<'_, str>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #33: &Option::<Cow::<'_, str>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #34: *Option::<Cow::<'_, str>> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #35: *const Option::<Cow::<'_, str>> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn <std::string::String as regex::Replacer>::by_ref(&mut std::string::String) -> regex::ReplacerRef::<'_, std::string::String> is reachable
[TypeContext] add candidate #36: ReplacerRef::<'_, String> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #37: &mut ReplacerRef::<'_, String> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #38: &ReplacerRef::<'_, String> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #39: *ReplacerRef::<'_, String> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #40: *const ReplacerRef::<'_, String> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn <&std::string::String as regex::Replacer>::no_expansion(&mut &std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>> is reachable
[Reachable]fn <&std::string::String as regex::Replacer>::by_ref(&mut &std::string::String) -> regex::ReplacerRef::<'_, &std::string::String> is reachable
[TypeContext] add candidate #41: ReplacerRef::<'_, &String> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } }
[TypeContext] add candidate #42: &mut ReplacerRef::<'_, &String> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } } }
[TypeContext] add candidate #43: &ReplacerRef::<'_, &String> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } } }
[TypeContext] add candidate #44: *ReplacerRef::<'_, &String> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } })
[TypeContext] add candidate #45: *const ReplacerRef::<'_, &String> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } })
[Reachable]fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::NoExpand::<'_>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>> is reachable
[TypeContext] add candidate #46: Option::<Cow::<'_, [u8]>> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })], constraints: [] } }] } }
[Reachable]fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::NoExpand::<'_>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> is reachable
[TypeContext] add candidate #47: ReplacerRef::<'_, NoExpand::<'_>> => Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #48: &mut ReplacerRef::<'_, NoExpand::<'_>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #49: &ReplacerRef::<'_, NoExpand::<'_>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #50: *ReplacerRef::<'_, NoExpand::<'_>> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #51: *const ReplacerRef::<'_, NoExpand::<'_>> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::bytes::RegexSet::empty() -> regex::bytes::RegexSet is reachable
[TypeContext] add candidate #52: RegexSet => Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #53: &mut RegexSet => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #54: &RegexSet => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #55: *RegexSet => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #56: *const RegexSet => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2447 ~ regex[3103]::re_set::bytes::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn regex::bytes::RegexSet::is_match(&regex::bytes::RegexSet, &[u8]) -> bool is reachable
[TypeContext] add candidate #57: bool => Primitive(Bool)
[TypeContext] add candidate #58: &mut bool => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Bool) }
[TypeContext] add candidate #59: &bool => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Bool) }
[TypeContext] add candidate #60: *bool => RawPointer(Mut, Primitive(Bool))
[TypeContext] add candidate #61: *const bool => RawPointer(Not, Primitive(Bool))
[Reachable]fn regex::bytes::RegexSet::matches(&regex::bytes::RegexSet, &[u8]) -> regex::bytes::SetMatches is reachable
[TypeContext] add candidate #62: SetMatches => Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #63: &mut SetMatches => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #64: &SetMatches => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #65: *SetMatches => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #66: *const SetMatches => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2452 ~ regex[3103]::re_set::bytes::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn regex::bytes::RegexSet::len(&regex::bytes::RegexSet) -> usize is reachable
[TypeContext] add candidate #67: usize => Primitive(Usize)
[TypeContext] add candidate #68: &mut usize => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Usize) }
[TypeContext] add candidate #69: &usize => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Usize) }
[TypeContext] add candidate #70: *usize => RawPointer(Mut, Primitive(Usize))
[TypeContext] add candidate #71: *const usize => RawPointer(Not, Primitive(Usize))
[Reachable]fn regex::bytes::RegexSet::is_empty(&regex::bytes::RegexSet) -> bool is reachable
[Reachable]fn regex::bytes::RegexSet::patterns(&regex::bytes::RegexSet) -> &[std::string::String] is reachable
[TypeContext] add candidate #72: &[String] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }) }
[TypeContext] add candidate #73: &mut &[String] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }) } }
[TypeContext] add candidate #74: &&[String] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }) } }
[TypeContext] add candidate #75: *&[String] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }) })
[TypeContext] add candidate #76: *const &[String] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }) })
[Reachable]fn <regex::bytes::RegexSet as std::default::Default>::default() -> regex::bytes::RegexSet is reachable
[Reachable]fn regex::bytes::RegexBuilder::new(&str) -> regex::bytes::RegexBuilder is reachable
[TypeContext] add candidate #77: RegexBuilder => Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #78: &mut RegexBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #79: &RegexBuilder => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #80: *RegexBuilder => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #81: *const RegexBuilder => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn regex::bytes::RegexBuilder::build(&regex::bytes::RegexBuilder) -> std::result::Result::<regex::bytes::Regex, regex::Error> is reachable
[TypeContext] add candidate #82: Result::<Regex, Error> => Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #83: &mut Result::<Regex, Error> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #84: &Result::<Regex, Error> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #85: *Result::<Regex, Error> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #86: *const Result::<Regex, Error> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2208 ~ regex[3103]::re_bytes::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::bytes::RegexBuilder::case_insensitive(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[TypeContext] add candidate #87: &mut &mut RegexBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #88: &&mut RegexBuilder => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #89: *&mut RegexBuilder => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[TypeContext] add candidate #90: *const &mut RegexBuilder => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2112 ~ regex[3103]::re_builder::bytes::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[Reachable]fn regex::bytes::RegexBuilder::multi_line(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::dot_matches_new_line(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::swap_greed(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::ignore_whitespace(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::unicode(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::octal(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::size_limit(&mut regex::bytes::RegexBuilder, usize) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::dfa_size_limit(&mut regex::bytes::RegexBuilder, usize) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn regex::bytes::RegexBuilder::nest_limit(&mut regex::bytes::RegexBuilder, u32) -> &mut regex::bytes::RegexBuilder is reachable
[Reachable]fn <regex::NoExpand::<'_> as regex::Replacer>::no_expansion(&mut regex::NoExpand::<'_>) -> std::option::Option::<std::borrow::Cow::<'_, str>> is reachable
[Reachable]fn <regex::NoExpand::<'_> as regex::Replacer>::by_ref(&mut regex::NoExpand::<'_>) -> regex::ReplacerRef::<'_, regex::NoExpand::<'_>> is reachable
[TypeContext] add candidate #91: ReplacerRef::<'_, NoExpand::<'_>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #92: &mut ReplacerRef::<'_, NoExpand::<'_>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #93: &ReplacerRef::<'_, NoExpand::<'_>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #94: *ReplacerRef::<'_, NoExpand::<'_>> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #95: *const ReplacerRef::<'_, NoExpand::<'_>> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::RegexSet::empty() -> regex::RegexSet is reachable
[TypeContext] add candidate #96: RegexSet => Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #97: &mut RegexSet => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #98: &RegexSet => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #99: *RegexSet => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #100: *const RegexSet => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2359 ~ regex[3103]::re_set::unicode::RegexSet)), segments: [PathSegment { name: "RegexSet", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn regex::RegexSet::is_match(&regex::RegexSet, &str) -> bool is reachable
[Reachable]fn regex::RegexSet::matches(&regex::RegexSet, &str) -> regex::SetMatches is reachable
[TypeContext] add candidate #101: SetMatches => Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #102: &mut SetMatches => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #103: &SetMatches => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #104: *SetMatches => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #105: *const SetMatches => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2364 ~ regex[3103]::re_set::unicode::SetMatches)), segments: [PathSegment { name: "SetMatches", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn regex::RegexSet::len(&regex::RegexSet) -> usize is reachable
[Reachable]fn regex::RegexSet::is_empty(&regex::RegexSet) -> bool is reachable
[Reachable]fn regex::RegexSet::patterns(&regex::RegexSet) -> &[std::string::String] is reachable
[Reachable]fn <regex::RegexSet as std::default::Default>::default() -> regex::RegexSet is reachable
[Reachable]fn regex::bytes::SetMatches::matched_any(&regex::bytes::SetMatches) -> bool is reachable
[Reachable]fn regex::bytes::SetMatches::matched(&regex::bytes::SetMatches, usize) -> bool is reachable
[Reachable]fn regex::bytes::SetMatches::len(&regex::bytes::SetMatches) -> usize is reachable
[Reachable]fn regex::bytes::SetMatches::iter(&regex::bytes::SetMatches) -> regex::bytes::SetMatchesIter::<'_> is reachable
[TypeContext] add candidate #106: SetMatchesIter::<'_> => Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #107: &mut SetMatchesIter::<'_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #108: &SetMatchesIter::<'_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #109: *SetMatchesIter::<'_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #110: *const SetMatchesIter::<'_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2464 ~ regex[3103]::re_set::bytes::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Regex::new(&str) -> std::result::Result::<regex::Regex, regex::Error> is reachable
[TypeContext] add candidate #111: Result::<Regex, Error> => Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #112: &mut Result::<Regex, Error> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #113: &Result::<Regex, Error> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #114: *Result::<Regex, Error> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #115: *const Result::<Regex, Error> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2529 ~ regex[3103]::re_unicode::Regex)), segments: [PathSegment { name: "Regex", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(0:1645 ~ regex[3103]::error::Error)), segments: [PathSegment { name: "Error", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::Regex::is_match(&regex::Regex, &str) -> bool is reachable
[Reachable]fn regex::Regex::find(&regex::Regex, &str) -> std::option::Option::<regex::Match::<'_>> is reachable
[TypeContext] add candidate #116: Option::<Match::<'_>> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #117: &mut Option::<Match::<'_>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #118: &Option::<Match::<'_>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #119: *Option::<Match::<'_>> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #120: *const Option::<Match::<'_>> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2511 ~ regex[3103]::re_unicode::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::Regex::find_iter(&regex::Regex, &str) -> regex::Matches::<'_, '_> is reachable
[TypeContext] add candidate #121: Matches::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #122: &mut Matches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #123: &Matches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #124: *Matches::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #125: *const Matches::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2591 ~ regex[3103]::re_unicode::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Regex::captures(&regex::Regex, &str) -> std::option::Option::<regex::Captures::<'_>> is reachable
[TypeContext] add candidate #126: Option::<Captures::<'_>> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #127: &mut Option::<Captures::<'_>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #128: &Option::<Captures::<'_>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #129: *Option::<Captures::<'_>> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #130: *const Option::<Captures::<'_>> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:1235 ~ regex[3103]::re_unicode::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::Regex::captures_iter(&regex::Regex, &str) -> regex::CaptureMatches::<'_, '_> is reachable
[TypeContext] add candidate #131: CaptureMatches::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #132: &mut CaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #133: &CaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #134: *CaptureMatches::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #135: *const CaptureMatches::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2582 ~ regex[3103]::re_unicode::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Regex::split(&regex::Regex, &str) -> regex::Split::<'_, '_> is reachable
[TypeContext] add candidate #136: Split::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #137: &mut Split::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #138: &Split::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #139: *Split::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #140: *const Split::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2544 ~ regex[3103]::re_unicode::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Regex::splitn(&regex::Regex, &str, usize) -> regex::SplitN::<'_, '_> is reachable
[TypeContext] add candidate #141: SplitN::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #142: &mut SplitN::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #143: &SplitN::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #144: *SplitN::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #145: *const SplitN::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2553 ~ regex[3103]::re_unicode::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Regex::shortest_match(&regex::Regex, &str) -> std::option::Option::<usize> is reachable
[TypeContext] add candidate #146: Option::<usize> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } }
[TypeContext] add candidate #147: &mut Option::<usize> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } } }
[TypeContext] add candidate #148: &Option::<usize> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } } }
[TypeContext] add candidate #149: *Option::<usize> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } })
[TypeContext] add candidate #150: *const Option::<usize> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } })
[Reachable]fn regex::Regex::shortest_match_at(&regex::Regex, &str, usize) -> std::option::Option::<usize> is reachable
[Reachable]fn regex::Regex::is_match_at(&regex::Regex, &str, usize) -> bool is reachable
[Reachable]fn regex::Regex::find_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Match::<'_>> is reachable
[Reachable]fn regex::Regex::captures_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Captures::<'_>> is reachable
[Reachable]fn regex::Regex::as_str(&regex::Regex) -> &str is reachable
[Reachable]fn regex::Regex::capture_names(&regex::Regex) -> regex::CaptureNames::<'_> is reachable
[TypeContext] add candidate #151: CaptureNames::<'_> => Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #152: &mut CaptureNames::<'_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #153: &CaptureNames::<'_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #154: *CaptureNames::<'_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #155: *const CaptureNames::<'_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2534 ~ regex[3103]::re_unicode::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Regex::captures_len(&regex::Regex) -> usize is reachable
[Reachable]fn regex::Regex::static_captures_len(&regex::Regex) -> std::option::Option::<usize> is reachable
[Reachable]fn regex::Regex::capture_locations(&regex::Regex) -> regex::CaptureLocations is reachable
[TypeContext] add candidate #156: CaptureLocations => Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #157: &mut CaptureLocations => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #158: &CaptureLocations => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #159: *CaptureLocations => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #160: *const CaptureLocations => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2562 ~ regex[3103]::re_unicode::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn <regex::Regex as std::str::FromStr>::from_str(&str) -> std::result::Result::<regex::Regex, regex::Error> is reachable
[Reachable]fn regex::RegexBuilder::new(&str) -> regex::RegexBuilder is reachable
[TypeContext] add candidate #161: RegexBuilder => Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #162: &mut RegexBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #163: &RegexBuilder => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #164: *RegexBuilder => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #165: *const RegexBuilder => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn regex::RegexBuilder::build(&regex::RegexBuilder) -> std::result::Result::<regex::Regex, regex::Error> is reachable
[Reachable]fn regex::RegexBuilder::case_insensitive(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[TypeContext] add candidate #166: &mut &mut RegexBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #167: &&mut RegexBuilder => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #168: *&mut RegexBuilder => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[TypeContext] add candidate #169: *const &mut RegexBuilder => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2135 ~ regex[3103]::re_builder::unicode::RegexBuilder)), segments: [PathSegment { name: "RegexBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[Reachable]fn regex::RegexBuilder::multi_line(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::dot_matches_new_line(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::swap_greed(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::ignore_whitespace(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::unicode(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::octal(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::size_limit(&mut regex::RegexBuilder, usize) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::dfa_size_limit(&mut regex::RegexBuilder, usize) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::RegexBuilder::nest_limit(&mut regex::RegexBuilder, u32) -> &mut regex::RegexBuilder is reachable
[Reachable]fn regex::Captures::<'_>::get(&regex::Captures::<'_>, usize) -> std::option::Option::<regex::Match::<'_>> is reachable
[Reachable]fn regex::Captures::<'_>::name(&regex::Captures::<'_>, &str) -> std::option::Option::<regex::Match::<'_>> is reachable
[Reachable]fn regex::Captures::<'_>::iter(&regex::Captures::<'_>) -> regex::SubCaptureMatches::<'_, '_> is reachable
[TypeContext] add candidate #170: SubCaptureMatches::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #171: &mut SubCaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #172: &SubCaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #173: *SubCaptureMatches::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #174: *const SubCaptureMatches::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2569 ~ regex[3103]::re_unicode::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::Captures::<'_>::expand(&regex::Captures::<'_>, &str, &mut std::string::String) -> () is reachable
[TypeContext] add candidate #175: () => Tuple([])
[TypeContext] add candidate #176: &mut () => BorrowedRef { lifetime: None, mutability: Mut, type_: Tuple([]) }
[TypeContext] add candidate #177: &() => BorrowedRef { lifetime: None, mutability: Not, type_: Tuple([]) }
[TypeContext] add candidate #178: *() => RawPointer(Mut, Tuple([]))
[TypeContext] add candidate #179: *const () => RawPointer(Not, Tuple([]))
[Reachable]fn regex::Captures::<'_>::len(&regex::Captures::<'_>) -> usize is reachable
[Reachable]fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str is reachable
[Reachable]fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str is reachable
[Reachable]fn regex::bytes::Regex::new(&str) -> std::result::Result::<regex::bytes::Regex, regex::Error> is reachable
[Reachable]fn regex::bytes::Regex::is_match(&regex::bytes::Regex, &[u8]) -> bool is reachable
[Reachable]fn regex::bytes::Regex::find(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>> is reachable
[TypeContext] add candidate #180: Option::<Match::<'_>> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #181: &mut Option::<Match::<'_>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #182: &Option::<Match::<'_>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #183: *Option::<Match::<'_>> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #184: *const Option::<Match::<'_>> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:2190 ~ regex[3103]::re_bytes::Match)), segments: [PathSegment { name: "Match", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::find_iter(&regex::bytes::Regex, &[u8]) -> regex::bytes::Matches::<'_, '_> is reachable
[TypeContext] add candidate #185: Matches::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #186: &mut Matches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #187: &Matches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #188: *Matches::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #189: *const Matches::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2213 ~ regex[3103]::re_bytes::Matches)), segments: [PathSegment { name: "Matches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::captures(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Captures::<'_>> is reachable
[TypeContext] add candidate #190: Option::<Captures::<'_>> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #191: &mut Option::<Captures::<'_>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #192: &Option::<Captures::<'_>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #193: *Option::<Captures::<'_>> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #194: *const Option::<Captures::<'_>> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(0:944 ~ regex[3103]::re_bytes::Captures)), segments: [PathSegment { name: "Captures", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::captures_iter(&regex::bytes::Regex, &[u8]) -> regex::bytes::CaptureMatches::<'_, '_> is reachable
[TypeContext] add candidate #195: CaptureMatches::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #196: &mut CaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #197: &CaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #198: *CaptureMatches::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #199: *const CaptureMatches::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2222 ~ regex[3103]::re_bytes::CaptureMatches)), segments: [PathSegment { name: "CaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::split(&regex::bytes::Regex, &[u8]) -> regex::bytes::Split::<'_, '_> is reachable
[TypeContext] add candidate #200: Split::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #201: &mut Split::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #202: &Split::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #203: *Split::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #204: *const Split::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2231 ~ regex[3103]::re_bytes::Split)), segments: [PathSegment { name: "Split", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::splitn(&regex::bytes::Regex, &[u8], usize) -> regex::bytes::SplitN::<'_, '_> is reachable
[TypeContext] add candidate #205: SplitN::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #206: &mut SplitN::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #207: &SplitN::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #208: *SplitN::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #209: *const SplitN::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2240 ~ regex[3103]::re_bytes::SplitN)), segments: [PathSegment { name: "SplitN", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::shortest_match(&regex::bytes::Regex, &[u8]) -> std::option::Option::<usize> is reachable
[Reachable]fn regex::bytes::Regex::shortest_match_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<usize> is reachable
[Reachable]fn regex::bytes::Regex::is_match_at(&regex::bytes::Regex, &[u8], usize) -> bool is reachable
[Reachable]fn regex::bytes::Regex::find_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>> is reachable
[Reachable]fn regex::bytes::Regex::captures_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Captures::<'_>> is reachable
[Reachable]fn regex::bytes::Regex::as_str(&regex::bytes::Regex) -> &str is reachable
[Reachable]fn regex::bytes::Regex::capture_names(&regex::bytes::Regex) -> regex::bytes::CaptureNames::<'_> is reachable
[TypeContext] add candidate #210: CaptureNames::<'_> => Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #211: &mut CaptureNames::<'_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #212: &CaptureNames::<'_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #213: *CaptureNames::<'_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #214: *const CaptureNames::<'_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2249 ~ regex[3103]::re_bytes::CaptureNames)), segments: [PathSegment { name: "CaptureNames", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[Reachable]fn regex::bytes::Regex::captures_len(&regex::bytes::Regex) -> usize is reachable
[Reachable]fn regex::bytes::Regex::static_captures_len(&regex::bytes::Regex) -> std::option::Option::<usize> is reachable
[Reachable]fn regex::bytes::Regex::capture_locations(&regex::bytes::Regex) -> regex::bytes::CaptureLocations is reachable
[TypeContext] add candidate #215: CaptureLocations => Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #216: &mut CaptureLocations => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #217: &CaptureLocations => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #218: *CaptureLocations => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #219: *const CaptureLocations => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2259 ~ regex[3103]::re_bytes::CaptureLocations)), segments: [PathSegment { name: "CaptureLocations", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn <regex::bytes::Regex as std::str::FromStr>::from_str(&str) -> std::result::Result::<regex::bytes::Regex, regex::Error> is reachable
[Reachable]fn <std::ops::range::Range::<usize> as std::convert::From::<regex::bytes::Match::<'_>>>::from(regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize> is reachable
[TypeContext] add candidate #220: Range::<usize> => Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } }
[TypeContext] add candidate #221: &mut Range::<usize> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } } }
[TypeContext] add candidate #222: &Range::<usize> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } } }
[TypeContext] add candidate #223: *Range::<usize> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } })
[TypeContext] add candidate #224: *const Range::<usize> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(2:40163 ~ core[b693]::ops::range::Range)), segments: [PathSegment { name: "Range", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] } })
[Reachable]fn <std::ops::range::Range::<usize> as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> std::ops::range::Range::<usize> is reachable
[Reachable]fn <&[u8] as regex::bytes::Replacer>::no_expansion(&mut &[u8]) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>> is reachable
[Reachable]fn <&[u8] as regex::bytes::Replacer>::by_ref(&mut &[u8]) -> regex::bytes::ReplacerRef::<'_, &[u8]> is reachable
[TypeContext] add candidate #225: ReplacerRef::<'_, &[u8]> => Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })], constraints: [] } }] } }
[Reachable]fn <regex::bytes::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::bytes::Captures::<'_>, usize) -> &[u8] is reachable
[Reachable]fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str is reachable
[Reachable]fn <regex::bytes::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::bytes::Captures::<'_>, &str) -> &[u8] is reachable
[Reachable]fn <&str as regex::Replacer>::replace_append(&mut &str, &regex::Captures::<'_>, &mut std::string::String) -> () is reachable
[Reachable]fn <&str as regex::Replacer>::no_expansion(&mut &str) -> std::option::Option::<std::borrow::Cow::<'_, str>> is reachable
[Reachable]fn <&str as regex::Replacer>::by_ref(&mut &str) -> regex::ReplacerRef::<'_, &str> is reachable
[TypeContext] add candidate #226: ReplacerRef::<'_, &str> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } }
[TypeContext] add candidate #227: &mut ReplacerRef::<'_, &str> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } } }
[TypeContext] add candidate #228: &ReplacerRef::<'_, &str> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } } }
[TypeContext] add candidate #229: *ReplacerRef::<'_, &str> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } })
[TypeContext] add candidate #230: *const ReplacerRef::<'_, &str> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } })
[Reachable]fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str is reachable
[Reachable]fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str is reachable
[Reachable]fn <regex::NoExpand::<'_> as regex::Replacer>::replace_append(&mut regex::NoExpand::<'_>, &regex::Captures::<'_>, &mut std::string::String) -> () is reachable
[Reachable]fn regex::RegexSetBuilder::case_insensitive(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::multi_line(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::dot_matches_new_line(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::swap_greed(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::ignore_whitespace(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::unicode(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::octal(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::case_insensitive(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::multi_line(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::dot_matches_new_line(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::swap_greed(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::ignore_whitespace(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::unicode(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::octal(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::CaptureLocations::get(&regex::CaptureLocations, usize) -> std::option::Option::<(usize ,usize)> is reachable
[Reachable]fn regex::RegexSetBuilder::size_limit(&mut regex::RegexSetBuilder, usize) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::dfa_size_limit(&mut regex::RegexSetBuilder, usize) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::RegexSetBuilder::nest_limit(&mut regex::RegexSetBuilder, u32) -> &mut regex::RegexSetBuilder is reachable
[Reachable]fn regex::SetMatches::matched(&regex::SetMatches, usize) -> bool is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::size_limit(&mut regex::bytes::RegexSetBuilder, usize) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::dfa_size_limit(&mut regex::bytes::RegexSetBuilder, usize) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::bytes::RegexSetBuilder::nest_limit(&mut regex::bytes::RegexSetBuilder, u32) -> &mut regex::bytes::RegexSetBuilder is reachable
[Reachable]fn regex::Regex::captures_read_at(&regex::Regex, &mut regex::CaptureLocations, &str, usize) -> std::option::Option::<regex::Match::<'_>> is reachable
[Reachable]fn regex::bytes::Captures::<'_>::get(&regex::bytes::Captures::<'_>, usize) -> std::option::Option::<regex::bytes::Match::<'_>> is reachable
[Reachable]fn <regex::bytes::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::bytes::Captures::<'_>, usize) -> &[u8] is reachable
[Reachable]fn regex::bytes::CaptureLocations::get(&regex::bytes::CaptureLocations, usize) -> std::option::Option::<(usize ,usize)> is reachable
[Reachable]fn regex::bytes::Regex::captures_read_at(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>> is reachable
[Reachable]fn regex::bytes::Regex::captures_read(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>> is reachable
[Reachable]fn regex::SetMatches::matched_any(&regex::SetMatches) -> bool is reachable
[Reachable]fn regex::SetMatches::len(&regex::SetMatches) -> usize is reachable
[Reachable]fn regex::SetMatches::iter(&regex::SetMatches) -> regex::SetMatchesIter::<'_> is reachable
[Reachable]fn regex::Regex::captures_read(&regex::Regex, &mut regex::CaptureLocations, &str) -> std::option::Option::<regex::Match::<'_>> is reachable
[Reachable]fn regex::Match::<'_>::start(&regex::Match::<'_>) -> usize is reachable
[Reachable]fn regex::Match::<'_>::end(&regex::Match::<'_>) -> usize is reachable
[Reachable]fn regex::Match::<'_>::is_empty(&regex::Match::<'_>) -> bool is reachable
[Reachable]fn regex::Match::<'_>::len(&regex::Match::<'_>) -> usize is reachable
[Reachable]fn regex::Match::<'_>::range(&regex::Match::<'_>) -> std::ops::range::Range::<usize> is reachable
[Reachable]fn regex::Match::<'_>::as_str(&regex::Match::<'_>) -> &str is reachable
[Reachable]fn <regex::Match::<'_> as std::cmp::PartialEq>::eq(&regex::Match::<'_>, &regex::Match::<'_>) -> bool is reachable
[Reachable]fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str is reachable
[Reachable]fn <std::ops::range::Range::<usize> as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> std::ops::range::Range::<usize> is reachable
[Reachable]fn <&std::borrow::Cow::<'_, str> as regex::Replacer>::replace_append(&mut &std::borrow::Cow::<'_, str>, &regex::Captures::<'_>, &mut std::string::String) -> () is reachable
[Reachable]fn <std::borrow::Cow::<'_, str> as regex::Replacer>::replace_append(&mut std::borrow::Cow::<'_, str>, &regex::Captures::<'_>, &mut std::string::String) -> () is reachable
[Reachable]fn regex::bytes::Captures::<'_>::name(&regex::bytes::Captures::<'_>, &str) -> std::option::Option::<regex::bytes::Match::<'_>> is reachable
[Reachable]fn <regex::bytes::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::bytes::Captures::<'_>, &str) -> &[u8] is reachable
[Reachable]fn regex::CaptureLocations::len(&regex::CaptureLocations) -> usize is reachable
[Reachable]fn regex::bytes::Match::<'_>::start(&regex::bytes::Match::<'_>) -> usize is reachable
[Reachable]fn regex::bytes::Match::<'_>::end(&regex::bytes::Match::<'_>) -> usize is reachable
[Reachable]fn regex::bytes::Match::<'_>::is_empty(&regex::bytes::Match::<'_>) -> bool is reachable
[Reachable]fn regex::bytes::Match::<'_>::len(&regex::bytes::Match::<'_>) -> usize is reachable
[Reachable]fn regex::bytes::Match::<'_>::range(&regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize> is reachable
[Reachable]fn regex::bytes::Match::<'_>::as_bytes(&regex::bytes::Match::<'_>) -> &[u8] is reachable
[Reachable]fn <std::ops::range::Range::<usize> as std::convert::From::<regex::bytes::Match::<'_>>>::from(regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize> is reachable
[Reachable]fn <regex::bytes::Match::<'_> as std::cmp::PartialEq>::eq(&regex::bytes::Match::<'_>, &regex::bytes::Match::<'_>) -> bool is reachable
[Reachable]fn regex::bytes::Captures::<'_>::iter(&regex::bytes::Captures::<'_>) -> regex::bytes::SubCaptureMatches::<'_, '_> is reachable
[Reachable]fn regex::bytes::Captures::<'_>::len(&regex::bytes::Captures::<'_>) -> usize is reachable
[Reachable]fn <&[u8] as regex::bytes::Replacer>::replace_append(&mut &[u8], &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> () is reachable
[Reachable]fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::NoExpand::<'_>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> () is reachable
[Reachable]fn regex::bytes::Captures::<'_>::expand(&regex::bytes::Captures::<'_>, &[u8], &mut std::vec::Vec::<u8>) -> () is reachable
[Reachable]fn regex::bytes::CaptureLocations::len(&regex::bytes::CaptureLocations) -> usize is reachable
[TypeContext] add candidate #231: &mut RegexSetBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #232: &mut &mut RegexSetBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #233: &&mut RegexSetBuilder => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #234: *&mut RegexSetBuilder => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[TypeContext] add candidate #235: *const &mut RegexSetBuilder => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2185 ~ regex[3103]::re_builder::set_unicode::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[TypeContext] add candidate #236: &mut RegexSetBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #237: &mut &mut RegexSetBuilder => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #238: &&mut RegexSetBuilder => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } } }
[TypeContext] add candidate #239: *&mut RegexSetBuilder => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[TypeContext] add candidate #240: *const &mut RegexSetBuilder => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2160 ~ regex[3103]::re_builder::set_bytes::RegexSetBuilder)), segments: [PathSegment { name: "RegexSetBuilder", args: AngleBracketed { args: [], constraints: [] } }] } } })
[TypeContext] add candidate #241: Option::<(usize ,usize)> => Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Tuple([Primitive(Usize), Primitive(Usize)]))], constraints: [] } }] } }
[TypeContext] add candidate #242: &mut Option::<(usize ,usize)> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Tuple([Primitive(Usize), Primitive(Usize)]))], constraints: [] } }] } } }
[TypeContext] add candidate #243: &Option::<(usize ,usize)> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Tuple([Primitive(Usize), Primitive(Usize)]))], constraints: [] } }] } } }
[TypeContext] add candidate #244: *Option::<(usize ,usize)> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Tuple([Primitive(Usize), Primitive(Usize)]))], constraints: [] } }] } })
[TypeContext] add candidate #245: *const Option::<(usize ,usize)> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Tuple([Primitive(Usize), Primitive(Usize)]))], constraints: [] } }] } })
[TypeContext] add candidate #246: SetMatchesIter::<'_> => Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #247: &mut SetMatchesIter::<'_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #248: &SetMatchesIter::<'_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #249: *SetMatchesIter::<'_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #250: *const SetMatchesIter::<'_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2376 ~ regex[3103]::re_set::unicode::SetMatchesIter)), segments: [PathSegment { name: "SetMatchesIter", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #251: SubCaptureMatches::<'_, '_> => Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } }
[TypeContext] add candidate #252: &mut SubCaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #253: &SubCaptureMatches::<'_, '_> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } } }
[TypeContext] add candidate #254: *SubCaptureMatches::<'_, '_> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
[TypeContext] add candidate #255: *const SubCaptureMatches::<'_, '_> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2266 ~ regex[3103]::re_bytes::SubCaptureMatches)), segments: [PathSegment { name: "SubCaptureMatches", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Lifetime(Lifetime("'_"))], constraints: [] } }] } })
===== Candidates =====
Type Candidate #0: (2)regex::bytes::SplitN::<'_, '_>
Type Candidate #1: (1)&mut regex::bytes::NoExpand::<'_>
Type Candidate #2: (2)*regex::Matches::<'_, '_>
Type Candidate #3: (2)regex::SubCaptureMatches::<'_, '_>
Type Candidate #4: (2)*const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #5: (22)&mut usize
Type Candidate #6: (2)*const regex::bytes::RegexBuilder
Type Candidate #7: (2)*regex::RegexBuilder
Type Candidate #8: (2)*const regex::RegexBuilder
Type Candidate #9: (2)regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #10: (8)&mut std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #11: (10)&mut &[u8]
Type Candidate #12: (26)bool
Type Candidate #13: (4)&std::option::Option::<regex::Captures::<'_>>
Type Candidate #14: (10)()
Type Candidate #15: (2)&regex::SubCaptureMatches::<'_, '_>
Type Candidate #16: (2)*const regex::bytes::CaptureLocations
Type Candidate #17: (2)&mut regex::ReplacerRef::<'_, &str>
Type Candidate #18: (2)regex::bytes::SetMatches
Type Candidate #19: (4)*std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #20: (30)&&str
Type Candidate #21: (10)*&[u8]
Type Candidate #22: (2)*regex::Split::<'_, '_>
Type Candidate #23: (1)&regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #24: (1)*const regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #25: (2)&mut regex::bytes::SetMatchesIter::<'_>
Type Candidate #26: (4)*const regex::bytes::RegexSet
Type Candidate #27: (2)regex::SetMatches
Type Candidate #28: (2)regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #29: (22)&mut regex::RegexBuilder
Type Candidate #30: (2)&mut std::string::String
Type Candidate #31: (2)*const regex::Matches::<'_, '_>
Type Candidate #32: (2)*const regex::bytes::Split::<'_, '_>
Type Candidate #33: (1)&mut regex::NoExpand::<'_>
Type Candidate #34: (1)*&[char]
Type Candidate #35: (2)*regex::bytes::SetMatchesIter::<'_>
Type Candidate #36: (4)regex::bytes::RegexSet
Type Candidate #37: (2)&mut regex::bytes::SetMatches
Type Candidate #38: (30)*&str
Type Candidate #39: (1)*regex::bytes::NoExpand::<'_>
Type Candidate #40: (1)*regex::NoExpand::<'_>
Type Candidate #41: (2)&mut regex::CaptureNames::<'_>
Type Candidate #42: (4)&mut std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #43: (2)&regex::Split::<'_, '_>
Type Candidate #44: (8)*const std::ops::range::Range::<usize>
Type Candidate #45: (22)&mut regex::bytes::RegexBuilder
Type Candidate #46: (4)*&[std::string::String]
Type Candidate #47: (1)&regex::bytes::NoExpand::<'_>
Type Candidate #48: (2)*const regex::CaptureNames::<'_>
Type Candidate #49: (4)std::option::Option::<regex::Captures::<'_>>
Type Candidate #50: (10)*const &mut regex::bytes::RegexSetBuilder
Type Candidate #51: (2)&regex::bytes::SetMatchesIter::<'_>
Type Candidate #52: (4)&mut std::option::Option::<regex::Captures::<'_>>
Type Candidate #53: (8)&mut std::ops::range::Range::<usize>
Type Candidate #54: (11)&[u8]
Type Candidate #55: (2)regex::CaptureMatches::<'_, '_>
Type Candidate #56: (2)&regex::bytes::CaptureLocations
Type Candidate #57: (8)*std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #58: (20)*&mut regex::RegexBuilder
Type Candidate #59: (4)regex::RegexSet
Type Candidate #60: (2)&mut regex::SubCaptureMatches::<'_, '_>
Type Candidate #61: (10)&mut ()
Type Candidate #62: (1)regex::bytes::NoExpand::<'_>
Type Candidate #63: (2)*regex::CaptureLocations
Type Candidate #64: (10)*&mut regex::bytes::RegexSetBuilder
Type Candidate #65: (2)&mut regex::bytes::SplitN::<'_, '_>
Type Candidate #66: (1)&mut &[char]
Type Candidate #67: (4)*std::option::Option::<regex::Captures::<'_>>
Type Candidate #68: (4)&mut regex::bytes::RegexSet
Type Candidate #69: (2)*regex::bytes::RegexBuilder
Type Candidate #70: (20)*&mut regex::bytes::RegexBuilder
Type Candidate #71: (2)regex::bytes::Matches::<'_, '_>
Type Candidate #72: (2)regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #73: (2)regex::CaptureNames::<'_>
Type Candidate #74: (4)*const std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #75: (8)&mut std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #76: (2)*const regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #77: (2)*const regex::ReplacerRef::<'_, &str>
Type Candidate #78: (1)*const &[char]
Type Candidate #79: (4)&std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #80: (2)*const regex::CaptureMatches::<'_, '_>
Type Candidate #81: (2)*const std::option::Option::<(usize ,usize)>
Type Candidate #82: (8)&std::ops::range::Range::<usize>
Type Candidate #83: (2)&regex::CaptureMatches::<'_, '_>
Type Candidate #84: (2)&regex::CaptureLocations
Type Candidate #85: (10)*()
Type Candidate #86: (30)&str
Type Candidate #87: (2)&std::string::String
Type Candidate #88: (2)regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #89: (30)&mut &str
Type Candidate #90: (2)*const regex::Split::<'_, '_>
Type Candidate #91: (2)*regex::bytes::CaptureLocations
Type Candidate #92: (2)*regex::bytes::SetMatches
Type Candidate #93: (20)*const &mut regex::RegexBuilder
Type Candidate #94: (2)&regex::Matches::<'_, '_>
Type Candidate #95: (30)*const &str
Type Candidate #96: (2)*regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #97: (6)*const std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #98: (2)*const regex::SetMatches
Type Candidate #99: (10)&&[u8]
Type Candidate #100: (10)&std::option::Option::<regex::Match::<'_>>
Type Candidate #101: (2)&regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #102: (2)&regex::ReplacerRef::<'_, &str>
Type Candidate #103: (2)regex::ReplacerRef::<'_, std::string::String>
Type Candidate #104: (22)*usize
Type Candidate #105: (2)*regex::ReplacerRef::<'_, std::string::String>
Type Candidate #106: (2)&mut regex::SetMatches
Type Candidate #107: (6)&mut std::result::Result::<regex::Regex, regex::Error>
Type Candidate #108: (1)regex::NoExpand::<'_>
Type Candidate #109: (2)&regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #110: (2)*regex::bytes::CaptureNames::<'_>
Type Candidate #111: (10)*const &mut regex::RegexSetBuilder
Type Candidate #112: (12)*const std::option::Option::<usize>
Type Candidate #113: (2)regex::Split::<'_, '_>
Type Candidate #114: (2)*regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #115: (2)&mut regex::Split::<'_, '_>
Type Candidate #116: (10)*std::option::Option::<regex::Match::<'_>>
Type Candidate #117: (2)&regex::bytes::Split::<'_, '_>
Type Candidate #118: (2)&mut regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #119: (10)&mut regex::RegexSetBuilder
Type Candidate #120: (1)regex::SetMatchesIter::<'_>
Type Candidate #121: (2)&mut regex::bytes::CaptureNames::<'_>
Type Candidate #122: (2)&mut regex::bytes::Matches::<'_, '_>
Type Candidate #123: (2)&regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #124: (10)*const &[u8]
Type Candidate #125: (4)&regex::RegexSet
Type Candidate #126: (8)std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #127: (2)*regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #128: (2)*const regex::bytes::SetMatchesIter::<'_>
Type Candidate #129: (2)&mut regex::Matches::<'_, '_>
Type Candidate #130: (20)&mut &mut regex::bytes::RegexBuilder
Type Candidate #131: (2)*const regex::SplitN::<'_, '_>
Type Candidate #132: (2)*const regex::bytes::SetMatches
Type Candidate #133: (2)regex::bytes::RegexBuilder
Type Candidate #134: (4)*regex::RegexSet
Type Candidate #135: (8)std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #136: (22)&usize
Type Candidate #137: (10)&mut std::option::Option::<regex::Match::<'_>>
Type Candidate #138: (4)std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #139: (26)&mut bool
Type Candidate #140: (4)&[std::string::String]
Type Candidate #141: (2)*const regex::bytes::SplitN::<'_, '_>
Type Candidate #142: (2)&regex::CaptureNames::<'_>
Type Candidate #143: (2)regex::bytes::CaptureNames::<'_>
Type Candidate #144: (2)&mut std::option::Option::<(usize ,usize)>
Type Candidate #145: (4)&mut &[std::string::String]
Type Candidate #146: (1)regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #147: (4)std::option::Option::<std::borrow::Cow::<'_, [u8]>>
Type Candidate #148: (4)&mut regex::RegexSet
Type Candidate #149: (2)&mut regex::bytes::Split::<'_, '_>
Type Candidate #150: (20)*const &mut regex::bytes::RegexBuilder
Type Candidate #151: (6)std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #152: (2)*const regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #153: (2)&regex::bytes::SetMatches
Type Candidate #154: (8)*const std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #155: (2)*regex::bytes::Matches::<'_, '_>
Type Candidate #156: (2)&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #157: (1)&&[char]
Type Candidate #158: (12)*std::option::Option::<usize>
Type Candidate #159: (12)&mut std::option::Option::<usize>
Type Candidate #160: (2)&regex::bytes::CaptureNames::<'_>
Type Candidate #161: (1)*const regex::SetMatchesIter::<'_>
Type Candidate #162: (26)&bool
Type Candidate #163: (12)std::option::Option::<usize>
Type Candidate #164: (10)&()
Type Candidate #165: (2)regex::SplitN::<'_, '_>
Type Candidate #166: (8)std::ops::range::Range::<usize>
Type Candidate #167: (2)*std::string::String
Type Candidate #168: (2)regex::ReplacerRef::<'_, &str>
Type Candidate #169: (2)*const regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #170: (22)usize
Type Candidate #171: (2)&mut regex::SplitN::<'_, '_>
Type Candidate #172: (2)regex::bytes::ReplacerRef::<'_, &[u8]>
Type Candidate #173: (10)&mut regex::bytes::RegexSetBuilder
Type Candidate #174: (2)regex::Matches::<'_, '_>
Type Candidate #175: (26)*const bool
Type Candidate #176: (2)*const regex::bytes::CaptureNames::<'_>
Type Candidate #177: (10)*&mut regex::RegexSetBuilder
Type Candidate #178: (1)&regex::NoExpand::<'_>
Type Candidate #179: (1)*const regex::bytes::NoExpand::<'_>
Type Candidate #180: (2)*regex::SetMatches
Type Candidate #181: (6)*std::result::Result::<regex::Regex, regex::Error>
Type Candidate #182: (6)*const std::result::Result::<regex::Regex, regex::Error>
Type Candidate #183: (2)&regex::RegexBuilder
Type Candidate #184: (1)&[char]
Type Candidate #185: (2)&regex::SetMatches
Type Candidate #186: (4)*regex::bytes::RegexSet
Type Candidate #187: (2)*regex::SubCaptureMatches::<'_, '_>
Type Candidate #188: (2)&regex::bytes::RegexBuilder
Type Candidate #189: (22)*const usize
Type Candidate #190: (2)*const regex::bytes::Matches::<'_, '_>
Type Candidate #191: (10)std::option::Option::<regex::Match::<'_>>
Type Candidate #192: (2)&mut regex::bytes::CaptureLocations
Type Candidate #193: (4)&&[std::string::String]
Type Candidate #194: (2)regex::bytes::CaptureLocations
Type Candidate #195: (6)&std::result::Result::<regex::Regex, regex::Error>
Type Candidate #196: (2)*const regex::ReplacerRef::<'_, std::string::String>
Type Candidate #197: (2)&regex::bytes::Matches::<'_, '_>
Type Candidate #198: (6)&mut std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #199: (2)*regex::ReplacerRef::<'_, &str>
Type Candidate #200: (2)std::string::String
Type Candidate #201: (10)&&mut regex::bytes::RegexSetBuilder
Type Candidate #202: (2)&regex::ReplacerRef::<'_, std::string::String>
Type Candidate #203: (4)*const std::option::Option::<regex::Captures::<'_>>
Type Candidate #204: (2)&mut regex::CaptureMatches::<'_, '_>
Type Candidate #205: (2)*const regex::CaptureLocations
Type Candidate #206: (4)*const regex::RegexSet
Type Candidate #207: (1)&regex::SetMatchesIter::<'_>
Type Candidate #208: (2)&regex::bytes::SplitN::<'_, '_>
Type Candidate #209: (10)*const std::option::Option::<regex::Match::<'_>>
Type Candidate #210: (2)regex::bytes::SetMatchesIter::<'_>
Type Candidate #211: (10)&mut &mut regex::bytes::RegexSetBuilder
Type Candidate #212: (2)&std::option::Option::<(usize ,usize)>
Type Candidate #213: (12)&std::option::Option::<usize>
Type Candidate #214: (2)*std::option::Option::<(usize ,usize)>
Type Candidate #215: (10)*const ()
Type Candidate #216: (6)std::result::Result::<regex::Regex, regex::Error>
Type Candidate #217: (2)&regex::SplitN::<'_, '_>
Type Candidate #218: (8)*std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #219: (2)*regex::CaptureNames::<'_>
Type Candidate #220: (4)*const &[std::string::String]
Type Candidate #221: (20)&&mut regex::RegexBuilder
Type Candidate #222: (1)*const regex::NoExpand::<'_>
Type Candidate #223: (2)&mut regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #224: (2)*regex::bytes::SplitN::<'_, '_>
Type Candidate #225: (1)*regex::SetMatchesIter::<'_>
Type Candidate #226: (10)&&mut regex::RegexSetBuilder
Type Candidate #227: (2)*const std::string::String
Type Candidate #228: (2)&mut regex::CaptureLocations
Type Candidate #229: (2)&regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #230: (2)*const regex::SubCaptureMatches::<'_, '_>
Type Candidate #231: (26)*bool
Type Candidate #232: (2)*regex::SplitN::<'_, '_>
Type Candidate #233: (8)&std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #234: (4)&regex::bytes::RegexSet
Type Candidate #235: (2)&mut regex::ReplacerRef::<'_, std::string::String>
Type Candidate #236: (2)*regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #237: (10)&mut &mut regex::RegexSetBuilder
Type Candidate #238: (2)*regex::bytes::Split::<'_, '_>
Type Candidate #239: (2)regex::RegexBuilder
Type Candidate #240: (6)*std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #241: (2)std::option::Option::<(usize ,usize)>
Type Candidate #242: (20)&&mut regex::bytes::RegexBuilder
Type Candidate #243: (20)&mut &mut regex::RegexBuilder
Type Candidate #244: (1)&mut regex::SetMatchesIter::<'_>
Type Candidate #245: (1)u8
Type Candidate #246: (2)&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #247: (2)*regex::CaptureMatches::<'_, '_>
Type Candidate #248: (8)*const std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #249: (1)*regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #250: (2)regex::CaptureLocations
Type Candidate #251: (2)regex::bytes::Split::<'_, '_>
Type Candidate #252: (8)&std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #253: (8)*std::ops::range::Range::<usize>
Type Candidate #254: (6)&std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #255: (1)&mut regex::bytes::SubCaptureMatches::<'_, '_>
===== !Candidates =====
[Solver] find solution for fn regex::RegexSetBuilder::new(I) -> regex::RegexSetBuilder, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*, *)`
set B: `(&mut Option::<Captures::<'_>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*CaptureMatches::<'_, '_>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (&&mut RegexSetBuilder, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (&ReplacerRef::<'_, &String>, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (*const bool, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
Merge: `(&mut Option::<Captures::<'_>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*CaptureMatches::<'_, '_>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (&&mut RegexSetBuilder, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (&ReplacerRef::<'_, &String>, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (*const bool, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] Solution Set = `(&mut Option::<Captures::<'_>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*CaptureMatches::<'_, '_>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (&&mut RegexSetBuilder, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (&ReplacerRef::<'_, &String>, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (*const bool, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::replace_append(&mut regex::ReplacerRef::<'_, R>, &regex::Captures::<'_>, &mut std::string::String) -> (), already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (NoExpand::<'_>), (String)`
Merge: `(&str), (&String), (NoExpand::<'_>), (String)`
[Solver] Solution Set = `(&str), (&String), (NoExpand::<'_>), (String)`
[Solver] Check Solution: (&str)
[TraitImpl] Recursively check: do we have impl regex::Replacer for &'a str?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &str>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }]
[Solver] impls={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] output depth = 1
[Solver] Check Solution: (&String)
[TraitImpl] Recursively check: do we have impl regex::Replacer for &'a std::string::String?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[Solver] output depth = 1
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::NoExpand::<'t>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] output depth = 1
[Solver] Check Solution: (String)
[TraitImpl] Recursively check: do we have impl regex::Replacer for std::string::String?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[Solver] output depth = 1
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::no_expansion(&mut regex::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (NoExpand::<'_>), (String)`
Merge: `(&str), (&String), (NoExpand::<'_>), (String)`
[Solver] Solution Set = `(&str), (&String), (NoExpand::<'_>), (String)`
[Solver] Check Solution: (&str)
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &str>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }]
[Solver] impls={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] output depth = 3
[Solver] Check Solution: (&String)
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[Solver] output depth = 3
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] output depth = 3
[Solver] Check Solution: (String)
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[Solver] output depth = 3
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::by_ref(&mut regex::ReplacerRef::<'_, R>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, R>>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (NoExpand::<'_>), (String)`
Merge: `(&str), (&String), (NoExpand::<'_>), (String)`
[Solver] Solution Set = `(&str), (&String), (NoExpand::<'_>), (String)`
[Solver] Check Solution: (&str)
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &str>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }]
[Solver] impls={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] output depth = 4
[TypeContext] add candidate #256: ReplacerRef::<'_, ReplacerRef::<'_, &str>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } })], constraints: [] } }] } }
[Solver] Check Solution: (&String)
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[Solver] output depth = 4
[TypeContext] add candidate #257: ReplacerRef::<'_, ReplacerRef::<'_, &String>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } })], constraints: [] } }] } }
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] output depth = 3
[TypeContext] add candidate #258: ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #259: &mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #260: &ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #261: *ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #262: *const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })
[Solver] Check Solution: (String)
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[Solver] output depth = 3
[TypeContext] add candidate #263: ReplacerRef::<'_, ReplacerRef::<'_, String>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #264: &mut ReplacerRef::<'_, ReplacerRef::<'_, String>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #265: &ReplacerRef::<'_, ReplacerRef::<'_, String>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #266: *ReplacerRef::<'_, ReplacerRef::<'_, String>> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #267: *const ReplacerRef::<'_, ReplacerRef::<'_, String>> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::RegexSet::new(I) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*, *)`
set B: `(&mut Option::<Captures::<'_>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&Option::<(usize ,usize)>, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<Match::<'_>>, *), (*const bool, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
Merge: `(&mut Option::<Captures::<'_>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&Option::<(usize ,usize)>, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<Match::<'_>>, *), (*const bool, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] Solution Set = `(&mut Option::<Captures::<'_>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&Option::<(usize ,usize)>, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<Match::<'_>>, *), (*const bool, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::ReplacerRef::<'_, R>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> (), already have 0 solutions
[Solver] generic params: ["R"]
[Solver] input#2: &mut std::vec::Vec::<u8> is unreachable
[Solver] Skip it. It is currently unreachable.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(NoExpand::<'_>)`
Merge: `(NoExpand::<'_>)`
[Solver] Solution Set = `(NoExpand::<'_>)`
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for regex::bytes::NoExpand::<'t>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] find mono function: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] output depth = 4
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::ReplacerRef::<'_, R>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, R>>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(NoExpand::<'_>)`
Merge: `(NoExpand::<'_>)`
[Solver] Solution Set = `(NoExpand::<'_>)`
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] find mono function: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] output depth = 3
[TypeContext] add candidate #268: ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #269: &mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #270: &ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #271: *ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #272: *const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::RegexSetBuilder::new(I) -> regex::bytes::RegexSetBuilder, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*, *)`
set B: `(&mut Option::<Captures::<'_>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const bool, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
Merge: `(&mut Option::<Captures::<'_>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const bool, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] Solution Set = `(&mut Option::<Captures::<'_>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const bool, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::RegexSet::new(I) -> std::result::Result::<regex::RegexSet, regex::Error>, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*, *)`
set B: `(&mut Option::<Captures::<'_>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const bool, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
Merge: `(&mut Option::<Captures::<'_>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const bool, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] Solution Set = `(&mut Option::<Captures::<'_>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<usize>, *), (*const SplitN::<'_, '_>, *), (*SetMatches, *), (&mut Option::<Match::<'_>>, *), (Option::<Cow::<'_, [u8]>>, *), (Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&&mut RegexSetBuilder, *), (Option::<Captures::<'_>>, *), (*SubCaptureMatches::<'_, '_>, *), (&mut RegexSetBuilder, *), (CaptureMatches::<'_, '_>, *), (&CaptureNames::<'_>, *), (*const SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*const String, *), (&&mut RegexBuilder, *), (RegexBuilder, *), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&RegexSet, *), (*const Option::<usize>, *), (&mut Result::<Regex, Error>, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const Option::<(usize ,usize)>, *), (&CaptureNames::<'_>, *), (ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>, *), (&mut Option::<Captures::<'_>>, *), (&mut Range::<usize>, *), (&mut &mut RegexSetBuilder, *), (*Range::<usize>, *), (&Option::<Match::<'_>>, *), (u8, *), ((), *), (*Split::<'_, '_>, *), (*RegexBuilder, *), (*const RegexSet, *), (&SplitN::<'_, '_>, *), (&mut Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (*ReplacerRef::<'_, &String>, *), (*const &[String], *), (bool, *), (*const Option::<Captures::<'_>>, *), (*const &mut RegexBuilder, *), (&&[u8], *), (NoExpand::<'_>, *), (&mut String, *), (*&mut RegexSetBuilder, *), (*const SetMatches, *), (&usize, *), (*&mut RegexBuilder, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Split::<'_, '_>, *), (&CaptureMatches::<'_, '_>, *), (*&mut RegexBuilder, *), (&mut CaptureNames::<'_>, *), (&bool, *), (&Option::<Cow::<'_, str>>, *), (*const CaptureNames::<'_>, *), (&ReplacerRef::<'_, &str>, *), (*&[u8], *), (*const ReplacerRef::<'_, &String>, *), (*CaptureNames::<'_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (Option::<(usize ,usize)>, *), (&[String], *), (*const &str, *), (Split::<'_, '_>, *), (*const ReplacerRef::<'_, &str>, *), (&mut RegexBuilder, *), (*RegexBuilder, *), (*const &mut RegexBuilder, *), (&NoExpand::<'_>, *), (*const Range::<usize>, *), (Range::<usize>, *), (&mut RegexBuilder, *), (&SetMatches, *), (&mut SplitN::<'_, '_>, *), (&mut (), *), (NoExpand::<'_>, *), (CaptureNames::<'_>, *), (*const usize, *), (*const NoExpand::<'_>, *), (*bool, *), (*SplitN::<'_, '_>, *), (*Matches::<'_, '_>, *), (ReplacerRef::<'_, &[u8]>, *), (&Range::<usize>, *), (*SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, NoExpand::<'_>>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>, *), (CaptureLocations, *), (&mut &str, *), (&mut Matches::<'_, '_>, *), (&mut Option::<(usize ,usize)>, *), (&Option::<(usize ,usize)>, *), (Matches::<'_, '_>, *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*NoExpand::<'_>, *), (*String, *), (&NoExpand::<'_>, *), (&mut SubCaptureMatches::<'_, '_>, *), (&[u8], *), (*const Result::<Regex, Error>, *), (&mut &mut RegexBuilder, *), (*SetMatchesIter::<'_>, *), (SplitN::<'_, '_>, *), (SetMatchesIter::<'_>, *), (*const SubCaptureMatches::<'_, '_>, *), (CaptureMatches::<'_, '_>, *), (&mut SetMatchesIter::<'_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (*const &[u8], *), (*ReplacerRef::<'_, &str>, *), (*&[char], *), (*CaptureMatches::<'_, '_>, *), (&mut &[String], *), (*const Split::<'_, '_>, *), (&&[char], *), (ReplacerRef::<'_, NoExpand::<'_>>, *), (*Matches::<'_, '_>, *), (&mut RegexSetBuilder, *), (*const SubCaptureMatches::<'_, '_>, *), (&mut CaptureMatches::<'_, '_>, *), (&SubCaptureMatches::<'_, '_>, *), (*SetMatches, *), (&RegexBuilder, *), (*const Result::<Regex, Error>, *), (*const RegexSet, *), (Result::<Regex, Error>, *), (*const CaptureLocations, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&Result::<Regex, Error>, *), (CaptureLocations, *), (SetMatches, *), (&&mut RegexBuilder, *), (*const SetMatches, *), (&mut Split::<'_, '_>, *), (*CaptureLocations, *), (*const ReplacerRef::<'_, String>, *), (&RegexBuilder, *), (*(), *), (&mut ReplacerRef::<'_, &str>, *), (*const CaptureLocations, *), (*const &mut RegexSetBuilder, *), (&CaptureLocations, *), (*SubCaptureMatches::<'_, '_>, *), (&mut Split::<'_, '_>, *), (RegexSet, *), (&SetMatches, *), (&SetMatchesIter::<'_>, *), (*Option::<Captures::<'_>>, *), (*CaptureLocations, *), (&SplitN::<'_, '_>, *), (*RegexSet, *), (*RegexSet, *), (&mut NoExpand::<'_>, *), (&mut RegexSet, *), (&mut &mut RegexSetBuilder, *), (*CaptureNames::<'_>, *), (*const Matches::<'_, '_>, *), (CaptureNames::<'_>, *), (Option::<Match::<'_>>, *), (Option::<Cow::<'_, str>>, *), (ReplacerRef::<'_, &String>, *), (SplitN::<'_, '_>, *), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*const &[char], *), (&Result::<Regex, Error>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (*SetMatchesIter::<'_>, *), (&Option::<Captures::<'_>>, *), (&ReplacerRef::<'_, String>, *), (&&mut RegexSetBuilder, *), (Option::<Match::<'_>>, *), (&&[String], *), (*const Option::<Match::<'_>>, *), (*ReplacerRef::<'_, String>, *), (Result::<Regex, Error>, *), (*const NoExpand::<'_>, *), (SubCaptureMatches::<'_, '_>, *), (&mut &[char], *), (*const (), *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<Captures::<'_>>, *), (&mut CaptureLocations, *), (&mut &[u8], *), (&SubCaptureMatches::<'_, '_>, *), (SubCaptureMatches::<'_, '_>, *), (*Result::<Regex, Error>, *), (*Option::<Match::<'_>>, *), (&str, *), (*Option::<usize>, *), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&mut ReplacerRef::<'_, String>, *), (*const CaptureNames::<'_>, *), (&Split::<'_, '_>, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (&mut Option::<Match::<'_>>, *), (&[char], *), (&mut CaptureNames::<'_>, *), (&SetMatchesIter::<'_>, *), (&String, *), (*const CaptureMatches::<'_, '_>, *), (Matches::<'_, '_>, *), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (&mut CaptureLocations, *), (*const &mut RegexSetBuilder, *), (*CaptureMatches::<'_, '_>, *), (*const Split::<'_, '_>, *), (ReplacerRef::<'_, &str>, *), (&RegexSet, *), (&mut usize, *), (&mut SetMatches, *), (ReplacerRef::<'_, String>, *), (&mut ReplacerRef::<'_, NoExpand::<'_>>, *), (&Option::<usize>, *), (&mut SubCaptureMatches::<'_, '_>, *), (*Option::<(usize ,usize)>, *), (*const RegexBuilder, *), (&CaptureLocations, *), (&mut Matches::<'_, '_>, *), (RegexSet, *), (&mut CaptureMatches::<'_, '_>, *), (&mut &mut RegexBuilder, *), (&CaptureMatches::<'_, '_>, *), (&mut bool, *), (&mut ReplacerRef::<'_, &String>, *), (*const Option::<Captures::<'_>>, *), (*&str, *), (RegexBuilder, *), (&mut RegexSet, *), (&(), *), (*const CaptureMatches::<'_, '_>, *), (&mut SplitN::<'_, '_>, *), (*Split::<'_, '_>, *), (SetMatches, *), (Split::<'_, '_>, *), (&mut Option::<Cow::<'_, str>>, *), (*Option::<Captures::<'_>>, *), (usize, *), (String, *), (&ReplacerRef::<'_, NoExpand::<'_>>, *), (*const SplitN::<'_, '_>, *), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>, *), (&Matches::<'_, '_>, *), (*&mut RegexSetBuilder, *), (*const Option::<Cow::<'_, str>>, *), (&mut SetMatches, *), (&mut Option::<usize>, *), (&ReplacerRef::<'_, &String>, *), (*const RegexBuilder, *), (*&[String], *), (&&str, *), (&mut NoExpand::<'_>, *), (*usize, *), (*ReplacerRef::<'_, NoExpand::<'_>>, *), (*const bool, *), (*const Option::<Match::<'_>>, *), (*Option::<Cow::<'_, str>>, *), (&Option::<Match::<'_>>, *), (*const Matches::<'_, '_>, *), (*Result::<Regex, Error>, *), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>, *), (&mut SetMatchesIter::<'_>, *), (*const SetMatchesIter::<'_>, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::Regex::replace(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (&mut &mut RegexSetBuilder), (CaptureLocations), (&Result::<Regex, Error>), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (&mut &mut RegexSetBuilder), (CaptureLocations), (&Result::<Regex, Error>), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (&mut &mut RegexSetBuilder), (CaptureLocations), (&Result::<Regex, Error>), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *const std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait regex::Replacer for usize fail
[Solver] Check Solution: (&mut String)
[TraitImpl] Check trait regex::Replacer for &mut std::string::String fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*Range::<usize>)
[TraitImpl] Check trait regex::Replacer for *std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const &[String])
[TraitImpl] Check trait regex::Replacer for *const &[std::string::String] fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SetMatches fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait regex::Replacer for *const bool fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait regex::Replacer for *const () fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*const String)
[TraitImpl] Check trait regex::Replacer for *const std::string::String fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SetMatches fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait regex::Replacer for &mut () fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&[String])
[TraitImpl] Check trait regex::Replacer for &[std::string::String] fail
[Solver] Check Solution: (&ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (String), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[TypeContext] add candidate #273: Cow::<'_, str> => Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }
[TypeContext] add candidate #274: &mut Cow::<'_, str> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } } }
[TypeContext] add candidate #275: &Cow::<'_, str> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } } }
[TypeContext] add candidate #276: *Cow::<'_, str> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })
[TypeContext] add candidate #277: *const Cow::<'_, str> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait regex::Replacer for *&[char] fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const regex::RegexBuilder fail
[Solver] Check Solution: (&str)
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }]
[Solver] impls={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[Solver] output depth = 2
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureLocations fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait regex::Replacer for &mut &[u8] fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*&[String])
[TraitImpl] Check trait regex::Replacer for *&[std::string::String] fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait regex::Replacer for &&[u8] fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*String)
[TraitImpl] Check trait regex::Replacer for *std::string::String fail
[Solver] Check Solution: (&ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &String>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (&String), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &String>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &std::string::String>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (NoExpand::<'_>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &[u8]>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, &[u8]> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::RegexBuilder fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::Replacer for regex::CaptureLocations fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, &String>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &String>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<usize>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<usize> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait regex::Replacer for *usize fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait regex::Replacer for &mut usize fail
[Solver] Check Solution: (&String)
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Option::<usize>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<usize> fail
[Solver] Check Solution: (())
[TraitImpl] Check trait regex::Replacer for () fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, &str>), generic_defs: ["R"]
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (&str), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &str>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut &[String])
[TraitImpl] Check trait regex::Replacer for &mut &[std::string::String] fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait regex::Replacer for &() fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::Replacer for regex::bytes::RegexSet fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &mut std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const Range::<usize>)
[TraitImpl] Check trait regex::Replacer for *const std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::Replacer for regex::SetMatches fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::Split::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait regex::Replacer for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait regex::Replacer for *bool fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::Replacer for &regex::SetMatches fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SetMatches fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Option::<usize>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<usize> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureLocations fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &mut std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureLocations fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait regex::Replacer for *const &[u8] fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait regex::Replacer for *&[u8] fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SetMatches fail
[Solver] Check Solution: (Range::<usize>)
[TraitImpl] Check trait regex::Replacer for std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (String)
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait regex::Replacer for &[u8] fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Range::<usize>)
[TraitImpl] Check trait regex::Replacer for &std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::Split::<'_, '_> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::Replacer for regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::RegexBuilder fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::NoExpand::<'_> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::Replacer for *const regex::RegexSet fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SetMatches fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait regex::Replacer for &[char] fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait regex::Replacer for &usize fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait regex::Replacer for *() fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::Replacer for *const regex::SetMatches fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::Replacer for regex::RegexSet fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::NoExpand::<'_> fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::Replacer for *regex::SetMatches fail
[Solver] Check Solution: (*Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait regex::Replacer for u8 fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::Replacer for &regex::RegexSet fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *const std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::Replacer for regex::RegexBuilder fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::Replacer for &mut regex::SetMatches fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, NoExpand::<'_>>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait regex::Replacer for *&str fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait regex::Replacer for bool fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait regex::Replacer for &&str fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait regex::Replacer for &mut &[char] fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (*const Option::<usize>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<usize> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::RegexSet fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexSet fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::Replacer for *regex::RegexSet fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&[String])
[TraitImpl] Check trait regex::Replacer for &&[std::string::String] fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, &str>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &str>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait regex::Replacer for *const &str fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureLocations fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::RegexSet fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait regex::Replacer for &&[char] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait regex::Replacer for *const usize fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait regex::Replacer for &mut bool fail
[Solver] Check Solution: (*const Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut Range::<usize>)
[TraitImpl] Check trait regex::Replacer for &mut std::ops::range::Range::<usize> fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &regex::RegexBuilder fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, String>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::NoExpand::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (Option::<usize>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<usize> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureNames::<'_> fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait regex::Replacer for &bool fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait regex::Replacer for &mut &str fail
[Solver] Running solve() took 2 ms.
[Solver] find solution for fn regex::Regex::replace_all(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *const std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait regex::Replacer for usize fail
[Solver] Check Solution: (&mut String)
[TraitImpl] Check trait regex::Replacer for &mut std::string::String fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*Range::<usize>)
[TraitImpl] Check trait regex::Replacer for *std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const &[String])
[TraitImpl] Check trait regex::Replacer for *const &[std::string::String] fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SetMatches fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait regex::Replacer for *const bool fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait regex::Replacer for *const () fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*const String)
[TraitImpl] Check trait regex::Replacer for *const std::string::String fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SetMatches fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait regex::Replacer for &mut () fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&[String])
[TraitImpl] Check trait regex::Replacer for &[std::string::String] fail
[Solver] Check Solution: (&ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait regex::Replacer for *&[char] fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const regex::RegexBuilder fail
[Solver] Check Solution: (&str)
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }]
[Solver] impls={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[Solver] output depth = 2
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureLocations fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait regex::Replacer for &mut &[u8] fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*&[String])
[TraitImpl] Check trait regex::Replacer for *&[std::string::String] fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait regex::Replacer for &&[u8] fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*String)
[TraitImpl] Check trait regex::Replacer for *std::string::String fail
[Solver] Check Solution: (&ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &String>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &std::string::String>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &[u8]>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, &[u8]> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::RegexBuilder fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*const Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for *const std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::Replacer for regex::CaptureLocations fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<usize>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<usize> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait regex::Replacer for *usize fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait regex::Replacer for &mut usize fail
[Solver] Check Solution: (&String)
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Option::<usize>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<usize> fail
[Solver] Check Solution: (())
[TraitImpl] Check trait regex::Replacer for () fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut &[String])
[TraitImpl] Check trait regex::Replacer for &mut &[std::string::String] fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait regex::Replacer for &() fail
[Solver] Check Solution: (*Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for *std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::Replacer for regex::bytes::RegexSet fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &mut std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const Range::<usize>)
[TraitImpl] Check trait regex::Replacer for *const std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::Replacer for regex::SetMatches fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::Split::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait regex::Replacer for *const &[char] fail
[Solver] Check Solution: (&mut Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for &mut std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait regex::Replacer for *bool fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::Replacer for &regex::SetMatches fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SetMatches fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Option::<usize>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<usize> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureLocations fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &mut std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureLocations fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait regex::Replacer for *const &[u8] fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait regex::Replacer for *&[u8] fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SetMatches fail
[Solver] Check Solution: (Range::<usize>)
[TraitImpl] Check trait regex::Replacer for std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (Cow::<'_, str>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for std::borrow::Cow::<'a, str>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=Cow::<'_, str>)
[GenericParam] visited={Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] output depth = 2
[Solver] Check Solution: (String)
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait regex::Replacer for &[u8] fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Range::<usize>)
[TraitImpl] Check trait regex::Replacer for &std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::Split::<'_, '_> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::Replacer for regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::RegexBuilder fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::NoExpand::<'_> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::Replacer for *const regex::RegexSet fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SetMatches fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait regex::Replacer for &[char] fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait regex::Replacer for &usize fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait regex::Replacer for *() fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::Replacer for *const regex::SetMatches fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::Replacer for regex::RegexSet fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, str>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for &'a std::borrow::Cow::<'a, str>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=&Cow::<'_, str>)
[GenericParam] visited={Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::NoExpand::<'_> fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::Replacer for *regex::SetMatches fail
[Solver] Check Solution: (*Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait regex::Replacer for u8 fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::Replacer for &regex::RegexSet fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *const std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::Replacer for regex::RegexBuilder fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::Replacer for &mut regex::SetMatches fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait regex::Replacer for *&str fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait regex::Replacer for bool fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait regex::Replacer for &&str fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait regex::Replacer for &mut &[char] fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (*const Option::<usize>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<usize> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::RegexSet fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexSet fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::Replacer for *regex::RegexSet fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&[String])
[TraitImpl] Check trait regex::Replacer for &&[std::string::String] fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, &str>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &str>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait regex::Replacer for *const &str fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureLocations fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::RegexSet fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait regex::Replacer for &&[char] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait regex::Replacer for *const usize fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait regex::Replacer for &mut bool fail
[Solver] Check Solution: (*const Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut Range::<usize>)
[TraitImpl] Check trait regex::Replacer for &mut std::ops::range::Range::<usize> fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &regex::RegexBuilder fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::NoExpand::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (Option::<usize>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<usize> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureNames::<'_> fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait regex::Replacer for &bool fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait regex::Replacer for &mut &str fail
[Solver] Running solve() took 2 ms.
[Solver] find solution for fn regex::Regex::replacen(&regex::Regex, &str, usize, R) -> std::borrow::Cow::<'_, str>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *const std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait regex::Replacer for usize fail
[Solver] Check Solution: (&mut String)
[TraitImpl] Check trait regex::Replacer for &mut std::string::String fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*Range::<usize>)
[TraitImpl] Check trait regex::Replacer for *std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const &[String])
[TraitImpl] Check trait regex::Replacer for *const &[std::string::String] fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SetMatches fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait regex::Replacer for *const bool fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait regex::Replacer for *const () fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*const String)
[TraitImpl] Check trait regex::Replacer for *const std::string::String fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SetMatches fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait regex::Replacer for &mut () fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&[String])
[TraitImpl] Check trait regex::Replacer for &[std::string::String] fail
[Solver] Check Solution: (&ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait regex::Replacer for *&[char] fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const regex::RegexBuilder fail
[Solver] Check Solution: (&str)
[GenericParam] Check pred succ : (R=&str)
[GenericParam] visited={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &str) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }]
[Solver] impls={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[Solver] output depth = 2
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureLocations fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait regex::Replacer for &mut &[u8] fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*&[String])
[TraitImpl] Check trait regex::Replacer for *&[std::string::String] fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait regex::Replacer for &&[u8] fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*String)
[TraitImpl] Check trait regex::Replacer for *std::string::String fail
[Solver] Check Solution: (&ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &String>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, &std::string::String>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &[u8]>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, &[u8]> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::RegexBuilder fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*const Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for *const std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::Replacer for regex::CaptureLocations fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<usize>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<usize> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait regex::Replacer for *usize fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait regex::Replacer for &mut usize fail
[Solver] Check Solution: (&String)
[GenericParam] Check pred succ : (R=&String)
[GenericParam] visited={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::string::String) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Option::<usize>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<usize> fail
[Solver] Check Solution: (())
[TraitImpl] Check trait regex::Replacer for () fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut &[String])
[TraitImpl] Check trait regex::Replacer for &mut &[std::string::String] fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait regex::Replacer for &() fail
[Solver] Check Solution: (*Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for *std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::Replacer for regex::bytes::RegexSet fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &mut std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const Range::<usize>)
[TraitImpl] Check trait regex::Replacer for *const std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::Replacer for regex::SetMatches fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::Split::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait regex::Replacer for *const &[char] fail
[Solver] Check Solution: (&mut Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for &mut std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait regex::Replacer for *bool fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::Replacer for &regex::SetMatches fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SetMatches fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Option::<usize>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<usize> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureLocations fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &mut std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureLocations fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait regex::Replacer for *const &[u8] fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait regex::Replacer for *&[u8] fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SetMatches fail
[Solver] Check Solution: (Range::<usize>)
[TraitImpl] Check trait regex::Replacer for std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (Cow::<'_, str>)
[GenericParam] Check pred succ : (R=Cow::<'_, str>)
[GenericParam] visited={Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] output depth = 2
[Solver] Check Solution: (String)
[GenericParam] Check pred succ : (R=String)
[GenericParam] visited={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::string::String) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait regex::Replacer for &[u8] fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Range::<usize>)
[TraitImpl] Check trait regex::Replacer for &std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::Split::<'_, '_> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::Replacer for regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &&mut regex::RegexBuilder fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::NoExpand::<'_> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::Replacer for *const regex::RegexSet fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SetMatches fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait regex::Replacer for &[char] fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait regex::Replacer for &usize fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait regex::Replacer for *() fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::Replacer for *const regex::SetMatches fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::Replacer for regex::RegexSet fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, str>)
[GenericParam] Check pred succ : (R=&Cow::<'_, str>)
[GenericParam] visited={Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::NoExpand::<'_> fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::Replacer for *regex::SetMatches fail
[Solver] Check Solution: (*Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait regex::Replacer for u8 fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::Replacer for &regex::RegexSet fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *const std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::Replacer for regex::RegexBuilder fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::Replacer for &mut regex::SetMatches fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait regex::Replacer for *&str fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for *std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait regex::Replacer for bool fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::Replacer for &std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait regex::Replacer for &&str fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait regex::Replacer for &mut &[char] fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (*const Option::<usize>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<usize> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::RegexSet fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::Replacer for &mut regex::RegexSet fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::Replacer for *regex::RegexSet fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&[String])
[TraitImpl] Check trait regex::Replacer for &&[std::string::String] fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for *const &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, &str>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &str>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, &str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for *const regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait regex::Replacer for *const &str fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureLocations fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &mut std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::Replacer for *const regex::bytes::RegexSet fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for &regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::Replacer for regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait regex::Replacer for &&[char] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait regex::Replacer for *const usize fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait regex::Replacer for &mut bool fail
[Solver] Check Solution: (*const Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut Range::<usize>)
[TraitImpl] Check trait regex::Replacer for &mut std::ops::range::Range::<usize> fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::Replacer for &regex::RegexBuilder fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::Replacer for &mut &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::Replacer for *regex::NoExpand::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (Option::<usize>)
[TraitImpl] Check trait regex::Replacer for std::option::Option::<usize> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::Replacer for *const std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::Replacer for &mut regex::CaptureNames::<'_> fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait regex::Replacer for &bool fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::Replacer for *regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait regex::Replacer for &mut &str fail
[Solver] Running solve() took 2 ms.
[Solver] find solution for fn regex::bytes::Regex::replace(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait regex::bytes::Replacer for usize fail
[Solver] Check Solution: (&mut String)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::string::String fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const &[String])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[std::string::String] fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SetMatches fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait regex::bytes::Replacer for *const bool fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait regex::bytes::Replacer for *const () fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*const String)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::string::String fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SetMatches fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait regex::bytes::Replacer for &mut () fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&[String])
[TraitImpl] Check trait regex::bytes::Replacer for &[std::string::String] fail
[Solver] Check Solution: (&ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait regex::bytes::Replacer for *&[char] fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::RegexBuilder fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait regex::bytes::Replacer for &str fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureLocations fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[u8] fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*&[String])
[TraitImpl] Check trait regex::bytes::Replacer for *&[std::string::String] fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait regex::bytes::Replacer for &&[u8] fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*String)
[TraitImpl] Check trait regex::bytes::Replacer for *std::string::String fail
[Solver] Check Solution: (&ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for regex::bytes::ReplacerRef::<'a, R>?
[TraitImpl] solution: (NoExpand::<'_>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[TypeContext] add candidate #278: Cow::<'_, [u8]> => Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } }
[TypeContext] add candidate #279: &mut Cow::<'_, [u8]> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } } }
[TypeContext] add candidate #280: &Cow::<'_, [u8]> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } } }
[TypeContext] add candidate #281: *Cow::<'_, [u8]> => RawPointer(Mut, Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })
[TypeContext] add candidate #282: *const Cow::<'_, [u8]> => RawPointer(Not, Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &[u8]>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for regex::bytes::ReplacerRef::<'a, R>?
[TraitImpl] solution: (&[u8]), generic_defs: ["R"]
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for &'a [u8]?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=&[u8])
[GenericParam] visited={Unknown, Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &[u8]>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, &[u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::RegexBuilder fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*const Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureLocations fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>> fail
[Solver] Check Solution: (&Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<usize> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait regex::bytes::Replacer for *usize fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait regex::bytes::Replacer for &mut usize fail
[Solver] Check Solution: (&String)
[TraitImpl] Check trait regex::bytes::Replacer for &std::string::String fail
[Solver] Check Solution: (&mut Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<usize> fail
[Solver] Check Solution: (())
[TraitImpl] Check trait regex::bytes::Replacer for () fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>> fail
[Solver] Check Solution: (&mut &[String])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[std::string::String] fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait regex::bytes::Replacer for &() fail
[Solver] Check Solution: (*Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::RegexSet fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SetMatches fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::Split::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] output depth = 3
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[char] fail
[Solver] Check Solution: (&mut Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait regex::bytes::Replacer for *bool fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SetMatches fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SetMatches fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<usize> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureLocations fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureLocations fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[u8] fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait regex::bytes::Replacer for *&[u8] fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SetMatches fail
[Solver] Check Solution: (Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (String)
[TraitImpl] Check trait regex::bytes::Replacer for std::string::String fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&[u8])
[GenericParam] Check pred succ : (R=&[u8])
[GenericParam] visited={Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] output depth = 3
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::Split::<'_, '_> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::RegexBuilder fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::NoExpand::<'_> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::RegexSet fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SetMatches fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait regex::bytes::Replacer for &[char] fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait regex::bytes::Replacer for &usize fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait regex::bytes::Replacer for *() fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SetMatches fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for regex::RegexSet fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::NoExpand::<'_> fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SetMatches fail
[Solver] Check Solution: (*Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait regex::bytes::Replacer for u8 fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::RegexSet fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for regex::RegexBuilder fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SetMatches fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for regex::bytes::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, NoExpand::<'_>>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait regex::bytes::Replacer for *&str fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait regex::bytes::Replacer for bool fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait regex::bytes::Replacer for &&str fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[char] fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (*const Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<usize> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::RegexSet fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexSet fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::RegexSet fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&[String])
[TraitImpl] Check trait regex::bytes::Replacer for &&[std::string::String] fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait regex::bytes::Replacer for *const &str fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureLocations fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::RegexSet fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait regex::bytes::Replacer for &&[char] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait regex::bytes::Replacer for *const usize fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait regex::bytes::Replacer for &mut bool fail
[Solver] Check Solution: (*const Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::ops::range::Range::<usize> fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::RegexBuilder fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::NoExpand::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<usize> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureNames::<'_> fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait regex::bytes::Replacer for &bool fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &str fail
[Solver] Running solve() took 2 ms.
[Solver] find solution for fn regex::bytes::Regex::replace_all(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait regex::bytes::Replacer for usize fail
[Solver] Check Solution: (&mut String)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::string::String fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const &[String])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[std::string::String] fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SetMatches fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait regex::bytes::Replacer for *const bool fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait regex::bytes::Replacer for *const () fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*const String)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::string::String fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SetMatches fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait regex::bytes::Replacer for &mut () fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&[String])
[TraitImpl] Check trait regex::bytes::Replacer for &[std::string::String] fail
[Solver] Check Solution: (&ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait regex::bytes::Replacer for *&[char] fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::RegexBuilder fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait regex::bytes::Replacer for &str fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureLocations fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[u8] fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*&[String])
[TraitImpl] Check trait regex::bytes::Replacer for *&[std::string::String] fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait regex::bytes::Replacer for &&[u8] fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*String)
[TraitImpl] Check trait regex::bytes::Replacer for *std::string::String fail
[Solver] Check Solution: (&ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &[u8]>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &[u8]>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, &[u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::RegexBuilder fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*const Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureLocations fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>> fail
[Solver] Check Solution: (&Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<usize> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait regex::bytes::Replacer for *usize fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait regex::bytes::Replacer for &mut usize fail
[Solver] Check Solution: (&String)
[TraitImpl] Check trait regex::bytes::Replacer for &std::string::String fail
[Solver] Check Solution: (&mut Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<usize> fail
[Solver] Check Solution: (())
[TraitImpl] Check trait regex::bytes::Replacer for () fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>> fail
[Solver] Check Solution: (&mut &[String])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[std::string::String] fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait regex::bytes::Replacer for &() fail
[Solver] Check Solution: (*Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::RegexSet fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SetMatches fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::Split::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] output depth = 3
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[char] fail
[Solver] Check Solution: (&mut Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait regex::bytes::Replacer for *bool fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SetMatches fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SetMatches fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<usize> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureLocations fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureLocations fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[u8] fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait regex::bytes::Replacer for *&[u8] fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SetMatches fail
[Solver] Check Solution: (Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (String)
[TraitImpl] Check trait regex::bytes::Replacer for std::string::String fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&[u8])
[GenericParam] Check pred succ : (R=&[u8])
[GenericParam] visited={Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] output depth = 3
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, [u8]>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for &'a std::borrow::Cow::<'a, [u8]>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=&Cow::<'_, [u8]>)
[GenericParam] visited={Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::Split::<'_, '_> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::RegexBuilder fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::NoExpand::<'_> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::RegexSet fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SetMatches fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait regex::bytes::Replacer for &[char] fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait regex::bytes::Replacer for &usize fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait regex::bytes::Replacer for *() fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SetMatches fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for regex::RegexSet fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::NoExpand::<'_> fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SetMatches fail
[Solver] Check Solution: (*Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait regex::bytes::Replacer for u8 fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::RegexSet fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for regex::RegexBuilder fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SetMatches fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait regex::bytes::Replacer for *&str fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait regex::bytes::Replacer for bool fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait regex::bytes::Replacer for &&str fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[char] fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (*const Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<usize> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::RegexSet fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexSet fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::RegexSet fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&[String])
[TraitImpl] Check trait regex::bytes::Replacer for &&[std::string::String] fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (Cow::<'_, [u8]>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for std::borrow::Cow::<'a, [u8]>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=Cow::<'_, [u8]>)
[GenericParam] visited={Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[Solver] output depth = 3
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait regex::bytes::Replacer for *const &str fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureLocations fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::RegexSet fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait regex::bytes::Replacer for &&[char] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait regex::bytes::Replacer for *const usize fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait regex::bytes::Replacer for &mut bool fail
[Solver] Check Solution: (*const Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::ops::range::Range::<usize> fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::RegexBuilder fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::NoExpand::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<usize> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureNames::<'_> fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait regex::bytes::Replacer for &bool fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &str fail
[Solver] Running solve() took 2 ms.
[Solver] find solution for fn regex::bytes::Regex::replacen(&regex::bytes::Regex, &[u8], usize, R) -> std::borrow::Cow::<'_, [u8]>, already have 0 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&mut &[String]), (CaptureMatches::<'_, '_>), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (&&mut RegexSetBuilder), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (Cow::<'_, str>), (String), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (&ReplacerRef::<'_, String>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (*const Option::<Captures::<'_>>), (&mut CaptureNames::<'_>), (CaptureMatches::<'_, '_>), (&bool), (*SubCaptureMatches::<'_, '_>), (&mut &str)`
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait regex::bytes::Replacer for usize fail
[Solver] Check Solution: (&mut String)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::string::String fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const &[String])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[std::string::String] fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SetMatches fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait regex::bytes::Replacer for *const bool fail
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait regex::bytes::Replacer for *const () fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*const String)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::string::String fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SetMatches fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait regex::bytes::Replacer for &mut () fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&[String])
[TraitImpl] Check trait regex::bytes::Replacer for &[std::string::String] fail
[Solver] Check Solution: (&ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait regex::bytes::Replacer for *&[char] fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::RegexBuilder fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait regex::bytes::Replacer for &str fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::RegexSet fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureLocations fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[u8] fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*&[String])
[TraitImpl] Check trait regex::bytes::Replacer for *&[std::string::String] fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait regex::bytes::Replacer for &&[u8] fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*String)
[TraitImpl] Check trait regex::bytes::Replacer for *std::string::String fail
[Solver] Check Solution: (&ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (*const CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (ReplacerRef::<'_, &[u8]>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, &[u8]>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, &[u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::RegexBuilder fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*const Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureLocations fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &String>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>> fail
[Solver] Check Solution: (&Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<usize> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait regex::bytes::Replacer for *usize fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait regex::bytes::Replacer for &mut usize fail
[Solver] Check Solution: (&String)
[TraitImpl] Check trait regex::bytes::Replacer for &std::string::String fail
[Solver] Check Solution: (&mut Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<usize> fail
[Solver] Check Solution: (())
[TraitImpl] Check trait regex::bytes::Replacer for () fail
[Solver] Check Solution: (*SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, &str>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>> fail
[Solver] Check Solution: (&mut &[String])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[std::string::String] fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait regex::bytes::Replacer for &() fail
[Solver] Check Solution: (*Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureLocations fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::RegexSet fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*const Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SetMatches fail
[Solver] Check Solution: (Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::Split::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[GenericParam] Check pred succ : (R=NoExpand::<'_>)
[GenericParam] visited={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] output depth = 3
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[char] fail
[Solver] Check Solution: (&mut Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait regex::bytes::Replacer for *bool fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::SetMatches fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SetMatches fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<usize> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureLocations fail
[Solver] Check Solution: (&mut Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (&CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureLocations fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait regex::bytes::Replacer for *const &[u8] fail
[Solver] Check Solution: (&&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait regex::bytes::Replacer for *&[u8] fail
[Solver] Check Solution: (*&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SetMatches fail
[Solver] Check Solution: (Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (String)
[TraitImpl] Check trait regex::bytes::Replacer for std::string::String fail
[Solver] Check Solution: (*const Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::Matches::<'_, '_> fail
[Solver] Check Solution: (&[u8])
[GenericParam] Check pred succ : (R=&[u8])
[GenericParam] visited={Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &[u8]) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] output depth = 3
[Solver] Check Solution: (*Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, [u8]>)
[GenericParam] Check pred succ : (R=&Cow::<'_, [u8]>)
[GenericParam] visited={Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::ops::range::Range::<usize> fail
[Solver] Check Solution: (*const Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::Split::<'_, '_> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::result::Result::<regex::bytes::Regex, regex::Error> fail
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*const SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, String>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, std::string::String> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &&mut regex::RegexBuilder fail
[Solver] Check Solution: (*CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::NoExpand::<'_> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::RegexSet fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&mut SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::Matches::<'_, '_> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SetMatches fail
[Solver] Check Solution: (Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait regex::bytes::Replacer for &[char] fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait regex::bytes::Replacer for &usize fail
[Solver] Check Solution: (&Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait regex::bytes::Replacer for *() fail
[Solver] Check Solution: (*const SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SetMatches fail
[Solver] Check Solution: (*Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (*const SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for regex::RegexSet fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::NoExpand::<'_> fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (&Cow::<'_, str>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (*const &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (*SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SplitN::<'_, '_> fail
[Solver] Check Solution: (*const NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::NoExpand::<'_> fail
[Solver] Check Solution: (*const Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::NoExpand::<'_> fail
[Solver] Check Solution: (*SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SetMatches fail
[Solver] Check Solution: (*Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait regex::bytes::Replacer for u8 fail
[Solver] Check Solution: (*RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::RegexBuilder fail
[Solver] Check Solution: (*ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::RegexSet fail
[Solver] Check Solution: (CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::CaptureNames::<'_> fail
[Solver] Check Solution: (Option::<Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for regex::RegexBuilder fail
[Solver] Check Solution: (&mut Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::Split::<'_, '_> fail
[Solver] Check Solution: (&mut &mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::RegexBuilder fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (*&mut RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *&mut regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&mut SetMatches)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SetMatches fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> fail
[Solver] Check Solution: (Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut SplitN::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::SplitN::<'_, '_> fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait regex::bytes::Replacer for *&str fail
[Solver] Check Solution: (*CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureLocations fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::bytes::Captures::<'_>> fail
[Solver] Check Solution: (*CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::CaptureNames::<'_> fail
[Solver] Check Solution: (*Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait regex::bytes::Replacer for bool fail
[Solver] Check Solution: (&Result::<Regex, Error>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::result::Result::<regex::Regex, regex::Error> fail
[Solver] Check Solution: (*const RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::RegexBuilder fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait regex::bytes::Replacer for &&str fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait regex::bytes::Replacer for &mut &[char] fail
[Solver] Check Solution: (*Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, &String>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, &std::string::String> fail
[Solver] Check Solution: (*const Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<usize> fail
[Solver] Check Solution: (&mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::bytes::Match::<'_>> fail
[Solver] Check Solution: (&mut Option::<Match::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::Match::<'_>> fail
[Solver] Check Solution: (&Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::RegexSet fail
[Solver] Check Solution: (&Matches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::Matches::<'_, '_> fail
[Solver] Check Solution: (*Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::RegexSet fail
[Solver] Check Solution: (*RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::RegexSet fail
[Solver] Check Solution: (SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&&[String])
[TraitImpl] Check trait regex::bytes::Replacer for &&[std::string::String] fail
[Solver] Check Solution: (*const &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for *const &mut regex::RegexSetBuilder fail
[Solver] Check Solution: (&SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (ReplacerRef::<'_, &str>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, &str> fail
[Solver] Check Solution: (&mut Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (Cow::<'_, [u8]>)
[GenericParam] Check pred succ : (R=Cow::<'_, [u8]>)
[GenericParam] visited={Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[Solver] output depth = 3
[Solver] Check Solution: (*const CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait regex::bytes::Replacer for *const &str fail
[Solver] Check Solution: (&mut CaptureLocations)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureLocations fail
[Solver] Check Solution: (&CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::CaptureNames::<'_> fail
[Solver] Check Solution: (&mut Option::<Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::option::Option::<std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*const RegexSet)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::bytes::RegexSet fail
[Solver] Check Solution: (&Split::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::bytes::Split::<'_, '_> fail
[Solver] Check Solution: (SetMatchesIter::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::SetMatchesIter::<'_> fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait regex::bytes::Replacer for &&[char] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait regex::bytes::Replacer for *const usize fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait regex::bytes::Replacer for &mut bool fail
[Solver] Check Solution: (*const Option::<(usize ,usize)>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<(usize ,usize)> fail
[Solver] Check Solution: (&mut Range::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::ops::range::Range::<usize> fail
[Solver] Check Solution: (&RegexBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::RegexBuilder fail
[Solver] Check Solution: (&mut &mut RegexSetBuilder)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &mut regex::bytes::RegexSetBuilder fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> fail
[Solver] Check Solution: (*NoExpand::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::NoExpand::<'_> fail
[Solver] Check Solution: (*ReplacerRef::<'_, NoExpand::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, regex::NoExpand::<'_>> fail
[Solver] Check Solution: (Option::<usize>)
[TraitImpl] Check trait regex::bytes::Replacer for std::option::Option::<usize> fail
[Solver] Check Solution: (*const Option::<Captures::<'_>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::option::Option::<regex::Captures::<'_>> fail
[Solver] Check Solution: (&mut CaptureNames::<'_>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::CaptureNames::<'_> fail
[Solver] Check Solution: (CaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::bytes::CaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait regex::bytes::Replacer for &bool fail
[Solver] Check Solution: (*SubCaptureMatches::<'_, '_>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::SubCaptureMatches::<'_, '_> fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait regex::bytes::Replacer for &mut &str fail
[Solver] Running solve() took 2 ms.
=====Iteration #1=====
num of func: 191
num of reachable: 191
num of reachable type: 191
[Reachable]fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::replace_append(&mut std::borrow::Cow::<'_, [u8]>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> () is reachable
[Reachable]fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, [u8]>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>> is reachable
[Reachable]fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::by_ref(&mut std::borrow::Cow::<'_, [u8]>) -> regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>> is reachable
[TypeContext] add candidate #283: ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>> => Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })], constraints: [] } }] } }
[Reachable]fn <std::borrow::Cow::<'_, str> as regex::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, str>) -> std::option::Option::<std::borrow::Cow::<'_, str>> is reachable
[Reachable]fn <std::borrow::Cow::<'_, str> as regex::Replacer>::by_ref(&mut std::borrow::Cow::<'_, str>) -> regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> is reachable
[TypeContext] add candidate #284: ReplacerRef::<'_, std::borrow::Cow::<'_, str>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } }
[TypeContext] add candidate #285: &mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>> => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #286: &ReplacerRef::<'_, std::borrow::Cow::<'_, str>> => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } } }
[TypeContext] add candidate #287: *ReplacerRef::<'_, std::borrow::Cow::<'_, str>> => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })
[TypeContext] add candidate #288: *const ReplacerRef::<'_, std::borrow::Cow::<'_, str>> => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })
===== Candidates =====
Type Candidate #0: (2)regex::bytes::SplitN::<'_, '_>
Type Candidate #1: (1)&mut regex::bytes::NoExpand::<'_>
Type Candidate #2: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #3: (2)*regex::Matches::<'_, '_>
Type Candidate #4: (2)regex::SubCaptureMatches::<'_, '_>
Type Candidate #5: (2)*const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #6: (22)&mut usize
Type Candidate #7: (2)*const regex::bytes::RegexBuilder
Type Candidate #8: (2)*regex::RegexBuilder
Type Candidate #9: (2)*const regex::RegexBuilder
Type Candidate #10: (2)regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #11: (14)&mut std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #12: (10)&mut &[u8]
Type Candidate #13: (26)bool
Type Candidate #14: (4)&std::option::Option::<regex::Captures::<'_>>
Type Candidate #15: (16)()
Type Candidate #16: (2)&regex::SubCaptureMatches::<'_, '_>
Type Candidate #17: (2)*const regex::bytes::CaptureLocations
Type Candidate #18: (2)&mut regex::ReplacerRef::<'_, &str>
Type Candidate #19: (2)regex::bytes::SetMatches
Type Candidate #20: (4)*std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #21: (30)&&str
Type Candidate #22: (10)*&[u8]
Type Candidate #23: (2)*regex::Split::<'_, '_>
Type Candidate #24: (1)&regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #25: (1)*const regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #26: (2)&mut regex::bytes::SetMatchesIter::<'_>
Type Candidate #27: (4)*const regex::bytes::RegexSet
Type Candidate #28: (2)regex::SetMatches
Type Candidate #29: (2)regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #30: (22)&mut regex::RegexBuilder
Type Candidate #31: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>
Type Candidate #32: (1)*regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #33: (19)&std::borrow::Cow::<'_, [u8]>
Type Candidate #34: (2)&mut std::string::String
Type Candidate #35: (2)*const regex::Matches::<'_, '_>
Type Candidate #36: (2)*const regex::bytes::Split::<'_, '_>
Type Candidate #37: (1)&mut regex::NoExpand::<'_>
Type Candidate #38: (1)*&[char]
Type Candidate #39: (2)*regex::bytes::SetMatchesIter::<'_>
Type Candidate #40: (4)regex::bytes::RegexSet
Type Candidate #41: (2)&mut regex::bytes::SetMatches
Type Candidate #42: (30)*&str
Type Candidate #43: (1)*regex::bytes::NoExpand::<'_>
Type Candidate #44: (1)*regex::NoExpand::<'_>
Type Candidate #45: (2)&mut regex::CaptureNames::<'_>
Type Candidate #46: (4)&mut std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #47: (2)&regex::Split::<'_, '_>
Type Candidate #48: (8)*const std::ops::range::Range::<usize>
Type Candidate #49: (22)&mut regex::bytes::RegexBuilder
Type Candidate #50: (4)*&[std::string::String]
Type Candidate #51: (1)&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #52: (1)&regex::bytes::NoExpand::<'_>
Type Candidate #53: (2)*const regex::CaptureNames::<'_>
Type Candidate #54: (4)std::option::Option::<regex::Captures::<'_>>
Type Candidate #55: (10)*const &mut regex::bytes::RegexSetBuilder
Type Candidate #56: (1)*regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #57: (2)&regex::bytes::SetMatchesIter::<'_>
Type Candidate #58: (4)&mut std::option::Option::<regex::Captures::<'_>>
Type Candidate #59: (8)&mut std::ops::range::Range::<usize>
Type Candidate #60: (11)&[u8]
Type Candidate #61: (2)regex::CaptureMatches::<'_, '_>
Type Candidate #62: (2)&regex::bytes::CaptureLocations
Type Candidate #63: (8)*std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #64: (20)*&mut regex::RegexBuilder
Type Candidate #65: (4)regex::RegexSet
Type Candidate #66: (2)&mut regex::SubCaptureMatches::<'_, '_>
Type Candidate #67: (2)&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #68: (16)&mut ()
Type Candidate #69: (1)regex::bytes::NoExpand::<'_>
Type Candidate #70: (2)*regex::CaptureLocations
Type Candidate #71: (10)*&mut regex::bytes::RegexSetBuilder
Type Candidate #72: (2)&mut regex::bytes::SplitN::<'_, '_>
Type Candidate #73: (1)&mut &[char]
Type Candidate #74: (4)*std::option::Option::<regex::Captures::<'_>>
Type Candidate #75: (4)&mut regex::bytes::RegexSet
Type Candidate #76: (2)*regex::bytes::RegexBuilder
Type Candidate #77: (20)*&mut regex::bytes::RegexBuilder
Type Candidate #78: (1)regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #79: (2)regex::bytes::Matches::<'_, '_>
Type Candidate #80: (2)regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #81: (2)regex::CaptureNames::<'_>
Type Candidate #82: (40)*std::borrow::Cow::<'_, str>
Type Candidate #83: (4)*const std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #84: (8)&mut std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #85: (2)*const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #86: (2)*const regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #87: (2)*const regex::ReplacerRef::<'_, &str>
Type Candidate #88: (1)*const &[char]
Type Candidate #89: (4)&std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #90: (2)*const regex::CaptureMatches::<'_, '_>
Type Candidate #91: (2)*const std::option::Option::<(usize ,usize)>
Type Candidate #92: (8)&std::ops::range::Range::<usize>
Type Candidate #93: (2)&regex::CaptureMatches::<'_, '_>
Type Candidate #94: (2)&regex::CaptureLocations
Type Candidate #95: (16)*()
Type Candidate #96: (30)&str
Type Candidate #97: (2)&std::string::String
Type Candidate #98: (2)regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #99: (30)&mut &str
Type Candidate #100: (2)*const regex::Split::<'_, '_>
Type Candidate #101: (19)std::borrow::Cow::<'_, [u8]>
Type Candidate #102: (2)*regex::bytes::CaptureLocations
Type Candidate #103: (2)*regex::bytes::SetMatches
Type Candidate #104: (20)*const &mut regex::RegexBuilder
Type Candidate #105: (2)&regex::Matches::<'_, '_>
Type Candidate #106: (30)*const &str
Type Candidate #107: (2)*regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #108: (6)*const std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #109: (2)*const regex::SetMatches
Type Candidate #110: (10)&&[u8]
Type Candidate #111: (10)&std::option::Option::<regex::Match::<'_>>
Type Candidate #112: (2)&regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #113: (2)&regex::ReplacerRef::<'_, &str>
Type Candidate #114: (2)regex::ReplacerRef::<'_, std::string::String>
Type Candidate #115: (22)*usize
Type Candidate #116: (2)*regex::ReplacerRef::<'_, std::string::String>
Type Candidate #117: (2)&mut regex::SetMatches
Type Candidate #118: (6)&mut std::result::Result::<regex::Regex, regex::Error>
Type Candidate #119: (2)&regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #120: (1)regex::NoExpand::<'_>
Type Candidate #121: (2)&regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #122: (2)*regex::bytes::CaptureNames::<'_>
Type Candidate #123: (10)*const &mut regex::RegexSetBuilder
Type Candidate #124: (12)*const std::option::Option::<usize>
Type Candidate #125: (2)regex::Split::<'_, '_>
Type Candidate #126: (2)*regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #127: (2)&mut regex::Split::<'_, '_>
Type Candidate #128: (10)*std::option::Option::<regex::Match::<'_>>
Type Candidate #129: (1)&regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #130: (2)&regex::bytes::Split::<'_, '_>
Type Candidate #131: (2)&mut regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #132: (10)&mut regex::RegexSetBuilder
Type Candidate #133: (1)*const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #134: (1)regex::SetMatchesIter::<'_>
Type Candidate #135: (19)*const std::borrow::Cow::<'_, [u8]>
Type Candidate #136: (2)&mut regex::bytes::CaptureNames::<'_>
Type Candidate #137: (2)&mut regex::bytes::Matches::<'_, '_>
Type Candidate #138: (2)&regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #139: (10)*const &[u8]
Type Candidate #140: (4)&regex::RegexSet
Type Candidate #141: (8)std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #142: (2)*regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #143: (2)*const regex::bytes::SetMatchesIter::<'_>
Type Candidate #144: (2)&mut regex::Matches::<'_, '_>
Type Candidate #145: (20)&mut &mut regex::bytes::RegexBuilder
Type Candidate #146: (2)*const regex::SplitN::<'_, '_>
Type Candidate #147: (2)*const regex::bytes::SetMatches
Type Candidate #148: (2)regex::bytes::RegexBuilder
Type Candidate #149: (4)*regex::RegexSet
Type Candidate #150: (14)std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #151: (22)&usize
Type Candidate #152: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>
Type Candidate #153: (2)regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #154: (10)&mut std::option::Option::<regex::Match::<'_>>
Type Candidate #155: (4)std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #156: (26)&mut bool
Type Candidate #157: (4)&[std::string::String]
Type Candidate #158: (2)*const regex::bytes::SplitN::<'_, '_>
Type Candidate #159: (2)&regex::CaptureNames::<'_>
Type Candidate #160: (2)regex::bytes::CaptureNames::<'_>
Type Candidate #161: (2)&mut std::option::Option::<(usize ,usize)>
Type Candidate #162: (4)&mut &[std::string::String]
Type Candidate #163: (1)regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #164: (7)std::option::Option::<std::borrow::Cow::<'_, [u8]>>
Type Candidate #165: (4)&mut regex::RegexSet
Type Candidate #166: (2)&mut regex::bytes::Split::<'_, '_>
Type Candidate #167: (1)&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #168: (20)*const &mut regex::bytes::RegexBuilder
Type Candidate #169: (6)std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #170: (2)*const regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #171: (1)&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #172: (2)&regex::bytes::SetMatches
Type Candidate #173: (2)*regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #174: (14)*const std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #175: (2)*regex::bytes::Matches::<'_, '_>
Type Candidate #176: (2)&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #177: (1)&&[char]
Type Candidate #178: (12)*std::option::Option::<usize>
Type Candidate #179: (12)&mut std::option::Option::<usize>
Type Candidate #180: (2)&regex::bytes::CaptureNames::<'_>
Type Candidate #181: (1)*const regex::SetMatchesIter::<'_>
Type Candidate #182: (26)&bool
Type Candidate #183: (12)std::option::Option::<usize>
Type Candidate #184: (16)&()
Type Candidate #185: (2)regex::SplitN::<'_, '_>
Type Candidate #186: (8)std::ops::range::Range::<usize>
Type Candidate #187: (2)*std::string::String
Type Candidate #188: (2)regex::ReplacerRef::<'_, &str>
Type Candidate #189: (2)*const regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #190: (22)usize
Type Candidate #191: (2)&mut regex::SplitN::<'_, '_>
Type Candidate #192: (2)regex::bytes::ReplacerRef::<'_, &[u8]>
Type Candidate #193: (10)&mut regex::bytes::RegexSetBuilder
Type Candidate #194: (2)regex::Matches::<'_, '_>
Type Candidate #195: (26)*const bool
Type Candidate #196: (2)*const regex::bytes::CaptureNames::<'_>
Type Candidate #197: (10)*&mut regex::RegexSetBuilder
Type Candidate #198: (1)&regex::NoExpand::<'_>
Type Candidate #199: (1)*const regex::bytes::NoExpand::<'_>
Type Candidate #200: (2)*regex::SetMatches
Type Candidate #201: (6)*std::result::Result::<regex::Regex, regex::Error>
Type Candidate #202: (6)*const std::result::Result::<regex::Regex, regex::Error>
Type Candidate #203: (2)&regex::RegexBuilder
Type Candidate #204: (1)&[char]
Type Candidate #205: (2)&regex::SetMatches
Type Candidate #206: (4)*regex::bytes::RegexSet
Type Candidate #207: (1)*const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #208: (2)*regex::SubCaptureMatches::<'_, '_>
Type Candidate #209: (2)&regex::bytes::RegexBuilder
Type Candidate #210: (22)*const usize
Type Candidate #211: (19)&mut std::borrow::Cow::<'_, [u8]>
Type Candidate #212: (2)*const regex::bytes::Matches::<'_, '_>
Type Candidate #213: (10)std::option::Option::<regex::Match::<'_>>
Type Candidate #214: (2)&mut regex::bytes::CaptureLocations
Type Candidate #215: (1)*const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #216: (4)&&[std::string::String]
Type Candidate #217: (2)regex::bytes::CaptureLocations
Type Candidate #218: (6)&std::result::Result::<regex::Regex, regex::Error>
Type Candidate #219: (2)*const regex::ReplacerRef::<'_, std::string::String>
Type Candidate #220: (2)&regex::bytes::Matches::<'_, '_>
Type Candidate #221: (6)&mut std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #222: (2)*regex::ReplacerRef::<'_, &str>
Type Candidate #223: (40)&mut std::borrow::Cow::<'_, str>
Type Candidate #224: (2)std::string::String
Type Candidate #225: (10)&&mut regex::bytes::RegexSetBuilder
Type Candidate #226: (1)&regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #227: (2)&regex::ReplacerRef::<'_, std::string::String>
Type Candidate #228: (4)*const std::option::Option::<regex::Captures::<'_>>
Type Candidate #229: (2)&mut regex::CaptureMatches::<'_, '_>
Type Candidate #230: (2)*const regex::CaptureLocations
Type Candidate #231: (4)*const regex::RegexSet
Type Candidate #232: (1)&regex::SetMatchesIter::<'_>
Type Candidate #233: (2)&regex::bytes::SplitN::<'_, '_>
Type Candidate #234: (1)&regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #235: (10)*const std::option::Option::<regex::Match::<'_>>
Type Candidate #236: (2)regex::bytes::SetMatchesIter::<'_>
Type Candidate #237: (10)&mut &mut regex::bytes::RegexSetBuilder
Type Candidate #238: (2)&std::option::Option::<(usize ,usize)>
Type Candidate #239: (12)&std::option::Option::<usize>
Type Candidate #240: (2)*std::option::Option::<(usize ,usize)>
Type Candidate #241: (16)*const ()
Type Candidate #242: (6)std::result::Result::<regex::Regex, regex::Error>
Type Candidate #243: (2)&regex::SplitN::<'_, '_>
Type Candidate #244: (14)*std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #245: (2)*regex::CaptureNames::<'_>
Type Candidate #246: (4)*const &[std::string::String]
Type Candidate #247: (20)&&mut regex::RegexBuilder
Type Candidate #248: (1)*const regex::NoExpand::<'_>
Type Candidate #249: (2)&mut regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #250: (2)*regex::bytes::SplitN::<'_, '_>
Type Candidate #251: (1)*regex::SetMatchesIter::<'_>
Type Candidate #252: (10)&&mut regex::RegexSetBuilder
Type Candidate #253: (2)*const std::string::String
Type Candidate #254: (2)&mut regex::CaptureLocations
Type Candidate #255: (2)regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>
Type Candidate #256: (2)&regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #257: (2)*const regex::SubCaptureMatches::<'_, '_>
Type Candidate #258: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #259: (26)*bool
Type Candidate #260: (2)*regex::SplitN::<'_, '_>
Type Candidate #261: (14)&std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #262: (40)*const std::borrow::Cow::<'_, str>
Type Candidate #263: (4)&regex::bytes::RegexSet
Type Candidate #264: (2)&mut regex::ReplacerRef::<'_, std::string::String>
Type Candidate #265: (2)*regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #266: (10)&mut &mut regex::RegexSetBuilder
Type Candidate #267: (2)*regex::bytes::Split::<'_, '_>
Type Candidate #268: (40)std::borrow::Cow::<'_, str>
Type Candidate #269: (40)&std::borrow::Cow::<'_, str>
Type Candidate #270: (2)regex::RegexBuilder
Type Candidate #271: (6)*std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #272: (2)std::option::Option::<(usize ,usize)>
Type Candidate #273: (20)&&mut regex::bytes::RegexBuilder
Type Candidate #274: (20)&mut &mut regex::RegexBuilder
Type Candidate #275: (1)&mut regex::SetMatchesIter::<'_>
Type Candidate #276: (1)u8
Type Candidate #277: (2)&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #278: (2)*regex::CaptureMatches::<'_, '_>
Type Candidate #279: (8)*const std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #280: (1)*regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #281: (1)*regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #282: (2)regex::CaptureLocations
Type Candidate #283: (2)regex::bytes::Split::<'_, '_>
Type Candidate #284: (8)&std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #285: (8)*std::ops::range::Range::<usize>
Type Candidate #286: (19)*std::borrow::Cow::<'_, [u8]>
Type Candidate #287: (6)&std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #288: (1)&mut regex::bytes::SubCaptureMatches::<'_, '_>
===== !Candidates =====
[Solver] find solution for fn regex::RegexSetBuilder::new(I) -> regex::RegexSetBuilder, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::replace_append(&mut regex::ReplacerRef::<'_, R>, &regex::Captures::<'_>, &mut std::string::String) -> (), already have 4 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
Merge: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Solution Set = `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 1
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 1
[Solver] Check Solution: (std::borrow::Cow::<'_, str>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for std::borrow::Cow::<'a, str>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=std::borrow::Cow::<'_, str>)
[GenericParam] visited={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] output depth = 1
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::no_expansion(&mut regex::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, already have 4 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
Merge: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Solution Set = `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 3
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 3
[Solver] Check Solution: (std::borrow::Cow::<'_, str>)
[GenericParam] Check pred succ : (R=std::borrow::Cow::<'_, str>)
[GenericParam] visited={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] output depth = 3
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::by_ref(&mut regex::ReplacerRef::<'_, R>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, R>>, already have 4 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
Merge: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Solution Set = `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Check Solution: (ReplacerRef::<'_, String>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, String>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 4
[TypeContext] add candidate #289: ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 4
[TypeContext] add candidate #290: ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[Solver] Check Solution: (std::borrow::Cow::<'_, str>)
[GenericParam] Check pred succ : (R=std::borrow::Cow::<'_, str>)
[GenericParam] visited={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] find mono function: fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }]
[Solver] impls={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] output depth = 4
[TypeContext] add candidate #291: ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>> => Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::RegexSet::new(I) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::ReplacerRef::<'_, R>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> (), already have 0 solutions
[Solver] generic params: ["R"]
[Solver] input#2: &mut std::vec::Vec::<u8> is unreachable
[Solver] Skip it. It is currently unreachable.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>, already have 1 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
Merge: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Solution Set = `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[Solver] find mono function: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[Solver] output depth = 4
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::ReplacerRef::<'_, R>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, R>>, already have 1 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
Merge: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Solution Set = `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Check Solution: (ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, NoExpand::<'_>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[Solver] find mono function: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[Solver] output depth = 4
[TypeContext] add candidate #292: ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>> => Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::RegexSetBuilder::new(I) -> regex::bytes::RegexSetBuilder, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn regex::RegexSet::new(I) -> std::result::Result::<regex::RegexSet, regex::Error>, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn regex::Regex::replace(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>, already have 12 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Check Solution: (*Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for *std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (*const Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for *const std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for *std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), generic_defs: ["R"]
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (std::borrow::Cow::<'_, str>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=std::borrow::Cow::<'_, str>)
[GenericParam] visited={Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Cow::<'_, str>)
[TraitImpl] Check trait regex::Replacer for &mut std::borrow::Cow::<'_, str> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (Cow::<'_, str>)
[GenericParam] Check pred succ : (R=Cow::<'_, str>)
[GenericParam] visited={Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[TraitImpl] Recursively check: do we have impl regex::Replacer for regex::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, ReplacerRef::<'_, String>>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, String>>)
[GenericParam] visited={Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for &std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Cow::<'_, str>)
[GenericParam] Check pred succ : (R=&Cow::<'_, str>)
[GenericParam] visited={Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[Solver] find mono function: fn regex::Regex::replace#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for &mut std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for *const std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Running solve() took 1 ms.
[Solver] find solution for fn regex::Regex::replace_all(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>, already have 14 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Check Solution: (*Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for *std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for &std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for &mut std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for *const std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::Regex::replacen(&regex::Regex, &str, usize, R) -> std::borrow::Cow::<'_, str>, already have 14 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Check Solution: (*Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for *std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>> fail
[Solver] Check Solution: (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for &regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Check trait regex::Replacer for regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2609 ~ regex[3103]::re_unicode::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for &std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[GenericParam] visited={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] find mono function: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::borrow::Cow::<'_, str>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2600 ~ regex[3103]::re_unicode::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Primitive(Str))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for &mut std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for *const std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::Replacer for std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::Replacer for *regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::Regex::replace(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>, already have 5 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Check Solution: (*Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for *std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for regex::bytes::ReplacerRef::<'a, R>?
[TraitImpl] solution: (std::borrow::Cow::<'_, [u8]>), generic_defs: ["R"]
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for std::borrow::Cow::<'a, [u8]>?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (R=std::borrow::Cow::<'_, [u8]>)
[GenericParam] visited={Unknown, Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Recursively check: do we have impl regex::bytes::Replacer for regex::bytes::ReplacerRef::<'a, R>?
[TraitImpl] solution: (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), generic_defs: ["R"]
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>> fail
[Solver] Check Solution: (&Cow::<'_, [u8]>)
[GenericParam] Check pred succ : (R=&Cow::<'_, [u8]>)
[GenericParam] visited={Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } } }]
[Solver] impls={Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[Solver] output depth = 3
[Solver] Check Solution: (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&mut Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (*const Cow::<'_, [u8]>)
[TraitImpl] Check trait regex::bytes::Replacer for *const std::borrow::Cow::<'_, [u8]> fail
[Solver] Check Solution: (Cow::<'_, [u8]>)
[GenericParam] Check pred succ : (R=Cow::<'_, [u8]>)
[GenericParam] visited={Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[Solver] find mono function: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[Solver] output depth = 3
[Solver] Check Solution: (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::Regex::replace_all(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>, already have 7 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::Regex::replacen(&regex::bytes::Regex, &[u8], usize, R) -> std::borrow::Cow::<'_, [u8]>, already have 7 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "std", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "borrow", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Slice(Primitive(U8)))], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for &regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] Check pred succ : (R=ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[GenericParam] visited={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] find mono function: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, [u8]>
[Solver] mono solution: [Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2279 ~ regex[3103]::re_bytes::ReplacerRef)), segments: [PathSegment { name: "ReplacerRef", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Path { path: Path { res: Def(Struct, DefId(0:2288 ~ regex[3103]::re_bytes::NoExpand)), segments: [PathSegment { name: "NoExpand", args: AngleBracketed { args: [Lifetime(Lifetime("'_"))], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } })], constraints: [] } }] } }]
[Solver] impls={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] output depth = 3
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>> fail
[Solver] Check Solution: (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>> fail
[Solver] Check Solution: (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Check Solution: (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>)
[TraitImpl] Check trait regex::bytes::Replacer for *regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> fail
[Solver] Running solve() took 0 ms.
=====Iteration #2=====
num of func: 191
num of reachable: 191
num of reachable type: 191
===== Candidates =====
Type Candidate #0: (2)regex::bytes::SplitN::<'_, '_>
Type Candidate #1: (1)&mut regex::bytes::NoExpand::<'_>
Type Candidate #2: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #3: (2)*regex::Matches::<'_, '_>
Type Candidate #4: (2)regex::SubCaptureMatches::<'_, '_>
Type Candidate #5: (2)*const regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #6: (22)&mut usize
Type Candidate #7: (2)*const regex::bytes::RegexBuilder
Type Candidate #8: (2)*regex::RegexBuilder
Type Candidate #9: (2)*const regex::RegexBuilder
Type Candidate #10: (2)regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #11: (17)&mut std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #12: (10)&mut &[u8]
Type Candidate #13: (26)bool
Type Candidate #14: (4)&std::option::Option::<regex::Captures::<'_>>
Type Candidate #15: (19)()
Type Candidate #16: (2)&regex::SubCaptureMatches::<'_, '_>
Type Candidate #17: (2)*const regex::bytes::CaptureLocations
Type Candidate #18: (2)&mut regex::ReplacerRef::<'_, &str>
Type Candidate #19: (2)regex::bytes::SetMatches
Type Candidate #20: (4)*std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #21: (30)&&str
Type Candidate #22: (10)*&[u8]
Type Candidate #23: (2)*regex::Split::<'_, '_>
Type Candidate #24: (1)&regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #25: (1)*const regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #26: (2)&mut regex::bytes::SetMatchesIter::<'_>
Type Candidate #27: (4)*const regex::bytes::RegexSet
Type Candidate #28: (2)regex::SetMatches
Type Candidate #29: (2)regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #30: (22)&mut regex::RegexBuilder
Type Candidate #31: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>
Type Candidate #32: (1)*regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #33: (27)&std::borrow::Cow::<'_, [u8]>
Type Candidate #34: (1)regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>
Type Candidate #35: (2)&mut std::string::String
Type Candidate #36: (2)*const regex::Matches::<'_, '_>
Type Candidate #37: (2)*const regex::bytes::Split::<'_, '_>
Type Candidate #38: (1)&mut regex::NoExpand::<'_>
Type Candidate #39: (1)*&[char]
Type Candidate #40: (2)*regex::bytes::SetMatchesIter::<'_>
Type Candidate #41: (4)regex::bytes::RegexSet
Type Candidate #42: (2)&mut regex::bytes::SetMatches
Type Candidate #43: (30)*&str
Type Candidate #44: (1)*regex::bytes::NoExpand::<'_>
Type Candidate #45: (1)*regex::NoExpand::<'_>
Type Candidate #46: (2)&mut regex::CaptureNames::<'_>
Type Candidate #47: (4)&mut std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #48: (2)&regex::Split::<'_, '_>
Type Candidate #49: (8)*const std::ops::range::Range::<usize>
Type Candidate #50: (22)&mut regex::bytes::RegexBuilder
Type Candidate #51: (4)*&[std::string::String]
Type Candidate #52: (1)&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #53: (1)&regex::bytes::NoExpand::<'_>
Type Candidate #54: (2)*const regex::CaptureNames::<'_>
Type Candidate #55: (4)std::option::Option::<regex::Captures::<'_>>
Type Candidate #56: (10)*const &mut regex::bytes::RegexSetBuilder
Type Candidate #57: (1)*regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #58: (2)&regex::bytes::SetMatchesIter::<'_>
Type Candidate #59: (4)&mut std::option::Option::<regex::Captures::<'_>>
Type Candidate #60: (8)&mut std::ops::range::Range::<usize>
Type Candidate #61: (11)&[u8]
Type Candidate #62: (2)regex::CaptureMatches::<'_, '_>
Type Candidate #63: (2)&regex::bytes::CaptureLocations
Type Candidate #64: (8)*std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #65: (20)*&mut regex::RegexBuilder
Type Candidate #66: (4)regex::RegexSet
Type Candidate #67: (2)&mut regex::SubCaptureMatches::<'_, '_>
Type Candidate #68: (2)&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #69: (19)&mut ()
Type Candidate #70: (1)regex::bytes::NoExpand::<'_>
Type Candidate #71: (2)*regex::CaptureLocations
Type Candidate #72: (10)*&mut regex::bytes::RegexSetBuilder
Type Candidate #73: (2)&mut regex::bytes::SplitN::<'_, '_>
Type Candidate #74: (1)&mut &[char]
Type Candidate #75: (4)*std::option::Option::<regex::Captures::<'_>>
Type Candidate #76: (4)&mut regex::bytes::RegexSet
Type Candidate #77: (2)*regex::bytes::RegexBuilder
Type Candidate #78: (20)*&mut regex::bytes::RegexBuilder
Type Candidate #79: (1)regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #80: (2)regex::bytes::Matches::<'_, '_>
Type Candidate #81: (2)regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #82: (2)regex::CaptureNames::<'_>
Type Candidate #83: (54)*std::borrow::Cow::<'_, str>
Type Candidate #84: (4)*const std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #85: (8)&mut std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #86: (2)*const regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #87: (2)*const regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #88: (2)*const regex::ReplacerRef::<'_, &str>
Type Candidate #89: (1)*const &[char]
Type Candidate #90: (4)&std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #91: (2)*const regex::CaptureMatches::<'_, '_>
Type Candidate #92: (2)*const std::option::Option::<(usize ,usize)>
Type Candidate #93: (8)&std::ops::range::Range::<usize>
Type Candidate #94: (2)&regex::CaptureMatches::<'_, '_>
Type Candidate #95: (2)&regex::CaptureLocations
Type Candidate #96: (19)*()
Type Candidate #97: (30)&str
Type Candidate #98: (2)&std::string::String
Type Candidate #99: (2)regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #100: (30)&mut &str
Type Candidate #101: (2)*const regex::Split::<'_, '_>
Type Candidate #102: (27)std::borrow::Cow::<'_, [u8]>
Type Candidate #103: (2)*regex::bytes::CaptureLocations
Type Candidate #104: (2)*regex::bytes::SetMatches
Type Candidate #105: (20)*const &mut regex::RegexBuilder
Type Candidate #106: (2)&regex::Matches::<'_, '_>
Type Candidate #107: (30)*const &str
Type Candidate #108: (2)*regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #109: (6)*const std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #110: (2)*const regex::SetMatches
Type Candidate #111: (10)&&[u8]
Type Candidate #112: (10)&std::option::Option::<regex::Match::<'_>>
Type Candidate #113: (2)&regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #114: (2)&regex::ReplacerRef::<'_, &str>
Type Candidate #115: (2)regex::ReplacerRef::<'_, std::string::String>
Type Candidate #116: (22)*usize
Type Candidate #117: (2)*regex::ReplacerRef::<'_, std::string::String>
Type Candidate #118: (2)&mut regex::SetMatches
Type Candidate #119: (6)&mut std::result::Result::<regex::Regex, regex::Error>
Type Candidate #120: (2)&regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #121: (1)regex::NoExpand::<'_>
Type Candidate #122: (2)&regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #123: (2)*regex::bytes::CaptureNames::<'_>
Type Candidate #124: (10)*const &mut regex::RegexSetBuilder
Type Candidate #125: (12)*const std::option::Option::<usize>
Type Candidate #126: (2)regex::Split::<'_, '_>
Type Candidate #127: (2)*regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #128: (2)&mut regex::Split::<'_, '_>
Type Candidate #129: (10)*std::option::Option::<regex::Match::<'_>>
Type Candidate #130: (1)&regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #131: (2)&regex::bytes::Split::<'_, '_>
Type Candidate #132: (2)&mut regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #133: (10)&mut regex::RegexSetBuilder
Type Candidate #134: (1)*const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #135: (1)regex::SetMatchesIter::<'_>
Type Candidate #136: (27)*const std::borrow::Cow::<'_, [u8]>
Type Candidate #137: (2)&mut regex::bytes::CaptureNames::<'_>
Type Candidate #138: (2)&mut regex::bytes::Matches::<'_, '_>
Type Candidate #139: (2)&regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #140: (10)*const &[u8]
Type Candidate #141: (4)&regex::RegexSet
Type Candidate #142: (8)std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #143: (2)*regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #144: (2)*const regex::bytes::SetMatchesIter::<'_>
Type Candidate #145: (2)&mut regex::Matches::<'_, '_>
Type Candidate #146: (20)&mut &mut regex::bytes::RegexBuilder
Type Candidate #147: (2)*const regex::SplitN::<'_, '_>
Type Candidate #148: (2)*const regex::bytes::SetMatches
Type Candidate #149: (2)regex::bytes::RegexBuilder
Type Candidate #150: (4)*regex::RegexSet
Type Candidate #151: (17)std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #152: (22)&usize
Type Candidate #153: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>
Type Candidate #154: (2)regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #155: (10)&mut std::option::Option::<regex::Match::<'_>>
Type Candidate #156: (4)std::option::Option::<regex::bytes::Captures::<'_>>
Type Candidate #157: (26)&mut bool
Type Candidate #158: (4)&[std::string::String]
Type Candidate #159: (2)*const regex::bytes::SplitN::<'_, '_>
Type Candidate #160: (2)&regex::CaptureNames::<'_>
Type Candidate #161: (2)regex::bytes::CaptureNames::<'_>
Type Candidate #162: (2)&mut std::option::Option::<(usize ,usize)>
Type Candidate #163: (4)&mut &[std::string::String]
Type Candidate #164: (1)regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #165: (8)std::option::Option::<std::borrow::Cow::<'_, [u8]>>
Type Candidate #166: (4)&mut regex::RegexSet
Type Candidate #167: (2)&mut regex::bytes::Split::<'_, '_>
Type Candidate #168: (1)&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #169: (20)*const &mut regex::bytes::RegexBuilder
Type Candidate #170: (6)std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #171: (2)*const regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #172: (1)&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #173: (2)&regex::bytes::SetMatches
Type Candidate #174: (2)*regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
Type Candidate #175: (17)*const std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #176: (2)*regex::bytes::Matches::<'_, '_>
Type Candidate #177: (2)&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
Type Candidate #178: (1)&&[char]
Type Candidate #179: (12)*std::option::Option::<usize>
Type Candidate #180: (12)&mut std::option::Option::<usize>
Type Candidate #181: (2)&regex::bytes::CaptureNames::<'_>
Type Candidate #182: (1)*const regex::SetMatchesIter::<'_>
Type Candidate #183: (26)&bool
Type Candidate #184: (12)std::option::Option::<usize>
Type Candidate #185: (19)&()
Type Candidate #186: (2)regex::SplitN::<'_, '_>
Type Candidate #187: (8)std::ops::range::Range::<usize>
Type Candidate #188: (2)*std::string::String
Type Candidate #189: (2)regex::ReplacerRef::<'_, &str>
Type Candidate #190: (2)*const regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #191: (22)usize
Type Candidate #192: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>
Type Candidate #193: (2)&mut regex::SplitN::<'_, '_>
Type Candidate #194: (2)regex::bytes::ReplacerRef::<'_, &[u8]>
Type Candidate #195: (10)&mut regex::bytes::RegexSetBuilder
Type Candidate #196: (2)regex::Matches::<'_, '_>
Type Candidate #197: (26)*const bool
Type Candidate #198: (2)*const regex::bytes::CaptureNames::<'_>
Type Candidate #199: (10)*&mut regex::RegexSetBuilder
Type Candidate #200: (1)&regex::NoExpand::<'_>
Type Candidate #201: (1)*const regex::bytes::NoExpand::<'_>
Type Candidate #202: (2)*regex::SetMatches
Type Candidate #203: (6)*std::result::Result::<regex::Regex, regex::Error>
Type Candidate #204: (6)*const std::result::Result::<regex::Regex, regex::Error>
Type Candidate #205: (2)&regex::RegexBuilder
Type Candidate #206: (1)&[char]
Type Candidate #207: (2)&regex::SetMatches
Type Candidate #208: (4)*regex::bytes::RegexSet
Type Candidate #209: (1)*const regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #210: (2)*regex::SubCaptureMatches::<'_, '_>
Type Candidate #211: (2)&regex::bytes::RegexBuilder
Type Candidate #212: (22)*const usize
Type Candidate #213: (27)&mut std::borrow::Cow::<'_, [u8]>
Type Candidate #214: (2)*const regex::bytes::Matches::<'_, '_>
Type Candidate #215: (10)std::option::Option::<regex::Match::<'_>>
Type Candidate #216: (2)&mut regex::bytes::CaptureLocations
Type Candidate #217: (1)*const regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #218: (4)&&[std::string::String]
Type Candidate #219: (2)regex::bytes::CaptureLocations
Type Candidate #220: (6)&std::result::Result::<regex::Regex, regex::Error>
Type Candidate #221: (2)*const regex::ReplacerRef::<'_, std::string::String>
Type Candidate #222: (2)&regex::bytes::Matches::<'_, '_>
Type Candidate #223: (6)&mut std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #224: (2)*regex::ReplacerRef::<'_, &str>
Type Candidate #225: (54)&mut std::borrow::Cow::<'_, str>
Type Candidate #226: (2)std::string::String
Type Candidate #227: (10)&&mut regex::bytes::RegexSetBuilder
Type Candidate #228: (1)&regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
Type Candidate #229: (2)&regex::ReplacerRef::<'_, std::string::String>
Type Candidate #230: (4)*const std::option::Option::<regex::Captures::<'_>>
Type Candidate #231: (2)&mut regex::CaptureMatches::<'_, '_>
Type Candidate #232: (2)*const regex::CaptureLocations
Type Candidate #233: (4)*const regex::RegexSet
Type Candidate #234: (1)&regex::SetMatchesIter::<'_>
Type Candidate #235: (2)&regex::bytes::SplitN::<'_, '_>
Type Candidate #236: (1)&regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #237: (10)*const std::option::Option::<regex::Match::<'_>>
Type Candidate #238: (2)regex::bytes::SetMatchesIter::<'_>
Type Candidate #239: (10)&mut &mut regex::bytes::RegexSetBuilder
Type Candidate #240: (2)&std::option::Option::<(usize ,usize)>
Type Candidate #241: (12)&std::option::Option::<usize>
Type Candidate #242: (2)*std::option::Option::<(usize ,usize)>
Type Candidate #243: (19)*const ()
Type Candidate #244: (6)std::result::Result::<regex::Regex, regex::Error>
Type Candidate #245: (2)&regex::SplitN::<'_, '_>
Type Candidate #246: (17)*std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #247: (2)*regex::CaptureNames::<'_>
Type Candidate #248: (4)*const &[std::string::String]
Type Candidate #249: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>
Type Candidate #250: (20)&&mut regex::RegexBuilder
Type Candidate #251: (1)*const regex::NoExpand::<'_>
Type Candidate #252: (2)&mut regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #253: (2)*regex::bytes::SplitN::<'_, '_>
Type Candidate #254: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>
Type Candidate #255: (1)*regex::SetMatchesIter::<'_>
Type Candidate #256: (10)&&mut regex::RegexSetBuilder
Type Candidate #257: (2)*const std::string::String
Type Candidate #258: (2)&mut regex::CaptureLocations
Type Candidate #259: (2)regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>
Type Candidate #260: (2)&regex::ReplacerRef::<'_, &std::string::String>
Type Candidate #261: (2)*const regex::SubCaptureMatches::<'_, '_>
Type Candidate #262: (1)regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
Type Candidate #263: (26)*bool
Type Candidate #264: (2)*regex::SplitN::<'_, '_>
Type Candidate #265: (17)&std::option::Option::<std::borrow::Cow::<'_, str>>
Type Candidate #266: (54)*const std::borrow::Cow::<'_, str>
Type Candidate #267: (4)&regex::bytes::RegexSet
Type Candidate #268: (2)&mut regex::ReplacerRef::<'_, std::string::String>
Type Candidate #269: (2)*regex::bytes::CaptureMatches::<'_, '_>
Type Candidate #270: (10)&mut &mut regex::RegexSetBuilder
Type Candidate #271: (2)*regex::bytes::Split::<'_, '_>
Type Candidate #272: (54)std::borrow::Cow::<'_, str>
Type Candidate #273: (54)&std::borrow::Cow::<'_, str>
Type Candidate #274: (2)regex::RegexBuilder
Type Candidate #275: (6)*std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #276: (2)std::option::Option::<(usize ,usize)>
Type Candidate #277: (20)&&mut regex::bytes::RegexBuilder
Type Candidate #278: (20)&mut &mut regex::RegexBuilder
Type Candidate #279: (1)&mut regex::SetMatchesIter::<'_>
Type Candidate #280: (1)u8
Type Candidate #281: (2)&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
Type Candidate #282: (2)*regex::CaptureMatches::<'_, '_>
Type Candidate #283: (8)*const std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #284: (1)*regex::bytes::SubCaptureMatches::<'_, '_>
Type Candidate #285: (1)*regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
Type Candidate #286: (2)regex::CaptureLocations
Type Candidate #287: (2)regex::bytes::Split::<'_, '_>
Type Candidate #288: (8)&std::option::Option::<regex::bytes::Match::<'_>>
Type Candidate #289: (8)*std::ops::range::Range::<usize>
Type Candidate #290: (27)*std::borrow::Cow::<'_, [u8]>
Type Candidate #291: (6)&std::result::Result::<regex::bytes::Regex, regex::Error>
Type Candidate #292: (1)&mut regex::bytes::SubCaptureMatches::<'_, '_>
===== !Candidates =====
[Solver] find solution for fn regex::RegexSetBuilder::new(I) -> regex::RegexSetBuilder, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::replace_append(&mut regex::ReplacerRef::<'_, R>, &regex::Captures::<'_>, &mut std::string::String) -> (), already have 7 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
Merge: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Solution Set = `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::no_expansion(&mut regex::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, already have 7 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
Merge: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Solution Set = `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::by_ref(&mut regex::ReplacerRef::<'_, R>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, R>>, already have 7 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
Merge: `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Solution Set = `(&str), (&String), (ReplacerRef::<'_, String>), (NoExpand::<'_>), (ReplacerRef::<'_, NoExpand::<'_>>), (std::borrow::Cow::<'_, str>), (String)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::RegexSet::new(I) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::ReplacerRef::<'_, R>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> (), already have 0 solutions
[Solver] generic params: ["R"]
[Solver] input#2: &mut std::vec::Vec::<u8> is unreachable
[Solver] Skip it. It is currently unreachable.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>, already have 2 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
Merge: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Solution Set = `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::ReplacerRef::<'_, R>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, R>>, already have 2 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument &mut ReplacerRef::<'_, R>:
set A: `(*)`
set B: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
Merge: `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Solution Set = `(ReplacerRef::<'_, NoExpand::<'_>>), (NoExpand::<'_>)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::RegexSetBuilder::new(I) -> regex::bytes::RegexSetBuilder, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn regex::RegexSet::new(I) -> std::result::Result::<regex::RegexSet, regex::Error>, already have 0 solutions
[Solver] generic params: ["I", "S"]
[Solver] Skip it. It is unsolvable.
[Solver] find solution for fn regex::Regex::replace(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>, already have 18 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::Regex::replace_all(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>, already have 18 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::Regex::replacen(&regex::Regex, &str, usize, R) -> std::borrow::Cow::<'_, str>, already have 18 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::Regex::replace(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>, already have 9 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::Regex::replace_all(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>, already have 9 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn regex::bytes::Regex::replacen(&regex::bytes::Regex, &[u8], usize, R) -> std::borrow::Cow::<'_, [u8]>, already have 9 solutions
[Solver] generic params: ["R"]
[Solver] Start solve()
[Solver] search for input argument R:
set A: `(*)`
set B: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
Merge: `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Solution Set = `(&mut RegexSet), (*const CaptureMatches::<'_, '_>), (CaptureLocations), (*const Result::<Regex, Error>), (SetMatchesIter::<'_>), (usize), (&mut String), (*const Split::<'_, '_>), (*Range::<usize>), (*const SetMatchesIter::<'_>), (*const &[String]), (*const SetMatches), (*const bool), (*Matches::<'_, '_>), (&mut &mut RegexBuilder), (&RegexBuilder), (*const ()), (*ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*Option::<Captures::<'_>>), (*const String), (*SetMatches), (&mut ()), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (CaptureNames::<'_>), (*NoExpand::<'_>), (&[String]), (&ReplacerRef::<'_, &String>), (ReplacerRef::<'_, String>), (*const &mut RegexSetBuilder), (*&[char]), (*const RegexBuilder), (&str), (Result::<Regex, Error>), (*RegexSet), (*const CaptureLocations), (&SetMatchesIter::<'_>), (Option::<(usize ,usize)>), (&mut &[u8]), (&mut CaptureMatches::<'_, '_>), (*&[String]), (&&[u8]), (Matches::<'_, '_>), (&SplitN::<'_, '_>), (&Option::<Match::<'_>>), (*String), (&ReplacerRef::<'_, &str>), (*Cow::<'_, [u8]>), (ReplacerRef::<'_, &String>), (&NoExpand::<'_>), (&mut RegexSetBuilder), (*const CaptureMatches::<'_, '_>), (ReplacerRef::<'_, NoExpand::<'_>>), (ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*SetMatchesIter::<'_>), (*Split::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>), (&mut CaptureMatches::<'_, '_>), (&mut ReplacerRef::<'_, &str>), (ReplacerRef::<'_, &[u8]>), (*&mut RegexBuilder), (*const SubCaptureMatches::<'_, '_>), (*const Matches::<'_, '_>), (*const Cow::<'_, str>), (&mut &mut RegexSetBuilder), (CaptureLocations), (ReplacerRef::<'_, ReplacerRef::<'_, &String>>), (&Option::<(usize ,usize)>), (&Result::<Regex, Error>), (*const CaptureLocations), (&mut SubCaptureMatches::<'_, '_>), (&&mut RegexSetBuilder), (Matches::<'_, '_>), (*Option::<usize>), (*CaptureNames::<'_>), (&Option::<Captures::<'_>>), (&mut Option::<Captures::<'_>>), (SplitN::<'_, '_>), (*usize), (&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&mut usize), (&String), (&mut Option::<usize>), (()), (*SetMatchesIter::<'_>), (&SetMatchesIter::<'_>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, &str>>), (&ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (CaptureMatches::<'_, '_>), (&mut &[String]), (&()), (*Cow::<'_, str>), (&CaptureLocations), (&SubCaptureMatches::<'_, '_>), (RegexSet), (*const ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut NoExpand::<'_>), (*SplitN::<'_, '_>), (Split::<'_, '_>), (&mut Result::<Regex, Error>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*const Range::<usize>), (*const Option::<Cow::<'_, str>>), (&Matches::<'_, '_>), (&&mut RegexBuilder), (SetMatches), (Split::<'_, '_>), (&mut RegexBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>), (*ReplacerRef::<'_, String>), (*const SubCaptureMatches::<'_, '_>), (&Split::<'_, '_>), (NoExpand::<'_>), (*const &[char]), (&mut Cow::<'_, str>), (*bool), (*const Option::<Match::<'_>>), (*Option::<Match::<'_>>), (&SetMatches), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (*&mut RegexSetBuilder), (&ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*Option::<(usize ,usize)>), (&Option::<usize>), (*const SplitN::<'_, '_>), (NoExpand::<'_>), (&mut SetMatchesIter::<'_>), (&mut CaptureNames::<'_>), (Option::<Cow::<'_, str>>), (*const ReplacerRef::<'_, String>), (*const ReplacerRef::<'_, NoExpand::<'_>>), (*CaptureLocations), (&mut Result::<Regex, Error>), (&mut SplitN::<'_, '_>), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>>), (&CaptureLocations), (&mut Matches::<'_, '_>), (*const &mut RegexBuilder), (*const &[u8]), (*&[u8]), (*&mut RegexSetBuilder), (&mut SetMatches), (Range::<usize>), (*ReplacerRef::<'_, &str>), (&&mut RegexSetBuilder), (Cow::<'_, str>), (String), (ReplacerRef::<'_, ReplacerRef::<'_, ReplacerRef::<'_, String>>>), (*const Matches::<'_, '_>), (&[u8]), (*Matches::<'_, '_>), (&Cow::<'_, [u8]>), (&mut Option::<(usize ,usize)>), (&mut ReplacerRef::<'_, String>), (*CaptureMatches::<'_, '_>), (&Option::<Captures::<'_>>), (*const ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (&SplitN::<'_, '_>), (&Range::<usize>), (*const Split::<'_, '_>), (RegexBuilder), (*Result::<Regex, Error>), (*const CaptureNames::<'_>), (*const SplitN::<'_, '_>), (SplitN::<'_, '_>), (ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (Option::<Captures::<'_>>), (&mut ReplacerRef::<'_, &String>), (&ReplacerRef::<'_, String>), (&&mut RegexBuilder), (*CaptureMatches::<'_, '_>), (&CaptureMatches::<'_, '_>), (&NoExpand::<'_>), (*const RegexSet), (Option::<Match::<'_>>), (&mut SetMatchesIter::<'_>), (&mut Matches::<'_, '_>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&ReplacerRef::<'_, NoExpand::<'_>>), (&mut RegexBuilder), (&SetMatches), (Result::<Regex, Error>), (SubCaptureMatches::<'_, '_>), (&[char]), (&usize), (&Option::<Match::<'_>>), (*()), (*const SetMatches), (*Option::<Match::<'_>>), (*const SetMatchesIter::<'_>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (RegexSet), (*RegexBuilder), (&CaptureNames::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (*const ReplacerRef::<'_, ReplacerRef::<'_, String>>), (&mut CaptureLocations), (*const NoExpand::<'_>), (&mut Split::<'_, '_>), (&Cow::<'_, str>), (*const &mut RegexBuilder), (*SplitN::<'_, '_>), (*const NoExpand::<'_>), (*const Option::<Match::<'_>>), (Option::<Captures::<'_>>), (&mut NoExpand::<'_>), (*SetMatches), (*Option::<Cow::<'_, str>>), (&CaptureMatches::<'_, '_>), (&mut Cow::<'_, [u8]>), (*const Cow::<'_, [u8]>), (u8), (*RegexBuilder), (*ReplacerRef::<'_, &String>), (&RegexSet), (CaptureNames::<'_>), (Option::<Cow::<'_, [u8]>>), (*const Result::<Regex, Error>), (RegexBuilder), (&mut Split::<'_, '_>), (&mut &mut RegexBuilder), (*const ReplacerRef::<'_, &str>), (*&mut RegexBuilder), (&mut SetMatches), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (Option::<Match::<'_>>), (&mut SplitN::<'_, '_>), (*&str), (*CaptureLocations), (*SubCaptureMatches::<'_, '_>), (*ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>), (*const Option::<Captures::<'_>>), (*CaptureNames::<'_>), (*Result::<Regex, Error>), (bool), (&Result::<Regex, Error>), (*const RegexBuilder), (&&str), (&mut &[char]), (*Split::<'_, '_>), (*const ReplacerRef::<'_, &String>), (*const Option::<usize>), (&mut RegexSetBuilder), (&mut Option::<Match::<'_>>), (&mut Option::<Match::<'_>>), (&Option::<Cow::<'_, str>>), (&RegexSet), (&Matches::<'_, '_>), (*Option::<Captures::<'_>>), (&mut RegexSet), (*RegexSet), (SubCaptureMatches::<'_, '_>), (&&[String]), (*const &mut RegexSetBuilder), (&SubCaptureMatches::<'_, '_>), (ReplacerRef::<'_, &str>), (&mut Option::<Captures::<'_>>), (&mut SubCaptureMatches::<'_, '_>), (Cow::<'_, [u8]>), (*const CaptureNames::<'_>), (&mut ReplacerRef::<'_, NoExpand::<'_>>), (*const &str), (&mut CaptureLocations), (&CaptureNames::<'_>), (&mut Option::<Cow::<'_, str>>), (*const RegexSet), (&Split::<'_, '_>), (SetMatchesIter::<'_>), (&&[char]), (*const usize), (&mut bool), (*const Option::<(usize ,usize)>), (&mut Range::<usize>), (&RegexBuilder), (&mut &mut RegexSetBuilder), (ReplacerRef::<'_, ReplacerRef::<'_, String>>), (*NoExpand::<'_>), (*ReplacerRef::<'_, NoExpand::<'_>>), (Option::<usize>), (&mut CaptureNames::<'_>), (*SubCaptureMatches::<'_, '_>), (CaptureMatches::<'_, '_>), (&bool), (*ReplacerRef::<'_, std::borrow::Cow::<'_, str>>), (*const Option::<Captures::<'_>>), (&mut &str)`
[Solver] Running solve() took 0 ms.
===== all reachable func =====
fn regex::escape(&str) -> std::string::String
fn <std::string::String as regex::Replacer>::no_expansion(&mut std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>>
fn <std::string::String as regex::Replacer>::by_ref(&mut std::string::String) -> regex::ReplacerRef::<'_, std::string::String>
fn <&std::string::String as regex::Replacer>::no_expansion(&mut &std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>>
fn <&std::string::String as regex::Replacer>::by_ref(&mut &std::string::String) -> regex::ReplacerRef::<'_, &std::string::String>
fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::replace_append(&mut std::borrow::Cow::<'_, [u8]>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, [u8]>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::by_ref(&mut std::borrow::Cow::<'_, [u8]>) -> regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>
fn <&std::borrow::Cow::<'_, str> as regex::Replacer>::replace_append(&mut &std::borrow::Cow::<'_, str>, &regex::Captures::<'_>, &mut std::string::String) -> ()
fn <std::borrow::Cow::<'_, str> as regex::Replacer>::replace_append(&mut std::borrow::Cow::<'_, str>, &regex::Captures::<'_>, &mut std::string::String) -> ()
fn <std::borrow::Cow::<'_, str> as regex::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, str>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
fn <std::borrow::Cow::<'_, str> as regex::Replacer>::by_ref(&mut std::borrow::Cow::<'_, str>) -> regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
fn regex::CaptureLocations::get(&regex::CaptureLocations, usize) -> std::option::Option::<(usize ,usize)>
fn regex::CaptureLocations::len(&regex::CaptureLocations) -> usize
fn regex::RegexSetBuilder::case_insensitive(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::multi_line(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::dot_matches_new_line(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::swap_greed(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::ignore_whitespace(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::unicode(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::octal(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::size_limit(&mut regex::RegexSetBuilder, usize) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::dfa_size_limit(&mut regex::RegexSetBuilder, usize) -> &mut regex::RegexSetBuilder
fn regex::RegexSetBuilder::nest_limit(&mut regex::RegexSetBuilder, u32) -> &mut regex::RegexSetBuilder
fn regex::bytes::Match::<'_>::start(&regex::bytes::Match::<'_>) -> usize
fn regex::bytes::Match::<'_>::end(&regex::bytes::Match::<'_>) -> usize
fn regex::bytes::Match::<'_>::is_empty(&regex::bytes::Match::<'_>) -> bool
fn regex::bytes::Match::<'_>::len(&regex::bytes::Match::<'_>) -> usize
fn regex::bytes::Match::<'_>::range(&regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize>
fn regex::bytes::Match::<'_>::as_bytes(&regex::bytes::Match::<'_>) -> &[u8]
fn <std::ops::range::Range::<usize> as std::convert::From::<regex::bytes::Match::<'_>>>::from(regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize>
fn <regex::bytes::Match::<'_> as std::cmp::PartialEq>::eq(&regex::bytes::Match::<'_>, &regex::bytes::Match::<'_>) -> bool
fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::NoExpand::<'_>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::NoExpand::<'_>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::NoExpand::<'_>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
fn regex::bytes::RegexSet::empty() -> regex::bytes::RegexSet
fn regex::bytes::RegexSet::is_match(&regex::bytes::RegexSet, &[u8]) -> bool
fn regex::bytes::RegexSet::matches(&regex::bytes::RegexSet, &[u8]) -> regex::bytes::SetMatches
fn regex::bytes::RegexSet::len(&regex::bytes::RegexSet) -> usize
fn regex::bytes::RegexSet::is_empty(&regex::bytes::RegexSet) -> bool
fn regex::bytes::RegexSet::patterns(&regex::bytes::RegexSet) -> &[std::string::String]
fn <regex::bytes::RegexSet as std::default::Default>::default() -> regex::bytes::RegexSet
fn regex::SetMatches::matched_any(&regex::SetMatches) -> bool
fn regex::SetMatches::matched(&regex::SetMatches, usize) -> bool
fn regex::SetMatches::len(&regex::SetMatches) -> usize
fn regex::SetMatches::iter(&regex::SetMatches) -> regex::SetMatchesIter::<'_>
fn regex::bytes::RegexBuilder::new(&str) -> regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::build(&regex::bytes::RegexBuilder) -> std::result::Result::<regex::bytes::Regex, regex::Error>
fn regex::bytes::RegexBuilder::case_insensitive(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::multi_line(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::dot_matches_new_line(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::swap_greed(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::ignore_whitespace(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::unicode(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::octal(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::size_limit(&mut regex::bytes::RegexBuilder, usize) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::dfa_size_limit(&mut regex::bytes::RegexBuilder, usize) -> &mut regex::bytes::RegexBuilder
fn regex::bytes::RegexBuilder::nest_limit(&mut regex::bytes::RegexBuilder, u32) -> &mut regex::bytes::RegexBuilder
fn <regex::NoExpand::<'_> as regex::Replacer>::replace_append(&mut regex::NoExpand::<'_>, &regex::Captures::<'_>, &mut std::string::String) -> ()
fn <regex::NoExpand::<'_> as regex::Replacer>::no_expansion(&mut regex::NoExpand::<'_>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
fn <regex::NoExpand::<'_> as regex::Replacer>::by_ref(&mut regex::NoExpand::<'_>) -> regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
fn regex::Match::<'_>::start(&regex::Match::<'_>) -> usize
fn regex::Match::<'_>::end(&regex::Match::<'_>) -> usize
fn regex::Match::<'_>::is_empty(&regex::Match::<'_>) -> bool
fn regex::Match::<'_>::len(&regex::Match::<'_>) -> usize
fn regex::Match::<'_>::range(&regex::Match::<'_>) -> std::ops::range::Range::<usize>
fn regex::Match::<'_>::as_str(&regex::Match::<'_>) -> &str
fn <regex::Match::<'_> as std::cmp::PartialEq>::eq(&regex::Match::<'_>, &regex::Match::<'_>) -> bool
fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str
fn <std::ops::range::Range::<usize> as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> std::ops::range::Range::<usize>
fn regex::bytes::RegexSetBuilder::case_insensitive(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::multi_line(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::dot_matches_new_line(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::swap_greed(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::ignore_whitespace(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::unicode(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::octal(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::size_limit(&mut regex::bytes::RegexSetBuilder, usize) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::dfa_size_limit(&mut regex::bytes::RegexSetBuilder, usize) -> &mut regex::bytes::RegexSetBuilder
fn regex::bytes::RegexSetBuilder::nest_limit(&mut regex::bytes::RegexSetBuilder, u32) -> &mut regex::bytes::RegexSetBuilder
fn regex::RegexSet::empty() -> regex::RegexSet
fn regex::RegexSet::is_match(&regex::RegexSet, &str) -> bool
fn regex::RegexSet::matches(&regex::RegexSet, &str) -> regex::SetMatches
fn regex::RegexSet::len(&regex::RegexSet) -> usize
fn regex::RegexSet::is_empty(&regex::RegexSet) -> bool
fn regex::RegexSet::patterns(&regex::RegexSet) -> &[std::string::String]
fn <regex::RegexSet as std::default::Default>::default() -> regex::RegexSet
fn regex::bytes::SetMatches::matched_any(&regex::bytes::SetMatches) -> bool
fn regex::bytes::SetMatches::matched(&regex::bytes::SetMatches, usize) -> bool
fn regex::bytes::SetMatches::len(&regex::bytes::SetMatches) -> usize
fn regex::bytes::SetMatches::iter(&regex::bytes::SetMatches) -> regex::bytes::SetMatchesIter::<'_>
fn regex::Regex::new(&str) -> std::result::Result::<regex::Regex, regex::Error>
fn regex::Regex::is_match(&regex::Regex, &str) -> bool
fn regex::Regex::find(&regex::Regex, &str) -> std::option::Option::<regex::Match::<'_>>
fn regex::Regex::find_iter(&regex::Regex, &str) -> regex::Matches::<'_, '_>
fn regex::Regex::captures(&regex::Regex, &str) -> std::option::Option::<regex::Captures::<'_>>
fn regex::Regex::captures_iter(&regex::Regex, &str) -> regex::CaptureMatches::<'_, '_>
fn regex::Regex::split(&regex::Regex, &str) -> regex::Split::<'_, '_>
fn regex::Regex::splitn(&regex::Regex, &str, usize) -> regex::SplitN::<'_, '_>
fn regex::Regex::shortest_match(&regex::Regex, &str) -> std::option::Option::<usize>
fn regex::Regex::shortest_match_at(&regex::Regex, &str, usize) -> std::option::Option::<usize>
fn regex::Regex::is_match_at(&regex::Regex, &str, usize) -> bool
fn regex::Regex::find_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Match::<'_>>
fn regex::Regex::captures_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Captures::<'_>>
fn regex::Regex::captures_read(&regex::Regex, &mut regex::CaptureLocations, &str) -> std::option::Option::<regex::Match::<'_>>
fn regex::Regex::captures_read_at(&regex::Regex, &mut regex::CaptureLocations, &str, usize) -> std::option::Option::<regex::Match::<'_>>
fn regex::Regex::as_str(&regex::Regex) -> &str
fn regex::Regex::capture_names(&regex::Regex) -> regex::CaptureNames::<'_>
fn regex::Regex::captures_len(&regex::Regex) -> usize
fn regex::Regex::static_captures_len(&regex::Regex) -> std::option::Option::<usize>
fn regex::Regex::capture_locations(&regex::Regex) -> regex::CaptureLocations
fn <regex::Regex as std::str::FromStr>::from_str(&str) -> std::result::Result::<regex::Regex, regex::Error>
fn regex::bytes::Captures::<'_>::get(&regex::bytes::Captures::<'_>, usize) -> std::option::Option::<regex::bytes::Match::<'_>>
fn regex::bytes::Captures::<'_>::name(&regex::bytes::Captures::<'_>, &str) -> std::option::Option::<regex::bytes::Match::<'_>>
fn regex::bytes::Captures::<'_>::iter(&regex::bytes::Captures::<'_>) -> regex::bytes::SubCaptureMatches::<'_, '_>
fn regex::bytes::Captures::<'_>::expand(&regex::bytes::Captures::<'_>, &[u8], &mut std::vec::Vec::<u8>) -> ()
fn regex::bytes::Captures::<'_>::len(&regex::bytes::Captures::<'_>) -> usize
fn <regex::bytes::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::bytes::Captures::<'_>, &str) -> &[u8]
fn <regex::bytes::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::bytes::Captures::<'_>, usize) -> &[u8]
fn regex::RegexBuilder::new(&str) -> regex::RegexBuilder
fn regex::RegexBuilder::build(&regex::RegexBuilder) -> std::result::Result::<regex::Regex, regex::Error>
fn regex::RegexBuilder::case_insensitive(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::multi_line(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::dot_matches_new_line(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::swap_greed(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::ignore_whitespace(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::unicode(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::octal(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::size_limit(&mut regex::RegexBuilder, usize) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::dfa_size_limit(&mut regex::RegexBuilder, usize) -> &mut regex::RegexBuilder
fn regex::RegexBuilder::nest_limit(&mut regex::RegexBuilder, u32) -> &mut regex::RegexBuilder
fn regex::bytes::CaptureLocations::get(&regex::bytes::CaptureLocations, usize) -> std::option::Option::<(usize ,usize)>
fn regex::bytes::CaptureLocations::len(&regex::bytes::CaptureLocations) -> usize
fn regex::Captures::<'_>::get(&regex::Captures::<'_>, usize) -> std::option::Option::<regex::Match::<'_>>
fn regex::Captures::<'_>::name(&regex::Captures::<'_>, &str) -> std::option::Option::<regex::Match::<'_>>
fn regex::Captures::<'_>::iter(&regex::Captures::<'_>) -> regex::SubCaptureMatches::<'_, '_>
fn regex::Captures::<'_>::expand(&regex::Captures::<'_>, &str, &mut std::string::String) -> ()
fn regex::Captures::<'_>::len(&regex::Captures::<'_>) -> usize
fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str
fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str
fn regex::bytes::Regex::new(&str) -> std::result::Result::<regex::bytes::Regex, regex::Error>
fn regex::bytes::Regex::is_match(&regex::bytes::Regex, &[u8]) -> bool
fn regex::bytes::Regex::find(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>>
fn regex::bytes::Regex::find_iter(&regex::bytes::Regex, &[u8]) -> regex::bytes::Matches::<'_, '_>
fn regex::bytes::Regex::captures(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Captures::<'_>>
fn regex::bytes::Regex::captures_iter(&regex::bytes::Regex, &[u8]) -> regex::bytes::CaptureMatches::<'_, '_>
fn regex::bytes::Regex::split(&regex::bytes::Regex, &[u8]) -> regex::bytes::Split::<'_, '_>
fn regex::bytes::Regex::splitn(&regex::bytes::Regex, &[u8], usize) -> regex::bytes::SplitN::<'_, '_>
fn regex::bytes::Regex::shortest_match(&regex::bytes::Regex, &[u8]) -> std::option::Option::<usize>
fn regex::bytes::Regex::shortest_match_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<usize>
fn regex::bytes::Regex::is_match_at(&regex::bytes::Regex, &[u8], usize) -> bool
fn regex::bytes::Regex::find_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>>
fn regex::bytes::Regex::captures_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Captures::<'_>>
fn regex::bytes::Regex::captures_read(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>>
fn regex::bytes::Regex::captures_read_at(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>>
fn regex::bytes::Regex::as_str(&regex::bytes::Regex) -> &str
fn regex::bytes::Regex::capture_names(&regex::bytes::Regex) -> regex::bytes::CaptureNames::<'_>
fn regex::bytes::Regex::captures_len(&regex::bytes::Regex) -> usize
fn regex::bytes::Regex::static_captures_len(&regex::bytes::Regex) -> std::option::Option::<usize>
fn regex::bytes::Regex::capture_locations(&regex::bytes::Regex) -> regex::bytes::CaptureLocations
fn <regex::bytes::Regex as std::str::FromStr>::from_str(&str) -> std::result::Result::<regex::bytes::Regex, regex::Error>
fn <std::ops::range::Range::<usize> as std::convert::From::<regex::bytes::Match::<'_>>>::from(regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize>
fn <std::ops::range::Range::<usize> as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> std::ops::range::Range::<usize>
fn <&[u8] as regex::bytes::Replacer>::replace_append(&mut &[u8], &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
fn <&[u8] as regex::bytes::Replacer>::no_expansion(&mut &[u8]) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
fn <&[u8] as regex::bytes::Replacer>::by_ref(&mut &[u8]) -> regex::bytes::ReplacerRef::<'_, &[u8]>
fn <regex::bytes::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::bytes::Captures::<'_>, usize) -> &[u8]
fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str
fn <regex::bytes::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::bytes::Captures::<'_>, &str) -> &[u8]
fn <&str as regex::Replacer>::replace_append(&mut &str, &regex::Captures::<'_>, &mut std::string::String) -> ()
fn <&str as regex::Replacer>::no_expansion(&mut &str) -> std::option::Option::<std::borrow::Cow::<'_, str>>
fn <&str as regex::Replacer>::by_ref(&mut &str) -> regex::ReplacerRef::<'_, &str>
fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str
fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str
===== !all reachable func =====
[Solver] init diverse solution for fn regex::RegexSetBuilder::new(I) -> regex::RegexSetBuilder
[Solver] init diverse solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::replace_append(&mut regex::ReplacerRef::<'_, R>, &regex::Captures::<'_>, &mut std::string::String) -> ()
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &str>, &regex::Captures::<'_>, &mut std::string::String) -> (), {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}, all={}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> (), {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>, &regex::Captures::<'_>, &mut std::string::String) -> (), {Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> (), {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>, &regex::Captures::<'_>, &mut std::string::String) -> (), {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>, &regex::Captures::<'_>, &mut std::string::String) -> (), {Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] init diverse solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::no_expansion(&mut regex::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &str>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}, all={}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, {Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>, {Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] init diverse solution for fn <regex::ReplacerRef::<'_, R> as regex::Replacer>::by_ref(&mut regex::ReplacerRef::<'_, R>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, R>>
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &str>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>, {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}, all={}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>, {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>, {Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>, {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>, {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>, {Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown, Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] init diverse solution for fn regex::bytes::RegexSet::new(I) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>
[Solver] init diverse solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::ReplacerRef::<'_, R>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
[Solver] init diverse solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::ReplacerRef::<'_, R>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
[Solver] reserve mono: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>, {Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}, all={}
[Solver] reserve mono: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>, {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}, all={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] init diverse solution for fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::ReplacerRef::<'_, R>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, R>>
[Solver] reserve mono: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>, {Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}, all={}
[Solver] reserve mono: fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>, {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}, all={Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] init diverse solution for fn regex::bytes::RegexSetBuilder::new(I) -> regex::bytes::RegexSetBuilder
[Solver] init diverse solution for fn regex::RegexSet::new(I) -> std::result::Result::<regex::RegexSet, regex::Error>
[Solver] init diverse solution for fn regex::Regex::replace(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}, all={}
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}, all={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn regex::Regex::replace#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38})), Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] init diverse solution for fn regex::Regex::replace_all(&regex::Regex, &str, R) -> std::borrow::Cow::<'_, str>
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}, all={}
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}, all={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38})), Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] reserve mono: fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38})), Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] init diverse solution for fn regex::Regex::replacen(&regex::Regex, &str, usize, R) -> std::borrow::Cow::<'_, str>
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}, all={}
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &str) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}, all={Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::string::String) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::string::String) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38})), Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] reserve mono: fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>, {Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}, all={Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31})), Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38})), Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[Solver] init diverse solution for fn regex::bytes::Regex::replace(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>
[Solver] reserve mono: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}, all={}
[Solver] reserve mono: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] reserve mono: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] reserve mono: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30})), Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] reserve mono: fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}, all={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36})), Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34})), Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] init diverse solution for fn regex::bytes::Regex::replace_all(&regex::bytes::Regex, &[u8], R) -> std::borrow::Cow::<'_, [u8]>
[Solver] reserve mono: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}, all={}
[Solver] reserve mono: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] reserve mono: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] reserve mono: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30})), Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] reserve mono: fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}, all={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36})), Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34})), Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[Solver] init diverse solution for fn regex::bytes::Regex::replacen(&regex::bytes::Regex, &[u8], usize, R) -> std::borrow::Cow::<'_, [u8]>
[Solver] reserve mono: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}, all={}
[Solver] reserve mono: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[Solver] reserve mono: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &[u8]) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] reserve mono: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}, all={Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30})), Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[Solver] reserve mono: fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>, {Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}, all={Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36})), Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34})), Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
===== diverse types =====
&String: false
ReplacerRef::<'_, String>: false
usize: false
&Regex: false
ReplacerRef::<'_, NoExpand::<'_>>: false
&mut ReplacerRef::<'_, NoExpand::<'_>>: false
NoExpand::<'_>: false
Cow::<'_, [u8]>: false
NoExpand::<'_>: false
&[u8]: false
&Cow::<'_, [u8]>: false
&mut ReplacerRef::<'_, NoExpand::<'_>>: false
&Captures::<'_>: false
&mut String: false
String: false
&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>: false
&Regex: false
&mut ReplacerRef::<'_, &String>: false
&mut ReplacerRef::<'_, String>: false
&str: false
&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>: false
&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>: false
Cow::<'_, str>: false
&Cow::<'_, str>: false
&mut ReplacerRef::<'_, &str>: false
===== !diverse types =====
[Diverse]fn regex::escape(&str) -> std::string::String is diverse
[Diverse]fn <std::string::String as regex::Replacer>::no_expansion(&mut std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>> is diverse
[Diverse]fn <std::string::String as regex::Replacer>::by_ref(&mut std::string::String) -> regex::ReplacerRef::<'_, std::string::String> is diverse
[Diverse]fn <&std::string::String as regex::Replacer>::by_ref(&mut &std::string::String) -> regex::ReplacerRef::<'_, &std::string::String> is diverse
[Diverse]fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, [u8]>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>> is diverse
[Diverse]fn <std::borrow::Cow::<'_, str> as regex::Replacer>::by_ref(&mut std::borrow::Cow::<'_, str>) -> regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> is diverse
[Diverse]fn regex::CaptureLocations::len(&regex::CaptureLocations) -> usize is diverse
[Diverse]fn regex::bytes::Match::<'_>::as_bytes(&regex::bytes::Match::<'_>) -> &[u8] is diverse
[Diverse]fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::NoExpand::<'_>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> is diverse
[Diverse]fn regex::bytes::RegexBuilder::build(&regex::bytes::RegexBuilder) -> std::result::Result::<regex::bytes::Regex, regex::Error> is diverse
[Diverse]fn <regex::NoExpand::<'_> as regex::Replacer>::by_ref(&mut regex::NoExpand::<'_>) -> regex::ReplacerRef::<'_, regex::NoExpand::<'_>> is diverse
[Diverse]fn regex::Match::<'_>::as_str(&regex::Match::<'_>) -> &str is diverse
[Diverse]fn regex::Regex::new(&str) -> std::result::Result::<regex::Regex, regex::Error> is diverse
[Diverse]fn regex::Regex::captures(&regex::Regex, &str) -> std::option::Option::<regex::Captures::<'_>> is diverse
[Diverse]fn <&str as regex::Replacer>::by_ref(&mut &str) -> regex::ReplacerRef::<'_, &str> is diverse
[Diverse]fn regex::Regex::capture_locations(&regex::Regex) -> regex::CaptureLocations is diverse
[Diverse]fn regex::bytes::Captures::<'_>::get(&regex::bytes::Captures::<'_>, usize) -> std::option::Option::<regex::bytes::Match::<'_>> is diverse
[Diverse]fn regex::bytes::Captures::<'_>::name(&regex::bytes::Captures::<'_>, &str) -> std::option::Option::<regex::bytes::Match::<'_>> is diverse
[Diverse]fn regex::bytes::Regex::find(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>> is diverse
[Diverse]fn regex::bytes::Regex::find_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>> is diverse
[Diverse]fn regex::bytes::Regex::captures_read(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>> is diverse
[Diverse]fn regex::bytes::Regex::captures_read_at(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>> is diverse
[Diverse]fn regex::bytes::RegexBuilder::new(&str) -> regex::bytes::RegexBuilder is diverse
[Diverse]fn regex::Regex::find(&regex::Regex, &str) -> std::option::Option::<regex::Match::<'_>> is diverse
[Diverse]fn regex::Regex::find_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Match::<'_>> is diverse
[Diverse]fn regex::Regex::captures_read(&regex::Regex, &mut regex::CaptureLocations, &str) -> std::option::Option::<regex::Match::<'_>> is diverse
[Diverse]fn regex::Regex::captures_read_at(&regex::Regex, &mut regex::CaptureLocations, &str, usize) -> std::option::Option::<regex::Match::<'_>> is diverse
[Diverse]fn regex::Captures::<'_>::get(&regex::Captures::<'_>, usize) -> std::option::Option::<regex::Match::<'_>> is diverse
[Diverse]fn regex::Captures::<'_>::name(&regex::Captures::<'_>, &str) -> std::option::Option::<regex::Match::<'_>> is diverse
[Diverse]fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str is diverse
[Diverse]fn regex::Regex::as_str(&regex::Regex) -> &str is diverse
[Diverse]fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str is diverse
[Diverse]fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str is diverse
[Diverse]fn regex::bytes::Regex::as_str(&regex::bytes::Regex) -> &str is diverse
[Diverse]fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str is diverse
[Diverse]fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str is diverse
[Diverse]fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str is diverse
[Diverse]fn regex::bytes::Regex::captures(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Captures::<'_>> is diverse
[Diverse]fn regex::bytes::Regex::captures_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Captures::<'_>> is diverse
[Diverse]fn regex::bytes::Regex::capture_locations(&regex::bytes::Regex) -> regex::bytes::CaptureLocations is diverse
propagate start
===== diverse types =====
&String: true
ReplacerRef::<'_, NoExpand::<'_>>: true
NoExpand::<'_>: false
Cow::<'_, [u8]>: true
&mut &String: false
&mut ReplacerRef::<'_, NoExpand::<'_>>: true
&mut NoExpand::<'_>: false
&mut &str: true
&mut CaptureLocations: true
&mut std::borrow::Cow::<'_, str>: false
&mut CaptureLocations: false
&Captures::<'_>: true
String: true
Match::<'_>: false
&Regex: true
&Match::<'_>: true
usize: true
&mut ReplacerRef::<'_, String>: true
&Regex: true
Cow::<'_, str>: true
&mut ReplacerRef::<'_, ReplacerRef::<'_, NoExpand::<'_>>>: false
&Cow::<'_, str>: true
&mut ReplacerRef::<'_, &str>: true
ReplacerRef::<'_, String>: true
&Captures::<'_>: true
NoExpand::<'_>: false
&[u8]: true
&Cow::<'_, [u8]>: true
&mut ReplacerRef::<'_, NoExpand::<'_>>: true
&mut String: true
&CaptureLocations: true
&Match::<'_>: true
&mut ReplacerRef::<'_, ReplacerRef::<'_, String>>: false
&mut ReplacerRef::<'_, &String>: true
&mut std::borrow::Cow::<'_, [u8]>: false
&str: true
&mut ReplacerRef::<'_, std::borrow::Cow::<'_, str>>: true
&mut NoExpand::<'_>: false
&RegexBuilder: true
===== !diverse types =====
unsolve generic function:
[unsolvable]fn regex::RegexSetBuilder::new(I) -> regex::RegexSetBuilder
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

[unsolvable]fn regex::bytes::RegexSet::new(I) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

fn <regex::bytes::ReplacerRef::<'_, R> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::ReplacerRef::<'_, R>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
Where:
R: regex::bytes::Replacer + std::marker::Sized, 
Type Pred:

[unsolvable]fn regex::bytes::RegexSetBuilder::new(I) -> regex::bytes::RegexSetBuilder
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

[unsolvable]fn regex::RegexSet::new(I) -> std::result::Result::<regex::RegexSet, regex::Error>
Where:
I: , 
S: , 
Type Pred:
S: std::convert::AsRef::<str>
I: std::iter::traits::collect::IntoIterator::<Item=S>

all mono function:
[R] monofun#1:fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[ ] monofun#2:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#3:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#4:fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[R] monofun#5:fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[R] monofun#6:fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[R] monofun#7:fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &str>, &regex::Captures::<'_>, &mut std::string::String) -> () : {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[R] monofun#8:fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[ ] monofun#9:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#10:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#11:fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[R] monofun#12:fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[R] monofun#13:fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[R] monofun#14:fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &str>) -> std::option::Option::<std::borrow::Cow::<'_, str>> : {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[R] monofun#15:fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>> : {Unknown, Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[ ] monofun#16:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>> : {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#17:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>> : {Unknown, Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#18:fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> : {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34})), Unknown}
[R] monofun#19:fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>> : {Unknown, Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[R] monofun#20:fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>> : {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33})), Unknown}
[R] monofun#21:fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &str>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>> : {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32})), Unknown}
[R] monofun#22:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[R] monofun#23:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>> : {Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[R] monofun#24:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29})), Unknown}
[R] monofun#25:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> : {Unknown, Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[R] monofun#26:fn regex::Regex::replace#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[ ] monofun#27:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#28:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#29:fn regex::Regex::replace#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[ ] monofun#30:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#31:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#32:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#33:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#34:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#35:fn regex::Regex::replace#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[R] monofun#36:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[ ] monofun#37:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#38:fn regex::Regex::replace#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[ ] monofun#39:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#40:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#41:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &std::string::String>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#42:fn regex::Regex::replace#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[R] monofun#43:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#44:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#45:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#46:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#47:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#48:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#49:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#50:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#51:fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[R] monofun#52:fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[R] monofun#53:fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[R] monofun#54:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[ ] monofun#55:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#56:fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[ ] monofun#57:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#58:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#59:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, &std::string::String>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#60:fn regex::Regex::replace_all#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[R] monofun#61:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#62:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#63:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#64:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#65:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#66:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#67:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, &str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#68:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#69:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1337 ~ regex[3103]::re_unicode::{impl#36}))}
[R] monofun#70:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::string::String) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1330 ~ regex[3103]::re_unicode::{impl#34}))}
[R] monofun#71:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1333 ~ regex[3103]::re_unicode::{impl#35}))}
[R] monofun#72:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1347 ~ regex[3103]::re_unicode::{impl#38}))}
[ ] monofun#73:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#74:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::string::String) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1326 ~ regex[3103]::re_unicode::{impl#33}))}
[ ] monofun#75:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#76:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[ ] monofun#77:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, &std::string::String>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#78:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &str) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1322 ~ regex[3103]::re_unicode::{impl#32}))}
[R] monofun#79:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str> : {Id(DefId(0:1317 ~ regex[3103]::re_unicode::{impl#31}))}
[R] monofun#80:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[R] monofun#81:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[ ] monofun#82:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[ ] monofun#83:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[ ] monofun#84:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#85:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[R] monofun#86:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[ ] monofun#87:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, &[u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#88:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[ ] monofun#89:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[ ] monofun#90:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#91:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[ ] monofun#92:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#93:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[R] monofun#94:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[R] monofun#95:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[ ] monofun#96:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, &[u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#97:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[ ] monofun#98:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[ ] monofun#99:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#100:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1023 ~ regex[3103]::re_bytes::{impl#33}))}
[ ] monofun#101:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#102:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1027 ~ regex[3103]::re_bytes::{impl#34}))}
[R] monofun#103:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &[u8]) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1012 ~ regex[3103]::re_bytes::{impl#30}))}
[R] monofun#104:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1037 ~ regex[3103]::re_bytes::{impl#36}))}
[ ] monofun#105:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, &[u8]>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
[R] monofun#106:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]> : {Id(DefId(0:1006 ~ regex[3103]::re_bytes::{impl#29}))}
====== statistic ======
GENERIC_API: 16
RPG_COVERED_API: 144
COVERED API: 185
RPG_COVERED_GENERIC: 9
RESERVE: 58
RPG_GENERIC: 14
PRUNE_ITERS: 1
ITERS: 3
UNSAFE: 0
RPG_API: 151
CANDIDATES: 293
MONO_FUNS: 106
API: 207
UNSOLVABLE: 4
TRAIT_IMPLS: 2060
COVERED GENERIC: 11
BLANKET_IMPLS: 0
======  advance  ======
MONO_PER_FUNCS: 9.636364
GENERIC COVERAGE: 0.6875
API COVERAGE: 0.8937198
=======================
using fast bfs end point
0, 2, 3, 5, 6, 25, 26, 38, 39, 40, 41, 42, 43, 44, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 75, 76, 77, 78, 79, 80, 81, 82, 84, 85, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 123, 124, 125, 126, 127, 128, 129, 130, 131, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 172, 173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185, 187, 188, 189, 190, 199, 200, 201, 202, 205, 206, 207, 208, 209, 210, 211, 212, 216, 218, 223, 225, 230, 232, 236, 237, 241, 242, 246, 247, 
There are total 160 sequences after bfs
total functions in crate : 249
total generic functions in crate : 16
0:fn regex::escape(&str) -> std::string::String
1:fn <std::string::String as regex::Replacer>::replace_append(&mut std::string::String, &regex::Captures::<'_>, &mut std::string::String) -> ()
2:fn <std::string::String as regex::Replacer>::no_expansion(&mut std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>>
3:fn <std::string::String as regex::Replacer>::by_ref(&mut std::string::String) -> regex::ReplacerRef::<'_, std::string::String>
4:fn <&std::string::String as regex::Replacer>::replace_append(&mut &std::string::String, &regex::Captures::<'_>, &mut std::string::String) -> ()
5:fn <&std::string::String as regex::Replacer>::no_expansion(&mut &std::string::String) -> std::option::Option::<std::borrow::Cow::<'_, str>>
6:fn <&std::string::String as regex::Replacer>::by_ref(&mut &std::string::String) -> regex::ReplacerRef::<'_, &std::string::String>
7:fn <&std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::replace_append(&mut &std::borrow::Cow::<'_, [u8]>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
8:fn <&std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::no_expansion(&mut &std::borrow::Cow::<'_, [u8]>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
9:fn <&std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::by_ref(&mut &std::borrow::Cow::<'_, [u8]>) -> regex::bytes::ReplacerRef::<'_, &std::borrow::Cow::<'_, [u8]>>
10:fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::replace_append(&mut std::borrow::Cow::<'_, [u8]>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
11:fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, [u8]>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
12:fn <std::borrow::Cow::<'_, [u8]> as regex::bytes::Replacer>::by_ref(&mut std::borrow::Cow::<'_, [u8]>) -> regex::bytes::ReplacerRef::<'_, std::borrow::Cow::<'_, [u8]>>
13:fn <&std::borrow::Cow::<'_, str> as regex::Replacer>::replace_append(&mut &std::borrow::Cow::<'_, str>, &regex::Captures::<'_>, &mut std::string::String) -> ()
14:fn <&std::borrow::Cow::<'_, str> as regex::Replacer>::no_expansion(&mut &std::borrow::Cow::<'_, str>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
15:fn <&std::borrow::Cow::<'_, str> as regex::Replacer>::by_ref(&mut &std::borrow::Cow::<'_, str>) -> regex::ReplacerRef::<'_, &std::borrow::Cow::<'_, str>>
16:fn <std::borrow::Cow::<'_, str> as regex::Replacer>::replace_append(&mut std::borrow::Cow::<'_, str>, &regex::Captures::<'_>, &mut std::string::String) -> ()
17:fn <std::borrow::Cow::<'_, str> as regex::Replacer>::no_expansion(&mut std::borrow::Cow::<'_, str>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
18:fn <std::borrow::Cow::<'_, str> as regex::Replacer>::by_ref(&mut std::borrow::Cow::<'_, str>) -> regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>
19:fn <std::vec::Vec::<u8> as regex::bytes::Replacer>::replace_append(&mut std::vec::Vec::<u8>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
20:fn <std::vec::Vec::<u8> as regex::bytes::Replacer>::no_expansion(&mut std::vec::Vec::<u8>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
21:fn <std::vec::Vec::<u8> as regex::bytes::Replacer>::by_ref(&mut std::vec::Vec::<u8>) -> regex::bytes::ReplacerRef::<'_, std::vec::Vec::<u8>>
22:fn <&std::vec::Vec::<u8> as regex::bytes::Replacer>::replace_append(&mut &std::vec::Vec::<u8>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
23:fn <&std::vec::Vec::<u8> as regex::bytes::Replacer>::no_expansion(&mut &std::vec::Vec::<u8>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
24:fn <&std::vec::Vec::<u8> as regex::bytes::Replacer>::by_ref(&mut &std::vec::Vec::<u8>) -> regex::bytes::ReplacerRef::<'_, &std::vec::Vec::<u8>>
25:fn regex::CaptureLocations::get(&regex::CaptureLocations, usize) -> std::option::Option::<(usize ,usize)>
26:fn regex::CaptureLocations::len(&regex::CaptureLocations) -> usize
27:fn regex::RegexSetBuilder::build(&regex::RegexSetBuilder) -> std::result::Result::<regex::RegexSet, regex::Error>
28:fn regex::RegexSetBuilder::case_insensitive(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
29:fn regex::RegexSetBuilder::multi_line(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
30:fn regex::RegexSetBuilder::dot_matches_new_line(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
31:fn regex::RegexSetBuilder::swap_greed(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
32:fn regex::RegexSetBuilder::ignore_whitespace(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
33:fn regex::RegexSetBuilder::unicode(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
34:fn regex::RegexSetBuilder::octal(&mut regex::RegexSetBuilder, bool) -> &mut regex::RegexSetBuilder
35:fn regex::RegexSetBuilder::size_limit(&mut regex::RegexSetBuilder, usize) -> &mut regex::RegexSetBuilder
36:fn regex::RegexSetBuilder::dfa_size_limit(&mut regex::RegexSetBuilder, usize) -> &mut regex::RegexSetBuilder
37:fn regex::RegexSetBuilder::nest_limit(&mut regex::RegexSetBuilder, u32) -> &mut regex::RegexSetBuilder
38:fn regex::bytes::Match::<'_>::start(&regex::bytes::Match::<'_>) -> usize
39:fn regex::bytes::Match::<'_>::end(&regex::bytes::Match::<'_>) -> usize
40:fn regex::bytes::Match::<'_>::is_empty(&regex::bytes::Match::<'_>) -> bool
41:fn regex::bytes::Match::<'_>::len(&regex::bytes::Match::<'_>) -> usize
42:fn regex::bytes::Match::<'_>::range(&regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize>
43:fn regex::bytes::Match::<'_>::as_bytes(&regex::bytes::Match::<'_>) -> &[u8]
44:fn <std::ops::range::Range::<usize> as std::convert::From::<regex::bytes::Match::<'_>>>::from(regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize>
45:fn <regex::bytes::Match::<'_> as std::cmp::PartialEq>::eq(&regex::bytes::Match::<'_>, &regex::bytes::Match::<'_>) -> bool
46:fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::replace_append(&mut regex::bytes::NoExpand::<'_>, &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
47:fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::no_expansion(&mut regex::bytes::NoExpand::<'_>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
48:fn <regex::bytes::NoExpand::<'_> as regex::bytes::Replacer>::by_ref(&mut regex::bytes::NoExpand::<'_>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>
49:fn regex::bytes::RegexSet::empty() -> regex::bytes::RegexSet
50:fn regex::bytes::RegexSet::is_match(&regex::bytes::RegexSet, &[u8]) -> bool
51:fn regex::bytes::RegexSet::matches(&regex::bytes::RegexSet, &[u8]) -> regex::bytes::SetMatches
52:fn regex::bytes::RegexSet::len(&regex::bytes::RegexSet) -> usize
53:fn regex::bytes::RegexSet::is_empty(&regex::bytes::RegexSet) -> bool
54:fn regex::bytes::RegexSet::patterns(&regex::bytes::RegexSet) -> &[std::string::String]
55:fn <regex::bytes::RegexSet as std::default::Default>::default() -> regex::bytes::RegexSet
56:fn regex::SetMatches::matched_any(&regex::SetMatches) -> bool
57:fn regex::SetMatches::matched(&regex::SetMatches, usize) -> bool
58:fn regex::SetMatches::len(&regex::SetMatches) -> usize
59:fn regex::SetMatches::iter(&regex::SetMatches) -> regex::SetMatchesIter::<'_>
60:fn regex::bytes::RegexBuilder::new(&str) -> regex::bytes::RegexBuilder
61:fn regex::bytes::RegexBuilder::build(&regex::bytes::RegexBuilder) -> std::result::Result::<regex::bytes::Regex, regex::Error>
62:fn regex::bytes::RegexBuilder::case_insensitive(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
63:fn regex::bytes::RegexBuilder::multi_line(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
64:fn regex::bytes::RegexBuilder::dot_matches_new_line(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
65:fn regex::bytes::RegexBuilder::swap_greed(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
66:fn regex::bytes::RegexBuilder::ignore_whitespace(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
67:fn regex::bytes::RegexBuilder::unicode(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
68:fn regex::bytes::RegexBuilder::octal(&mut regex::bytes::RegexBuilder, bool) -> &mut regex::bytes::RegexBuilder
69:fn regex::bytes::RegexBuilder::size_limit(&mut regex::bytes::RegexBuilder, usize) -> &mut regex::bytes::RegexBuilder
70:fn regex::bytes::RegexBuilder::dfa_size_limit(&mut regex::bytes::RegexBuilder, usize) -> &mut regex::bytes::RegexBuilder
71:fn regex::bytes::RegexBuilder::nest_limit(&mut regex::bytes::RegexBuilder, u32) -> &mut regex::bytes::RegexBuilder
72:fn <regex::Error as std::error::Error>::description(&regex::Error) -> &str
73:fn <regex::Error as std::cmp::PartialEq>::eq(&regex::Error, &regex::Error) -> bool
74:fn <regex::NoExpand::<'_> as regex::Replacer>::replace_append(&mut regex::NoExpand::<'_>, &regex::Captures::<'_>, &mut std::string::String) -> ()
75:fn <regex::NoExpand::<'_> as regex::Replacer>::no_expansion(&mut regex::NoExpand::<'_>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
76:fn <regex::NoExpand::<'_> as regex::Replacer>::by_ref(&mut regex::NoExpand::<'_>) -> regex::ReplacerRef::<'_, regex::NoExpand::<'_>>
77:fn regex::Match::<'_>::start(&regex::Match::<'_>) -> usize
78:fn regex::Match::<'_>::end(&regex::Match::<'_>) -> usize
79:fn regex::Match::<'_>::is_empty(&regex::Match::<'_>) -> bool
80:fn regex::Match::<'_>::len(&regex::Match::<'_>) -> usize
81:fn regex::Match::<'_>::range(&regex::Match::<'_>) -> std::ops::range::Range::<usize>
82:fn regex::Match::<'_>::as_str(&regex::Match::<'_>) -> &str
83:fn <regex::Match::<'_> as std::cmp::PartialEq>::eq(&regex::Match::<'_>, &regex::Match::<'_>) -> bool
84:fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str
85:fn <std::ops::range::Range::<usize> as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> std::ops::range::Range::<usize>
86:fn regex::bytes::RegexSetBuilder::build(&regex::bytes::RegexSetBuilder) -> std::result::Result::<regex::bytes::RegexSet, regex::Error>
87:fn regex::bytes::RegexSetBuilder::case_insensitive(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
88:fn regex::bytes::RegexSetBuilder::multi_line(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
89:fn regex::bytes::RegexSetBuilder::dot_matches_new_line(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
90:fn regex::bytes::RegexSetBuilder::swap_greed(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
91:fn regex::bytes::RegexSetBuilder::ignore_whitespace(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
92:fn regex::bytes::RegexSetBuilder::unicode(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
93:fn regex::bytes::RegexSetBuilder::octal(&mut regex::bytes::RegexSetBuilder, bool) -> &mut regex::bytes::RegexSetBuilder
94:fn regex::bytes::RegexSetBuilder::size_limit(&mut regex::bytes::RegexSetBuilder, usize) -> &mut regex::bytes::RegexSetBuilder
95:fn regex::bytes::RegexSetBuilder::dfa_size_limit(&mut regex::bytes::RegexSetBuilder, usize) -> &mut regex::bytes::RegexSetBuilder
96:fn regex::bytes::RegexSetBuilder::nest_limit(&mut regex::bytes::RegexSetBuilder, u32) -> &mut regex::bytes::RegexSetBuilder
97:fn regex::RegexSet::empty() -> regex::RegexSet
98:fn regex::RegexSet::is_match(&regex::RegexSet, &str) -> bool
99:fn regex::RegexSet::matches(&regex::RegexSet, &str) -> regex::SetMatches
100:fn regex::RegexSet::len(&regex::RegexSet) -> usize
101:fn regex::RegexSet::is_empty(&regex::RegexSet) -> bool
102:fn regex::RegexSet::patterns(&regex::RegexSet) -> &[std::string::String]
103:fn <regex::RegexSet as std::default::Default>::default() -> regex::RegexSet
104:fn regex::bytes::SetMatches::matched_any(&regex::bytes::SetMatches) -> bool
105:fn regex::bytes::SetMatches::matched(&regex::bytes::SetMatches, usize) -> bool
106:fn regex::bytes::SetMatches::len(&regex::bytes::SetMatches) -> usize
107:fn regex::bytes::SetMatches::iter(&regex::bytes::SetMatches) -> regex::bytes::SetMatchesIter::<'_>
108:fn regex::Regex::new(&str) -> std::result::Result::<regex::Regex, regex::Error>
109:fn regex::Regex::is_match(&regex::Regex, &str) -> bool
110:fn regex::Regex::find(&regex::Regex, &str) -> std::option::Option::<regex::Match::<'_>>
111:fn regex::Regex::find_iter(&regex::Regex, &str) -> regex::Matches::<'_, '_>
112:fn regex::Regex::captures(&regex::Regex, &str) -> std::option::Option::<regex::Captures::<'_>>
113:fn regex::Regex::captures_iter(&regex::Regex, &str) -> regex::CaptureMatches::<'_, '_>
114:fn regex::Regex::split(&regex::Regex, &str) -> regex::Split::<'_, '_>
115:fn regex::Regex::splitn(&regex::Regex, &str, usize) -> regex::SplitN::<'_, '_>
116:fn regex::Regex::shortest_match(&regex::Regex, &str) -> std::option::Option::<usize>
117:fn regex::Regex::shortest_match_at(&regex::Regex, &str, usize) -> std::option::Option::<usize>
118:fn regex::Regex::is_match_at(&regex::Regex, &str, usize) -> bool
119:fn regex::Regex::find_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Match::<'_>>
120:fn regex::Regex::captures_at(&regex::Regex, &str, usize) -> std::option::Option::<regex::Captures::<'_>>
121:fn regex::Regex::captures_read(&regex::Regex, &mut regex::CaptureLocations, &str) -> std::option::Option::<regex::Match::<'_>>
122:fn regex::Regex::captures_read_at(&regex::Regex, &mut regex::CaptureLocations, &str, usize) -> std::option::Option::<regex::Match::<'_>>
123:fn regex::Regex::as_str(&regex::Regex) -> &str
124:fn regex::Regex::capture_names(&regex::Regex) -> regex::CaptureNames::<'_>
125:fn regex::Regex::captures_len(&regex::Regex) -> usize
126:fn regex::Regex::static_captures_len(&regex::Regex) -> std::option::Option::<usize>
127:fn regex::Regex::capture_locations(&regex::Regex) -> regex::CaptureLocations
128:fn <regex::Regex as std::str::FromStr>::from_str(&str) -> std::result::Result::<regex::Regex, regex::Error>
129:fn regex::bytes::Captures::<'_>::get(&regex::bytes::Captures::<'_>, usize) -> std::option::Option::<regex::bytes::Match::<'_>>
130:fn regex::bytes::Captures::<'_>::name(&regex::bytes::Captures::<'_>, &str) -> std::option::Option::<regex::bytes::Match::<'_>>
131:fn regex::bytes::Captures::<'_>::iter(&regex::bytes::Captures::<'_>) -> regex::bytes::SubCaptureMatches::<'_, '_>
132:fn regex::bytes::Captures::<'_>::expand(&regex::bytes::Captures::<'_>, &[u8], &mut std::vec::Vec::<u8>) -> ()
133:fn regex::bytes::Captures::<'_>::len(&regex::bytes::Captures::<'_>) -> usize
134:fn <regex::bytes::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::bytes::Captures::<'_>, &str) -> &[u8]
135:fn <regex::bytes::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::bytes::Captures::<'_>, usize) -> &[u8]
136:fn regex::RegexBuilder::new(&str) -> regex::RegexBuilder
137:fn regex::RegexBuilder::build(&regex::RegexBuilder) -> std::result::Result::<regex::Regex, regex::Error>
138:fn regex::RegexBuilder::case_insensitive(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
139:fn regex::RegexBuilder::multi_line(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
140:fn regex::RegexBuilder::dot_matches_new_line(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
141:fn regex::RegexBuilder::swap_greed(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
142:fn regex::RegexBuilder::ignore_whitespace(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
143:fn regex::RegexBuilder::unicode(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
144:fn regex::RegexBuilder::octal(&mut regex::RegexBuilder, bool) -> &mut regex::RegexBuilder
145:fn regex::RegexBuilder::size_limit(&mut regex::RegexBuilder, usize) -> &mut regex::RegexBuilder
146:fn regex::RegexBuilder::dfa_size_limit(&mut regex::RegexBuilder, usize) -> &mut regex::RegexBuilder
147:fn regex::RegexBuilder::nest_limit(&mut regex::RegexBuilder, u32) -> &mut regex::RegexBuilder
148:fn regex::bytes::CaptureLocations::get(&regex::bytes::CaptureLocations, usize) -> std::option::Option::<(usize ,usize)>
149:fn regex::bytes::CaptureLocations::len(&regex::bytes::CaptureLocations) -> usize
150:fn regex::Captures::<'_>::get(&regex::Captures::<'_>, usize) -> std::option::Option::<regex::Match::<'_>>
151:fn regex::Captures::<'_>::name(&regex::Captures::<'_>, &str) -> std::option::Option::<regex::Match::<'_>>
152:fn regex::Captures::<'_>::iter(&regex::Captures::<'_>) -> regex::SubCaptureMatches::<'_, '_>
153:fn regex::Captures::<'_>::expand(&regex::Captures::<'_>, &str, &mut std::string::String) -> ()
154:fn regex::Captures::<'_>::len(&regex::Captures::<'_>) -> usize
155:fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str
156:fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str
157:fn regex::bytes::Regex::new(&str) -> std::result::Result::<regex::bytes::Regex, regex::Error>
158:fn regex::bytes::Regex::is_match(&regex::bytes::Regex, &[u8]) -> bool
159:fn regex::bytes::Regex::find(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>>
160:fn regex::bytes::Regex::find_iter(&regex::bytes::Regex, &[u8]) -> regex::bytes::Matches::<'_, '_>
161:fn regex::bytes::Regex::captures(&regex::bytes::Regex, &[u8]) -> std::option::Option::<regex::bytes::Captures::<'_>>
162:fn regex::bytes::Regex::captures_iter(&regex::bytes::Regex, &[u8]) -> regex::bytes::CaptureMatches::<'_, '_>
163:fn regex::bytes::Regex::split(&regex::bytes::Regex, &[u8]) -> regex::bytes::Split::<'_, '_>
164:fn regex::bytes::Regex::splitn(&regex::bytes::Regex, &[u8], usize) -> regex::bytes::SplitN::<'_, '_>
165:fn regex::bytes::Regex::shortest_match(&regex::bytes::Regex, &[u8]) -> std::option::Option::<usize>
166:fn regex::bytes::Regex::shortest_match_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<usize>
167:fn regex::bytes::Regex::is_match_at(&regex::bytes::Regex, &[u8], usize) -> bool
168:fn regex::bytes::Regex::find_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>>
169:fn regex::bytes::Regex::captures_at(&regex::bytes::Regex, &[u8], usize) -> std::option::Option::<regex::bytes::Captures::<'_>>
170:fn regex::bytes::Regex::captures_read(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8]) -> std::option::Option::<regex::bytes::Match::<'_>>
171:fn regex::bytes::Regex::captures_read_at(&regex::bytes::Regex, &mut regex::bytes::CaptureLocations, &[u8], usize) -> std::option::Option::<regex::bytes::Match::<'_>>
172:fn regex::bytes::Regex::as_str(&regex::bytes::Regex) -> &str
173:fn regex::bytes::Regex::capture_names(&regex::bytes::Regex) -> regex::bytes::CaptureNames::<'_>
174:fn regex::bytes::Regex::captures_len(&regex::bytes::Regex) -> usize
175:fn regex::bytes::Regex::static_captures_len(&regex::bytes::Regex) -> std::option::Option::<usize>
176:fn regex::bytes::Regex::capture_locations(&regex::bytes::Regex) -> regex::bytes::CaptureLocations
177:fn <regex::bytes::Regex as std::str::FromStr>::from_str(&str) -> std::result::Result::<regex::bytes::Regex, regex::Error>
178:fn <std::ops::range::Range::<usize> as std::convert::From::<regex::bytes::Match::<'_>>>::from(regex::bytes::Match::<'_>) -> std::ops::range::Range::<usize>
179:fn <std::ops::range::Range::<usize> as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> std::ops::range::Range::<usize>
180:fn <&[u8] as regex::bytes::Replacer>::replace_append(&mut &[u8], &regex::bytes::Captures::<'_>, &mut std::vec::Vec::<u8>) -> ()
181:fn <&[u8] as regex::bytes::Replacer>::no_expansion(&mut &[u8]) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
182:fn <&[u8] as regex::bytes::Replacer>::by_ref(&mut &[u8]) -> regex::bytes::ReplacerRef::<'_, &[u8]>
183:fn <regex::bytes::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::bytes::Captures::<'_>, usize) -> &[u8]
184:fn <regex::Captures::<'_> as std::ops::Index::<usize>>::index(&regex::Captures::<'_>, usize) -> &str
185:fn <regex::bytes::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::bytes::Captures::<'_>, &str) -> &[u8]
186:fn <&str as regex::Replacer>::replace_append(&mut &str, &regex::Captures::<'_>, &mut std::string::String) -> ()
187:fn <&str as regex::Replacer>::no_expansion(&mut &str) -> std::option::Option::<std::borrow::Cow::<'_, str>>
188:fn <&str as regex::Replacer>::by_ref(&mut &str) -> regex::ReplacerRef::<'_, &str>
189:fn <&str as std::convert::From::<regex::Match::<'_>>>::from(regex::Match::<'_>) -> &str
190:fn <regex::Captures::<'_> as std::ops::Index::<&str>>::index(&regex::Captures::<'_>, &str) -> &str
191:fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
192:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
193:fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> ()
194:fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>, &regex::Captures::<'_>, &mut std::string::String) -> ()
195:fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &std::string::String>, &regex::Captures::<'_>, &mut std::string::String) -> ()
196:fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::replace_append#mono(&mut regex::ReplacerRef::<'_, &str>, &regex::Captures::<'_>, &mut std::string::String) -> ()
197:fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
198:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
199:fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
200:fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
201:fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
202:fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::no_expansion#mono(&mut regex::ReplacerRef::<'_, &str>) -> std::option::Option::<std::borrow::Cow::<'_, str>>
203:fn <regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::borrow::Cow::<'_, str>>>
204:fn <regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>>
205:fn <regex::ReplacerRef::<'_, std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, std::string::String>>
206:fn <regex::ReplacerRef::<'_, regex::NoExpand::<'_>> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, regex::NoExpand::<'_>>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, regex::NoExpand::<'_>>>
207:fn <regex::ReplacerRef::<'_, &std::string::String> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &std::string::String>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &std::string::String>>
208:fn <regex::ReplacerRef::<'_, &str> as regex::Replacer>::by_ref#mono(&mut regex::ReplacerRef::<'_, &str>) -> regex::ReplacerRef::<'_, regex::ReplacerRef::<'_, &str>>
209:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
210:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::no_expansion#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::option::Option::<std::borrow::Cow::<'_, [u8]>>
211:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>>
212:fn <regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>> as regex::bytes::Replacer>::by_ref#mono(&mut regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> regex::bytes::ReplacerRef::<'_, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>>
213:fn regex::Regex::replace#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
214:fn regex::Regex::replace#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
215:fn regex::Regex::replace#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str>
216:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>
217:fn regex::Regex::replace#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str>
218:fn regex::Regex::replace#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str>
219:fn regex::Regex::replace#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>
220:fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
221:fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::string::String) -> std::borrow::Cow::<'_, str>
222:fn regex::Regex::replace_all#mono(&regex::Regex, &str, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
223:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>
224:fn regex::Regex::replace_all#mono(&regex::Regex, &str, &std::string::String) -> std::borrow::Cow::<'_, str>
225:fn regex::Regex::replace_all#mono(&regex::Regex, &str, &str) -> std::borrow::Cow::<'_, str>
226:fn regex::Regex::replace_all#mono(&regex::Regex, &str, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>
227:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
228:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::string::String) -> std::borrow::Cow::<'_, str>
229:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, std::borrow::Cow::<'_, str>) -> std::borrow::Cow::<'_, str>
230:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::NoExpand::<'_>) -> std::borrow::Cow::<'_, str>
231:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &std::string::String) -> std::borrow::Cow::<'_, str>
232:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, &str) -> std::borrow::Cow::<'_, str>
233:fn regex::Regex::replacen#mono(&regex::Regex, &str, usize, regex::ReplacerRef::<'_, std::string::String>) -> std::borrow::Cow::<'_, str>
234:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
235:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
236:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]>
237:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>
238:fn regex::bytes::Regex::replace#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>
239:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
240:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
241:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], &[u8]) -> std::borrow::Cow::<'_, [u8]>
242:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>
243:fn regex::bytes::Regex::replace_all#mono(&regex::bytes::Regex, &[u8], regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>
244:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
245:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &std::borrow::Cow::<'_, [u8]>) -> std::borrow::Cow::<'_, [u8]>
246:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, &[u8]) -> std::borrow::Cow::<'_, [u8]>
247:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::NoExpand::<'_>) -> std::borrow::Cow::<'_, [u8]>
248:fn regex::bytes::Regex::replacen#mono(&regex::bytes::Regex, &[u8], usize, regex::bytes::ReplacerRef::<'_, regex::bytes::NoExpand::<'_>>) -> std::borrow::Cow::<'_, [u8]>
======
total test sequences : 160
There are total 151 nodes need to be covered.
There are total 1283 edges need to be covered.
There are toatl 160 sequences.
There are toatl 149 valid sequences for fuzz.
-----------STATISTICS-----------
total nodes: 249
total edges: 1283
covered nodes: 151
232, 208, 246, 210, 241, 205, 236, 212, 200, 207, 202, 209, 216, 247, 223, 211, 199, 242, 230, 218, 206, 237, 225, 201, 
covered monos: 24
covered edges: 134
node coverage: 0.606425702811245
edge coverage: 0.1044427123928293
targets covered by reverse search: 0
total targets: 130
max length = 0
total length = 305
average time to fuzz each api = 2.019867549668874
--------------------------------
test_file_path: "/home/rumono/regex/fuzz_target/test_files"
reproduce_file_path: "/home/rumono/regex/fuzz_target/replay_files"
Fuzz Target Generator exits successfully.
Total time cost: 926 ms
