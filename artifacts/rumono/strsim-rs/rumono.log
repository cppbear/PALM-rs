Fuzz Target Generator for Rust Libraries: v0.1.0
Fuzz Target Renderer Init
crate: strsim
[TypeContext] add candidate #0: u8 => Primitive(U8)
[TypeContext] add candidate #1: &[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
Add function: fn strsim::sorensen_dice(&str, &str) -> f64
visibility: Some(Public)
Add function: fn strsim::normalized_damerau_levenshtein(&str, &str) -> f64
visibility: Some(Public)
Add function: fn strsim::damerau_levenshtein(&str, &str) -> usize
visibility: Some(Public)
Add function: fn strsim::generic_damerau_levenshtein(&[Elem], &[Elem]) -> usize
visibility: Some(Public)
Add function: fn strsim::osa_distance(&str, &str) -> usize
visibility: Some(Public)
Add function: fn strsim::normalized_levenshtein(&str, &str) -> f64
visibility: Some(Public)
Add function: fn strsim::levenshtein(&str, &str) -> usize
visibility: Some(Public)
Add function: fn strsim::generic_levenshtein(&'a Iter1, &'b Iter2) -> usize
visibility: Some(Public)
Add function: fn strsim::jaro_winkler(&str, &str) -> f64
visibility: Some(Public)
Add function: fn strsim::generic_jaro_winkler(&'a Iter1, &'b Iter2) -> f64
visibility: Some(Public)
Add function: fn strsim::jaro(&str, &str) -> f64
visibility: Some(Public)
Add function: fn strsim::generic_jaro(&'a Iter1, &'b Iter2) -> f64
visibility: Some(Public)
Add function: fn strsim::hamming(&str, &str) -> strsim::HammingResult
visibility: Some(Public)
Add function: fn strsim::generic_hamming(Iter1, Iter2) -> strsim::HammingResult
visibility: Some(Public)
==== run after krate ====
ignore RegionPredicate: RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
bounds to facts ignore lifetime: Lifetime("'static")

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:236 ~ alloc[2c7c]::boxed::thin::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:212 ~ alloc[2c7c]::boxed::thin::ThinBox)), segments: [PathSegment { name: "ThinBox", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::boxed::thin::ThinBox")
type_def_id: Some(DefId(5:212 ~ alloc[2c7c]::boxed::thin::ThinBox))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:235 ~ alloc[2c7c]::boxed::thin::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::thin::ThinBox"
std::boxed::thin::ThinBox::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:237 ~ alloc[2c7c]::boxed::thin::{impl#6}::Target)), kind: AssocType, docs: "" }
"fn <std::boxed::thin::ThinBox::<T> as std::ops::Deref>::deref(&std::boxed::thin::ThinBox::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7793 ~ alloc[2c7c]::string::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7794 ~ alloc[2c7c]::string::{impl#82}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7792 ~ alloc[2c7c]::string::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::string::String>>::eq(&str, &std::string::String) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::string::String>>::ne(&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7803 ~ alloc[2c7c]::string::{impl#84}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7804 ~ alloc[2c7c]::string::{impl#84}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7802 ~ alloc[2c7c]::string::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
[TypeContext] add candidate #2: &str => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
[TypeContext] add candidate #3: &mut &str => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #4: &&str => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #5: *&str => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[TypeContext] add candidate #6: *const &str => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
assoc types:
"fn <&str as std::cmp::PartialEq::<std::string::String>>::eq(&&str, &std::string::String) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::string::String>>::ne(&&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::string::String")
type_def_id: Some(DefId(5:7759 ~ alloc[2c7c]::string::String))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5941 ~ alloc[2c7c]::string::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::string::String"
std::string::String is not fuzzable
assoc types:
Target: str
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5942 ~ alloc[2c7c]::string::{impl#28}::Target)), kind: AssocType, docs: "" }
"fn <std::string::String as std::ops::Deref>::deref(&std::string::String) -> &str" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8161 ~ std[d8a0]::ffi::os_str::{impl#77}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8162 ~ std[d8a0]::ffi::os_str::{impl#77}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9074 ~ std[d8a0]::path::{impl#178}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9075 ~ std[d8a0]::path::{impl#178}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9073 ~ std[d8a0]::path::{impl#178})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8958 ~ std[d8a0]::path::{impl#135}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8959 ~ std[d8a0]::path::{impl#135}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8957 ~ std[d8a0]::path::{impl#135})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9118 ~ std[d8a0]::path::{impl#191}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9119 ~ std[d8a0]::path::{impl#191}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9117 ~ std[d8a0]::path::{impl#191})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9042 ~ std[d8a0]::path::{impl#166}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9041 ~ std[d8a0]::path::{impl#166})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8945 ~ std[d8a0]::path::{impl#131}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8944 ~ std[d8a0]::path::{impl#131})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8177 ~ std[d8a0]::ffi::os_str::{impl#81}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8178 ~ std[d8a0]::ffi::os_str::{impl#81}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9105 ~ std[d8a0]::path::{impl#187}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9104 ~ std[d8a0]::path::{impl#187})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9111 ~ std[d8a0]::path::{impl#189}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9110 ~ std[d8a0]::path::{impl#189})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8185 ~ std[d8a0]::ffi::os_str::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8186 ~ std[d8a0]::ffi::os_str::{impl#83}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8951 ~ std[d8a0]::path::{impl#133}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8950 ~ std[d8a0]::path::{impl#133})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8169 ~ std[d8a0]::ffi::os_str::{impl#79}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8170 ~ std[d8a0]::ffi::os_str::{impl#79}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9082 ~ std[d8a0]::path::{impl#180}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9083 ~ std[d8a0]::path::{impl#180}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9081 ~ std[d8a0]::path::{impl#180})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9048 ~ std[d8a0]::path::{impl#168}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9047 ~ std[d8a0]::path::{impl#168})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8966 ~ std[d8a0]::path::{impl#137}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8967 ~ std[d8a0]::path::{impl#137}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8965 ~ std[d8a0]::path::{impl#137})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9126 ~ std[d8a0]::path::{impl#193}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9127 ~ std[d8a0]::path::{impl#193}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9125 ~ std[d8a0]::path::{impl#193})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7813 ~ alloc[2c7c]::string::{impl#86}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7814 ~ alloc[2c7c]::string::{impl#86}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7812 ~ alloc[2c7c]::string::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7823 ~ alloc[2c7c]::string::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7824 ~ alloc[2c7c]::string::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7822 ~ alloc[2c7c]::string::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("B")])
impl generics: Generics { params: [GenericParamDef { name: "B", def_id: DefId(5:803 ~ alloc[2c7c]::borrow::{impl#4}::B), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("B"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: QPath(QPathData { assoc: PathSegment { name: "Owned", args: AngleBracketed { args: [], constraints: [] } }, self_type: Generic("B"), should_show_cast: true, trait_: Some(Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }) }), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Enum, DefId(5:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("B"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(5:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:802 ~ alloc[2c7c]::borrow::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::borrow::Cow"
std::borrow::Cow::<'_, B> is not fuzzable
assoc types:
Target: B
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:804 ~ alloc[2c7c]::borrow::{impl#4}::Target)), kind: AssocType, docs: "" }
"fn <std::borrow::Cow::<'_, B> as std::ops::Deref>::deref(&std::borrow::Cow::<'_, B>) -> &B" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7679 ~ alloc[2c7c]::ffi::c_str::CString)), segments: [PathSegment { name: "CString", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::ffi::c_str::CString")
type_def_id: Some(DefId(5:7679 ~ alloc[2c7c]::ffi::c_str::CString))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:4811 ~ alloc[2c7c]::ffi::c_str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CString"
std::ffi::CString is not fuzzable
assoc types:
Target: std::ffi::CStr
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:4812 ~ alloc[2c7c]::ffi::c_str::{impl#3}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::CString as std::ops::Deref>::deref(&std::ffi::CString) -> &std::ffi::CStr" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:502 ~ alloc[2c7c]::boxed::{impl#38}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:503 ~ alloc[2c7c]::boxed::{impl#38}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(5:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:501 ~ alloc[2c7c]::boxed::{impl#38})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:504 ~ alloc[2c7c]::boxed::{impl#38}::Target)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<T, A> as std::ops::Deref>::deref(&std::boxed::Box::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:6292 ~ alloc[2c7c]::sync::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:6293 ~ alloc[2c7c]::sync::{impl#29}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:6105 ~ alloc[2c7c]::sync::Arc)), segments: [PathSegment { name: "Arc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::sync::Arc")
type_def_id: Some(DefId(5:6105 ~ alloc[2c7c]::sync::Arc))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:6291 ~ alloc[2c7c]::sync::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::sync::Arc"
std::sync::Arc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:6294 ~ alloc[2c7c]::sync::{impl#29}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::Arc::<T, A> as std::ops::Deref>::deref(&std::sync::Arc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:898 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:899 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:883 ~ alloc[2c7c]::collections::binary_heap::PeekMut)), segments: [PathSegment { name: "PeekMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::collections::binary_heap::PeekMut")
type_def_id: Some(DefId(5:883 ~ alloc[2c7c]::collections::binary_heap::PeekMut))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:897 ~ alloc[2c7c]::collections::binary_heap::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::collections::binary_heap::PeekMut"
std::collections::binary_heap::PeekMut::<'_, T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:900 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::collections::binary_heap::PeekMut::<'_, T, A> as std::ops::Deref>::deref(&std::collections::binary_heap::PeekMut::<'_, T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8072 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8073 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8074 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8060 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8061 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8062 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8054 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8055 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8056 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7330 ~ alloc[2c7c]::vec::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:7331 ~ alloc[2c7c]::vec::{impl#8}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7185 ~ alloc[2c7c]::vec::Vec)), segments: [PathSegment { name: "Vec", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::vec::Vec")
type_def_id: Some(DefId(5:7185 ~ alloc[2c7c]::vec::Vec))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:7329 ~ alloc[2c7c]::vec::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::vec::Vec"
std::vec::Vec::<T, A> is not fuzzable
assoc types:
Target: [T]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:7332 ~ alloc[2c7c]::vec::{impl#8}::Target)), kind: AssocType, docs: "" }
"fn <std::vec::Vec::<T, A> as std::ops::Deref>::deref(&std::vec::Vec::<T, A>) -> &[T]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5150 ~ alloc[2c7c]::rc::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:5151 ~ alloc[2c7c]::rc::{impl#25}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:4981 ~ alloc[2c7c]::rc::Rc)), segments: [PathSegment { name: "Rc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::rc::Rc")
type_def_id: Some(DefId(5:4981 ~ alloc[2c7c]::rc::Rc))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5149 ~ alloc[2c7c]::rc::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::rc::Rc"
std::rc::Rc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5152 ~ alloc[2c7c]::rc::{impl#25}::Target)), kind: AssocType, docs: "" }
"fn <std::rc::Rc::<T, A> as std::ops::Deref>::deref(&std::rc::Rc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5393 ~ alloc[2c7c]::rc::{impl#79}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:5394 ~ alloc[2c7c]::rc::{impl#79}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:7747 ~ alloc[2c7c]::rc::UniqueRc)), segments: [PathSegment { name: "UniqueRc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::rc::UniqueRc")
type_def_id: Some(DefId(5:7747 ~ alloc[2c7c]::rc::UniqueRc))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5392 ~ alloc[2c7c]::rc::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::rc::UniqueRc"
std::rc::UniqueRc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5395 ~ alloc[2c7c]::rc::{impl#79}::Target)), kind: AssocType, docs: "" }
"fn <std::rc::UniqueRc::<T, A> as std::ops::Deref>::deref(&std::rc::UniqueRc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:222 ~ miniz_oxide[68e8]::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<miniz_oxide::StreamResult>>::from(miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:224 ~ miniz_oxide[68e8]::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<&miniz_oxide::StreamResult>>::from(&miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<&miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:5268 ~ core[b693]::ffi::c_str::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::PartialOrd>::partial_cmp(&std::ffi::CStr, &std::ffi::CStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::CStr as std::cmp::PartialOrd>::lt(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::CStr as std::cmp::PartialOrd>::le(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::CStr as std::cmp::PartialOrd>::gt(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::CStr as std::cmp::PartialOrd>::ge(&std::ffi::CStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:41118 ~ core[b693]::ffi::c_str::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::hash::Hash>::hash(&std::ffi::CStr, &mut __H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::ffi::CStr as std::hash::Hash>::hash_slice(&[std::ffi::CStr], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:5242 ~ core[b693]::ffi::c_str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Output: std::ffi::CStr
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:5273 ~ core[b693]::ffi::c_str::{impl#11}::Output)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::ops::Index::<std::ops::range::RangeFrom::<usize>>>::index(&std::ffi::CStr, std::ops::range::RangeFrom::<usize>) -> &std::ffi::CStr" is filtered.
Add std::ops::Index::<std::ops::range::RangeFrom::<usize>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:5267 ~ core[b693]::ffi::c_str::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:5265 ~ core[b693]::ffi::c_str::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::PartialEq>::eq(&std::ffi::CStr, &std::ffi::CStr) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::CStr as std::cmp::PartialEq>::ne(&std::ffi::CStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:5244 ~ core[b693]::ffi::c_str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
&std::ffi::CStr is not fuzzable
assoc types:
"fn <&std::ffi::CStr as std::default::Default>::default() -> &std::ffi::CStr" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:5270 ~ core[b693]::ffi::c_str::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::Ord>::cmp(&std::ffi::CStr, &std::ffi::CStr) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::ffi::CStr as std::cmp::Ord>::max(std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
[Impl] add default impl: min
"fn <std::ffi::CStr as std::cmp::Ord>::min(std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
[Impl] add default impl: clamp
"fn <std::ffi::CStr as std::cmp::Ord>::clamp(std::ffi::CStr, std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:5275 ~ core[b693]::ffi::c_str::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::convert::AsRef::<std::ffi::CStr>>::as_ref(&std::ffi::CStr) -> &std::ffi::CStr" is filtered.
Add std::convert::AsRef::<std::ffi::CStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: None
impl_def_id: DefId(2:5249 ~ core[b693]::ffi::c_str::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn std::ffi::CStr::from_ptr(*const i8) -> &'a std::ffi::CStr" is filtered.
"fn std::ffi::CStr::from_bytes_until_nul(&[u8]) -> std::result::Result::<&std::ffi::CStr, std::ffi::FromBytesUntilNulError>" is filtered.
"fn std::ffi::CStr::from_bytes_with_nul(&[u8]) -> std::result::Result::<&std::ffi::CStr, std::ffi::FromBytesWithNulError>" is filtered.
"fn std::ffi::CStr::from_bytes_with_nul_unchecked(&[u8]) -> &std::ffi::CStr" is filtered.
"fn std::ffi::CStr::as_ptr(&std::ffi::CStr) -> *const i8" is filtered.
"fn std::ffi::CStr::count_bytes(&std::ffi::CStr) -> usize" is filtered.
"fn std::ffi::CStr::is_empty(&std::ffi::CStr) -> bool" is filtered.
"fn std::ffi::CStr::to_bytes(&std::ffi::CStr) -> &[u8]" is filtered.
"fn std::ffi::CStr::to_bytes_with_nul(&std::ffi::CStr) -> &[u8]" is filtered.
"fn std::ffi::CStr::bytes(&std::ffi::CStr) -> std::ffi::Bytes::<'_>" is filtered.
"fn std::ffi::CStr::to_str(&std::ffi::CStr) -> std::result::Result::<&str, std::str::error::Utf8Error>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: None
impl_def_id: DefId(5:4883 ~ alloc[2c7c]::ffi::c_str::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn std::ffi::CStr::to_string_lossy(&std::ffi::CStr) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::ffi::CStr::into_c_string(std::boxed::Box::<std::ffi::CStr>) -> std::ffi::CString" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:4872 ~ alloc[2c7c]::ffi::c_str::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Owned: std::ffi::CString
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:4873 ~ alloc[2c7c]::ffi::c_str::{impl#30}::Owned)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::borrow::ToOwned>::to_owned(&std::ffi::CStr) -> std::ffi::CString" is filtered.
"fn <std::ffi::CStr as std::borrow::ToOwned>::clone_into(&std::ffi::CStr, &mut std::ffi::CString) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4904 ~ core[b693]::cell::{impl#45}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:4897 ~ core[b693]::cell::RefMut)), segments: [PathSegment { name: "RefMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::RefMut")
type_def_id: Some(DefId(2:4897 ~ core[b693]::cell::RefMut))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:4903 ~ core[b693]::cell::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::cell::RefMut"
std::cell::RefMut::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:4905 ~ core[b693]::cell::{impl#45}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::RefMut::<'_, T> as std::ops::Deref>::deref(&std::cell::RefMut::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:946 ~ core[b693]::num::nonzero::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:945 ~ core[b693]::num::nonzero::{impl#8})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:957 ~ core[b693]::num::nonzero::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:34630 ~ core[b693]::ops::bit::BitOr)), segments: [PathSegment { name: "BitOr", args: AngleBracketed { args: [], constraints: [AssocItemConstraint { assoc: PathSegment { name: "Output", args: AngleBracketed { args: [], constraints: [] } }, kind: Equality { term: Type(Generic("T")) } }] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::bit::BitOr
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::bit::BitOr")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(2:34630 ~ core[b693]::ops::bit::BitOr))
impl_def_id: DefId(2:956 ~ core[b693]::num::nonzero::{impl#11})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4847 ~ core[b693]::cell::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:4841 ~ core[b693]::cell::Ref)), segments: [PathSegment { name: "Ref", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::Ref")
type_def_id: Some(DefId(2:4841 ~ core[b693]::cell::Ref))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:4846 ~ core[b693]::cell::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::cell::Ref"
std::cell::Ref::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:4848 ~ core[b693]::cell::{impl#37}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::Ref::<'_, T> as std::ops::Deref>::deref(&std::cell::Ref::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:1974 ~ core[b693]::mem::manually_drop::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop)), segments: [PathSegment { name: "ManuallyDrop", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::mem::manually_drop::ManuallyDrop")
type_def_id: Some(DefId(2:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:1973 ~ core[b693]::mem::manually_drop::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::mem::manually_drop::ManuallyDrop"
std::mem::manually_drop::ManuallyDrop::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:1975 ~ core[b693]::mem::manually_drop::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::mem::manually_drop::ManuallyDrop::<T> as std::ops::Deref>::deref(&std::mem::manually_drop::ManuallyDrop::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10100 ~ core[b693]::result::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10101 ~ core[b693]::result::{impl#28}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:10102 ~ core[b693]::result::{impl#28}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:10099 ~ core[b693]::result::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, F> is not fuzzable
assoc types:
"fn <std::result::Result::<T, F> as std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>>>::from_residual(std::ops::try_trait::Yeet::<E>) -> std::result::Result::<T, F>" is filtered.
Add std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:41177 ~ core[b693]::ffi::va_list::{impl#8}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:41176 ~ core[b693]::ffi::va_list::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5333 ~ core[b693]::ffi::va_list::{impl#6}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(2:5332 ~ core[b693]::ffi::va_list::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5336 ~ core[b693]::ffi::va_list::{impl#7}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::drop::Drop
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::drop::Drop")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(2:3580 ~ core[b693]::ops::drop::Drop))
impl_def_id: DefId(2:5335 ~ core[b693]::ffi::va_list::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5305 ~ core[b693]::ffi::va_list::{impl#0}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(2:5304 ~ core[b693]::ffi::va_list::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::as_va_list(&'a mut std::ffi::va_list::VaListImpl::<'_>) -> std::ffi::va_list::VaList::<'a, 'f>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(2:5325 ~ core[b693]::ffi::va_list::{impl#5}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(2:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(2:5324 ~ core[b693]::ffi::va_list::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::arg(&mut std::ffi::va_list::VaListImpl::<'_>) -> T" is filtered.
"fn std::ffi::va_list::VaListImpl::<'_>::with_copy(&std::ffi::va_list::VaListImpl::<'_>, F) -> R" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9928 ~ core[b693]::result::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9929 ~ core[b693]::result::{impl#0}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9927 ~ core[b693]::result::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn std::result::Result::<T, E>::is_ok(&std::result::Result::<T, E>) -> bool" is filtered.
"fn std::result::Result::<T, E>::is_ok_and(std::result::Result::<T, E>, impl GenericParamMap { inner: {\"impl\": [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: \"FnOnce\", args: Parenthesized { inputs: [Generic(\"T\")], output: Some(Primitive(Bool)) } }] }]}, generic_defs: [\"impl\"], type_pred: [] }) -> bool" is filtered.
"fn std::result::Result::<T, E>::is_err(&std::result::Result::<T, E>) -> bool" is filtered.
"fn std::result::Result::<T, E>::is_err_and(std::result::Result::<T, E>, impl GenericParamMap { inner: {\"impl\": [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: \"FnOnce\", args: Parenthesized { inputs: [Generic(\"E\")], output: Some(Primitive(Bool)) } }] }]}, generic_defs: [\"impl\"], type_pred: [] }) -> bool" is filtered.
"fn std::result::Result::<T, E>::ok(std::result::Result::<T, E>) -> std::option::Option::<T>" is filtered.
"fn std::result::Result::<T, E>::err(std::result::Result::<T, E>) -> std::option::Option::<E>" is filtered.
"fn std::result::Result::<T, E>::as_ref(&std::result::Result::<T, E>) -> std::result::Result::<&T, &E>" is filtered.
"fn std::result::Result::<T, E>::as_mut(&mut std::result::Result::<T, E>) -> std::result::Result::<&mut T, &mut E>" is filtered.
"fn std::result::Result::<T, E>::map(std::result::Result::<T, E>, F) -> std::result::Result::<U, E>" is filtered.
"fn std::result::Result::<T, E>::map_or(std::result::Result::<T, E>, U, F) -> U" is filtered.
"fn std::result::Result::<T, E>::map_or_else(std::result::Result::<T, E>, D, F) -> U" is filtered.
"fn std::result::Result::<T, E>::map_err(std::result::Result::<T, E>, O) -> std::result::Result::<T, F>" is filtered.
"fn std::result::Result::<T, E>::inspect(std::result::Result::<T, E>, F) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<T, E>::inspect_err(std::result::Result::<T, E>, F) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<T, E>::as_deref(&std::result::Result::<T, E>) -> std::result::Result::<&<T as std::ops::Deref>::Target, &E>" is filtered.
"fn std::result::Result::<T, E>::as_deref_mut(&mut std::result::Result::<T, E>) -> std::result::Result::<&mut <T as std::ops::Deref>::Target, &mut E>" is filtered.
"fn std::result::Result::<T, E>::iter(&std::result::Result::<T, E>) -> std::result::Iter::<'_, T>" is filtered.
"fn std::result::Result::<T, E>::iter_mut(&mut std::result::Result::<T, E>) -> std::result::IterMut::<'_, T>" is filtered.
"fn std::result::Result::<T, E>::expect(std::result::Result::<T, E>, &str) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_or_default(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::expect_err(std::result::Result::<T, E>, &str) -> E" is filtered.
"fn std::result::Result::<T, E>::unwrap_err(std::result::Result::<T, E>) -> E" is filtered.
"fn std::result::Result::<T, E>::into_ok(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::into_err(std::result::Result::<T, E>) -> E" is filtered.
"fn std::result::Result::<T, E>::and(std::result::Result::<T, E>, std::result::Result::<U, E>) -> std::result::Result::<U, E>" is filtered.
"fn std::result::Result::<T, E>::and_then(std::result::Result::<T, E>, F) -> std::result::Result::<U, E>" is filtered.
"fn std::result::Result::<T, E>::or(std::result::Result::<T, E>, std::result::Result::<T, F>) -> std::result::Result::<T, F>" is filtered.
"fn std::result::Result::<T, E>::or_else(std::result::Result::<T, E>, O) -> std::result::Result::<T, F>" is filtered.
"fn std::result::Result::<T, E>::unwrap_or(std::result::Result::<T, E>, T) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_or_else(std::result::Result::<T, E>, F) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_unchecked(std::result::Result::<T, E>) -> T" is filtered.
"fn std::result::Result::<T, E>::unwrap_err_unchecked(std::result::Result::<T, E>) -> E" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: None, mutability: Not, type_: Generic("T") }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9984 ~ core[b693]::result::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9985 ~ core[b693]::result::{impl#1}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: None, mutability: Not, type_: Generic("T") }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9983 ~ core[b693]::result::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<&T, E> is not fuzzable
assoc types:
"fn std::result::Result::<&T, E>::copied(std::result::Result::<&T, E>) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<&T, E>::cloned(std::result::Result::<&T, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([BorrowedRef { lifetime: None, mutability: Mut, type_: Generic("T") }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9991 ~ core[b693]::result::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9992 ~ core[b693]::result::{impl#2}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(BorrowedRef { lifetime: None, mutability: Mut, type_: Generic("T") }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9990 ~ core[b693]::result::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<&mut T, E> is not fuzzable
assoc types:
"fn std::result::Result::<&mut T, E>::copied(std::result::Result::<&mut T, E>) -> std::result::Result::<T, E>" is filtered.
"fn std::result::Result::<&mut T, E>::cloned(std::result::Result::<&mut T, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9998 ~ core[b693]::result::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:9999 ~ core[b693]::result::{impl#3}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:42580 ~ core[b693]::option::Option)), segments: [PathSegment { name: "Option", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:9997 ~ core[b693]::result::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<std::option::Option::<T>, E> is not fuzzable
assoc types:
"fn std::result::Result::<std::option::Option::<T>, E>::transpose(std::result::Result::<std::option::Option::<T>, E>) -> std::option::Option::<std::result::Result::<T, E>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10002 ~ core[b693]::result::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10003 ~ core[b693]::result::{impl#4}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: None
impl_def_id: DefId(2:10001 ~ core[b693]::result::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<std::result::Result::<T, E>, E> is not fuzzable
assoc types:
"fn std::result::Result::<std::result::Result::<T, E>, E>::flatten(std::result::Result::<std::result::Result::<T, E>, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:5828 ~ std[d8a0]::process::{impl#61}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(1:5829 ~ std[d8a0]::process::{impl#61}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:5817 ~ std[d8a0]::process::Termination)), segments: [PathSegment { name: "Termination", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: std::process::Termination
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::process::Termination")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(1:5817 ~ std[d8a0]::process::Termination))
impl_def_id: DefId(1:5827 ~ std[d8a0]::process::{impl#61})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::process::Termination>::report(std::result::Result::<T, E>) -> std::process::ExitCode" is filtered.
Add std::process::Termination Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("V"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "A", def_id: DefId(2:10081 ~ core[b693]::result::{impl#25}::A), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10082 ~ core[b693]::result::{impl#25}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(2:10083 ~ core[b693]::result::{impl#25}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator)), segments: [PathSegment { name: "FromIterator", args: AngleBracketed { args: [Type(Generic("A"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::collect::FromIterator
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("V")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::FromIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator))
impl_def_id: DefId(2:10080 ~ core[b693]::result::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42855 ~ core[b693]::result::{impl#30}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42856 ~ core[b693]::result::{impl#30}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(2:42854 ~ core[b693]::result::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42865 ~ core[b693]::result::{impl#33}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42866 ~ core[b693]::result::{impl#33}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:42864 ~ core[b693]::result::{impl#33})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::partial_cmp(&std::result::Result::<T, E>, &std::result::Result::<T, E>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::lt(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::le(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::gt(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::result::Result::<T, E> as std::cmp::PartialOrd>::ge(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:8294 ~ core[b693]::iter::traits::accum::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:8295 ~ core[b693]::iter::traits::accum::{impl#1}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:8296 ~ core[b693]::iter::traits::accum::{impl#1}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8280 ~ core[b693]::iter::traits::accum::Product)), segments: [PathSegment { name: "Product", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::accum::Product
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::accum::Product")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8280 ~ core[b693]::iter::traits::accum::Product))
impl_def_id: DefId(2:8293 ~ core[b693]::iter::traits::accum::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42858 ~ core[b693]::result::{impl#31}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42859 ~ core[b693]::result::{impl#31}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:42857 ~ core[b693]::result::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42881 ~ core[b693]::result::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42882 ~ core[b693]::result::{impl#37}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:42880 ~ core[b693]::result::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::hash::Hash>::hash(&std::result::Result::<T, E>, &mut __H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::result::Result::<T, E> as std::hash::Hash>::hash_slice(&[std::result::Result::<T, E>], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(2:32742 ~ core[b693]::convert::Infallible)), segments: [PathSegment { name: "Infallible", args: AngleBracketed { args: [], constraints: [] } }] } }, Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10105 ~ core[b693]::result::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10106 ~ core[b693]::result::{impl#29}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::Residual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(2:32742 ~ core[b693]::convert::Infallible)), segments: [PathSegment { name: "Infallible", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::Residual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3796 ~ core[b693]::ops::try_trait::Residual))
impl_def_id: DefId(2:10104 ~ core[b693]::result::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<std::convert::Infallible, E> is not fuzzable
assoc types:
TryType: std::result::Result::<T, E>
not covered item Item { name: Some("TryType"), item_id: DefId(DefId(2:10107 ~ core[b693]::result::{impl#29}::TryType)), kind: AssocType, docs: "" }
Add std::ops::try_trait::Residual::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:10018 ~ core[b693]::result::{impl#7}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:10019 ~ core[b693]::result::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10020 ~ core[b693]::result::{impl#7}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:10017 ~ core[b693]::result::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:10025 ~ core[b693]::result::{impl#8}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:10026 ~ core[b693]::result::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10027 ~ core[b693]::result::{impl#8}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:10024 ~ core[b693]::result::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10012 ~ core[b693]::result::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10013 ~ core[b693]::result::{impl#6}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:10011 ~ core[b693]::result::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42877 ~ core[b693]::result::{impl#36}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42878 ~ core[b693]::result::{impl#36}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:42876 ~ core[b693]::result::{impl#36})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42869 ~ core[b693]::result::{impl#34}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42870 ~ core[b693]::result::{impl#34}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:42868 ~ core[b693]::result::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10007 ~ core[b693]::result::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10008 ~ core[b693]::result::{impl#5}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(2:10006 ~ core[b693]::result::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42861 ~ core[b693]::result::{impl#32}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42862 ~ core[b693]::result::{impl#32}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:42860 ~ core[b693]::result::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::cmp::PartialEq>::eq(&std::result::Result::<T, E>, &std::result::Result::<T, E>) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::result::Result::<T, E> as std::cmp::PartialEq>::ne(&std::result::Result::<T, E>, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:42873 ~ core[b693]::result::{impl#35}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:42874 ~ core[b693]::result::{impl#35}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("E"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:42872 ~ core[b693]::result::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
"fn <std::result::Result::<T, E> as std::cmp::Ord>::cmp(&std::result::Result::<T, E>, &std::result::Result::<T, E>) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::result::Result::<T, E> as std::cmp::Ord>::max(std::result::Result::<T, E>, std::result::Result::<T, E>) -> std::result::Result::<T, E>" is filtered.
[Impl] add default impl: min
"fn <std::result::Result::<T, E> as std::cmp::Ord>::min(std::result::Result::<T, E>, std::result::Result::<T, E>) -> std::result::Result::<T, E>" is filtered.
[Impl] add default impl: clamp
"fn <std::result::Result::<T, E> as std::cmp::Ord>::clamp(std::result::Result::<T, E>, std::result::Result::<T, E>, std::result::Result::<T, E>) -> std::result::Result::<T, E>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10095 ~ core[b693]::result::{impl#27}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10096 ~ core[b693]::result::{impl#27}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:10097 ~ core[b693]::result::{impl#27}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:10094 ~ core[b693]::result::{impl#27})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, F> is not fuzzable
assoc types:
"fn <std::result::Result::<T, F> as std::ops::try_trait::FromResidual::<std::result::Result::<std::convert::Infallible, E>>>::from_residual(std::result::Result::<std::convert::Infallible, E>) -> std::result::Result::<T, F>" is filtered.
Add std::ops::try_trait::FromResidual::<std::result::Result::<std::convert::Infallible, E>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10100 ~ core[b693]::result::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10101 ~ core[b693]::result::{impl#28}::E), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:10102 ~ core[b693]::result::{impl#28}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::try_trait::FromResidual
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::FromResidual")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3790 ~ core[b693]::ops::try_trait::FromResidual))
impl_def_id: DefId(2:10099 ~ core[b693]::result::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, F> is not fuzzable
assoc types:
"fn <std::result::Result::<T, F> as std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>>>::from_residual(std::ops::try_trait::Yeet::<E>) -> std::result::Result::<T, F>" is filtered.
Add std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:8287 ~ core[b693]::iter::traits::accum::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:8288 ~ core[b693]::iter::traits::accum::{impl#0}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:8289 ~ core[b693]::iter::traits::accum::{impl#0}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum)), segments: [PathSegment { name: "Sum", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::iter::traits::accum::Sum
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::accum::Sum")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum))
impl_def_id: DefId(2:8286 ~ core[b693]::iter::traits::accum::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("E")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10088 ~ core[b693]::result::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "E", def_id: DefId(2:10089 ~ core[b693]::result::{impl#26}::E), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::try_trait::Try
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("E"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::try_trait::Try")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3785 ~ core[b693]::ops::try_trait::Try))
impl_def_id: DefId(2:10087 ~ core[b693]::result::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<T, E> is not fuzzable
assoc types:
Output: T
Residual: std::result::Result::<std::convert::Infallible, E>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:10090 ~ core[b693]::result::{impl#26}::Output)), kind: AssocType, docs: "" }
not covered item Item { name: Some("Residual"), item_id: DefId(DefId(2:10091 ~ core[b693]::result::{impl#26}::Residual)), kind: AssocType, docs: "" }
"fn <std::result::Result::<T, E> as std::ops::try_trait::Try>::from_output(<std::result::Result::<T, E> as std::ops::try_trait::Try>::Output) -> std::result::Result::<T, E>" is filtered.
"fn <std::result::Result::<T, E> as std::ops::try_trait::Try>::branch(std::result::Result::<T, E>) -> std::ops::control_flow::ControlFlow::<<std::result::Result::<T, E> as std::ops::try_trait::Try>::Residual, <std::result::Result::<T, E> as std::ops::try_trait::Try>::Output>" is filtered.
Add std::ops::try_trait::Try Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:222 ~ miniz_oxide[68e8]::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<miniz_oxide::StreamResult>>::from(miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }, Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } }])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(2:42845 ~ core[b693]::result::Result)), segments: [PathSegment { name: "Result", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Enum, DefId(9:412 ~ miniz_oxide[68e8]::MZStatus)), segments: [PathSegment { name: "MZStatus", args: AngleBracketed { args: [], constraints: [] } }] } }), Type(Path { path: Path { res: Def(Enum, DefId(9:435 ~ miniz_oxide[68e8]::MZError)), segments: [PathSegment { name: "MZError", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("core::result::Result")
type_def_id: Some(DefId(2:42845 ~ core[b693]::result::Result))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(9:224 ~ miniz_oxide[68e8]::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::result::Result"
std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> is not fuzzable
assoc types:
"fn <std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError> as std::convert::From::<&miniz_oxide::StreamResult>>::from(&miniz_oxide::StreamResult) -> std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>" is filtered.
Add std::convert::From::<&miniz_oxide::StreamResult> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(2:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(2:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Output: std::ffi::CStr
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:5273 ~ core[b693]::ffi::c_str::{impl#11}::Output)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::ops::Index::<std::ops::range::RangeFrom::<usize>>>::index(&std::ffi::CStr, std::ops::range::RangeFrom::<usize>) -> &std::ffi::CStr" is filtered.
Add std::ops::Index::<std::ops::range::RangeFrom::<usize>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("Ptr")])
impl generics: Generics { params: [GenericParamDef { name: "Ptr", def_id: DefId(2:9693 ~ core[b693]::pin::{impl#13}::Ptr), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Ptr"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:42704 ~ core[b693]::pin::Pin)), segments: [PathSegment { name: "Pin", args: AngleBracketed { args: [Type(Generic("Ptr"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::pin::Pin")
type_def_id: Some(DefId(2:42704 ~ core[b693]::pin::Pin))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:9692 ~ core[b693]::pin::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::pin::Pin"
std::pin::Pin::<Ptr> is not fuzzable
assoc types:
Target: <Ptr as std::ops::Deref>::Target
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:9694 ~ core[b693]::pin::{impl#13}::Target)), kind: AssocType, docs: "" }
"fn <std::pin::Pin::<Ptr> as std::ops::Deref>::deref(&std::pin::Pin::<Ptr>) -> &<Ptr as std::ops::Deref>::Target" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4629 ~ core[b693]::cell::lazy::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(2:4630 ~ core[b693]::cell::lazy::{impl#2}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:4613 ~ core[b693]::cell::lazy::LazyCell)), segments: [PathSegment { name: "LazyCell", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::lazy::LazyCell")
type_def_id: Some(DefId(2:4613 ~ core[b693]::cell::lazy::LazyCell))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:4628 ~ core[b693]::cell::lazy::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::cell::lazy::LazyCell"
std::cell::lazy::LazyCell::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:4631 ~ core[b693]::cell::lazy::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::lazy::LazyCell::<T, F> as std::ops::Deref>::deref(&std::cell::lazy::LazyCell::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:9524 ~ core[b693]::panic::unwind_safe::{impl#21}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(2:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:9523 ~ core[b693]::panic::unwind_safe::{impl#21})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:9525 ~ core[b693]::panic::unwind_safe::{impl#21}::Target)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::ops::Deref>::deref(&std::panic::unwind_safe::AssertUnwindSafe::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:5309 ~ core[b693]::ffi::va_list::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'f", def_id: DefId(2:5310 ~ core[b693]::ffi::va_list::{impl#1}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(2:41179 ~ core[b693]::ffi::va_list::VaList)), segments: [PathSegment { name: "VaList", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::ffi::va_list::VaList")
type_def_id: Some(DefId(2:41179 ~ core[b693]::ffi::va_list::VaList))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(2:5308 ~ core[b693]::ffi::va_list::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaList"
std::ffi::va_list::VaList::<'_, '_> is not fuzzable
assoc types:
Target: std::ffi::va_list::VaListImpl::<'f>
not covered item Item { name: Some("Target"), item_id: DefId(DefId(2:5311 ~ core[b693]::ffi::va_list::{impl#1}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::va_list::VaList::<'_, '_> as std::ops::Deref>::deref(&std::ffi::va_list::VaList::<'_, '_>) -> &std::ffi::va_list::VaListImpl::<'f>" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7055 ~ std[d8a0]::sync::rwlock::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9461 ~ std[d8a0]::sync::rwlock::MappedRwLockReadGuard)), segments: [PathSegment { name: "MappedRwLockReadGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::MappedRwLockReadGuard")
type_def_id: Some(DefId(1:9461 ~ std[d8a0]::sync::rwlock::MappedRwLockReadGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7054 ~ std[d8a0]::sync::rwlock::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::MappedRwLockReadGuard"
std::sync::rwlock::MappedRwLockReadGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7056 ~ std[d8a0]::sync::rwlock::{impl#28}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::MappedRwLockReadGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::MappedRwLockReadGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9023 ~ std[d8a0]::path::{impl#159})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9021 ~ std[d8a0]::path::{impl#158})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9053 ~ std[d8a0]::path::{impl#170})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8933 ~ std[d8a0]::path::{impl#127}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8932 ~ std[d8a0]::path::{impl#127})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9030 ~ std[d8a0]::path::{impl#162}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9029 ~ std[d8a0]::path::{impl#162})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::eq(&std::path::Path, &&'a std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9074 ~ std[d8a0]::path::{impl#178}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9075 ~ std[d8a0]::path::{impl#178}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9073 ~ std[d8a0]::path::{impl#178})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:5560 ~ std[d8a0]::path::{impl#68})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq>::eq(&std::path::Path, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8958 ~ std[d8a0]::path::{impl#135}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8959 ~ std[d8a0]::path::{impl#135}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8957 ~ std[d8a0]::path::{impl#135})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8923 ~ std[d8a0]::path::{impl#123})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9042 ~ std[d8a0]::path::{impl#166}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9041 ~ std[d8a0]::path::{impl#166})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9033 ~ std[d8a0]::path::{impl#163}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9032 ~ std[d8a0]::path::{impl#163})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9090 ~ std[d8a0]::path::{impl#182}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9089 ~ std[d8a0]::path::{impl#182})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8945 ~ std[d8a0]::path::{impl#131}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8944 ~ std[d8a0]::path::{impl#131})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9065 ~ std[d8a0]::path::{impl#175}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9064 ~ std[d8a0]::path::{impl#175})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::eq(&std::ffi::OsStr, &&'a std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9062 ~ std[d8a0]::path::{impl#174}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9061 ~ std[d8a0]::path::{impl#174})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: None
impl_def_id: DefId(1:5485 ~ std[d8a0]::path::{impl#63})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn std::path::Path::new(&S) -> &std::path::Path" is filtered.
"fn std::path::Path::as_os_str(&std::path::Path) -> &std::ffi::OsStr" is filtered.
"fn std::path::Path::as_mut_os_str(&mut std::path::Path) -> &mut std::ffi::OsStr" is filtered.
"fn std::path::Path::to_str(&std::path::Path) -> std::option::Option::<&str>" is filtered.
"fn std::path::Path::to_string_lossy(&std::path::Path) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::path::Path::to_path_buf(&std::path::Path) -> std::path::PathBuf" is filtered.
"fn std::path::Path::is_absolute(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_relative(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::has_root(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::parent(&std::path::Path) -> std::option::Option::<&std::path::Path>" is filtered.
"fn std::path::Path::ancestors(&std::path::Path) -> std::path::Ancestors::<'_>" is filtered.
"fn std::path::Path::file_name(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::strip_prefix(&std::path::Path, P) -> std::result::Result::<&std::path::Path, std::path::StripPrefixError>" is filtered.
"fn std::path::Path::starts_with(&std::path::Path, P) -> bool" is filtered.
"fn std::path::Path::ends_with(&std::path::Path, P) -> bool" is filtered.
"fn std::path::Path::file_stem(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::file_prefix(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::extension(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::join(&std::path::Path, P) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_file_name(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_extension(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_added_extension(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::components(&std::path::Path) -> std::path::Components::<'_>" is filtered.
"fn std::path::Path::iter(&std::path::Path) -> std::path::Iter::<'_>" is filtered.
"fn std::path::Path::display(&std::path::Path) -> std::path::Display::<'_>" is filtered.
"fn std::path::Path::metadata(&std::path::Path) -> std::result::Result::<std::fs::Metadata, std::io::Error>" is filtered.
"fn std::path::Path::symlink_metadata(&std::path::Path) -> std::result::Result::<std::fs::Metadata, std::io::Error>" is filtered.
"fn std::path::Path::canonicalize(&std::path::Path) -> std::result::Result::<std::path::PathBuf, std::io::Error>" is filtered.
"fn std::path::Path::read_link(&std::path::Path) -> std::result::Result::<std::path::PathBuf, std::io::Error>" is filtered.
"fn std::path::Path::read_dir(&std::path::Path) -> std::result::Result::<std::fs::ReadDir, std::io::Error>" is filtered.
"fn std::path::Path::exists(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::try_exists(&std::path::Path) -> std::result::Result::<bool, std::io::Error>" is filtered.
"fn std::path::Path::is_file(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_dir(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_symlink(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::into_path_buf(std::boxed::Box::<std::path::Path>) -> std::path::PathBuf" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(1:5467 ~ std[d8a0]::path::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
Owned: std::path::PathBuf
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:5468 ~ std[d8a0]::path::{impl#56}::Owned)), kind: AssocType, docs: "" }
"fn <std::path::Path as std::borrow::ToOwned>::to_owned(&std::path::Path) -> std::path::PathBuf" is filtered.
"fn <std::path::Path as std::borrow::ToOwned>::clone_into(&std::path::Path, &mut std::path::PathBuf) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:5551 ~ std[d8a0]::path::{impl#65})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5572 ~ std[d8a0]::path::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::path::Path>>::as_ref(&std::ffi::OsStr) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5549 ~ std[d8a0]::path::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::path::Path) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5570 ~ std[d8a0]::path::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::path::Path>>::as_ref(&std::path::Path) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5578 ~ std[d8a0]::path::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::path::Path>>::as_ref(&str) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:5568 ~ std[d8a0]::path::{impl#72})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::Ord>::cmp(&std::path::Path, &std::path::Path) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::path::Path as std::cmp::Ord>::max(std::path::Path, std::path::Path) -> std::path::Path" is filtered.
[Impl] add default impl: min
"fn <std::path::Path as std::cmp::Ord>::min(std::path::Path, std::path::Path) -> std::path::Path" is filtered.
[Impl] add default impl: clamp
"fn <std::path::Path as std::cmp::Ord>::clamp(std::path::Path, std::path::Path, std::path::Path) -> std::path::Path" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8927 ~ std[d8a0]::path::{impl#125})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8939 ~ std[d8a0]::path::{impl#129}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8938 ~ std[d8a0]::path::{impl#129})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8951 ~ std[d8a0]::path::{impl#133}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8950 ~ std[d8a0]::path::{impl#133})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9096 ~ std[d8a0]::path::{impl#184}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9095 ~ std[d8a0]::path::{impl#184})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9068 ~ std[d8a0]::path::{impl#176}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9067 ~ std[d8a0]::path::{impl#176})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9039 ~ std[d8a0]::path::{impl#165}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9038 ~ std[d8a0]::path::{impl#165})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9036 ~ std[d8a0]::path::{impl#164}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9035 ~ std[d8a0]::path::{impl#164})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::partial_cmp(&std::path::Path, &&'a std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9082 ~ std[d8a0]::path::{impl#180}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9083 ~ std[d8a0]::path::{impl#180}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9081 ~ std[d8a0]::path::{impl#180})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9048 ~ std[d8a0]::path::{impl#168}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9047 ~ std[d8a0]::path::{impl#168})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8966 ~ std[d8a0]::path::{impl#137}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8967 ~ std[d8a0]::path::{impl#137}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8965 ~ std[d8a0]::path::{impl#137})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9025 ~ std[d8a0]::path::{impl#160})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9071 ~ std[d8a0]::path::{impl#177}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9070 ~ std[d8a0]::path::{impl#177})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::partial_cmp(&std::ffi::OsStr, &&'a std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9027 ~ std[d8a0]::path::{impl#161})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:5566 ~ std[d8a0]::path::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd>::partial_cmp(&std::path::Path, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9057 ~ std[d8a0]::path::{impl#172})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:5590 ~ std[d8a0]::path::{impl#81}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(1:5589 ~ std[d8a0]::path::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:5562 ~ std[d8a0]::path::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::hash::Hash>::hash(&std::path::Path, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::path::Path as std::hash::Hash>::hash_slice(&[std::path::Path], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:5565 ~ std[d8a0]::path::{impl#70})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::Write
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Write")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3664 ~ std[d8a0]::io::Write))
impl_def_id: DefId(1:3237 ~ std[d8a0]::io::impls::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: &mut [u8]
&mut [u8] is not fuzzable
assoc types:
"fn <&mut [u8] as std::io::Write>::write(&mut &mut [u8], &[u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::write_vectored(&mut &mut [u8], &[std::io::IoSlice::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::is_write_vectored(&&mut [u8]) -> bool" is filtered.
"fn <&mut [u8] as std::io::Write>::write_all(&mut &mut [u8], &[u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::flush(&mut &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
Add std::io::Write Provide Method. is_local=false
[Impl] add default impl: write_all_vectored
"fn <&mut [u8] as std::io::Write>::write_all_vectored(&mut &mut [u8], &mut [std::io::IoSlice::<'_>]) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: write_fmt
"fn <&mut [u8] as std::io::Write>::write_fmt(&mut &mut [u8], std::fmt::Arguments::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: by_ref
"fn <&mut [u8] as std::io::Write>::by_ref(&mut &mut [u8]) -> &mut &mut [u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Path { path: Path { res: Def(Enum, DefId(2:40484 ~ core[b693]::ascii::ascii_char::AsciiChar)), segments: [PathSegment { name: "AsciiChar", args: AngleBracketed { args: [], constraints: [] } }] } })
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:4441 ~ core[b693]::ascii::ascii_char::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[std::ascii::ascii_char::AsciiChar] is not fuzzable
assoc types:
"fn [std::ascii::ascii_char::AsciiChar]::as_str(&[std::ascii::ascii_char::AsciiChar]) -> &str" is filtered.
"fn [std::ascii::ascii_char::AsciiChar]::as_bytes(&[std::ascii::ascii_char::AsciiChar]) -> &[u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12907 ~ core[b693]::slice::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:12908 ~ core[b693]::slice::{impl#1}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Array(Generic("T"), "N"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12906 ~ core[b693]::slice::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[[T;N]] is not fuzzable
assoc types:
"fn [[T;N]]::as_flattened(&[[T;N]]) -> &[T]" is filtered.
"fn [[T;N]]::as_flattened_mut(&mut [[T;N]]) -> &mut [T]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(F32))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12911 ~ core[b693]::slice::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [f32]
[f32] is not fuzzable
assoc types:
"fn [f32]::sort_floats(&mut [f32]) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(F64))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12913 ~ core[b693]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [f64]
[f64] is not fuzzable
assoc types:
"fn [f64]::sort_floats(&mut [f64]) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12703 ~ core[b693]::slice::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:12702 ~ core[b693]::slice::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn [T]::len(&[T]) -> usize" is filtered.
"fn [T]::is_empty(&[T]) -> bool" is filtered.
"fn [T]::first(&[T]) -> std::option::Option::<&T>" is filtered.
"fn [T]::first_mut(&mut [T]) -> std::option::Option::<&mut T>" is filtered.
"fn [T]::split_first(&[T]) -> std::option::Option::<(&T ,&[T])>" is filtered.
"fn [T]::split_first_mut(&mut [T]) -> std::option::Option::<(&mut T ,&mut [T])>" is filtered.
"fn [T]::split_last(&[T]) -> std::option::Option::<(&T ,&[T])>" is filtered.
"fn [T]::split_last_mut(&mut [T]) -> std::option::Option::<(&mut T ,&mut [T])>" is filtered.
"fn [T]::last(&[T]) -> std::option::Option::<&T>" is filtered.
"fn [T]::last_mut(&mut [T]) -> std::option::Option::<&mut T>" is filtered.
"fn [T]::first_chunk(&[T]) -> std::option::Option::<&[T;N]>" is filtered.
"fn [T]::first_chunk_mut(&mut [T]) -> std::option::Option::<&mut [T;N]>" is filtered.
"fn [T]::split_first_chunk(&[T]) -> std::option::Option::<(&[T;N] ,&[T])>" is filtered.
"fn [T]::split_first_chunk_mut(&mut [T]) -> std::option::Option::<(&mut [T;N] ,&mut [T])>" is filtered.
"fn [T]::split_last_chunk(&[T]) -> std::option::Option::<(&[T] ,&[T;N])>" is filtered.
"fn [T]::split_last_chunk_mut(&mut [T]) -> std::option::Option::<(&mut [T] ,&mut [T;N])>" is filtered.
"fn [T]::last_chunk(&[T]) -> std::option::Option::<&[T;N]>" is filtered.
"fn [T]::last_chunk_mut(&mut [T]) -> std::option::Option::<&mut [T;N]>" is filtered.
"fn [T]::get(&[T], I) -> std::option::Option::<&<I as std::slice::index::SliceIndex::<[T]>>::Output>" is filtered.
"fn [T]::get_mut(&mut [T], I) -> std::option::Option::<&mut <I as std::slice::index::SliceIndex::<[T]>>::Output>" is filtered.
"fn [T]::get_unchecked(&[T], I) -> &<I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
"fn [T]::get_unchecked_mut(&mut [T], I) -> &mut <I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
"fn [T]::as_ptr(&[T]) -> *const T" is filtered.
"fn [T]::as_mut_ptr(&mut [T]) -> *T" is filtered.
"fn [T]::as_ptr_range(&[T]) -> std::ops::range::Range::<*const T>" is filtered.
"fn [T]::as_mut_ptr_range(&mut [T]) -> std::ops::range::Range::<*T>" is filtered.
"fn [T]::swap(&mut [T], usize, usize) -> ()" is filtered.
"fn [T]::swap_unchecked(&mut [T], usize, usize) -> ()" is filtered.
"fn [T]::reverse(&mut [T]) -> ()" is filtered.
"fn [T]::iter(&[T]) -> std::slice::iter::Iter::<'_, T>" is filtered.
"fn [T]::iter_mut(&mut [T]) -> std::slice::iter::IterMut::<'_, T>" is filtered.
"fn [T]::windows(&[T], usize) -> std::slice::iter::Windows::<'_, T>" is filtered.
"fn [T]::chunks(&[T], usize) -> std::slice::iter::Chunks::<'_, T>" is filtered.
"fn [T]::chunks_mut(&mut [T], usize) -> std::slice::iter::ChunksMut::<'_, T>" is filtered.
"fn [T]::chunks_exact(&[T], usize) -> std::slice::iter::ChunksExact::<'_, T>" is filtered.
"fn [T]::chunks_exact_mut(&mut [T], usize) -> std::slice::iter::ChunksExactMut::<'_, T>" is filtered.
"fn [T]::as_chunks_unchecked(&[T]) -> &[[T;N]]" is filtered.
"fn [T]::as_chunks(&[T]) -> (&[[T;N]] ,&[T])" is filtered.
"fn [T]::as_rchunks(&[T]) -> (&[T] ,&[[T;N]])" is filtered.
"fn [T]::array_chunks(&[T]) -> std::slice::iter::ArrayChunks::<'_, T, <const>>" is filtered.
"fn [T]::as_chunks_unchecked_mut(&mut [T]) -> &mut [[T;N]]" is filtered.
"fn [T]::as_chunks_mut(&mut [T]) -> (&mut [[T;N]] ,&mut [T])" is filtered.
"fn [T]::as_rchunks_mut(&mut [T]) -> (&mut [T] ,&mut [[T;N]])" is filtered.
"fn [T]::array_chunks_mut(&mut [T]) -> std::slice::iter::ArrayChunksMut::<'_, T, <const>>" is filtered.
"fn [T]::array_windows(&[T]) -> std::slice::iter::ArrayWindows::<'_, T, <const>>" is filtered.
"fn [T]::rchunks(&[T], usize) -> std::slice::iter::RChunks::<'_, T>" is filtered.
"fn [T]::rchunks_mut(&mut [T], usize) -> std::slice::iter::RChunksMut::<'_, T>" is filtered.
"fn [T]::rchunks_exact(&[T], usize) -> std::slice::iter::RChunksExact::<'_, T>" is filtered.
"fn [T]::rchunks_exact_mut(&mut [T], usize) -> std::slice::iter::RChunksExactMut::<'_, T>" is filtered.
"fn [T]::chunk_by(&[T], F) -> std::slice::iter::ChunkBy::<'_, T, F>" is filtered.
"fn [T]::chunk_by_mut(&mut [T], F) -> std::slice::iter::ChunkByMut::<'_, T, F>" is filtered.
"fn [T]::split_at(&[T], usize) -> (&[T] ,&[T])" is filtered.
"fn [T]::split_at_mut(&mut [T], usize) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::split_at_unchecked(&[T], usize) -> (&[T] ,&[T])" is filtered.
"fn [T]::split_at_mut_unchecked(&mut [T], usize) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::split_at_checked(&[T], usize) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::split_at_mut_checked(&mut [T], usize) -> std::option::Option::<(&mut [T] ,&mut [T])>" is filtered.
"fn [T]::split(&[T], F) -> std::slice::iter::Split::<'_, T, F>" is filtered.
"fn [T]::split_mut(&mut [T], F) -> std::slice::iter::SplitMut::<'_, T, F>" is filtered.
"fn [T]::split_inclusive(&[T], F) -> std::slice::iter::SplitInclusive::<'_, T, F>" is filtered.
"fn [T]::split_inclusive_mut(&mut [T], F) -> std::slice::iter::SplitInclusiveMut::<'_, T, F>" is filtered.
"fn [T]::rsplit(&[T], F) -> std::slice::iter::RSplit::<'_, T, F>" is filtered.
"fn [T]::rsplit_mut(&mut [T], F) -> std::slice::iter::RSplitMut::<'_, T, F>" is filtered.
"fn [T]::splitn(&[T], usize, F) -> std::slice::iter::SplitN::<'_, T, F>" is filtered.
"fn [T]::splitn_mut(&mut [T], usize, F) -> std::slice::iter::SplitNMut::<'_, T, F>" is filtered.
"fn [T]::rsplitn(&[T], usize, F) -> std::slice::iter::RSplitN::<'_, T, F>" is filtered.
"fn [T]::rsplitn_mut(&mut [T], usize, F) -> std::slice::iter::RSplitNMut::<'_, T, F>" is filtered.
"fn [T]::split_once(&[T], F) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::rsplit_once(&[T], F) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::contains(&[T], &T) -> bool" is filtered.
"fn [T]::starts_with(&[T], &[T]) -> bool" is filtered.
"fn [T]::ends_with(&[T], &[T]) -> bool" is filtered.
"fn [T]::strip_prefix(&[T], &P) -> std::option::Option::<&[T]>" is filtered.
"fn [T]::strip_suffix(&[T], &P) -> std::option::Option::<&[T]>" is filtered.
"fn [T]::binary_search(&[T], &T) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::binary_search_by(&'a [T], F) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::binary_search_by_key(&'a [T], &B, F) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::sort_unstable(&mut [T]) -> ()" is filtered.
"fn [T]::sort_unstable_by(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_unstable_by_key(&mut [T], F) -> ()" is filtered.
"fn [T]::select_nth_unstable(&mut [T], usize) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::select_nth_unstable_by(&mut [T], usize, F) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::select_nth_unstable_by_key(&mut [T], usize, F) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::partition_dedup(&mut [T]) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::partition_dedup_by(&mut [T], F) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::partition_dedup_by_key(&mut [T], F) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::rotate_left(&mut [T], usize) -> ()" is filtered.
"fn [T]::rotate_right(&mut [T], usize) -> ()" is filtered.
"fn [T]::fill(&mut [T], T) -> ()" is filtered.
"fn [T]::fill_with(&mut [T], F) -> ()" is filtered.
"fn [T]::clone_from_slice(&mut [T], &[T]) -> ()" is filtered.
"fn [T]::copy_from_slice(&mut [T], &[T]) -> ()" is filtered.
"fn [T]::copy_within(&mut [T], R, usize) -> ()" is filtered.
"fn [T]::swap_with_slice(&mut [T], &mut [T]) -> ()" is filtered.
"fn [T]::align_to(&[T]) -> (&[T] ,&[U] ,&[T])" is filtered.
"fn [T]::align_to_mut(&mut [T]) -> (&mut [T] ,&mut [U] ,&mut [T])" is filtered.
"fn [T]::as_simd(&[T]) -> (&[T] ,&[std::core_simd::vector::Simd::<T, <const>>] ,&[T])" is filtered.
"fn [T]::as_simd_mut(&mut [T]) -> (&mut [T] ,&mut [std::core_simd::vector::Simd::<T, <const>>] ,&mut [T])" is filtered.
"fn [T]::is_sorted(&[T]) -> bool" is filtered.
"fn [T]::is_sorted_by(&'a [T], F) -> bool" is filtered.
"fn [T]::is_sorted_by_key(&'a [T], F) -> bool" is filtered.
"fn [T]::partition_point(&[T], P) -> usize" is filtered.
"fn [T]::take(&mut &'a [T], R) -> std::option::Option::<&'a [T]>" is filtered.
"fn [T]::take_mut(&mut &'a mut [T], R) -> std::option::Option::<&'a mut [T]>" is filtered.
"fn [T]::take_first(&mut &'a [T]) -> std::option::Option::<&'a T>" is filtered.
"fn [T]::take_first_mut(&mut &'a mut [T]) -> std::option::Option::<&'a mut T>" is filtered.
"fn [T]::take_last(&mut &'a [T]) -> std::option::Option::<&'a T>" is filtered.
"fn [T]::take_last_mut(&mut &'a mut [T]) -> std::option::Option::<&'a mut T>" is filtered.
"fn [T]::get_many_unchecked_mut(&mut [T], [usize;N]) -> [&mut T;N]" is filtered.
"fn [T]::get_many_mut(&mut [T], [usize;N]) -> std::result::Result::<[&mut T;N], std::slice::GetManyMutError::<<const>>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:11412 ~ core[b693]::slice::ascii::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::is_ascii(&[u8]) -> bool" is filtered.
"fn [u8]::as_ascii(&[u8]) -> std::option::Option::<&[std::ascii::ascii_char::AsciiChar]>" is filtered.
"fn [u8]::as_ascii_unchecked(&[u8]) -> &[std::ascii::ascii_char::AsciiChar]" is filtered.
"fn [u8]::eq_ignore_ascii_case(&[u8], &[u8]) -> bool" is filtered.
"fn [u8]::make_ascii_uppercase(&mut [u8]) -> ()" is filtered.
"fn [u8]::make_ascii_lowercase(&mut [u8]) -> ()" is filtered.
"fn [u8]::escape_ascii(&[u8]) -> std::slice::ascii::EscapeAscii::<'_>" is filtered.
"fn [u8]::trim_ascii_start(&[u8]) -> &[u8]" is filtered.
"fn [u8]::trim_ascii_end(&[u8]) -> &[u8]" is filtered.
"fn [u8]::trim_ascii(&[u8]) -> &[u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(2:13662 ~ core[b693]::str::lossy::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::utf8_chunks(&[u8]) -> std::str::lossy::Utf8Chunks::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5522 ~ alloc[2c7c]::slice::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(5:5521 ~ alloc[2c7c]::slice::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn [T]::sort(&mut [T]) -> ()" is filtered.
"fn [T]::sort_by(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_by_key(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_by_cached_key(&mut [T], F) -> ()" is filtered.
"fn [T]::to_vec(&[T]) -> std::vec::Vec::<T>" is filtered.
"fn [T]::to_vec_in(&[T], A) -> std::vec::Vec::<T, A>" is filtered.
"fn [T]::into_vec(std::boxed::Box::<[T], A>) -> std::vec::Vec::<T, A>" is filtered.
"fn [T]::repeat(&[T], usize) -> std::vec::Vec::<T>" is filtered.
"fn [T]::concat(&[T]) -> <[T] as std::slice::Concat::<Item>>::Output" is filtered.
"fn [T]::join(&[T], Separator) -> <[T] as std::slice::Join::<Separator>>::Output" is filtered.
"fn [T]::connect(&[T], Separator) -> <[T] as std::slice::Join::<Separator>>::Output" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(5:5548 ~ alloc[2c7c]::slice::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::to_ascii_uppercase(&[u8]) -> std::vec::Vec::<u8>" is filtered.
"fn [u8]::to_ascii_lowercase(&[u8]) -> std::vec::Vec::<u8>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:3889 ~ std[d8a0]::net::socket_addr::{impl#13}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: std::net::socket_addr::ToSocketAddrs
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Path { path: Path { res: Def(Enum, DefId(2:42520 ~ core[b693]::net::socket_addr::SocketAddr)), segments: [PathSegment { name: "SocketAddr", args: AngleBracketed { args: [], constraints: [] } }] } }) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::net::socket_addr::ToSocketAddrs")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3856 ~ std[d8a0]::net::socket_addr::ToSocketAddrs))
impl_def_id: DefId(1:3888 ~ std[d8a0]::net::socket_addr::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[std::net::SocketAddr] is not fuzzable
assoc types:
Iter: std::iter::adapters::cloned::Cloned::<std::slice::iter::Iter::<'a, std::net::SocketAddr>>
not covered item Item { name: Some("Iter"), item_id: DefId(DefId(1:3890 ~ std[d8a0]::net::socket_addr::{impl#13}::Iter)), kind: AssocType, docs: "" }
"fn <&[std::net::SocketAddr] as std::net::ToSocketAddrs>::to_socket_addrs(&&[std::net::SocketAddr]) -> std::result::Result::<<&'a [std::net::SocketAddr] as std::net::ToSocketAddrs>::Iter, std::io::Error>" is filtered.
Add std::net::ToSocketAddrs Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(1:2259 ~ std[d8a0]::ffi::os_str::{impl#51}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::ffi::OsString
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:2260 ~ std[d8a0]::ffi::os_str::{impl#51}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&std::ffi::OsStr>>::join(&[S], &std::ffi::OsStr) -> std::ffi::OsString" is filtered.
Add std::slice::Join::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::BufRead
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::BufRead")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3692 ~ std[d8a0]::io::BufRead))
impl_def_id: DefId(1:3234 ~ std[d8a0]::io::impls::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
[TypeContext] add candidate #7: &mut &[u8] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) } }
[TypeContext] add candidate #8: &&[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) } }
[TypeContext] add candidate #9: *&[u8] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })
[TypeContext] add candidate #10: *const &[u8] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })
assoc types:
"fn <&[u8] as std::io::BufRead>::fill_buf(&mut &[u8]) -> std::result::Result::<&[u8], std::io::Error>" is filtered.
"fn <&[u8] as std::io::BufRead>::consume(&mut &[u8], usize) -> ()" is filtered.
Add std::io::BufRead Provide Method. is_local=false
[Impl] add default impl: has_data_left
"fn <&[u8] as std::io::BufRead>::has_data_left(&mut &[u8]) -> std::result::Result::<bool, std::io::Error>" is filtered.
[Impl] add default impl: read_until
"fn <&[u8] as std::io::BufRead>::read_until(&mut &[u8], u8, &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: skip_until
"fn <&[u8] as std::io::BufRead>::skip_until(&mut &[u8], u8) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: read_line
"fn <&[u8] as std::io::BufRead>::read_line(&mut &[u8], &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: split
"fn <&[u8] as std::io::BufRead>::split(&[u8], u8) -> std::io::Split::<&[u8]>" is filtered.
[Impl] add default impl: lines
"fn <&[u8] as std::io::BufRead>::lines(&[u8]) -> std::io::Lines::<&[u8]>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::Read
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Read")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3607 ~ std[d8a0]::io::Read))
impl_def_id: DefId(1:3224 ~ std[d8a0]::io::impls::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
assoc types:
"fn <&[u8] as std::io::Read>::read(&mut &[u8], &mut [u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_buf(&mut &[u8], std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_vectored(&mut &[u8], &mut [std::io::IoSliceMut::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::is_read_vectored(&&[u8]) -> bool" is filtered.
"fn <&[u8] as std::io::Read>::read_exact(&mut &[u8], &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_buf_exact(&mut &[u8], std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_to_end(&mut &[u8], &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_to_string(&mut &[u8], &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
Add std::io::Read Provide Method. is_local=false
[Impl] add default impl: by_ref
"fn <&[u8] as std::io::Read>::by_ref(&mut &[u8]) -> &mut &[u8]" is filtered.
[Impl] add default impl: bytes
"fn <&[u8] as std::io::Read>::bytes(&[u8]) -> std::io::Bytes::<&[u8]>" is filtered.
[Impl] add default impl: chain
"fn <&[u8] as std::io::Read>::chain(&[u8], R) -> std::io::Chain::<&[u8], R>" is filtered.
[Impl] add default impl: take
"fn <&[u8] as std::io::Read>::take(&[u8], u64) -> std::io::Take::<&[u8]>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::ascii::AsciiExt
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::ascii::AsciiExt")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:646 ~ std[d8a0]::ascii::AsciiExt))
impl_def_id: DefId(1:659 ~ std[d8a0]::ascii::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
Owned: std::vec::Vec::<u8>
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:660 ~ std[d8a0]::ascii::{impl#2}::Owned)), kind: AssocType, docs: "" }
"fn <[u8] as std::ascii::AsciiExt>::is_ascii(&[u8]) -> bool" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::to_ascii_uppercase(&[u8]) -> <[u8] as std::ascii::AsciiExt>::Owned" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::to_ascii_lowercase(&[u8]) -> <[u8] as std::ascii::AsciiExt>::Owned" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::eq_ignore_ascii_case(&[u8], &[u8]) -> bool" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::make_ascii_uppercase(&mut [u8]) -> ()" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::make_ascii_lowercase(&mut [u8]) -> ()" is filtered.
Add std::ascii::AsciiExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11475 ~ core[b693]::slice::cmp::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:11474 ~ core[b693]::slice::cmp::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialOrd>::partial_cmp(&[T], &[T]) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <[T] as std::cmp::PartialOrd>::lt(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <[T] as std::cmp::PartialOrd>::le(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <[T] as std::cmp::PartialOrd>::gt(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <[T] as std::cmp::PartialOrd>::ge(&[T], &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:13570 ~ core[b693]::str::pattern::{impl#24}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(2:13571 ~ core[b693]::str::pattern::{impl#24}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::str::pattern::Pattern
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Slice(Primitive(Char)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::pattern::Pattern")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:13443 ~ core[b693]::str::pattern::Pattern))
impl_def_id: DefId(2:13569 ~ core[b693]::str::pattern::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[char] is fuzzable
[TypeContext] add candidate #11: &[char] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }
[TypeContext] add candidate #12: &mut &[char] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) } }
[TypeContext] add candidate #13: &&[char] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) } }
[TypeContext] add candidate #14: *&[char] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) })
[TypeContext] add candidate #15: *const &[char] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) })
assoc types:
Searcher: std::str::pattern::CharSliceSearcher::<'a, 'b>
not covered item Item { name: Some("Searcher"), item_id: DefId(DefId(2:45083 ~ core[b693]::str::pattern::{impl#24}::Searcher)), kind: AssocType, docs: "" }
"fn <&[char] as std::str::pattern::Pattern::<'_>>::into_searcher(&[char], &'a str) -> std::str::pattern::CharSliceSearcher::<'a, 'b>" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_contained_in(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_prefix_of(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::strip_prefix_of(&[char], &'a str) -> std::option::Option::<&'a str>" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_suffix_of(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::strip_suffix_of(&[char], &'a str) -> std::option::Option::<&'a str>" is filtered.
Add std::str::pattern::Pattern::<'a> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:32841 ~ core[b693]::marker::{impl#35}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:32840 ~ core[b693]::marker::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10972 ~ core[b693]::hash::impls::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:10971 ~ core[b693]::hash::impls::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::hash::Hash>::hash(&[T], &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <[T] as std::hash::Hash>::hash_slice(&[[T]], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:11729 ~ core[b693]::slice::iter::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:11730 ~ core[b693]::slice::iter::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:11728 ~ core[b693]::slice::iter::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:11735 ~ core[b693]::slice::iter::{impl#2}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(2:11736 ~ core[b693]::slice::iter::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(2:11734 ~ core[b693]::slice::iter::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2824 ~ core[b693]::clone::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2823 ~ core[b693]::clone::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::clone::CloneToUninit>::clone_to_uninit(&[T], *[T]) -> ()" is filtered.
Add std::clone::CloneToUninit Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2827 ~ core[b693]::clone::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(2:2826 ~ core[b693]::clone::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::clone::CloneToUninit>::clone_to_uninit(&[T], *[T]) -> ()" is filtered.
Add std::clone::CloneToUninit Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:10802 ~ core[b693]::fmt::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:10801 ~ core[b693]::fmt::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:32929 ~ core[b693]::marker::{impl#93}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32908 ~ core[b693]::marker::ConstParamTy)), segments: [PathSegment { name: "ConstParamTy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::marker::ConstParamTy
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::ConstParamTy")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:32908 ~ core[b693]::marker::ConstParamTy))
impl_def_id: DefId(2:32928 ~ core[b693]::marker::{impl#93})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::marker::ConstParamTy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11527 ~ core[b693]::slice::index::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "I", def_id: DefId(2:11528 ~ core[b693]::slice::index::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(2:11526 ~ core[b693]::slice::index::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<I>>::index_mut(&mut [T], I) -> &mut <I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
Add std::ops::IndexMut::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11522 ~ core[b693]::slice::index::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "I", def_id: DefId(2:11523 ~ core[b693]::slice::index::{impl#0}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:11521 ~ core[b693]::slice::index::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: <I as std::slice::index::SliceIndex::<[T]>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:11524 ~ core[b693]::slice::index::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<I>>::index(&[T], I) -> &<I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
Add std::ops::Index::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11470 ~ core[b693]::slice::cmp::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:11469 ~ core[b693]::slice::cmp::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3114 ~ core[b693]::convert::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::AsMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(2:3113 ~ core[b693]::convert::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::convert::AsMut::<[T]>>::as_mut(&mut [T]) -> &mut [T]" is filtered.
Add std::convert::AsMut::<[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12934 ~ core[b693]::slice::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::slice::SlicePattern
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::slice::SlicePattern")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:12930 ~ core[b693]::slice::SlicePattern))
impl_def_id: DefId(2:12933 ~ core[b693]::slice::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Item: T
not covered item Item { name: Some("Item"), item_id: DefId(DefId(2:12935 ~ core[b693]::slice::{impl#8}::Item)), kind: AssocType, docs: "" }
"fn <[T] as std::slice::SlicePattern>::as_slice(&[T]) -> &[<[T] as std::slice::SlicePattern>::Item]" is filtered.
Add std::slice::SlicePattern Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4123 ~ core[b693]::array::equality::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4124 ~ core[b693]::array::equality::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4122 ~ core[b693]::array::equality::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::eq(&&mut [T], &[U;N]) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::ne(&&mut [T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4099 ~ core[b693]::array::equality::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4100 ~ core[b693]::array::equality::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4098 ~ core[b693]::array::equality::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::eq(&[T], &[U;N]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::ne(&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4111 ~ core[b693]::array::equality::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4112 ~ core[b693]::array::equality::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4110 ~ core[b693]::array::equality::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::eq(&&[T], &[U;N]) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::ne(&&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11465 ~ core[b693]::slice::cmp::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:11466 ~ core[b693]::slice::cmp::{impl#0}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:11464 ~ core[b693]::slice::cmp::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U]>>::eq(&[T], &[U]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U]>>::ne(&[T], &[U]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12928 ~ core[b693]::slice::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:12927 ~ core[b693]::slice::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::default::Default>::default() -> &mut [T]" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:12925 ~ core[b693]::slice::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:12924 ~ core[b693]::slice::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::default::Default>::default() -> &[T]" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11472 ~ core[b693]::slice::cmp::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:11471 ~ core[b693]::slice::cmp::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::Ord>::cmp(&[T], &[T]) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <[T] as std::cmp::Ord>::max([T], [T]) -> [T]" is filtered.
[Impl] add default impl: min
"fn <[T] as std::cmp::Ord>::min([T], [T]) -> [T]" is filtered.
[Impl] add default impl: clamp
"fn <[T] as std::cmp::Ord>::clamp([T], [T], [T]) -> [T]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:11727 ~ core[b693]::slice::iter::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(2:11726 ~ core[b693]::slice::iter::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3111 ~ core[b693]::convert::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:3110 ~ core[b693]::convert::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::convert::AsRef::<[T]>>::as_ref(&[T]) -> &[T]" is filtered.
Add std::convert::AsRef::<[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:13877 ~ core[b693]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<[u8]>>::as_ref(&str) -> &[u8]" is filtered.
Add std::convert::AsRef::<[u8]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8072 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8073 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8074 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8060 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8061 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8062 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:8054 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(5:8055 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(5:8056 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5681 ~ alloc[2c7c]::str::{impl#1}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5680 ~ alloc[2c7c]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5682 ~ alloc[2c7c]::str::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&str>>::join(&[S], &str) -> std::string::String" is filtered.
Add std::slice::Join::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5566 ~ alloc[2c7c]::slice::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5567 ~ alloc[2c7c]::slice::{impl#3}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5568 ~ alloc[2c7c]::slice::{impl#3}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&T>>::join(&[V], &T) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5572 ~ alloc[2c7c]::slice::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5573 ~ alloc[2c7c]::slice::{impl#4}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5571 ~ alloc[2c7c]::slice::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5574 ~ alloc[2c7c]::slice::{impl#4}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&[T]>>::join(&[V], &[T]) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5677 ~ alloc[2c7c]::str::{impl#0}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(5:5676 ~ alloc[2c7c]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5678 ~ alloc[2c7c]::str::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Concat::<str>>::concat(&[S]) -> std::string::String" is filtered.
Add std::slice::Concat::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5560 ~ alloc[2c7c]::slice::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5561 ~ alloc[2c7c]::slice::{impl#2}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(5:5559 ~ alloc[2c7c]::slice::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5562 ~ alloc[2c7c]::slice::{impl#2}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Concat::<T>>::concat(&[V]) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Concat::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5598 ~ alloc[2c7c]::slice::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:5597 ~ alloc[2c7c]::slice::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Owned: std::vec::Vec::<T>
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:5599 ~ alloc[2c7c]::slice::{impl#9}::Owned)), kind: AssocType, docs: "" }
"fn <[T] as std::borrow::ToOwned>::to_owned(&[T]) -> std::vec::Vec::<T>" is filtered.
"fn <[T] as std::borrow::ToOwned>::clone_into(&[T], &mut std::vec::Vec::<T>) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9023 ~ std[d8a0]::path::{impl#159})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9021 ~ std[d8a0]::path::{impl#158})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8161 ~ std[d8a0]::ffi::os_str::{impl#77}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8162 ~ std[d8a0]::ffi::os_str::{impl#77}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8983 ~ std[d8a0]::path::{impl#143})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::eq(&std::ffi::OsStr, &str) -> bool" is filtered.
Add std::cmp::PartialEq::<str> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9030 ~ std[d8a0]::path::{impl#162}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9029 ~ std[d8a0]::path::{impl#162})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::eq(&std::path::Path, &&'a std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8145 ~ std[d8a0]::ffi::os_str::{impl#73}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8146 ~ std[d8a0]::ffi::os_str::{impl#73}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8993 ~ std[d8a0]::path::{impl#147}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8992 ~ std[d8a0]::path::{impl#147})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2228 ~ std[d8a0]::ffi::os_str::{impl#40})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq>::eq(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9118 ~ std[d8a0]::path::{impl#191}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9119 ~ std[d8a0]::path::{impl#191}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9117 ~ std[d8a0]::path::{impl#191})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9033 ~ std[d8a0]::path::{impl#163}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9032 ~ std[d8a0]::path::{impl#163})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&str, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9065 ~ std[d8a0]::path::{impl#175}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9064 ~ std[d8a0]::path::{impl#175})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::eq(&std::ffi::OsStr, &&'a std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8129 ~ std[d8a0]::ffi::os_str::{impl#69}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8130 ~ std[d8a0]::ffi::os_str::{impl#69}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9062 ~ std[d8a0]::path::{impl#174}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9061 ~ std[d8a0]::path::{impl#174})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8177 ~ std[d8a0]::ffi::os_str::{impl#81}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8178 ~ std[d8a0]::ffi::os_str::{impl#81}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9105 ~ std[d8a0]::path::{impl#187}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9104 ~ std[d8a0]::path::{impl#187})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: None
impl_def_id: DefId(1:2167 ~ std[d8a0]::ffi::os_str::{impl#23})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn std::ffi::OsStr::new(&S) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::from_encoded_bytes_unchecked(&[u8]) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::to_str(&std::ffi::OsStr) -> std::option::Option::<&str>" is filtered.
"fn std::ffi::OsStr::to_string_lossy(&std::ffi::OsStr) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::ffi::OsStr::to_os_string(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::is_empty(&std::ffi::OsStr) -> bool" is filtered.
"fn std::ffi::OsStr::len(&std::ffi::OsStr) -> usize" is filtered.
"fn std::ffi::OsStr::into_os_string(std::boxed::Box::<std::ffi::OsStr>) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::as_encoded_bytes(&std::ffi::OsStr) -> &[u8]" is filtered.
"fn std::ffi::OsStr::slice_encoded_bytes(&std::ffi::OsStr, R) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::make_ascii_lowercase(&mut std::ffi::OsStr) -> ()" is filtered.
"fn std::ffi::OsStr::make_ascii_uppercase(&mut std::ffi::OsStr) -> ()" is filtered.
"fn std::ffi::OsStr::to_ascii_lowercase(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::to_ascii_uppercase(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::is_ascii(&std::ffi::OsStr) -> bool" is filtered.
"fn std::ffi::OsStr::eq_ignore_ascii_case(&std::ffi::OsStr, S) -> bool" is filtered.
"fn std::ffi::OsStr::display(&std::ffi::OsStr) -> std::ffi::Display::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(1:2265 ~ std[d8a0]::ffi::os_str::{impl#53})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
Owned: std::ffi::OsString
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:2266 ~ std[d8a0]::ffi::os_str::{impl#53}::Owned)), kind: AssocType, docs: "" }
"fn <std::ffi::OsStr as std::borrow::ToOwned>::to_owned(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn <std::ffi::OsStr as std::borrow::ToOwned>::clone_into(&std::ffi::OsStr, &mut std::ffi::OsString) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:2249 ~ std[d8a0]::ffi::os_str::{impl#48})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:2269 ~ std[d8a0]::ffi::os_str::{impl#54})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::ffi::OsStr) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&str) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5572 ~ std[d8a0]::path::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::path::Path>>::as_ref(&std::ffi::OsStr) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5549 ~ std[d8a0]::path::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::path::Path) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:2243 ~ std[d8a0]::ffi::os_str::{impl#46})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::Ord>::cmp(&std::ffi::OsStr, &std::ffi::OsStr) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::ffi::OsStr as std::cmp::Ord>::max(std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
[Impl] add default impl: min
"fn <std::ffi::OsStr as std::cmp::Ord>::min(std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
[Impl] add default impl: clamp
"fn <std::ffi::OsStr as std::cmp::Ord>::clamp(std::ffi::OsStr, std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9111 ~ std[d8a0]::path::{impl#189}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9110 ~ std[d8a0]::path::{impl#189})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8185 ~ std[d8a0]::ffi::os_str::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8186 ~ std[d8a0]::ffi::os_str::{impl#83}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:2235 ~ std[d8a0]::ffi::os_str::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::lt(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::le(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::gt(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::ge(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::partial_cmp(&std::ffi::OsStr, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<str> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8987 ~ std[d8a0]::path::{impl#145})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8169 ~ std[d8a0]::ffi::os_str::{impl#79}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8170 ~ std[d8a0]::ffi::os_str::{impl#79}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9068 ~ std[d8a0]::path::{impl#176}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9067 ~ std[d8a0]::path::{impl#176})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8153 ~ std[d8a0]::ffi::os_str::{impl#75}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8154 ~ std[d8a0]::ffi::os_str::{impl#75}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9039 ~ std[d8a0]::path::{impl#165}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9038 ~ std[d8a0]::path::{impl#165})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9036 ~ std[d8a0]::path::{impl#164}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9035 ~ std[d8a0]::path::{impl#164})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::partial_cmp(&std::path::Path, &&'a std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8137 ~ std[d8a0]::ffi::os_str::{impl#71}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8138 ~ std[d8a0]::ffi::os_str::{impl#71}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9025 ~ std[d8a0]::path::{impl#160})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8999 ~ std[d8a0]::path::{impl#149}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8998 ~ std[d8a0]::path::{impl#149})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9071 ~ std[d8a0]::path::{impl#177}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9070 ~ std[d8a0]::path::{impl#177})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::partial_cmp(&std::ffi::OsStr, &&'a std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9027 ~ std[d8a0]::path::{impl#161})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9126 ~ std[d8a0]::path::{impl#193}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:9127 ~ std[d8a0]::path::{impl#193}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9125 ~ std[d8a0]::path::{impl#193})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2221 ~ std[d8a0]::ffi::os_str::{impl#37}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Error: std::str::error::Utf8Error
not covered item Item { name: Some("Error"), item_id: DefId(DefId(1:2222 ~ std[d8a0]::ffi::os_str::{impl#37}::Error)), kind: AssocType, docs: "" }
"fn <&str as std::convert::TryFrom::<&std::ffi::OsStr>>::try_from(&'a std::ffi::OsStr) -> std::result::Result::<&'a str, <&'a str as std::convert::TryFrom::<&'a std::ffi::OsStr>>::Error>" is filtered.
Add std::convert::TryFrom::<&'a std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::os::unix::ffi::os_str::OsStrExt
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::os::unix::ffi::os_str::OsStrExt")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:4124 ~ std[d8a0]::os::unix::ffi::os_str::OsStrExt))
impl_def_id: DefId(1:4127 ~ std[d8a0]::os::unix::ffi::os_str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::os::unix::ffi::os_str::OsStrExt>::from_bytes(&[u8]) -> &std::ffi::OsStr" is filtered.
"fn <std::ffi::OsStr as std::os::unix::ffi::os_str::OsStrExt>::as_bytes(&std::ffi::OsStr) -> &[u8]" is filtered.
Add std::os::unix::ffi::os_str::OsStrExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(1:2259 ~ std[d8a0]::ffi::os_str::{impl#51}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::ffi::OsString
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:2260 ~ std[d8a0]::ffi::os_str::{impl#51}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&std::ffi::OsStr>>::join(&[S], &std::ffi::OsStr) -> std::ffi::OsString" is filtered.
Add std::slice::Join::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:2226 ~ std[d8a0]::ffi::os_str::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::default::Default>::default() -> &std::ffi::OsStr" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:2246 ~ std[d8a0]::ffi::os_str::{impl#47})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::hash::Hash>::hash(&std::ffi::OsStr, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::ffi::OsStr as std::hash::Hash>::hash_slice(&[std::ffi::OsStr], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:2234 ~ std[d8a0]::ffi::os_str::{impl#43})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8933 ~ std[d8a0]::path::{impl#127}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8932 ~ std[d8a0]::path::{impl#127})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8983 ~ std[d8a0]::path::{impl#143})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8993 ~ std[d8a0]::path::{impl#147}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8992 ~ std[d8a0]::path::{impl#147})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8923 ~ std[d8a0]::path::{impl#123})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:5367 ~ std[d8a0]::path::PathBuf)), segments: [PathSegment { name: "PathBuf", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::path::PathBuf")
type_def_id: Some(DefId(1:5367 ~ std[d8a0]::path::PathBuf))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:5438 ~ std[d8a0]::path::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::path::PathBuf"
std::path::PathBuf is not fuzzable
assoc types:
Target: std::path::Path
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:5439 ~ std[d8a0]::path::{impl#44}::Target)), kind: AssocType, docs: "" }
"fn <std::path::PathBuf as std::ops::Deref>::deref(&std::path::PathBuf) -> &std::path::Path" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8927 ~ std[d8a0]::path::{impl#125})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8939 ~ std[d8a0]::path::{impl#129}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8938 ~ std[d8a0]::path::{impl#129})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8987 ~ std[d8a0]::path::{impl#145})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8999 ~ std[d8a0]::path::{impl#149}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8998 ~ std[d8a0]::path::{impl#149})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7059 ~ std[d8a0]::sync::rwlock::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9466 ~ std[d8a0]::sync::rwlock::MappedRwLockWriteGuard)), segments: [PathSegment { name: "MappedRwLockWriteGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::MappedRwLockWriteGuard")
type_def_id: Some(DefId(1:9466 ~ std[d8a0]::sync::rwlock::MappedRwLockWriteGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7058 ~ std[d8a0]::sync::rwlock::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::MappedRwLockWriteGuard"
std::sync::rwlock::MappedRwLockWriteGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7060 ~ std[d8a0]::sync::rwlock::{impl#29}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::MappedRwLockWriteGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::MappedRwLockWriteGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4123 ~ core[b693]::array::equality::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4124 ~ core[b693]::array::equality::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4122 ~ core[b693]::array::equality::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::eq(&&mut [T], &[U;N]) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::ne(&&mut [T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4099 ~ core[b693]::array::equality::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4100 ~ core[b693]::array::equality::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4098 ~ core[b693]::array::equality::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::eq(&[T], &[U;N]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::ne(&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:4111 ~ core[b693]::array::equality::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:4112 ~ core[b693]::array::equality::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(2:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:4110 ~ core[b693]::array::equality::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::eq(&&[T], &[U;N]) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::ne(&&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5566 ~ alloc[2c7c]::slice::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(5:5567 ~ alloc[2c7c]::slice::{impl#3}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5568 ~ alloc[2c7c]::slice::{impl#3}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&T>>::join(&[V], &T) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:3661 ~ std[d8a0]::io::{impl#11}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:8510 ~ std[d8a0]::io::IoSlice)), segments: [PathSegment { name: "IoSlice", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::io::IoSlice")
type_def_id: Some(DefId(1:8510 ~ std[d8a0]::io::IoSlice))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:3660 ~ std[d8a0]::io::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::io::IoSlice"
std::io::IoSlice::<'_> is not fuzzable
assoc types:
Target: [u8]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:3662 ~ std[d8a0]::io::{impl#11}::Target)), kind: AssocType, docs: "" }
"fn <std::io::IoSlice::<'_> as std::ops::Deref>::deref(&std::io::IoSlice::<'_>) -> &[u8]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6096 ~ std[d8a0]::sync::lazy_lock::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(1:6097 ~ std[d8a0]::sync::lazy_lock::{impl#3}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:6075 ~ std[d8a0]::sync::lazy_lock::LazyLock)), segments: [PathSegment { name: "LazyLock", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::lazy_lock::LazyLock")
type_def_id: Some(DefId(1:6075 ~ std[d8a0]::sync::lazy_lock::LazyLock))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6095 ~ std[d8a0]::sync::lazy_lock::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::sync::lazy_lock::LazyLock"
std::sync::lazy_lock::LazyLock::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6098 ~ std[d8a0]::sync::lazy_lock::{impl#3}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::lazy_lock::LazyLock::<T, F> as std::ops::Deref>::deref(&std::sync::lazy_lock::LazyLock::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9053 ~ std[d8a0]::path::{impl#170})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8145 ~ std[d8a0]::ffi::os_str::{impl#73}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8146 ~ std[d8a0]::ffi::os_str::{impl#73}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9090 ~ std[d8a0]::path::{impl#182}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:9089 ~ std[d8a0]::path::{impl#182})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2149 ~ std[d8a0]::ffi::os_str::{impl#16}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8129 ~ std[d8a0]::ffi::os_str::{impl#69}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8130 ~ std[d8a0]::ffi::os_str::{impl#69}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:2089 ~ std[d8a0]::ffi::os_str::OsString)), segments: [PathSegment { name: "OsString", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::ffi::os_str::OsString")
type_def_id: Some(DefId(1:2089 ~ std[d8a0]::ffi::os_str::OsString))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:2128 ~ std[d8a0]::ffi::os_str::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsString"
std::ffi::OsString is not fuzzable
assoc types:
Target: std::ffi::OsStr
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:2129 ~ std[d8a0]::ffi::os_str::{impl#7}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::OsString as std::ops::Deref>::deref(&std::ffi::OsString) -> &std::ffi::OsStr" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:9096 ~ std[d8a0]::path::{impl#184}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9095 ~ std[d8a0]::path::{impl#184})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8153 ~ std[d8a0]::ffi::os_str::{impl#75}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8154 ~ std[d8a0]::ffi::os_str::{impl#75}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:8137 ~ std[d8a0]::ffi::os_str::{impl#71}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:8138 ~ std[d8a0]::ffi::os_str::{impl#71}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(1:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:9057 ~ std[d8a0]::path::{impl#172})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6654 ~ std[d8a0]::sync::mutex::{impl#12}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9423 ~ std[d8a0]::sync::mutex::MutexGuard)), segments: [PathSegment { name: "MutexGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::mutex::MutexGuard")
type_def_id: Some(DefId(1:9423 ~ std[d8a0]::sync::mutex::MutexGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6653 ~ std[d8a0]::sync::mutex::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::sync::mutex::MutexGuard"
std::sync::mutex::MutexGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6655 ~ std[d8a0]::sync::mutex::{impl#12}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::mutex::MutexGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::mutex::MutexGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3098 ~ core[b693]::convert::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3097 ~ core[b693]::convert::{impl#5})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6933 ~ std[d8a0]::sync::reentrant_lock::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:6905 ~ std[d8a0]::sync::reentrant_lock::ReentrantLockGuard)), segments: [PathSegment { name: "ReentrantLockGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::reentrant_lock::ReentrantLockGuard")
type_def_id: Some(DefId(1:6905 ~ std[d8a0]::sync::reentrant_lock::ReentrantLockGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6932 ~ std[d8a0]::sync::reentrant_lock::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::sync::reentrant_lock::ReentrantLockGuard"
std::sync::reentrant_lock::ReentrantLockGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6934 ~ std[d8a0]::sync::reentrant_lock::{impl#11}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::reentrant_lock::ReentrantLockGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::reentrant_lock::ReentrantLockGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:6685 ~ std[d8a0]::sync::mutex::{impl#18}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9428 ~ std[d8a0]::sync::mutex::MappedMutexGuard)), segments: [PathSegment { name: "MappedMutexGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::mutex::MappedMutexGuard")
type_def_id: Some(DefId(1:9428 ~ std[d8a0]::sync::mutex::MappedMutexGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:6684 ~ std[d8a0]::sync::mutex::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::sync::mutex::MappedMutexGuard"
std::sync::mutex::MappedMutexGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:6686 ~ std[d8a0]::sync::mutex::{impl#18}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::mutex::MappedMutexGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::mutex::MappedMutexGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7048 ~ std[d8a0]::sync::rwlock::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9456 ~ std[d8a0]::sync::rwlock::RwLockWriteGuard)), segments: [PathSegment { name: "RwLockWriteGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::RwLockWriteGuard")
type_def_id: Some(DefId(1:9456 ~ std[d8a0]::sync::rwlock::RwLockWriteGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7047 ~ std[d8a0]::sync::rwlock::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::RwLockWriteGuard"
std::sync::rwlock::RwLockWriteGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7049 ~ std[d8a0]::sync::rwlock::{impl#26}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::RwLockWriteGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::RwLockWriteGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:3642 ~ std[d8a0]::io::{impl#5}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:3625 ~ std[d8a0]::io::IoSliceMut)), segments: [PathSegment { name: "IoSliceMut", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::io::IoSliceMut")
type_def_id: Some(DefId(1:3625 ~ std[d8a0]::io::IoSliceMut))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:3641 ~ std[d8a0]::io::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::io::IoSliceMut"
std::io::IoSliceMut::<'_> is not fuzzable
assoc types:
Target: [u8]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:3643 ~ std[d8a0]::io::{impl#5}::Target)), kind: AssocType, docs: "" }
"fn <std::io::IoSliceMut::<'_> as std::ops::Deref>::deref(&std::io::IoSliceMut::<'_>) -> &[u8]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::eq(&std::ffi::OsStr, &str) -> bool" is filtered.
Add std::cmp::PartialEq::<str> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&str, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2149 ~ std[d8a0]::ffi::os_str::{impl#16}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&str) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5578 ~ std[d8a0]::path::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::path::Path>>::as_ref(&str) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::partial_cmp(&std::ffi::OsStr, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<str> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:2221 ~ std[d8a0]::ffi::os_str::{impl#37}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Error: std::str::error::Utf8Error
not covered item Item { name: Some("Error"), item_id: DefId(DefId(1:2222 ~ std[d8a0]::ffi::os_str::{impl#37}::Error)), kind: AssocType, docs: "" }
"fn <&str as std::convert::TryFrom::<&std::ffi::OsStr>>::try_from(&'a std::ffi::OsStr) -> std::result::Result::<&'a str, <&'a str as std::convert::TryFrom::<&'a std::ffi::OsStr>>::Error>" is filtered.
Add std::convert::TryFrom::<&'a std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::net::socket_addr::ToSocketAddrs
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::net::socket_addr::ToSocketAddrs")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3856 ~ std[d8a0]::net::socket_addr::ToSocketAddrs))
impl_def_id: DefId(1:3885 ~ std[d8a0]::net::socket_addr::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Iter: std::vec::into_iter::IntoIter::<std::net::SocketAddr>
not covered item Item { name: Some("Iter"), item_id: DefId(DefId(1:3886 ~ std[d8a0]::net::socket_addr::{impl#12}::Iter)), kind: AssocType, docs: "" }
"fn <str as std::net::ToSocketAddrs>::to_socket_addrs(&str) -> std::result::Result::<std::vec::into_iter::IntoIter::<std::net::SocketAddr>, std::io::Error>" is filtered.
Add std::net::ToSocketAddrs Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::ascii::AsciiExt
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::ascii::AsciiExt")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:646 ~ std[d8a0]::ascii::AsciiExt))
impl_def_id: DefId(1:661 ~ std[d8a0]::ascii::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Owned: std::string::String
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(1:662 ~ std[d8a0]::ascii::{impl#3}::Owned)), kind: AssocType, docs: "" }
"fn <str as std::ascii::AsciiExt>::is_ascii(&str) -> bool" is filtered.
"fn <str as std::ascii::AsciiExt>::to_ascii_uppercase(&str) -> <str as std::ascii::AsciiExt>::Owned" is filtered.
"fn <str as std::ascii::AsciiExt>::to_ascii_lowercase(&str) -> <str as std::ascii::AsciiExt>::Owned" is filtered.
"fn <str as std::ascii::AsciiExt>::eq_ignore_ascii_case(&str, &str) -> bool" is filtered.
"fn <str as std::ascii::AsciiExt>::make_ascii_uppercase(&mut str) -> ()" is filtered.
"fn <str as std::ascii::AsciiExt>::make_ascii_lowercase(&mut str) -> ()" is filtered.
Add std::ascii::AsciiExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(2:13307 ~ core[b693]::str::traits::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialOrd>::partial_cmp(&str, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <str as std::cmp::PartialOrd>::lt(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <str as std::cmp::PartialOrd>::le(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <str as std::cmp::PartialOrd>::gt(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <str as std::cmp::PartialOrd>::ge(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::error::Error
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::error::Error")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3153 ~ core[b693]::error::Error))
impl_def_id: DefId(2:13883 ~ core[b693]::str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Add std::error::Error Provide Method. is_local=false
[Impl] add default impl: source
"fn <&str as std::error::Error>::source(&&str) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'static\")))>" is filtered.
[Impl] add default impl: description
"fn <&str as std::error::Error>::description(&&str) -> &str" is filtered.
[Impl] add default impl: cause
"fn <&str as std::error::Error>::cause(&&str) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)>" is filtered.
[Impl] add default impl: provide
"fn <&str as std::error::Error>::provide(&'a &str, &mut std::error::Request::<'a>) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(2:13592 ~ core[b693]::str::pattern::{impl#31}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(2:13593 ~ core[b693]::str::pattern::{impl#31}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::str::pattern::Pattern
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::pattern::Pattern")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:13443 ~ core[b693]::str::pattern::Pattern))
impl_def_id: DefId(2:13591 ~ core[b693]::str::pattern::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Searcher: std::str::pattern::StrSearcher::<'a, 'b>
not covered item Item { name: Some("Searcher"), item_id: DefId(DefId(2:13594 ~ core[b693]::str::pattern::{impl#31}::Searcher)), kind: AssocType, docs: "" }
"fn <&str as std::str::pattern::Pattern::<'_>>::into_searcher(&str, &'a str) -> std::str::pattern::StrSearcher::<'a, 'b>" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_prefix_of(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_contained_in(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::strip_prefix_of(&str, &'a str) -> std::option::Option::<&'a str>" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_suffix_of(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::strip_suffix_of(&str, &'a str) -> std::option::Option::<&'a str>" is filtered.
Add std::str::pattern::Pattern::<'a> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(2:32835 ~ core[b693]::marker::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(2:10962 ~ core[b693]::hash::impls::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::hash::Hash>::hash(&str, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <str as std::hash::Hash>::hash_slice(&[str], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(2:10771 ~ core[b693]::fmt::{impl#17})
is_local_impl: false
is_external_type: true
type_name: "std::str"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(2:10767 ~ core[b693]::fmt::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::ConstParamTy
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::ConstParamTy")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:32908 ~ core[b693]::marker::ConstParamTy))
impl_def_id: DefId(2:32923 ~ core[b693]::marker::{impl#90})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::marker::ConstParamTy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:13314 ~ core[b693]::str::traits::{impl#5}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::IndexMut
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(2:13313 ~ core[b693]::str::traits::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::ops::IndexMut::<I>>::index_mut(&mut str, I) -> &mut <I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
Add std::ops::IndexMut::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(2:13310 ~ core[b693]::str::traits::{impl#4}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::Index
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(2:13309 ~ core[b693]::str::traits::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Output: <I as std::slice::index::SliceIndex::<str>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(2:13311 ~ core[b693]::str::traits::{impl#4}::Output)), kind: AssocType, docs: "" }
"fn <str as std::ops::Index::<I>>::index(&str, I) -> &<I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
Add std::ops::Index::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(2:13306 ~ core[b693]::str::traits::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsMut
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(2:3118 ~ core[b693]::convert::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsMut::<str>>::as_mut(&mut str) -> &mut str" is filtered.
Add std::convert::AsMut::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(2:13304 ~ core[b693]::str::traits::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq>::eq(&str, &str) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:13881 ~ core[b693]::str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&mut str is not fuzzable
assoc types:
"fn <&mut str as std::default::Default>::default() -> &mut str" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(2:13879 ~ core[b693]::str::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::default::Default>::default() -> &str" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(2:13302 ~ core[b693]::str::traits::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::Ord>::cmp(&str, &str) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <str as std::cmp::Ord>::max(str, str) -> str" is filtered.
[Impl] add default impl: min
"fn <str as std::cmp::Ord>::min(str, str) -> str" is filtered.
[Impl] add default impl: clamp
"fn <str as std::cmp::Ord>::clamp(str, str, str) -> str" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:13877 ~ core[b693]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<[u8]>>::as_ref(&str) -> &[u8]" is filtered.
Add std::convert::AsRef::<[u8]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(2:3116 ~ core[b693]::convert::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<str>>::as_ref(&str) -> &str" is filtered.
Add std::convert::AsRef::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7793 ~ alloc[2c7c]::string::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7794 ~ alloc[2c7c]::string::{impl#82}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7792 ~ alloc[2c7c]::string::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::string::String>>::eq(&str, &std::string::String) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::string::String>>::ne(&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7813 ~ alloc[2c7c]::string::{impl#86}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7814 ~ alloc[2c7c]::string::{impl#86}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7812 ~ alloc[2c7c]::string::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7823 ~ alloc[2c7c]::string::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7824 ~ alloc[2c7c]::string::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7822 ~ alloc[2c7c]::string::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:7803 ~ alloc[2c7c]::string::{impl#84}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:7804 ~ alloc[2c7c]::string::{impl#84}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:7802 ~ alloc[2c7c]::string::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::string::String>>::eq(&&str, &std::string::String) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::string::String>>::ne(&&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Primitive(Str)
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: None
impl_def_id: DefId(2:13742 ~ core[b693]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn str::len(&str) -> usize" is filtered.
"fn str::is_empty(&str) -> bool" is filtered.
"fn str::is_char_boundary(&str, usize) -> bool" is filtered.
"fn str::floor_char_boundary(&str, usize) -> usize" is filtered.
"fn str::ceil_char_boundary(&str, usize) -> usize" is filtered.
"fn str::as_bytes(&str) -> &[u8]" is filtered.
"fn str::as_bytes_mut(&mut str) -> &mut [u8]" is filtered.
"fn str::as_ptr(&str) -> *const u8" is filtered.
"fn str::as_mut_ptr(&mut str) -> *u8" is filtered.
"fn str::get(&str, I) -> std::option::Option::<&<I as std::slice::index::SliceIndex::<str>>::Output>" is filtered.
"fn str::get_mut(&mut str, I) -> std::option::Option::<&mut <I as std::slice::index::SliceIndex::<str>>::Output>" is filtered.
"fn str::get_unchecked(&str, I) -> &<I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
"fn str::get_unchecked_mut(&mut str, I) -> &mut <I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
"fn str::slice_unchecked(&str, usize, usize) -> &str" is filtered.
"fn str::slice_mut_unchecked(&mut str, usize, usize) -> &mut str" is filtered.
"fn str::split_at(&str, usize) -> (&str ,&str)" is filtered.
"fn str::split_at_mut(&mut str, usize) -> (&mut str ,&mut str)" is filtered.
"fn str::split_at_checked(&str, usize) -> std::option::Option::<(&str ,&str)>" is filtered.
"fn str::split_at_mut_checked(&mut str, usize) -> std::option::Option::<(&mut str ,&mut str)>" is filtered.
"fn str::chars(&str) -> std::str::iter::Chars::<'_>" is filtered.
"fn str::char_indices(&str) -> std::str::iter::CharIndices::<'_>" is filtered.
"fn str::bytes(&str) -> std::str::iter::Bytes::<'_>" is filtered.
"fn str::split_whitespace(&str) -> std::str::iter::SplitWhitespace::<'_>" is filtered.
"fn str::split_ascii_whitespace(&str) -> std::str::iter::SplitAsciiWhitespace::<'_>" is filtered.
"fn str::lines(&str) -> std::str::iter::Lines::<'_>" is filtered.
"fn str::lines_any(&str) -> std::str::iter::LinesAny::<'_>" is filtered.
"fn str::encode_utf16(&str) -> std::str::iter::EncodeUtf16::<'_>" is filtered.
"fn str::contains(&'a str, P) -> bool" is filtered.
"fn str::starts_with(&'a str, P) -> bool" is filtered.
"fn str::ends_with(&'a str, P) -> bool" is filtered.
"fn str::find(&'a str, P) -> std::option::Option::<usize>" is filtered.
"fn str::rfind(&'a str, P) -> std::option::Option::<usize>" is filtered.
"fn str::split(&'a str, P) -> std::str::iter::Split::<'a, P>" is filtered.
"fn str::split_inclusive(&'a str, P) -> std::str::iter::SplitInclusive::<'a, P>" is filtered.
"fn str::rsplit(&'a str, P) -> std::str::iter::RSplit::<'a, P>" is filtered.
"fn str::split_terminator(&'a str, P) -> std::str::iter::SplitTerminator::<'a, P>" is filtered.
"fn str::rsplit_terminator(&'a str, P) -> std::str::iter::RSplitTerminator::<'a, P>" is filtered.
"fn str::splitn(&'a str, usize, P) -> std::str::iter::SplitN::<'a, P>" is filtered.
"fn str::rsplitn(&'a str, usize, P) -> std::str::iter::RSplitN::<'a, P>" is filtered.
"fn str::split_once(&'a str, P) -> std::option::Option::<(&'a str ,&'a str)>" is filtered.
"fn str::rsplit_once(&'a str, P) -> std::option::Option::<(&'a str ,&'a str)>" is filtered.
"fn str::matches(&'a str, P) -> std::str::iter::Matches::<'a, P>" is filtered.
"fn str::rmatches(&'a str, P) -> std::str::iter::RMatches::<'a, P>" is filtered.
"fn str::match_indices(&'a str, P) -> std::str::iter::MatchIndices::<'a, P>" is filtered.
"fn str::rmatch_indices(&'a str, P) -> std::str::iter::RMatchIndices::<'a, P>" is filtered.
"fn str::trim(&str) -> &str" is filtered.
"fn str::trim_start(&str) -> &str" is filtered.
"fn str::trim_end(&str) -> &str" is filtered.
"fn str::trim_left(&str) -> &str" is filtered.
"fn str::trim_right(&str) -> &str" is filtered.
"fn str::trim_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_start_matches(&'a str, P) -> &'a str" is filtered.
"fn str::strip_prefix(&'a str, P) -> std::option::Option::<&'a str>" is filtered.
"fn str::strip_suffix(&'a str, P) -> std::option::Option::<&'a str>" is filtered.
"fn str::trim_end_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_left_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_right_matches(&'a str, P) -> &'a str" is filtered.
"fn str::parse(&str) -> std::result::Result::<F, <F as std::str::FromStr>::Err>" is filtered.
"fn str::is_ascii(&str) -> bool" is filtered.
"fn str::as_ascii(&str) -> std::option::Option::<&[std::ascii::ascii_char::AsciiChar]>" is filtered.
"fn str::eq_ignore_ascii_case(&str, &str) -> bool" is filtered.
"fn str::make_ascii_uppercase(&mut str) -> ()" is filtered.
"fn str::make_ascii_lowercase(&mut str) -> ()" is filtered.
"fn str::trim_ascii_start(&str) -> &str" is filtered.
"fn str::trim_ascii_end(&str) -> &str" is filtered.
"fn str::trim_ascii(&str) -> &str" is filtered.
"fn str::escape_debug(&str) -> std::str::iter::EscapeDebug::<'_>" is filtered.
"fn str::escape_default(&str) -> std::str::iter::EscapeDefault::<'_>" is filtered.
"fn str::escape_unicode(&str) -> std::str::iter::EscapeUnicode::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Primitive(Str)
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: None
impl_def_id: DefId(5:5701 ~ alloc[2c7c]::str::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn str::into_boxed_bytes(std::boxed::Box::<str>) -> std::boxed::Box::<[u8]>" is filtered.
"fn str::replace(&'a str, P, &str) -> std::string::String" is filtered.
"fn str::replacen(&'a str, P, &str, usize) -> std::string::String" is filtered.
"fn str::to_lowercase(&str) -> std::string::String" is filtered.
"fn str::to_uppercase(&str) -> std::string::String" is filtered.
"fn str::into_string(std::boxed::Box::<str>) -> std::string::String" is filtered.
"fn str::repeat(&str, usize) -> std::string::String" is filtered.
"fn str::to_ascii_uppercase(&str) -> std::string::String" is filtered.
"fn str::to_ascii_lowercase(&str) -> std::string::String" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5681 ~ alloc[2c7c]::str::{impl#1}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:5680 ~ alloc[2c7c]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5682 ~ alloc[2c7c]::str::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&str>>::join(&[S], &str) -> std::string::String" is filtered.
Add std::slice::Join::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:5677 ~ alloc[2c7c]::str::{impl#0}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(1:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(5:5676 ~ alloc[2c7c]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:5678 ~ alloc[2c7c]::str::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Concat::<str>>::concat(&[S]) -> std::string::String" is filtered.
Add std::slice::Concat::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::str")
type_def_id: Some(DefId(1:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:5697 ~ alloc[2c7c]::str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Owned: std::string::String
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:5698 ~ alloc[2c7c]::str::{impl#4}::Owned)), kind: AssocType, docs: "" }
"fn <str as std::borrow::ToOwned>::to_owned(&str) -> std::string::String" is filtered.
"fn <str as std::borrow::ToOwned>::clone_into(&str, &mut std::string::String) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:7044 ~ std[d8a0]::sync::rwlock::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9451 ~ std[d8a0]::sync::rwlock::RwLockReadGuard)), segments: [PathSegment { name: "RwLockReadGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::RwLockReadGuard")
type_def_id: Some(DefId(1:9451 ~ std[d8a0]::sync::rwlock::RwLockReadGuard))
trait_def_id: Some(DefId(2:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:7043 ~ std[d8a0]::sync::rwlock::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::RwLockReadGuard"
std::sync::rwlock::RwLockReadGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:7045 ~ std[d8a0]::sync::rwlock::{impl#25}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::RwLockReadGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::RwLockReadGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(2:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(2:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(2:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(2:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(2:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(2:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(2:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(2:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(2:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(2:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(2:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(2:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(2:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:5954 ~ alloc[2c7c]::string::{impl#32}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: alloc::string::ToString
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::string::ToString")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(5:5951 ~ alloc[2c7c]::string::ToString))
impl_def_id: DefId(5:5953 ~ alloc[2c7c]::string::{impl#32})
is_local_impl: false
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(0:117 ~ strsim[f974]::{impl#9})
is_local_impl: true
is_external_type: false
type_name: "strsim::StrSimError"
strsim::StrSimError is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(0:118 ~ strsim[f974]::{impl#10})
is_local_impl: true
is_external_type: false
type_name: "strsim::StrSimError"
strsim::StrSimError is not fuzzable
assoc types:
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <strsim::StrSimError as std::cmp::PartialEq>::ne(&strsim::StrSimError, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(0:17 ~ strsim[f974]::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:115 ~ strsim[f974]::{impl#8})
is_local_impl: true
is_external_type: false
type_name: "strsim::StrSimError"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::error::Error
impl for: Path { path: Path { res: Def(Enum, DefId(0:112 ~ strsim[f974]::StrSimError)), segments: [PathSegment { name: "StrSimError", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::error::Error")
type_full_name: Some("strsim::StrSimError")
type_def_id: Some(DefId(0:112 ~ strsim[f974]::StrSimError))
trait_def_id: Some(DefId(2:3153 ~ core[b693]::error::Error))
impl_def_id: DefId(0:19 ~ strsim[f974]::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "strsim::StrSimError"
strsim::StrSimError is not fuzzable
assoc types:
Add std::error::Error Provide Method. is_local=false
[Impl] add default impl: source
"fn <strsim::StrSimError as std::error::Error>::source(&strsim::StrSimError) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'static\")))>" is filtered.
[Impl] add default impl: description
"fn <strsim::StrSimError as std::error::Error>::description(&strsim::StrSimError) -> &str" is filtered.
[Impl] add default impl: cause
"fn <strsim::StrSimError as std::error::Error>::cause(&strsim::StrSimError) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(2:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)>" is filtered.
[Impl] add default impl: provide
"fn <strsim::StrSimError as std::error::Error>::provide(&'a strsim::StrSimError, &mut std::error::Request::<'a>) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<

visibility: ModVisibity { crate_name: "strsim", inner: {"strsim": Public} }

type std::sync::rwlock::MappedRwLockWriteGuard implement 1 traits: 
DefId(1:7058 ~ std[d8a0]::sync::rwlock::{impl#29}): impl std::ops::Deref for std::sync::rwlock::MappedRwLockWriteGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::path::PathBuf implement 1 traits: 
DefId(1:5438 ~ std[d8a0]::path::{impl#44}): impl std::ops::Deref for std::path::PathBuf
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::path::Path implement 55 traits: 
DefId(1:9073 ~ std[d8a0]::path::{impl#178}): impl std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8957 ~ std[d8a0]::path::{impl#135}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9041 ~ std[d8a0]::path::{impl#166}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8944 ~ std[d8a0]::path::{impl#131}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8950 ~ std[d8a0]::path::{impl#133}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9081 ~ std[d8a0]::path::{impl#180}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9047 ~ std[d8a0]::path::{impl#168}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8965 ~ std[d8a0]::path::{impl#137}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9021 ~ std[d8a0]::path::{impl#158}): impl std::cmp::PartialEq::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9053 ~ std[d8a0]::path::{impl#170}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8932 ~ std[d8a0]::path::{impl#127}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9029 ~ std[d8a0]::path::{impl#162}): impl std::cmp::PartialEq::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9073 ~ std[d8a0]::path::{impl#178}): impl std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5560 ~ std[d8a0]::path::{impl#68}): impl std::cmp::PartialEq for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8957 ~ std[d8a0]::path::{impl#135}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8923 ~ std[d8a0]::path::{impl#123}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9041 ~ std[d8a0]::path::{impl#166}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9089 ~ std[d8a0]::path::{impl#182}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8944 ~ std[d8a0]::path::{impl#131}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9061 ~ std[d8a0]::path::{impl#174}): impl std::cmp::PartialEq::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5467 ~ std[d8a0]::path::{impl#56}): impl std::borrow::ToOwned for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5551 ~ std[d8a0]::path::{impl#65}): impl std::fmt::Debug for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5549 ~ std[d8a0]::path::{impl#64}): impl std::convert::AsRef::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5570 ~ std[d8a0]::path::{impl#73}): impl std::convert::AsRef::<std::path::Path> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5568 ~ std[d8a0]::path::{impl#72}): impl std::cmp::Ord for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8927 ~ std[d8a0]::path::{impl#125}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8938 ~ std[d8a0]::path::{impl#129}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8950 ~ std[d8a0]::path::{impl#133}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9095 ~ std[d8a0]::path::{impl#184}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9067 ~ std[d8a0]::path::{impl#176}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9035 ~ std[d8a0]::path::{impl#164}): impl std::cmp::PartialOrd::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9081 ~ std[d8a0]::path::{impl#180}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9047 ~ std[d8a0]::path::{impl#168}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8965 ~ std[d8a0]::path::{impl#137}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9025 ~ std[d8a0]::path::{impl#160}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5566 ~ std[d8a0]::path::{impl#71}): impl std::cmp::PartialOrd for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9057 ~ std[d8a0]::path::{impl#172}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5589 ~ std[d8a0]::path::{impl#81}): impl std::iter::traits::collect::IntoIterator for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5562 ~ std[d8a0]::path::{impl#69}): impl std::hash::Hash for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5565 ~ std[d8a0]::path::{impl#70}): impl std::cmp::Eq for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9021 ~ std[d8a0]::path::{impl#158}): impl std::cmp::PartialEq::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9029 ~ std[d8a0]::path::{impl#162}): impl std::cmp::PartialEq::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9061 ~ std[d8a0]::path::{impl#174}): impl std::cmp::PartialEq::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5549 ~ std[d8a0]::path::{impl#64}): impl std::convert::AsRef::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9067 ~ std[d8a0]::path::{impl#176}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9035 ~ std[d8a0]::path::{impl#164}): impl std::cmp::PartialOrd::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9025 ~ std[d8a0]::path::{impl#160}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8932 ~ std[d8a0]::path::{impl#127}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8923 ~ std[d8a0]::path::{impl#123}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8927 ~ std[d8a0]::path::{impl#125}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8938 ~ std[d8a0]::path::{impl#129}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9053 ~ std[d8a0]::path::{impl#170}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9089 ~ std[d8a0]::path::{impl#182}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9095 ~ std[d8a0]::path::{impl#184}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9057 ~ std[d8a0]::path::{impl#172}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::rwlock::RwLockReadGuard implement 1 traits: 
DefId(1:7043 ~ std[d8a0]::sync::rwlock::{impl#25}): impl std::ops::Deref for std::sync::rwlock::RwLockReadGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::c_str::CStr implement 11 traits: 
DefId(2:5268 ~ core[b693]::ffi::c_str::{impl#9}): impl std::cmp::PartialOrd for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:41118 ~ core[b693]::ffi::c_str::{impl#18}): impl std::hash::Hash for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5242 ~ core[b693]::ffi::c_str::{impl#3}): impl std::fmt::Debug for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11}): impl std::ops::Index::<std::ops::range::RangeFrom::<usize>> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5267 ~ core[b693]::ffi::c_str::{impl#8}): impl std::cmp::Eq for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5265 ~ core[b693]::ffi::c_str::{impl#7}): impl std::cmp::PartialEq for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5244 ~ core[b693]::ffi::c_str::{impl#4}): impl std::default::Default for &std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5270 ~ core[b693]::ffi::c_str::{impl#10}): impl std::cmp::Ord for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5275 ~ core[b693]::ffi::c_str::{impl#12}): impl std::convert::AsRef::<std::ffi::CStr> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4872 ~ alloc[2c7c]::ffi::c_str::{impl#30}): impl std::borrow::ToOwned for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5272 ~ core[b693]::ffi::c_str::{impl#11}): impl std::ops::Index::<std::ops::range::RangeFrom::<usize>> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::sync::Arc implement 1 traits: 
DefId(5:6291 ~ alloc[2c7c]::sync::{impl#29}): impl std::ops::Deref for std::sync::Arc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::pin::Pin implement 1 traits: 
DefId(2:9692 ~ core[b693]::pin::{impl#13}): impl std::ops::Deref for std::pin::Pin::<Ptr>
bounds: GenericParamMap { inner: {"Ptr": []}, generic_defs: ["Ptr"], type_pred: [(Generic("Ptr"), [Path { res: Def(Trait, DefId(2:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::panic::unwind_safe::AssertUnwindSafe implement 1 traits: 
DefId(2:9523 ~ core[b693]::panic::unwind_safe::{impl#21}): impl std::ops::Deref for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }

type std::io::IoSlice implement 1 traits: 
DefId(1:3660 ~ std[d8a0]::io::{impl#11}): impl std::ops::Deref for std::io::IoSlice::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::lazy_lock::LazyLock implement 1 traits: 
DefId(1:6095 ~ std[d8a0]::sync::lazy_lock::{impl#3}): impl std::ops::Deref for std::sync::lazy_lock::LazyLock::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type std::sync::rwlock::MappedRwLockReadGuard implement 1 traits: 
DefId(1:7054 ~ std[d8a0]::sync::rwlock::{impl#28}): impl std::ops::Deref for std::sync::rwlock::MappedRwLockReadGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::rc::Rc implement 1 traits: 
DefId(5:5149 ~ alloc[2c7c]::rc::{impl#25}): impl std::ops::Deref for std::rc::Rc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::ffi::os_str::OsStr implement 60 traits: 
DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9117 ~ std[d8a0]::path::{impl#191}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9104 ~ std[d8a0]::path::{impl#187}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9110 ~ std[d8a0]::path::{impl#189}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9125 ~ std[d8a0]::path::{impl#193}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9023 ~ std[d8a0]::path::{impl#159}): impl std::cmp::PartialEq::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9032 ~ std[d8a0]::path::{impl#163}): impl std::cmp::PartialEq::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9064 ~ std[d8a0]::path::{impl#175}): impl std::cmp::PartialEq::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5572 ~ std[d8a0]::path::{impl#74}): impl std::convert::AsRef::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9038 ~ std[d8a0]::path::{impl#165}): impl std::cmp::PartialOrd::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9070 ~ std[d8a0]::path::{impl#177}): impl std::cmp::PartialOrd::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9027 ~ std[d8a0]::path::{impl#161}): impl std::cmp::PartialOrd::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9023 ~ std[d8a0]::path::{impl#159}): impl std::cmp::PartialEq::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8160 ~ std[d8a0]::ffi::os_str::{impl#77}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8983 ~ std[d8a0]::path::{impl#143}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41}): impl std::cmp::PartialEq::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8992 ~ std[d8a0]::path::{impl#147}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2228 ~ std[d8a0]::ffi::os_str::{impl#40}): impl std::cmp::PartialEq for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9117 ~ std[d8a0]::path::{impl#191}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9032 ~ std[d8a0]::path::{impl#163}): impl std::cmp::PartialEq::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9064 ~ std[d8a0]::path::{impl#175}): impl std::cmp::PartialEq::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8176 ~ std[d8a0]::ffi::os_str::{impl#81}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9104 ~ std[d8a0]::path::{impl#187}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2265 ~ std[d8a0]::ffi::os_str::{impl#53}): impl std::borrow::ToOwned for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2249 ~ std[d8a0]::ffi::os_str::{impl#48}): impl std::fmt::Debug for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2269 ~ std[d8a0]::ffi::os_str::{impl#54}): impl std::convert::AsRef::<std::ffi::OsStr> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5572 ~ std[d8a0]::path::{impl#74}): impl std::convert::AsRef::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2243 ~ std[d8a0]::ffi::os_str::{impl#46}): impl std::cmp::Ord for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9110 ~ std[d8a0]::path::{impl#189}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8184 ~ std[d8a0]::ffi::os_str::{impl#83}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2235 ~ std[d8a0]::ffi::os_str::{impl#44}): impl std::cmp::PartialOrd for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45}): impl std::cmp::PartialOrd::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8987 ~ std[d8a0]::path::{impl#145}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8168 ~ std[d8a0]::ffi::os_str::{impl#79}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9038 ~ std[d8a0]::path::{impl#165}): impl std::cmp::PartialOrd::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8998 ~ std[d8a0]::path::{impl#149}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9070 ~ std[d8a0]::path::{impl#177}): impl std::cmp::PartialOrd::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9027 ~ std[d8a0]::path::{impl#161}): impl std::cmp::PartialOrd::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:9125 ~ std[d8a0]::path::{impl#193}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:4127 ~ std[d8a0]::os::unix::ffi::os_str::{impl#1}): impl std::os::unix::ffi::os_str::OsStrExt for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2226 ~ std[d8a0]::ffi::os_str::{impl#39}): impl std::default::Default for &std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2246 ~ std[d8a0]::ffi::os_str::{impl#47}): impl std::hash::Hash for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2234 ~ std[d8a0]::ffi::os_str::{impl#43}): impl std::cmp::Eq for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8983 ~ std[d8a0]::path::{impl#143}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8992 ~ std[d8a0]::path::{impl#147}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8987 ~ std[d8a0]::path::{impl#145}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8998 ~ std[d8a0]::path::{impl#149}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8144 ~ std[d8a0]::ffi::os_str::{impl#73}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8128 ~ std[d8a0]::ffi::os_str::{impl#69}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8152 ~ std[d8a0]::ffi::os_str::{impl#75}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:8136 ~ std[d8a0]::ffi::os_str::{impl#71}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2230 ~ std[d8a0]::ffi::os_str::{impl#41}): impl std::cmp::PartialEq::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2241 ~ std[d8a0]::ffi::os_str::{impl#45}): impl std::cmp::PartialOrd::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::Ref implement 1 traits: 
DefId(2:4846 ~ core[b693]::cell::{impl#37}): impl std::ops::Deref for std::cell::Ref::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::boxed::Box implement 1 traits: 
DefId(5:501 ~ alloc[2c7c]::boxed::{impl#38}): impl std::ops::Deref for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::ffi::os_str::OsString implement 1 traits: 
DefId(1:2128 ~ std[d8a0]::ffi::os_str::{impl#7}): impl std::ops::Deref for std::ffi::OsString
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::io::IoSliceMut implement 1 traits: 
DefId(1:3641 ~ std[d8a0]::io::{impl#5}): impl std::ops::Deref for std::io::IoSliceMut::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::result::Result implement 25 traits: 
DefId(9:222 ~ miniz_oxide[68e8]::{impl#3}): impl std::convert::From::<miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(9:224 ~ miniz_oxide[68e8]::{impl#4}): impl std::convert::From::<&miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10099 ~ core[b693]::result::{impl#28}): impl std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> for std::result::Result::<T, F>
bounds: GenericParamMap { inner: {"T": [], "E": [], "F": []}, generic_defs: ["T", "E", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }])] }
DefId(1:5827 ~ std[d8a0]::process::{impl#61}): impl std::process::Termination for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:5817 ~ std[d8a0]::process::Termination)), segments: [PathSegment { name: "Termination", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10080 ~ core[b693]::result::{impl#25}): impl std::iter::traits::collect::FromIterator::<std::result::Result::<A, E>> for std::result::Result::<V, E>
bounds: GenericParamMap { inner: {"V": [], "A": [], "E": []}, generic_defs: ["A", "E", "V"], type_pred: [(Generic("V"), [Path { res: Def(Trait, DefId(2:8314 ~ core[b693]::iter::traits::collect::FromIterator)), segments: [PathSegment { name: "FromIterator", args: AngleBracketed { args: [Type(Generic("A"))], constraints: [] } }] }])] }
DefId(2:42854 ~ core[b693]::result::{impl#30}): impl std::marker::Copy for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42864 ~ core[b693]::result::{impl#33}): impl std::cmp::PartialOrd for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:8293 ~ core[b693]::iter::traits::accum::{impl#1}): impl std::iter::traits::accum::Product::<std::result::Result::<U, E>> for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": [], "U": []}, generic_defs: ["T", "U", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:8280 ~ core[b693]::iter::traits::accum::Product)), segments: [PathSegment { name: "Product", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:42857 ~ core[b693]::result::{impl#31}): impl std::marker::StructuralPartialEq for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:42880 ~ core[b693]::result::{impl#37}): impl std::hash::Hash for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10104 ~ core[b693]::result::{impl#29}): impl std::ops::try_trait::Residual::<T> for std::result::Result::<std::convert::Infallible, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:10017 ~ core[b693]::result::{impl#7}): impl std::iter::traits::collect::IntoIterator for &'a std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:10024 ~ core[b693]::result::{impl#8}): impl std::iter::traits::collect::IntoIterator for &'a mut std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:10011 ~ core[b693]::result::{impl#6}): impl std::iter::traits::collect::IntoIterator for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(2:42876 ~ core[b693]::result::{impl#36}): impl std::fmt::Debug for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42868 ~ core[b693]::result::{impl#34}): impl std::cmp::Eq for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10006 ~ core[b693]::result::{impl#5}): impl std::clone::Clone for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42860 ~ core[b693]::result::{impl#32}): impl std::cmp::PartialEq for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:42872 ~ core[b693]::result::{impl#35}): impl std::cmp::Ord for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("E"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10094 ~ core[b693]::result::{impl#27}): impl std::ops::try_trait::FromResidual::<std::result::Result::<std::convert::Infallible, E>> for std::result::Result::<T, F>
bounds: GenericParamMap { inner: {"T": [], "E": [], "F": []}, generic_defs: ["T", "E", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }])] }
DefId(2:10099 ~ core[b693]::result::{impl#28}): impl std::ops::try_trait::FromResidual::<std::ops::try_trait::Yeet::<E>> for std::result::Result::<T, F>
bounds: GenericParamMap { inner: {"T": [], "E": [], "F": []}, generic_defs: ["T", "E", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("E"))], constraints: [] } }] }])] }
DefId(2:8286 ~ core[b693]::iter::traits::accum::{impl#0}): impl std::iter::traits::accum::Sum::<std::result::Result::<U, E>> for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": [], "U": []}, generic_defs: ["T", "U", "E"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:8276 ~ core[b693]::iter::traits::accum::Sum)), segments: [PathSegment { name: "Sum", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:10087 ~ core[b693]::result::{impl#26}): impl std::ops::try_trait::Try for std::result::Result::<T, E>
bounds: GenericParamMap { inner: {"T": [], "E": []}, generic_defs: ["T", "E"], type_pred: [] }
DefId(9:222 ~ miniz_oxide[68e8]::{impl#3}): impl std::convert::From::<miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(9:224 ~ miniz_oxide[68e8]::{impl#4}): impl std::convert::From::<&miniz_oxide::StreamResult> for std::result::Result::<miniz_oxide::MZStatus, miniz_oxide::MZError>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::boxed::thin::ThinBox implement 1 traits: 
DefId(5:235 ~ alloc[2c7c]::boxed::thin::{impl#6}): impl std::ops::Deref for std::boxed::thin::ThinBox::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::slice implement 49 traits: 
DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &[T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:3237 ~ std[d8a0]::io::impls::{impl#10}): impl std::io::Write for &mut [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3888 ~ std[d8a0]::net::socket_addr::{impl#13}): impl std::net::ToSocketAddrs for &'a [std::net::SocketAddr]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51}): impl std::slice::Join::<&std::ffi::OsStr> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }])] }
DefId(1:3234 ~ std[d8a0]::io::impls::{impl#9}): impl std::io::BufRead for &[u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3224 ~ std[d8a0]::io::impls::{impl#8}): impl std::io::Read for &[u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:659 ~ std[d8a0]::ascii::{impl#2}): impl std::ascii::AsciiExt for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:11474 ~ core[b693]::slice::cmp::{impl#3}): impl std::cmp::PartialOrd for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:13569 ~ core[b693]::str::pattern::{impl#24}): impl std::str::pattern::Pattern::<'a> for &'b [char]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32840 ~ core[b693]::marker::{impl#35}): impl std::marker::StructuralPartialEq for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:10971 ~ core[b693]::hash::impls::{impl#4}): impl std::hash::Hash for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:11728 ~ core[b693]::slice::iter::{impl#1}): impl std::iter::traits::collect::IntoIterator for &'a [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:11734 ~ core[b693]::slice::iter::{impl#2}): impl std::iter::traits::collect::IntoIterator for &'a mut [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:2823 ~ core[b693]::clone::{impl#2}): impl std::clone::CloneToUninit for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2826 ~ core[b693]::clone::{impl#3}): impl std::clone::CloneToUninit for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:10801 ~ core[b693]::fmt::{impl#26}): impl std::fmt::Debug for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:32928 ~ core[b693]::marker::{impl#93}): impl std::marker::ConstParamTy for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32908 ~ core[b693]::marker::ConstParamTy)), segments: [PathSegment { name: "ConstParamTy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:11526 ~ core[b693]::slice::index::{impl#1}): impl std::ops::IndexMut::<I> for [T]
bounds: GenericParamMap { inner: {"T": [], "I": []}, generic_defs: ["T", "I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(2:11521 ~ core[b693]::slice::index::{impl#0}): impl std::ops::Index::<I> for [T]
bounds: GenericParamMap { inner: {"T": [], "I": []}, generic_defs: ["T", "I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(2:11469 ~ core[b693]::slice::cmp::{impl#1}): impl std::cmp::Eq for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3113 ~ core[b693]::convert::{impl#9}): impl std::convert::AsMut::<[T]> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:12933 ~ core[b693]::slice::{impl#8}): impl std::slice::SlicePattern for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:4122 ~ core[b693]::array::equality::{impl#6}): impl std::cmp::PartialEq::<[U;N]> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4098 ~ core[b693]::array::equality::{impl#2}): impl std::cmp::PartialEq::<[U;N]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4110 ~ core[b693]::array::equality::{impl#4}): impl std::cmp::PartialEq::<[U;N]> for &[T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:11464 ~ core[b693]::slice::cmp::{impl#0}): impl std::cmp::PartialEq::<[U]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:12927 ~ core[b693]::slice::{impl#7}): impl std::default::Default for &mut [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:12924 ~ core[b693]::slice::{impl#6}): impl std::default::Default for &[T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:11471 ~ core[b693]::slice::cmp::{impl#2}): impl std::cmp::Ord for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:11726 ~ core[b693]::slice::iter::{impl#0}): impl std::iter::traits::iterator::Iterator for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3110 ~ core[b693]::convert::{impl#8}): impl std::convert::AsRef::<[T]> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(5:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &[T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:5680 ~ alloc[2c7c]::str::{impl#1}): impl std::slice::Join::<&str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3}): impl std::slice::Join::<&T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5571 ~ alloc[2c7c]::slice::{impl#4}): impl std::slice::Join::<&[T]> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5676 ~ alloc[2c7c]::str::{impl#0}): impl std::slice::Concat::<str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(5:5559 ~ alloc[2c7c]::slice::{impl#2}): impl std::slice::Concat::<T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5597 ~ alloc[2c7c]::slice::{impl#9}): impl std::borrow::ToOwned for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2258 ~ std[d8a0]::ffi::os_str::{impl#51}): impl std::slice::Join::<&std::ffi::OsStr> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(1:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }])] }
DefId(2:4122 ~ core[b693]::array::equality::{impl#6}): impl std::cmp::PartialEq::<[U;N]> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4098 ~ core[b693]::array::equality::{impl#2}): impl std::cmp::PartialEq::<[U;N]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(2:4110 ~ core[b693]::array::equality::{impl#4}): impl std::cmp::PartialEq::<[U;N]> for &[T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(5:5565 ~ alloc[2c7c]::slice::{impl#3}): impl std::slice::Join::<&T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(5:5680 ~ alloc[2c7c]::str::{impl#1}): impl std::slice::Join::<&str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(5:5676 ~ alloc[2c7c]::str::{impl#0}): impl std::slice::Concat::<str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }

type alloc::vec::Vec implement 1 traits: 
DefId(5:7329 ~ alloc[2c7c]::vec::{impl#8}): impl std::ops::Deref for std::vec::Vec::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::va_list::VaListImpl implement 3 traits: 
DefId(2:41176 ~ core[b693]::ffi::va_list::{impl#8}): impl std::fmt::Debug for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5332 ~ core[b693]::ffi::va_list::{impl#6}): impl std::clone::Clone for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:5335 ~ core[b693]::ffi::va_list::{impl#7}): impl std::ops::drop::Drop for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::mutex::MappedMutexGuard implement 1 traits: 
DefId(1:6684 ~ std[d8a0]::sync::mutex::{impl#18}): impl std::ops::Deref for std::sync::mutex::MappedMutexGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::cell::lazy::LazyCell implement 1 traits: 
DefId(2:4628 ~ core[b693]::cell::lazy::{impl#2}): impl std::ops::Deref for std::cell::lazy::LazyCell::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(2:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type alloc::ffi::c_str::CString implement 1 traits: 
DefId(5:4811 ~ alloc[2c7c]::ffi::c_str::{impl#3}): impl std::ops::Deref for std::ffi::CString
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::mem::manually_drop::ManuallyDrop implement 1 traits: 
DefId(2:1973 ~ core[b693]::mem::manually_drop::{impl#2}): impl std::ops::Deref for std::mem::manually_drop::ManuallyDrop::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::sync::reentrant_lock::ReentrantLockGuard implement 1 traits: 
DefId(1:6932 ~ std[d8a0]::sync::reentrant_lock::{impl#11}): impl std::ops::Deref for std::sync::reentrant_lock::ReentrantLockGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::collections::binary_heap::PeekMut implement 1 traits: 
DefId(5:897 ~ alloc[2c7c]::collections::binary_heap::{impl#2}): impl std::ops::Deref for std::collections::binary_heap::PeekMut::<'_, T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::sync::rwlock::RwLockWriteGuard implement 1 traits: 
DefId(1:7047 ~ std[d8a0]::sync::rwlock::{impl#26}): impl std::ops::Deref for std::sync::rwlock::RwLockWriteGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type strsim::StrSimError implement 19 traits: 
DefId(2:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32818 ~ core[b693]::marker::Send): impl std::marker::Send for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(2:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(2:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(2:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(2:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:5953 ~ alloc[2c7c]::string::{impl#32}): impl std::string::ToString for strsim::StrSimError
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:10665 ~ core[b693]::fmt::Display)), segments: [PathSegment { name: "Display", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:117 ~ strsim[f974]::{impl#9}): impl std::marker::StructuralPartialEq for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:118 ~ strsim[f974]::{impl#10}): impl std::cmp::PartialEq for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:17 ~ strsim[f974]::{impl#0}): impl std::fmt::Display for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:115 ~ strsim[f974]::{impl#8}): impl std::fmt::Debug for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:19 ~ strsim[f974]::{impl#1}): impl std::error::Error for strsim::StrSimError
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::RefMut implement 1 traits: 
DefId(2:4903 ~ core[b693]::cell::{impl#45}): impl std::ops::Deref for std::cell::RefMut::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::va_list::VaList implement 1 traits: 
DefId(2:5308 ~ core[b693]::ffi::va_list::{impl#1}): impl std::ops::Deref for std::ffi::va_list::VaList::<'a, 'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::str implement 42 traits: 
DefId(5:7792 ~ alloc[2c7c]::string::{impl#82}): impl std::cmp::PartialEq::<std::string::String> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7802 ~ alloc[2c7c]::string::{impl#84}): impl std::cmp::PartialEq::<std::string::String> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7812 ~ alloc[2c7c]::string::{impl#86}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7822 ~ alloc[2c7c]::string::{impl#88}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5578 ~ std[d8a0]::path::{impl#77}): impl std::convert::AsRef::<std::path::Path> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13877 ~ core[b693]::str::{impl#1}): impl std::convert::AsRef::<[u8]> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42}): impl std::cmp::PartialEq::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56}): impl std::convert::AsRef::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37}): impl std::convert::TryFrom::<&'a std::ffi::OsStr> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14}): impl std::cmp::PartialEq::<std::ffi::OsString> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2144 ~ std[d8a0]::ffi::os_str::{impl#14}): impl std::cmp::PartialEq::<std::ffi::OsString> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2232 ~ std[d8a0]::ffi::os_str::{impl#42}): impl std::cmp::PartialEq::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2148 ~ std[d8a0]::ffi::os_str::{impl#16}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2273 ~ std[d8a0]::ffi::os_str::{impl#56}): impl std::convert::AsRef::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5578 ~ std[d8a0]::path::{impl#77}): impl std::convert::AsRef::<std::path::Path> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:2220 ~ std[d8a0]::ffi::os_str::{impl#37}): impl std::convert::TryFrom::<&'a std::ffi::OsStr> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3885 ~ std[d8a0]::net::socket_addr::{impl#12}): impl std::net::ToSocketAddrs for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:661 ~ std[d8a0]::ascii::{impl#3}): impl std::ascii::AsciiExt for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13307 ~ core[b693]::str::traits::{impl#3}): impl std::cmp::PartialOrd for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13883 ~ core[b693]::str::{impl#4}): impl std::error::Error for &str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13591 ~ core[b693]::str::pattern::{impl#31}): impl std::str::pattern::Pattern::<'a> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32835 ~ core[b693]::marker::{impl#32}): impl std::marker::StructuralPartialEq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10962 ~ core[b693]::hash::impls::{impl#2}): impl std::hash::Hash for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10771 ~ core[b693]::fmt::{impl#17}): impl std::fmt::Display for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:10767 ~ core[b693]::fmt::{impl#16}): impl std::fmt::Debug for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:32923 ~ core[b693]::marker::{impl#90}): impl std::marker::ConstParamTy for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13313 ~ core[b693]::str::traits::{impl#5}): impl std::ops::IndexMut::<I> for str
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(2:13309 ~ core[b693]::str::traits::{impl#4}): impl std::ops::Index::<I> for str
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(2:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(2:13306 ~ core[b693]::str::traits::{impl#2}): impl std::cmp::Eq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3118 ~ core[b693]::convert::{impl#11}): impl std::convert::AsMut::<str> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13304 ~ core[b693]::str::traits::{impl#1}): impl std::cmp::PartialEq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13881 ~ core[b693]::str::{impl#3}): impl std::default::Default for &mut str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13879 ~ core[b693]::str::{impl#2}): impl std::default::Default for &str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13302 ~ core[b693]::str::traits::{impl#0}): impl std::cmp::Ord for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:13877 ~ core[b693]::str::{impl#1}): impl std::convert::AsRef::<[u8]> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(2:3116 ~ core[b693]::convert::{impl#10}): impl std::convert::AsRef::<str> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7792 ~ alloc[2c7c]::string::{impl#82}): impl std::cmp::PartialEq::<std::string::String> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7812 ~ alloc[2c7c]::string::{impl#86}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7822 ~ alloc[2c7c]::string::{impl#88}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:7802 ~ alloc[2c7c]::string::{impl#84}): impl std::cmp::PartialEq::<std::string::String> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5697 ~ alloc[2c7c]::str::{impl#4}): impl std::borrow::ToOwned for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::string::String implement 1 traits: 
DefId(5:5941 ~ alloc[2c7c]::string::{impl#28}): impl std::ops::Deref for std::string::String
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::borrow::Cow implement 1 traits: 
DefId(5:802 ~ alloc[2c7c]::borrow::{impl#4}): impl std::ops::Deref for std::borrow::Cow::<'_, B>
bounds: GenericParamMap { inner: {"B": []}, generic_defs: ["B"], type_pred: [(Generic("B"), [Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (QPath(QPathData { assoc: PathSegment { name: "Owned", args: AngleBracketed { args: [], constraints: [] } }, self_type: Generic("B"), should_show_cast: true, trait_: Some(Path { res: Def(Trait, DefId(5:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }) }), [Path { res: Def(Trait, DefId(2:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] }])] }

type std::sync::mutex::MutexGuard implement 1 traits: 
DefId(1:6653 ~ std[d8a0]::sync::mutex::{impl#12}): impl std::ops::Deref for std::sync::mutex::MutexGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::rc::UniqueRc implement 1 traits: 
DefId(5:5392 ~ alloc[2c7c]::rc::{impl#79}): impl std::ops::Deref for std::rc::UniqueRc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(2:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(2:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
Type Candidate #0: (11)&mut &str
Type Candidate #1: (11)&&str
Type Candidate #2: (2)*&[u8]
Type Candidate #3: (2)*const &[u8]
Type Candidate #4: (11)*&str
Type Candidate #5: (1)&&[char]
Type Candidate #6: (3)&[u8]
Type Candidate #7: (1)&mut &[char]
Type Candidate #8: (1)u8
Type Candidate #9: (11)*const &str
Type Candidate #10: (11)&str
Type Candidate #11: (2)&mut &[u8]
Type Candidate #12: (2)&&[u8]
Type Candidate #13: (1)&[char]
Type Candidate #14: (1)*const &[char]
Type Candidate #15: (1)*&[char]
unsupport function:
[ApiGraph] Resolve this function
fn strsim::generic_damerau_levenshtein(&[Elem], &[Elem]) -> usize
Where:
Elem: , 
Type Pred:
Elem: std::cmp::Eq + std::hash::Hash + std::clone::Clone

[ApiGraph] Resolve this function
fn strsim::generic_levenshtein(&Iter1, &Iter2) -> usize
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
&'a Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
&'b Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

[ApiGraph] Resolve this function
fn strsim::generic_jaro_winkler(&Iter1, &Iter2) -> f64
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
&'a Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
&'b Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

[ApiGraph] Resolve this function
fn strsim::generic_jaro(&Iter1, &Iter2) -> f64
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
&'a Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
&'b Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

[ApiGraph] Resolve this function
fn strsim::generic_hamming(Iter1, Iter2) -> strsim::HammingResult
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

=====Iteration #0=====
num of func: 10
num of reachable: 10
num of reachable type: 10
[Reachable]fn strsim::sorensen_dice(&str, &str) -> f64 is reachable
[TypeContext] add candidate #16: f64 => Primitive(F64)
[TypeContext] add candidate #17: &mut f64 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(F64) }
[TypeContext] add candidate #18: &f64 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(F64) }
[TypeContext] add candidate #19: *f64 => RawPointer(Mut, Primitive(F64))
[TypeContext] add candidate #20: *const f64 => RawPointer(Not, Primitive(F64))
[Reachable]fn strsim::normalized_damerau_levenshtein(&str, &str) -> f64 is reachable
[Reachable]fn strsim::damerau_levenshtein(&str, &str) -> usize is reachable
[TypeContext] add candidate #21: usize => Primitive(Usize)
[TypeContext] add candidate #22: &mut usize => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Usize) }
[TypeContext] add candidate #23: &usize => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Usize) }
[TypeContext] add candidate #24: *usize => RawPointer(Mut, Primitive(Usize))
[TypeContext] add candidate #25: *const usize => RawPointer(Not, Primitive(Usize))
[Reachable]fn strsim::osa_distance(&str, &str) -> usize is reachable
[Reachable]fn strsim::normalized_levenshtein(&str, &str) -> f64 is reachable
[Reachable]fn strsim::levenshtein(&str, &str) -> usize is reachable
[Reachable]fn strsim::jaro_winkler(&str, &str) -> f64 is reachable
[Reachable]fn strsim::jaro(&str, &str) -> f64 is reachable
[Reachable]fn strsim::hamming(&str, &str) -> strsim::HammingResult is reachable
[TypeContext] add candidate #26: HammingResult => Path { path: Path { res: Def(TyAlias, DefId(0:20 ~ strsim[f974]::HammingResult)), segments: [PathSegment { name: "HammingResult", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #27: &mut HammingResult => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(TyAlias, DefId(0:20 ~ strsim[f974]::HammingResult)), segments: [PathSegment { name: "HammingResult", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #28: &HammingResult => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(TyAlias, DefId(0:20 ~ strsim[f974]::HammingResult)), segments: [PathSegment { name: "HammingResult", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #29: *HammingResult => RawPointer(Mut, Path { path: Path { res: Def(TyAlias, DefId(0:20 ~ strsim[f974]::HammingResult)), segments: [PathSegment { name: "HammingResult", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #30: *const HammingResult => RawPointer(Not, Path { path: Path { res: Def(TyAlias, DefId(0:20 ~ strsim[f974]::HammingResult)), segments: [PathSegment { name: "HammingResult", args: AngleBracketed { args: [], constraints: [] } }] } })
===== Candidates =====
Type Candidate #0: (1)*&[char]
Type Candidate #1: (2)&strsim::HammingResult
Type Candidate #2: (11)&mut &str
Type Candidate #3: (2)*const &[u8]
Type Candidate #4: (2)strsim::HammingResult
Type Candidate #5: (11)*&str
Type Candidate #6: (1)&&[char]
Type Candidate #7: (1)&mut &[char]
Type Candidate #8: (2)&mut strsim::HammingResult
Type Candidate #9: (11)*const &str
Type Candidate #10: (6)&mut usize
Type Candidate #11: (6)&usize
Type Candidate #12: (6)usize
Type Candidate #13: (2)&mut &[u8]
Type Candidate #14: (2)&&[u8]
Type Candidate #15: (1)*const &[char]
Type Candidate #16: (6)*usize
Type Candidate #17: (2)*const strsim::HammingResult
Type Candidate #18: (11)&&str
Type Candidate #19: (2)*&[u8]
Type Candidate #20: (10)*const f64
Type Candidate #21: (3)&[u8]
Type Candidate #22: (10)&mut f64
Type Candidate #23: (1)u8
Type Candidate #24: (10)f64
Type Candidate #25: (2)*strsim::HammingResult
Type Candidate #26: (10)*f64
Type Candidate #27: (11)&str
Type Candidate #28: (1)&[char]
Type Candidate #29: (10)&f64
Type Candidate #30: (6)*const usize
===== !Candidates =====
[Solver] find solution for fn strsim::generic_damerau_levenshtein(&[Elem], &[Elem]) -> usize, already have 0 solutions
[Solver] generic params: ["Elem"]
[Solver] Start solve()
[Solver] search for input argument &[Elem]:
set A: `(*)`
set B: `(u8), (char)`
Merge: `(u8), (char)`
[Solver] search for input argument &[Elem]:
set A: `(u8), (char)`
set B: `(u8), (char)`
Merge: `(u8), (char)`
[Solver] Solution Set = `(u8), (char)`
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::cmp::Eq for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::cmp::Eq for char fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn strsim::generic_levenshtein(&Iter1, &Iter2) -> usize, already have 0 solutions
[Solver] generic params: ["Iter1", "Iter2", "Elem1", "Elem2"]
[Solver] Start solve()
[Solver] search for input argument &Iter1:
set A: `(*, *, *, *)`
set B: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
Merge: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
[Solver] search for input argument &Iter2:
set A: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
set B: `(*, HammingResult, *, *), (*, str, *, *), (*, [u8], *, *), (*, f64, *, *), (*, &[u8], *, *), (*, &str, *, *), (*, &[char], *, *), (*, [char], *, *), (*, usize, *, *)`
Merge: `(&[char], HammingResult, *, *), (&[char], str, *, *), (&[char], [u8], *, *), (&[char], f64, *, *), (&[char], &[u8], *, *), (&[char], &str, *, *), (&[char], &[char], *, *), (&[char], [char], *, *), (&[char], usize, *, *), (f64, HammingResult, *, *), (f64, str, *, *), (f64, [u8], *, *), (f64, f64, *, *), (f64, &[u8], *, *), (f64, &str, *, *), (f64, &[char], *, *), (f64, [char], *, *), (f64, usize, *, *), ([char], HammingResult, *, *), ([char], str, *, *), ([char], [u8], *, *), ([char], f64, *, *), ([char], &[u8], *, *), ([char], &str, *, *), ([char], &[char], *, *), ([char], [char], *, *), ([char], usize, *, *), (&[u8], HammingResult, *, *), (&[u8], str, *, *), (&[u8], [u8], *, *), (&[u8], f64, *, *), (&[u8], &[u8], *, *), (&[u8], &str, *, *), (&[u8], &[char], *, *), (&[u8], [char], *, *), (&[u8], usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, str, *, *), (HammingResult, [u8], *, *), (HammingResult, f64, *, *), (HammingResult, &[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &[char], *, *), (HammingResult, [char], *, *), (HammingResult, usize, *, *), (usize, HammingResult, *, *), (usize, str, *, *), (usize, [u8], *, *), (usize, f64, *, *), (usize, &[u8], *, *), (usize, &str, *, *), (usize, &[char], *, *), (usize, [char], *, *), (usize, usize, *, *), ([u8], HammingResult, *, *), ([u8], str, *, *), ([u8], [u8], *, *), ([u8], f64, *, *), ([u8], &[u8], *, *), ([u8], &str, *, *), ([u8], &[char], *, *), ([u8], [char], *, *), ([u8], usize, *, *), (str, HammingResult, *, *), (str, str, *, *), (str, [u8], *, *), (str, f64, *, *), (str, &[u8], *, *), (str, &str, *, *), (str, &[char], *, *), (str, [char], *, *), (str, usize, *, *), (&str, HammingResult, *, *), (&str, str, *, *), (&str, [u8], *, *), (&str, f64, *, *), (&str, &[u8], *, *), (&str, &str, *, *), (&str, &[char], *, *), (&str, [char], *, *), (&str, usize, *, *)`
[Solver] Solution Set = `(&[char], HammingResult, *, *), (&[char], str, *, *), (&[char], [u8], *, *), (&[char], f64, *, *), (&[char], &[u8], *, *), (&[char], &str, *, *), (&[char], &[char], *, *), (&[char], [char], *, *), (&[char], usize, *, *), (f64, HammingResult, *, *), (f64, str, *, *), (f64, [u8], *, *), (f64, f64, *, *), (f64, &[u8], *, *), (f64, &str, *, *), (f64, &[char], *, *), (f64, [char], *, *), (f64, usize, *, *), ([char], HammingResult, *, *), ([char], str, *, *), ([char], [u8], *, *), ([char], f64, *, *), ([char], &[u8], *, *), ([char], &str, *, *), ([char], &[char], *, *), ([char], [char], *, *), ([char], usize, *, *), (&[u8], HammingResult, *, *), (&[u8], str, *, *), (&[u8], [u8], *, *), (&[u8], f64, *, *), (&[u8], &[u8], *, *), (&[u8], &str, *, *), (&[u8], &[char], *, *), (&[u8], [char], *, *), (&[u8], usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, str, *, *), (HammingResult, [u8], *, *), (HammingResult, f64, *, *), (HammingResult, &[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &[char], *, *), (HammingResult, [char], *, *), (HammingResult, usize, *, *), (usize, HammingResult, *, *), (usize, str, *, *), (usize, [u8], *, *), (usize, f64, *, *), (usize, &[u8], *, *), (usize, &str, *, *), (usize, &[char], *, *), (usize, [char], *, *), (usize, usize, *, *), ([u8], HammingResult, *, *), ([u8], str, *, *), ([u8], [u8], *, *), ([u8], f64, *, *), ([u8], &[u8], *, *), ([u8], &str, *, *), ([u8], &[char], *, *), ([u8], [char], *, *), ([u8], usize, *, *), (str, HammingResult, *, *), (str, str, *, *), (str, [u8], *, *), (str, f64, *, *), (str, &[u8], *, *), (str, &str, *, *), (str, &[char], *, *), (str, [char], *, *), (str, usize, *, *), (&str, HammingResult, *, *), (&str, str, *, *), (&str, [u8], *, *), (&str, f64, *, *), (&str, &[u8], *, *), (&str, &str, *, *), (&str, &[char], *, *), (&str, [char], *, *), (&str, usize, *, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn strsim::generic_jaro_winkler(&Iter1, &Iter2) -> f64, already have 0 solutions
[Solver] generic params: ["Iter1", "Iter2", "Elem1", "Elem2"]
[Solver] Start solve()
[Solver] search for input argument &Iter1:
set A: `(*, *, *, *)`
set B: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
Merge: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
[Solver] search for input argument &Iter2:
set A: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
set B: `(*, HammingResult, *, *), (*, str, *, *), (*, [u8], *, *), (*, f64, *, *), (*, &[u8], *, *), (*, &str, *, *), (*, &[char], *, *), (*, [char], *, *), (*, usize, *, *)`
Merge: `(&[char], HammingResult, *, *), (&[char], str, *, *), (&[char], [u8], *, *), (&[char], f64, *, *), (&[char], &[u8], *, *), (&[char], &str, *, *), (&[char], &[char], *, *), (&[char], [char], *, *), (&[char], usize, *, *), (f64, HammingResult, *, *), (f64, str, *, *), (f64, [u8], *, *), (f64, f64, *, *), (f64, &[u8], *, *), (f64, &str, *, *), (f64, &[char], *, *), (f64, [char], *, *), (f64, usize, *, *), ([char], HammingResult, *, *), ([char], str, *, *), ([char], [u8], *, *), ([char], f64, *, *), ([char], &[u8], *, *), ([char], &str, *, *), ([char], &[char], *, *), ([char], [char], *, *), ([char], usize, *, *), (&[u8], HammingResult, *, *), (&[u8], str, *, *), (&[u8], [u8], *, *), (&[u8], f64, *, *), (&[u8], &[u8], *, *), (&[u8], &str, *, *), (&[u8], &[char], *, *), (&[u8], [char], *, *), (&[u8], usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, str, *, *), (HammingResult, [u8], *, *), (HammingResult, f64, *, *), (HammingResult, &[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &[char], *, *), (HammingResult, [char], *, *), (HammingResult, usize, *, *), (usize, HammingResult, *, *), (usize, str, *, *), (usize, [u8], *, *), (usize, f64, *, *), (usize, &[u8], *, *), (usize, &str, *, *), (usize, &[char], *, *), (usize, [char], *, *), (usize, usize, *, *), ([u8], HammingResult, *, *), ([u8], str, *, *), ([u8], [u8], *, *), ([u8], f64, *, *), ([u8], &[u8], *, *), ([u8], &str, *, *), ([u8], &[char], *, *), ([u8], [char], *, *), ([u8], usize, *, *), (str, HammingResult, *, *), (str, str, *, *), (str, [u8], *, *), (str, f64, *, *), (str, &[u8], *, *), (str, &str, *, *), (str, &[char], *, *), (str, [char], *, *), (str, usize, *, *), (&str, HammingResult, *, *), (&str, str, *, *), (&str, [u8], *, *), (&str, f64, *, *), (&str, &[u8], *, *), (&str, &str, *, *), (&str, &[char], *, *), (&str, [char], *, *), (&str, usize, *, *)`
[Solver] Solution Set = `(&[char], HammingResult, *, *), (&[char], str, *, *), (&[char], [u8], *, *), (&[char], f64, *, *), (&[char], &[u8], *, *), (&[char], &str, *, *), (&[char], &[char], *, *), (&[char], [char], *, *), (&[char], usize, *, *), (f64, HammingResult, *, *), (f64, str, *, *), (f64, [u8], *, *), (f64, f64, *, *), (f64, &[u8], *, *), (f64, &str, *, *), (f64, &[char], *, *), (f64, [char], *, *), (f64, usize, *, *), ([char], HammingResult, *, *), ([char], str, *, *), ([char], [u8], *, *), ([char], f64, *, *), ([char], &[u8], *, *), ([char], &str, *, *), ([char], &[char], *, *), ([char], [char], *, *), ([char], usize, *, *), (&[u8], HammingResult, *, *), (&[u8], str, *, *), (&[u8], [u8], *, *), (&[u8], f64, *, *), (&[u8], &[u8], *, *), (&[u8], &str, *, *), (&[u8], &[char], *, *), (&[u8], [char], *, *), (&[u8], usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, str, *, *), (HammingResult, [u8], *, *), (HammingResult, f64, *, *), (HammingResult, &[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &[char], *, *), (HammingResult, [char], *, *), (HammingResult, usize, *, *), (usize, HammingResult, *, *), (usize, str, *, *), (usize, [u8], *, *), (usize, f64, *, *), (usize, &[u8], *, *), (usize, &str, *, *), (usize, &[char], *, *), (usize, [char], *, *), (usize, usize, *, *), ([u8], HammingResult, *, *), ([u8], str, *, *), ([u8], [u8], *, *), ([u8], f64, *, *), ([u8], &[u8], *, *), ([u8], &str, *, *), ([u8], &[char], *, *), ([u8], [char], *, *), ([u8], usize, *, *), (str, HammingResult, *, *), (str, str, *, *), (str, [u8], *, *), (str, f64, *, *), (str, &[u8], *, *), (str, &str, *, *), (str, &[char], *, *), (str, [char], *, *), (str, usize, *, *), (&str, HammingResult, *, *), (&str, str, *, *), (&str, [u8], *, *), (&str, f64, *, *), (&str, &[u8], *, *), (&str, &str, *, *), (&str, &[char], *, *), (&str, [char], *, *), (&str, usize, *, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn strsim::generic_jaro(&Iter1, &Iter2) -> f64, already have 0 solutions
[Solver] generic params: ["Iter1", "Iter2", "Elem1", "Elem2"]
[Solver] Start solve()
[Solver] search for input argument &Iter1:
set A: `(*, *, *, *)`
set B: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
Merge: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
[Solver] search for input argument &Iter2:
set A: `(&[char], *, *, *), (f64, *, *, *), ([char], *, *, *), (&[u8], *, *, *), (HammingResult, *, *, *), (usize, *, *, *), ([u8], *, *, *), (str, *, *, *), (&str, *, *, *)`
set B: `(*, HammingResult, *, *), (*, str, *, *), (*, [u8], *, *), (*, f64, *, *), (*, &[u8], *, *), (*, &str, *, *), (*, &[char], *, *), (*, [char], *, *), (*, usize, *, *)`
Merge: `(&[char], HammingResult, *, *), (&[char], str, *, *), (&[char], [u8], *, *), (&[char], f64, *, *), (&[char], &[u8], *, *), (&[char], &str, *, *), (&[char], &[char], *, *), (&[char], [char], *, *), (&[char], usize, *, *), (f64, HammingResult, *, *), (f64, str, *, *), (f64, [u8], *, *), (f64, f64, *, *), (f64, &[u8], *, *), (f64, &str, *, *), (f64, &[char], *, *), (f64, [char], *, *), (f64, usize, *, *), ([char], HammingResult, *, *), ([char], str, *, *), ([char], [u8], *, *), ([char], f64, *, *), ([char], &[u8], *, *), ([char], &str, *, *), ([char], &[char], *, *), ([char], [char], *, *), ([char], usize, *, *), (&[u8], HammingResult, *, *), (&[u8], str, *, *), (&[u8], [u8], *, *), (&[u8], f64, *, *), (&[u8], &[u8], *, *), (&[u8], &str, *, *), (&[u8], &[char], *, *), (&[u8], [char], *, *), (&[u8], usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, str, *, *), (HammingResult, [u8], *, *), (HammingResult, f64, *, *), (HammingResult, &[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &[char], *, *), (HammingResult, [char], *, *), (HammingResult, usize, *, *), (usize, HammingResult, *, *), (usize, str, *, *), (usize, [u8], *, *), (usize, f64, *, *), (usize, &[u8], *, *), (usize, &str, *, *), (usize, &[char], *, *), (usize, [char], *, *), (usize, usize, *, *), ([u8], HammingResult, *, *), ([u8], str, *, *), ([u8], [u8], *, *), ([u8], f64, *, *), ([u8], &[u8], *, *), ([u8], &str, *, *), ([u8], &[char], *, *), ([u8], [char], *, *), ([u8], usize, *, *), (str, HammingResult, *, *), (str, str, *, *), (str, [u8], *, *), (str, f64, *, *), (str, &[u8], *, *), (str, &str, *, *), (str, &[char], *, *), (str, [char], *, *), (str, usize, *, *), (&str, HammingResult, *, *), (&str, str, *, *), (&str, [u8], *, *), (&str, f64, *, *), (&str, &[u8], *, *), (&str, &str, *, *), (&str, &[char], *, *), (&str, [char], *, *), (&str, usize, *, *)`
[Solver] Solution Set = `(&[char], HammingResult, *, *), (&[char], str, *, *), (&[char], [u8], *, *), (&[char], f64, *, *), (&[char], &[u8], *, *), (&[char], &str, *, *), (&[char], &[char], *, *), (&[char], [char], *, *), (&[char], usize, *, *), (f64, HammingResult, *, *), (f64, str, *, *), (f64, [u8], *, *), (f64, f64, *, *), (f64, &[u8], *, *), (f64, &str, *, *), (f64, &[char], *, *), (f64, [char], *, *), (f64, usize, *, *), ([char], HammingResult, *, *), ([char], str, *, *), ([char], [u8], *, *), ([char], f64, *, *), ([char], &[u8], *, *), ([char], &str, *, *), ([char], &[char], *, *), ([char], [char], *, *), ([char], usize, *, *), (&[u8], HammingResult, *, *), (&[u8], str, *, *), (&[u8], [u8], *, *), (&[u8], f64, *, *), (&[u8], &[u8], *, *), (&[u8], &str, *, *), (&[u8], &[char], *, *), (&[u8], [char], *, *), (&[u8], usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, str, *, *), (HammingResult, [u8], *, *), (HammingResult, f64, *, *), (HammingResult, &[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &[char], *, *), (HammingResult, [char], *, *), (HammingResult, usize, *, *), (usize, HammingResult, *, *), (usize, str, *, *), (usize, [u8], *, *), (usize, f64, *, *), (usize, &[u8], *, *), (usize, &str, *, *), (usize, &[char], *, *), (usize, [char], *, *), (usize, usize, *, *), ([u8], HammingResult, *, *), ([u8], str, *, *), ([u8], [u8], *, *), ([u8], f64, *, *), ([u8], &[u8], *, *), ([u8], &str, *, *), ([u8], &[char], *, *), ([u8], [char], *, *), ([u8], usize, *, *), (str, HammingResult, *, *), (str, str, *, *), (str, [u8], *, *), (str, f64, *, *), (str, &[u8], *, *), (str, &str, *, *), (str, &[char], *, *), (str, [char], *, *), (str, usize, *, *), (&str, HammingResult, *, *), (&str, str, *, *), (&str, [u8], *, *), (&str, f64, *, *), (&str, &[u8], *, *), (&str, &str, *, *), (&str, &[char], *, *), (&str, [char], *, *), (&str, usize, *, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn strsim::generic_hamming(Iter1, Iter2) -> strsim::HammingResult, already have 0 solutions
[Solver] generic params: ["Iter1", "Iter2", "Elem1", "Elem2"]
[Solver] Start solve()
[Solver] search for input argument Iter1:
set A: `(*, *, *, *)`
set B: `(*usize, *, *, *), (&&[char], *, *, *), (*const HammingResult, *, *, *), (*const f64, *, *, *), (*&[char], *, *, *), (&mut &[char], *, *, *), (&f64, *, *, *), (&usize, *, *, *), (&mut usize, *, *, *), (u8, *, *, *), (HammingResult, *, *, *), (usize, *, *, *), (*const &[char], *, *, *), (&mut HammingResult, *, *, *), (*const &[u8], *, *, *), (*f64, *, *, *), (&HammingResult, *, *, *), (&str, *, *, *), (&mut &[u8], *, *, *), (*const &str, *, *, *), (&&str, *, *, *), (*HammingResult, *, *, *), (&[u8], *, *, *), (&mut &str, *, *, *), (*const usize, *, *, *), (&mut f64, *, *, *), (f64, *, *, *), (*&str, *, *, *), (&[char], *, *, *), (&&[u8], *, *, *), (*&[u8], *, *, *)`
Merge: `(*usize, *, *, *), (&&[char], *, *, *), (*const HammingResult, *, *, *), (*const f64, *, *, *), (*&[char], *, *, *), (&mut &[char], *, *, *), (&f64, *, *, *), (&usize, *, *, *), (&mut usize, *, *, *), (u8, *, *, *), (HammingResult, *, *, *), (usize, *, *, *), (*const &[char], *, *, *), (&mut HammingResult, *, *, *), (*const &[u8], *, *, *), (*f64, *, *, *), (&HammingResult, *, *, *), (&str, *, *, *), (&mut &[u8], *, *, *), (*const &str, *, *, *), (&&str, *, *, *), (*HammingResult, *, *, *), (&[u8], *, *, *), (&mut &str, *, *, *), (*const usize, *, *, *), (&mut f64, *, *, *), (f64, *, *, *), (*&str, *, *, *), (&[char], *, *, *), (&&[u8], *, *, *), (*&[u8], *, *, *)`
[Solver] search for input argument Iter2:
set A: `(*usize, *, *, *), (&&[char], *, *, *), (*const HammingResult, *, *, *), (*const f64, *, *, *), (*&[char], *, *, *), (&mut &[char], *, *, *), (&f64, *, *, *), (&usize, *, *, *), (&mut usize, *, *, *), (u8, *, *, *), (HammingResult, *, *, *), (usize, *, *, *), (*const &[char], *, *, *), (&mut HammingResult, *, *, *), (*const &[u8], *, *, *), (*f64, *, *, *), (&HammingResult, *, *, *), (&str, *, *, *), (&mut &[u8], *, *, *), (*const &str, *, *, *), (&&str, *, *, *), (*HammingResult, *, *, *), (&[u8], *, *, *), (&mut &str, *, *, *), (*const usize, *, *, *), (&mut f64, *, *, *), (f64, *, *, *), (*&str, *, *, *), (&[char], *, *, *), (&&[u8], *, *, *), (*&[u8], *, *, *)`
set B: `(*, HammingResult, *, *), (*, &mut HammingResult, *, *), (*, *const &[char], *, *), (*, *const f64, *, *), (*, *const &str, *, *), (*, &mut &[u8], *, *), (*, &&str, *, *), (*, f64, *, *), (*, *&str, *, *), (*, &&[u8], *, *), (*, *HammingResult, *, *), (*, *const HammingResult, *, *), (*, &&[char], *, *), (*, usize, *, *), (*, &mut usize, *, *), (*, *const &[u8], *, *), (*, &[u8], *, *), (*, &usize, *, *), (*, *f64, *, *), (*, *usize, *, *), (*, u8, *, *), (*, &mut &[char], *, *), (*, &f64, *, *), (*, *&[char], *, *), (*, *&[u8], *, *), (*, &str, *, *), (*, &mut &str, *, *), (*, &HammingResult, *, *), (*, &mut f64, *, *), (*, &[char], *, *), (*, *const usize, *, *)`
Merge: `(*usize, HammingResult, *, *), (*usize, &mut HammingResult, *, *), (*usize, *const &[char], *, *), (*usize, *const f64, *, *), (*usize, *const &str, *, *), (*usize, &mut &[u8], *, *), (*usize, &&str, *, *), (*usize, f64, *, *), (*usize, *&str, *, *), (*usize, &&[u8], *, *), (*usize, *HammingResult, *, *), (*usize, *const HammingResult, *, *), (*usize, &&[char], *, *), (*usize, usize, *, *), (*usize, &mut usize, *, *), (*usize, *const &[u8], *, *), (*usize, &[u8], *, *), (*usize, &usize, *, *), (*usize, *f64, *, *), (*usize, *usize, *, *), (*usize, u8, *, *), (*usize, &mut &[char], *, *), (*usize, &f64, *, *), (*usize, *&[char], *, *), (*usize, *&[u8], *, *), (*usize, &str, *, *), (*usize, &mut &str, *, *), (*usize, &HammingResult, *, *), (*usize, &mut f64, *, *), (*usize, &[char], *, *), (*usize, *const usize, *, *), (&&[char], HammingResult, *, *), (&&[char], &mut HammingResult, *, *), (&&[char], *const &[char], *, *), (&&[char], *const f64, *, *), (&&[char], *const &str, *, *), (&&[char], &mut &[u8], *, *), (&&[char], &&str, *, *), (&&[char], f64, *, *), (&&[char], *&str, *, *), (&&[char], &&[u8], *, *), (&&[char], *HammingResult, *, *), (&&[char], *const HammingResult, *, *), (&&[char], &&[char], *, *), (&&[char], usize, *, *), (&&[char], &mut usize, *, *), (&&[char], *const &[u8], *, *), (&&[char], &[u8], *, *), (&&[char], &usize, *, *), (&&[char], *f64, *, *), (&&[char], *usize, *, *), (&&[char], u8, *, *), (&&[char], &mut &[char], *, *), (&&[char], &f64, *, *), (&&[char], *&[char], *, *), (&&[char], *&[u8], *, *), (&&[char], &str, *, *), (&&[char], &mut &str, *, *), (&&[char], &HammingResult, *, *), (&&[char], &mut f64, *, *), (&&[char], &[char], *, *), (&&[char], *const usize, *, *), (*const HammingResult, HammingResult, *, *), (*const HammingResult, &mut HammingResult, *, *), (*const HammingResult, *const &[char], *, *), (*const HammingResult, *const f64, *, *), (*const HammingResult, *const &str, *, *), (*const HammingResult, &mut &[u8], *, *), (*const HammingResult, &&str, *, *), (*const HammingResult, f64, *, *), (*const HammingResult, *&str, *, *), (*const HammingResult, &&[u8], *, *), (*const HammingResult, *HammingResult, *, *), (*const HammingResult, *const HammingResult, *, *), (*const HammingResult, &&[char], *, *), (*const HammingResult, usize, *, *), (*const HammingResult, &mut usize, *, *), (*const HammingResult, *const &[u8], *, *), (*const HammingResult, &[u8], *, *), (*const HammingResult, &usize, *, *), (*const HammingResult, *f64, *, *), (*const HammingResult, *usize, *, *), (*const HammingResult, u8, *, *), (*const HammingResult, &mut &[char], *, *), (*const HammingResult, &f64, *, *), (*const HammingResult, *&[char], *, *), (*const HammingResult, *&[u8], *, *), (*const HammingResult, &str, *, *), (*const HammingResult, &mut &str, *, *), (*const HammingResult, &HammingResult, *, *), (*const HammingResult, &mut f64, *, *), (*const HammingResult, &[char], *, *), (*const HammingResult, *const usize, *, *), (*const f64, HammingResult, *, *), (*const f64, &mut HammingResult, *, *), (*const f64, *const &[char], *, *), (*const f64, *const f64, *, *), (*const f64, *const &str, *, *), (*const f64, &mut &[u8], *, *), (*const f64, &&str, *, *), (*const f64, f64, *, *), (*const f64, *&str, *, *), (*const f64, &&[u8], *, *), (*const f64, *HammingResult, *, *), (*const f64, *const HammingResult, *, *), (*const f64, &&[char], *, *), (*const f64, usize, *, *), (*const f64, &mut usize, *, *), (*const f64, *const &[u8], *, *), (*const f64, &[u8], *, *), (*const f64, &usize, *, *), (*const f64, *f64, *, *), (*const f64, *usize, *, *), (*const f64, u8, *, *), (*const f64, &mut &[char], *, *), (*const f64, &f64, *, *), (*const f64, *&[char], *, *), (*const f64, *&[u8], *, *), (*const f64, &str, *, *), (*const f64, &mut &str, *, *), (*const f64, &HammingResult, *, *), (*const f64, &mut f64, *, *), (*const f64, &[char], *, *), (*const f64, *const usize, *, *), (*&[char], HammingResult, *, *), (*&[char], &mut HammingResult, *, *), (*&[char], *const &[char], *, *), (*&[char], *const f64, *, *), (*&[char], *const &str, *, *), (*&[char], &mut &[u8], *, *), (*&[char], &&str, *, *), (*&[char], f64, *, *), (*&[char], *&str, *, *), (*&[char], &&[u8], *, *), (*&[char], *HammingResult, *, *), (*&[char], *const HammingResult, *, *), (*&[char], &&[char], *, *), (*&[char], usize, *, *), (*&[char], &mut usize, *, *), (*&[char], *const &[u8], *, *), (*&[char], &[u8], *, *), (*&[char], &usize, *, *), (*&[char], *f64, *, *), (*&[char], *usize, *, *), (*&[char], u8, *, *), (*&[char], &mut &[char], *, *), (*&[char], &f64, *, *), (*&[char], *&[char], *, *), (*&[char], *&[u8], *, *), (*&[char], &str, *, *), (*&[char], &mut &str, *, *), (*&[char], &HammingResult, *, *), (*&[char], &mut f64, *, *), (*&[char], &[char], *, *), (*&[char], *const usize, *, *), (&mut &[char], HammingResult, *, *), (&mut &[char], &mut HammingResult, *, *), (&mut &[char], *const &[char], *, *), (&mut &[char], *const f64, *, *), (&mut &[char], *const &str, *, *), (&mut &[char], &mut &[u8], *, *), (&mut &[char], &&str, *, *), (&mut &[char], f64, *, *), (&mut &[char], *&str, *, *), (&mut &[char], &&[u8], *, *), (&mut &[char], *HammingResult, *, *), (&mut &[char], *const HammingResult, *, *), (&mut &[char], &&[char], *, *), (&mut &[char], usize, *, *), (&mut &[char], &mut usize, *, *), (&mut &[char], *const &[u8], *, *), (&mut &[char], &[u8], *, *), (&mut &[char], &usize, *, *), (&mut &[char], *f64, *, *), (&mut &[char], *usize, *, *), (&mut &[char], u8, *, *), (&mut &[char], &mut &[char], *, *), (&mut &[char], &f64, *, *), (&mut &[char], *&[char], *, *), (&mut &[char], *&[u8], *, *), (&mut &[char], &str, *, *), (&mut &[char], &mut &str, *, *), (&mut &[char], &HammingResult, *, *), (&mut &[char], &mut f64, *, *), (&mut &[char], &[char], *, *), (&mut &[char], *const usize, *, *), (&f64, HammingResult, *, *), (&f64, &mut HammingResult, *, *), (&f64, *const &[char], *, *), (&f64, *const f64, *, *), (&f64, *const &str, *, *), (&f64, &mut &[u8], *, *), (&f64, &&str, *, *), (&f64, f64, *, *), (&f64, *&str, *, *), (&f64, &&[u8], *, *), (&f64, *HammingResult, *, *), (&f64, *const HammingResult, *, *), (&f64, &&[char], *, *), (&f64, usize, *, *), (&f64, &mut usize, *, *), (&f64, *const &[u8], *, *), (&f64, &[u8], *, *), (&f64, &usize, *, *), (&f64, *f64, *, *), (&f64, *usize, *, *), (&f64, u8, *, *), (&f64, &mut &[char], *, *), (&f64, &f64, *, *), (&f64, *&[char], *, *), (&f64, *&[u8], *, *), (&f64, &str, *, *), (&f64, &mut &str, *, *), (&f64, &HammingResult, *, *), (&f64, &mut f64, *, *), (&f64, &[char], *, *), (&f64, *const usize, *, *), (&usize, HammingResult, *, *), (&usize, &mut HammingResult, *, *), (&usize, *const &[char], *, *), (&usize, *const f64, *, *), (&usize, *const &str, *, *), (&usize, &mut &[u8], *, *), (&usize, &&str, *, *), (&usize, f64, *, *), (&usize, *&str, *, *), (&usize, &&[u8], *, *), (&usize, *HammingResult, *, *), (&usize, *const HammingResult, *, *), (&usize, &&[char], *, *), (&usize, usize, *, *), (&usize, &mut usize, *, *), (&usize, *const &[u8], *, *), (&usize, &[u8], *, *), (&usize, &usize, *, *), (&usize, *f64, *, *), (&usize, *usize, *, *), (&usize, u8, *, *), (&usize, &mut &[char], *, *), (&usize, &f64, *, *), (&usize, *&[char], *, *), (&usize, *&[u8], *, *), (&usize, &str, *, *), (&usize, &mut &str, *, *), (&usize, &HammingResult, *, *), (&usize, &mut f64, *, *), (&usize, &[char], *, *), (&usize, *const usize, *, *), (&mut usize, HammingResult, *, *), (&mut usize, &mut HammingResult, *, *), (&mut usize, *const &[char], *, *), (&mut usize, *const f64, *, *), (&mut usize, *const &str, *, *), (&mut usize, &mut &[u8], *, *), (&mut usize, &&str, *, *), (&mut usize, f64, *, *), (&mut usize, *&str, *, *), (&mut usize, &&[u8], *, *), (&mut usize, *HammingResult, *, *), (&mut usize, *const HammingResult, *, *), (&mut usize, &&[char], *, *), (&mut usize, usize, *, *), (&mut usize, &mut usize, *, *), (&mut usize, *const &[u8], *, *), (&mut usize, &[u8], *, *), (&mut usize, &usize, *, *), (&mut usize, *f64, *, *), (&mut usize, *usize, *, *), (&mut usize, u8, *, *), (&mut usize, &mut &[char], *, *), (&mut usize, &f64, *, *), (&mut usize, *&[char], *, *), (&mut usize, *&[u8], *, *), (&mut usize, &str, *, *), (&mut usize, &mut &str, *, *), (&mut usize, &HammingResult, *, *), (&mut usize, &mut f64, *, *), (&mut usize, &[char], *, *), (&mut usize, *const usize, *, *), (u8, HammingResult, *, *), (u8, &mut HammingResult, *, *), (u8, *const &[char], *, *), (u8, *const f64, *, *), (u8, *const &str, *, *), (u8, &mut &[u8], *, *), (u8, &&str, *, *), (u8, f64, *, *), (u8, *&str, *, *), (u8, &&[u8], *, *), (u8, *HammingResult, *, *), (u8, *const HammingResult, *, *), (u8, &&[char], *, *), (u8, usize, *, *), (u8, &mut usize, *, *), (u8, *const &[u8], *, *), (u8, &[u8], *, *), (u8, &usize, *, *), (u8, *f64, *, *), (u8, *usize, *, *), (u8, u8, *, *), (u8, &mut &[char], *, *), (u8, &f64, *, *), (u8, *&[char], *, *), (u8, *&[u8], *, *), (u8, &str, *, *), (u8, &mut &str, *, *), (u8, &HammingResult, *, *), (u8, &mut f64, *, *), (u8, &[char], *, *), (u8, *const usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, &mut HammingResult, *, *), (HammingResult, *const &[char], *, *), (HammingResult, *const f64, *, *), (HammingResult, *const &str, *, *), (HammingResult, &mut &[u8], *, *), (HammingResult, &&str, *, *), (HammingResult, f64, *, *), (HammingResult, *&str, *, *), (HammingResult, &&[u8], *, *), (HammingResult, *HammingResult, *, *), (HammingResult, *const HammingResult, *, *), (HammingResult, &&[char], *, *), (HammingResult, usize, *, *), (HammingResult, &mut usize, *, *), (HammingResult, *const &[u8], *, *), (HammingResult, &[u8], *, *), (HammingResult, &usize, *, *), (HammingResult, *f64, *, *), (HammingResult, *usize, *, *), (HammingResult, u8, *, *), (HammingResult, &mut &[char], *, *), (HammingResult, &f64, *, *), (HammingResult, *&[char], *, *), (HammingResult, *&[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &mut &str, *, *), (HammingResult, &HammingResult, *, *), (HammingResult, &mut f64, *, *), (HammingResult, &[char], *, *), (HammingResult, *const usize, *, *), (usize, HammingResult, *, *), (usize, &mut HammingResult, *, *), (usize, *const &[char], *, *), (usize, *const f64, *, *), (usize, *const &str, *, *), (usize, &mut &[u8], *, *), (usize, &&str, *, *), (usize, f64, *, *), (usize, *&str, *, *), (usize, &&[u8], *, *), (usize, *HammingResult, *, *), (usize, *const HammingResult, *, *), (usize, &&[char], *, *), (usize, usize, *, *), (usize, &mut usize, *, *), (usize, *const &[u8], *, *), (usize, &[u8], *, *), (usize, &usize, *, *), (usize, *f64, *, *), (usize, *usize, *, *), (usize, u8, *, *), (usize, &mut &[char], *, *), (usize, &f64, *, *), (usize, *&[char], *, *), (usize, *&[u8], *, *), (usize, &str, *, *), (usize, &mut &str, *, *), (usize, &HammingResult, *, *), (usize, &mut f64, *, *), (usize, &[char], *, *), (usize, *const usize, *, *), (*const &[char], HammingResult, *, *), (*const &[char], &mut HammingResult, *, *), (*const &[char], *const &[char], *, *), (*const &[char], *const f64, *, *), (*const &[char], *const &str, *, *), (*const &[char], &mut &[u8], *, *), (*const &[char], &&str, *, *), (*const &[char], f64, *, *), (*const &[char], *&str, *, *), (*const &[char], &&[u8], *, *), (*const &[char], *HammingResult, *, *), (*const &[char], *const HammingResult, *, *), (*const &[char], &&[char], *, *), (*const &[char], usize, *, *), (*const &[char], &mut usize, *, *), (*const &[char], *const &[u8], *, *), (*const &[char], &[u8], *, *), (*const &[char], &usize, *, *), (*const &[char], *f64, *, *), (*const &[char], *usize, *, *), (*const &[char], u8, *, *), (*const &[char], &mut &[char], *, *), (*const &[char], &f64, *, *), (*const &[char], *&[char], *, *), (*const &[char], *&[u8], *, *), (*const &[char], &str, *, *), (*const &[char], &mut &str, *, *), (*const &[char], &HammingResult, *, *), (*const &[char], &mut f64, *, *), (*const &[char], &[char], *, *), (*const &[char], *const usize, *, *), (&mut HammingResult, HammingResult, *, *), (&mut HammingResult, &mut HammingResult, *, *), (&mut HammingResult, *const &[char], *, *), (&mut HammingResult, *const f64, *, *), (&mut HammingResult, *const &str, *, *), (&mut HammingResult, &mut &[u8], *, *), (&mut HammingResult, &&str, *, *), (&mut HammingResult, f64, *, *), (&mut HammingResult, *&str, *, *), (&mut HammingResult, &&[u8], *, *), (&mut HammingResult, *HammingResult, *, *), (&mut HammingResult, *const HammingResult, *, *), (&mut HammingResult, &&[char], *, *), (&mut HammingResult, usize, *, *), (&mut HammingResult, &mut usize, *, *), (&mut HammingResult, *const &[u8], *, *), (&mut HammingResult, &[u8], *, *), (&mut HammingResult, &usize, *, *), (&mut HammingResult, *f64, *, *), (&mut HammingResult, *usize, *, *), (&mut HammingResult, u8, *, *), (&mut HammingResult, &mut &[char], *, *), (&mut HammingResult, &f64, *, *), (&mut HammingResult, *&[char], *, *), (&mut HammingResult, *&[u8], *, *), (&mut HammingResult, &str, *, *), (&mut HammingResult, &mut &str, *, *), (&mut HammingResult, &HammingResult, *, *), (&mut HammingResult, &mut f64, *, *), (&mut HammingResult, &[char], *, *), (&mut HammingResult, *const usize, *, *), (*const &[u8], HammingResult, *, *), (*const &[u8], &mut HammingResult, *, *), (*const &[u8], *const &[char], *, *), (*const &[u8], *const f64, *, *), (*const &[u8], *const &str, *, *), (*const &[u8], &mut &[u8], *, *), (*const &[u8], &&str, *, *), (*const &[u8], f64, *, *), (*const &[u8], *&str, *, *), (*const &[u8], &&[u8], *, *), (*const &[u8], *HammingResult, *, *), (*const &[u8], *const HammingResult, *, *), (*const &[u8], &&[char], *, *), (*const &[u8], usize, *, *), (*const &[u8], &mut usize, *, *), (*const &[u8], *const &[u8], *, *), (*const &[u8], &[u8], *, *), (*const &[u8], &usize, *, *), (*const &[u8], *f64, *, *), (*const &[u8], *usize, *, *), (*const &[u8], u8, *, *), (*const &[u8], &mut &[char], *, *), (*const &[u8], &f64, *, *), (*const &[u8], *&[char], *, *), (*const &[u8], *&[u8], *, *), (*const &[u8], &str, *, *), (*const &[u8], &mut &str, *, *), (*const &[u8], &HammingResult, *, *), (*const &[u8], &mut f64, *, *), (*const &[u8], &[char], *, *), (*const &[u8], *const usize, *, *), (*f64, HammingResult, *, *), (*f64, &mut HammingResult, *, *), (*f64, *const &[char], *, *), (*f64, *const f64, *, *), (*f64, *const &str, *, *), (*f64, &mut &[u8], *, *), (*f64, &&str, *, *), (*f64, f64, *, *), (*f64, *&str, *, *), (*f64, &&[u8], *, *), (*f64, *HammingResult, *, *), (*f64, *const HammingResult, *, *), (*f64, &&[char], *, *), (*f64, usize, *, *), (*f64, &mut usize, *, *), (*f64, *const &[u8], *, *), (*f64, &[u8], *, *), (*f64, &usize, *, *), (*f64, *f64, *, *), (*f64, *usize, *, *), (*f64, u8, *, *), (*f64, &mut &[char], *, *), (*f64, &f64, *, *), (*f64, *&[char], *, *), (*f64, *&[u8], *, *), (*f64, &str, *, *), (*f64, &mut &str, *, *), (*f64, &HammingResult, *, *), (*f64, &mut f64, *, *), (*f64, &[char], *, *), (*f64, *const usize, *, *), (&HammingResult, HammingResult, *, *), (&HammingResult, &mut HammingResult, *, *), (&HammingResult, *const &[char], *, *), (&HammingResult, *const f64, *, *), (&HammingResult, *const &str, *, *), (&HammingResult, &mut &[u8], *, *), (&HammingResult, &&str, *, *), (&HammingResult, f64, *, *), (&HammingResult, *&str, *, *), (&HammingResult, &&[u8], *, *), (&HammingResult, *HammingResult, *, *), (&HammingResult, *const HammingResult, *, *), (&HammingResult, &&[char], *, *), (&HammingResult, usize, *, *), (&HammingResult, &mut usize, *, *), (&HammingResult, *const &[u8], *, *), (&HammingResult, &[u8], *, *), (&HammingResult, &usize, *, *), (&HammingResult, *f64, *, *), (&HammingResult, *usize, *, *), (&HammingResult, u8, *, *), (&HammingResult, &mut &[char], *, *), (&HammingResult, &f64, *, *), (&HammingResult, *&[char], *, *), (&HammingResult, *&[u8], *, *), (&HammingResult, &str, *, *), (&HammingResult, &mut &str, *, *), (&HammingResult, &HammingResult, *, *), (&HammingResult, &mut f64, *, *), (&HammingResult, &[char], *, *), (&HammingResult, *const usize, *, *), (&str, HammingResult, *, *), (&str, &mut HammingResult, *, *), (&str, *const &[char], *, *), (&str, *const f64, *, *), (&str, *const &str, *, *), (&str, &mut &[u8], *, *), (&str, &&str, *, *), (&str, f64, *, *), (&str, *&str, *, *), (&str, &&[u8], *, *), (&str, *HammingResult, *, *), (&str, *const HammingResult, *, *), (&str, &&[char], *, *), (&str, usize, *, *), (&str, &mut usize, *, *), (&str, *const &[u8], *, *), (&str, &[u8], *, *), (&str, &usize, *, *), (&str, *f64, *, *), (&str, *usize, *, *), (&str, u8, *, *), (&str, &mut &[char], *, *), (&str, &f64, *, *), (&str, *&[char], *, *), (&str, *&[u8], *, *), (&str, &str, *, *), (&str, &mut &str, *, *), (&str, &HammingResult, *, *), (&str, &mut f64, *, *), (&str, &[char], *, *), (&str, *const usize, *, *), (&mut &[u8], HammingResult, *, *), (&mut &[u8], &mut HammingResult, *, *), (&mut &[u8], *const &[char], *, *), (&mut &[u8], *const f64, *, *), (&mut &[u8], *const &str, *, *), (&mut &[u8], &mut &[u8], *, *), (&mut &[u8], &&str, *, *), (&mut &[u8], f64, *, *), (&mut &[u8], *&str, *, *), (&mut &[u8], &&[u8], *, *), (&mut &[u8], *HammingResult, *, *), (&mut &[u8], *const HammingResult, *, *), (&mut &[u8], &&[char], *, *), (&mut &[u8], usize, *, *), (&mut &[u8], &mut usize, *, *), (&mut &[u8], *const &[u8], *, *), (&mut &[u8], &[u8], *, *), (&mut &[u8], &usize, *, *), (&mut &[u8], *f64, *, *), (&mut &[u8], *usize, *, *), (&mut &[u8], u8, *, *), (&mut &[u8], &mut &[char], *, *), (&mut &[u8], &f64, *, *), (&mut &[u8], *&[char], *, *), (&mut &[u8], *&[u8], *, *), (&mut &[u8], &str, *, *), (&mut &[u8], &mut &str, *, *), (&mut &[u8], &HammingResult, *, *), (&mut &[u8], &mut f64, *, *), (&mut &[u8], &[char], *, *), (&mut &[u8], *const usize, *, *), (*const &str, HammingResult, *, *), (*const &str, &mut HammingResult, *, *), (*const &str, *const &[char], *, *), (*const &str, *const f64, *, *), (*const &str, *const &str, *, *), (*const &str, &mut &[u8], *, *), (*const &str, &&str, *, *), (*const &str, f64, *, *), (*const &str, *&str, *, *), (*const &str, &&[u8], *, *), (*const &str, *HammingResult, *, *), (*const &str, *const HammingResult, *, *), (*const &str, &&[char], *, *), (*const &str, usize, *, *), (*const &str, &mut usize, *, *), (*const &str, *const &[u8], *, *), (*const &str, &[u8], *, *), (*const &str, &usize, *, *), (*const &str, *f64, *, *), (*const &str, *usize, *, *), (*const &str, u8, *, *), (*const &str, &mut &[char], *, *), (*const &str, &f64, *, *), (*const &str, *&[char], *, *), (*const &str, *&[u8], *, *), (*const &str, &str, *, *), (*const &str, &mut &str, *, *), (*const &str, &HammingResult, *, *), (*const &str, &mut f64, *, *), (*const &str, &[char], *, *), (*const &str, *const usize, *, *), (&&str, HammingResult, *, *), (&&str, &mut HammingResult, *, *), (&&str, *const &[char], *, *), (&&str, *const f64, *, *), (&&str, *const &str, *, *), (&&str, &mut &[u8], *, *), (&&str, &&str, *, *), (&&str, f64, *, *), (&&str, *&str, *, *), (&&str, &&[u8], *, *), (&&str, *HammingResult, *, *), (&&str, *const HammingResult, *, *), (&&str, &&[char], *, *), (&&str, usize, *, *), (&&str, &mut usize, *, *), (&&str, *const &[u8], *, *), (&&str, &[u8], *, *), (&&str, &usize, *, *), (&&str, *f64, *, *), (&&str, *usize, *, *), (&&str, u8, *, *), (&&str, &mut &[char], *, *), (&&str, &f64, *, *), (&&str, *&[char], *, *), (&&str, *&[u8], *, *), (&&str, &str, *, *), (&&str, &mut &str, *, *), (&&str, &HammingResult, *, *), (&&str, &mut f64, *, *), (&&str, &[char], *, *), (&&str, *const usize, *, *), (*HammingResult, HammingResult, *, *), (*HammingResult, &mut HammingResult, *, *), (*HammingResult, *const &[char], *, *), (*HammingResult, *const f64, *, *), (*HammingResult, *const &str, *, *), (*HammingResult, &mut &[u8], *, *), (*HammingResult, &&str, *, *), (*HammingResult, f64, *, *), (*HammingResult, *&str, *, *), (*HammingResult, &&[u8], *, *), (*HammingResult, *HammingResult, *, *), (*HammingResult, *const HammingResult, *, *), (*HammingResult, &&[char], *, *), (*HammingResult, usize, *, *), (*HammingResult, &mut usize, *, *), (*HammingResult, *const &[u8], *, *), (*HammingResult, &[u8], *, *), (*HammingResult, &usize, *, *), (*HammingResult, *f64, *, *), (*HammingResult, *usize, *, *), (*HammingResult, u8, *, *), (*HammingResult, &mut &[char], *, *), (*HammingResult, &f64, *, *), (*HammingResult, *&[char], *, *), (*HammingResult, *&[u8], *, *), (*HammingResult, &str, *, *), (*HammingResult, &mut &str, *, *), (*HammingResult, &HammingResult, *, *), (*HammingResult, &mut f64, *, *), (*HammingResult, &[char], *, *), (*HammingResult, *const usize, *, *), (&[u8], HammingResult, *, *), (&[u8], &mut HammingResult, *, *), (&[u8], *const &[char], *, *), (&[u8], *const f64, *, *), (&[u8], *const &str, *, *), (&[u8], &mut &[u8], *, *), (&[u8], &&str, *, *), (&[u8], f64, *, *), (&[u8], *&str, *, *), (&[u8], &&[u8], *, *), (&[u8], *HammingResult, *, *), (&[u8], *const HammingResult, *, *), (&[u8], &&[char], *, *), (&[u8], usize, *, *), (&[u8], &mut usize, *, *), (&[u8], *const &[u8], *, *), (&[u8], &[u8], *, *), (&[u8], &usize, *, *), (&[u8], *f64, *, *), (&[u8], *usize, *, *), (&[u8], u8, *, *), (&[u8], &mut &[char], *, *), (&[u8], &f64, *, *), (&[u8], *&[char], *, *), (&[u8], *&[u8], *, *), (&[u8], &str, *, *), (&[u8], &mut &str, *, *), (&[u8], &HammingResult, *, *), (&[u8], &mut f64, *, *), (&[u8], &[char], *, *), (&[u8], *const usize, *, *), (&mut &str, HammingResult, *, *), (&mut &str, &mut HammingResult, *, *), (&mut &str, *const &[char], *, *), (&mut &str, *const f64, *, *), (&mut &str, *const &str, *, *), (&mut &str, &mut &[u8], *, *), (&mut &str, &&str, *, *), (&mut &str, f64, *, *), (&mut &str, *&str, *, *), (&mut &str, &&[u8], *, *), (&mut &str, *HammingResult, *, *), (&mut &str, *const HammingResult, *, *), (&mut &str, &&[char], *, *), (&mut &str, usize, *, *), (&mut &str, &mut usize, *, *), (&mut &str, *const &[u8], *, *), (&mut &str, &[u8], *, *), (&mut &str, &usize, *, *), (&mut &str, *f64, *, *), (&mut &str, *usize, *, *), (&mut &str, u8, *, *), (&mut &str, &mut &[char], *, *), (&mut &str, &f64, *, *), (&mut &str, *&[char], *, *), (&mut &str, *&[u8], *, *), (&mut &str, &str, *, *), (&mut &str, &mut &str, *, *), (&mut &str, &HammingResult, *, *), (&mut &str, &mut f64, *, *), (&mut &str, &[char], *, *), (&mut &str, *const usize, *, *), (*const usize, HammingResult, *, *), (*const usize, &mut HammingResult, *, *), (*const usize, *const &[char], *, *), (*const usize, *const f64, *, *), (*const usize, *const &str, *, *), (*const usize, &mut &[u8], *, *), (*const usize, &&str, *, *), (*const usize, f64, *, *), (*const usize, *&str, *, *), (*const usize, &&[u8], *, *), (*const usize, *HammingResult, *, *), (*const usize, *const HammingResult, *, *), (*const usize, &&[char], *, *), (*const usize, usize, *, *), (*const usize, &mut usize, *, *), (*const usize, *const &[u8], *, *), (*const usize, &[u8], *, *), (*const usize, &usize, *, *), (*const usize, *f64, *, *), (*const usize, *usize, *, *), (*const usize, u8, *, *), (*const usize, &mut &[char], *, *), (*const usize, &f64, *, *), (*const usize, *&[char], *, *), (*const usize, *&[u8], *, *), (*const usize, &str, *, *), (*const usize, &mut &str, *, *), (*const usize, &HammingResult, *, *), (*const usize, &mut f64, *, *), (*const usize, &[char], *, *), (*const usize, *const usize, *, *), (&mut f64, HammingResult, *, *), (&mut f64, &mut HammingResult, *, *), (&mut f64, *const &[char], *, *), (&mut f64, *const f64, *, *), (&mut f64, *const &str, *, *), (&mut f64, &mut &[u8], *, *), (&mut f64, &&str, *, *), (&mut f64, f64, *, *), (&mut f64, *&str, *, *), (&mut f64, &&[u8], *, *), (&mut f64, *HammingResult, *, *), (&mut f64, *const HammingResult, *, *), (&mut f64, &&[char], *, *), (&mut f64, usize, *, *), (&mut f64, &mut usize, *, *), (&mut f64, *const &[u8], *, *), (&mut f64, &[u8], *, *), (&mut f64, &usize, *, *), (&mut f64, *f64, *, *), (&mut f64, *usize, *, *), (&mut f64, u8, *, *), (&mut f64, &mut &[char], *, *), (&mut f64, &f64, *, *), (&mut f64, *&[char], *, *), (&mut f64, *&[u8], *, *), (&mut f64, &str, *, *), (&mut f64, &mut &str, *, *), (&mut f64, &HammingResult, *, *), (&mut f64, &mut f64, *, *), (&mut f64, &[char], *, *), (&mut f64, *const usize, *, *), (f64, HammingResult, *, *), (f64, &mut HammingResult, *, *), (f64, *const &[char], *, *), (f64, *const f64, *, *), (f64, *const &str, *, *), (f64, &mut &[u8], *, *), (f64, &&str, *, *), (f64, f64, *, *), (f64, *&str, *, *), (f64, &&[u8], *, *), (f64, *HammingResult, *, *), (f64, *const HammingResult, *, *), (f64, &&[char], *, *), (f64, usize, *, *), (f64, &mut usize, *, *), (f64, *const &[u8], *, *), (f64, &[u8], *, *), (f64, &usize, *, *), (f64, *f64, *, *), (f64, *usize, *, *), (f64, u8, *, *), (f64, &mut &[char], *, *), (f64, &f64, *, *), (f64, *&[char], *, *), (f64, *&[u8], *, *), (f64, &str, *, *), (f64, &mut &str, *, *), (f64, &HammingResult, *, *), (f64, &mut f64, *, *), (f64, &[char], *, *), (f64, *const usize, *, *), (*&str, HammingResult, *, *), (*&str, &mut HammingResult, *, *), (*&str, *const &[char], *, *), (*&str, *const f64, *, *), (*&str, *const &str, *, *), (*&str, &mut &[u8], *, *), (*&str, &&str, *, *), (*&str, f64, *, *), (*&str, *&str, *, *), (*&str, &&[u8], *, *), (*&str, *HammingResult, *, *), (*&str, *const HammingResult, *, *), (*&str, &&[char], *, *), (*&str, usize, *, *), (*&str, &mut usize, *, *), (*&str, *const &[u8], *, *), (*&str, &[u8], *, *), (*&str, &usize, *, *), (*&str, *f64, *, *), (*&str, *usize, *, *), (*&str, u8, *, *), (*&str, &mut &[char], *, *), (*&str, &f64, *, *), (*&str, *&[char], *, *), (*&str, *&[u8], *, *), (*&str, &str, *, *), (*&str, &mut &str, *, *), (*&str, &HammingResult, *, *), (*&str, &mut f64, *, *), (*&str, &[char], *, *), (*&str, *const usize, *, *), (&[char], HammingResult, *, *), (&[char], &mut HammingResult, *, *), (&[char], *const &[char], *, *), (&[char], *const f64, *, *), (&[char], *const &str, *, *), (&[char], &mut &[u8], *, *), (&[char], &&str, *, *), (&[char], f64, *, *), (&[char], *&str, *, *), (&[char], &&[u8], *, *), (&[char], *HammingResult, *, *), (&[char], *const HammingResult, *, *), (&[char], &&[char], *, *), (&[char], usize, *, *), (&[char], &mut usize, *, *), (&[char], *const &[u8], *, *), (&[char], &[u8], *, *), (&[char], &usize, *, *), (&[char], *f64, *, *), (&[char], *usize, *, *), (&[char], u8, *, *), (&[char], &mut &[char], *, *), (&[char], &f64, *, *), (&[char], *&[char], *, *), (&[char], *&[u8], *, *), (&[char], &str, *, *), (&[char], &mut &str, *, *), (&[char], &HammingResult, *, *), (&[char], &mut f64, *, *), (&[char], &[char], *, *), (&[char], *const usize, *, *), (&&[u8], HammingResult, *, *), (&&[u8], &mut HammingResult, *, *), (&&[u8], *const &[char], *, *), (&&[u8], *const f64, *, *), (&&[u8], *const &str, *, *), (&&[u8], &mut &[u8], *, *), (&&[u8], &&str, *, *), (&&[u8], f64, *, *), (&&[u8], *&str, *, *), (&&[u8], &&[u8], *, *), (&&[u8], *HammingResult, *, *), (&&[u8], *const HammingResult, *, *), (&&[u8], &&[char], *, *), (&&[u8], usize, *, *), (&&[u8], &mut usize, *, *), (&&[u8], *const &[u8], *, *), (&&[u8], &[u8], *, *), (&&[u8], &usize, *, *), (&&[u8], *f64, *, *), (&&[u8], *usize, *, *), (&&[u8], u8, *, *), (&&[u8], &mut &[char], *, *), (&&[u8], &f64, *, *), (&&[u8], *&[char], *, *), (&&[u8], *&[u8], *, *), (&&[u8], &str, *, *), (&&[u8], &mut &str, *, *), (&&[u8], &HammingResult, *, *), (&&[u8], &mut f64, *, *), (&&[u8], &[char], *, *), (&&[u8], *const usize, *, *), (*&[u8], HammingResult, *, *), (*&[u8], &mut HammingResult, *, *), (*&[u8], *const &[char], *, *), (*&[u8], *const f64, *, *), (*&[u8], *const &str, *, *), (*&[u8], &mut &[u8], *, *), (*&[u8], &&str, *, *), (*&[u8], f64, *, *), (*&[u8], *&str, *, *), (*&[u8], &&[u8], *, *), (*&[u8], *HammingResult, *, *), (*&[u8], *const HammingResult, *, *), (*&[u8], &&[char], *, *), (*&[u8], usize, *, *), (*&[u8], &mut usize, *, *), (*&[u8], *const &[u8], *, *), (*&[u8], &[u8], *, *), (*&[u8], &usize, *, *), (*&[u8], *f64, *, *), (*&[u8], *usize, *, *), (*&[u8], u8, *, *), (*&[u8], &mut &[char], *, *), (*&[u8], &f64, *, *), (*&[u8], *&[char], *, *), (*&[u8], *&[u8], *, *), (*&[u8], &str, *, *), (*&[u8], &mut &str, *, *), (*&[u8], &HammingResult, *, *), (*&[u8], &mut f64, *, *), (*&[u8], &[char], *, *), (*&[u8], *const usize, *, *)`
[Solver] Solution Set = `(*usize, HammingResult, *, *), (*usize, &mut HammingResult, *, *), (*usize, *const &[char], *, *), (*usize, *const f64, *, *), (*usize, *const &str, *, *), (*usize, &mut &[u8], *, *), (*usize, &&str, *, *), (*usize, f64, *, *), (*usize, *&str, *, *), (*usize, &&[u8], *, *), (*usize, *HammingResult, *, *), (*usize, *const HammingResult, *, *), (*usize, &&[char], *, *), (*usize, usize, *, *), (*usize, &mut usize, *, *), (*usize, *const &[u8], *, *), (*usize, &[u8], *, *), (*usize, &usize, *, *), (*usize, *f64, *, *), (*usize, *usize, *, *), (*usize, u8, *, *), (*usize, &mut &[char], *, *), (*usize, &f64, *, *), (*usize, *&[char], *, *), (*usize, *&[u8], *, *), (*usize, &str, *, *), (*usize, &mut &str, *, *), (*usize, &HammingResult, *, *), (*usize, &mut f64, *, *), (*usize, &[char], *, *), (*usize, *const usize, *, *), (&&[char], HammingResult, *, *), (&&[char], &mut HammingResult, *, *), (&&[char], *const &[char], *, *), (&&[char], *const f64, *, *), (&&[char], *const &str, *, *), (&&[char], &mut &[u8], *, *), (&&[char], &&str, *, *), (&&[char], f64, *, *), (&&[char], *&str, *, *), (&&[char], &&[u8], *, *), (&&[char], *HammingResult, *, *), (&&[char], *const HammingResult, *, *), (&&[char], &&[char], *, *), (&&[char], usize, *, *), (&&[char], &mut usize, *, *), (&&[char], *const &[u8], *, *), (&&[char], &[u8], *, *), (&&[char], &usize, *, *), (&&[char], *f64, *, *), (&&[char], *usize, *, *), (&&[char], u8, *, *), (&&[char], &mut &[char], *, *), (&&[char], &f64, *, *), (&&[char], *&[char], *, *), (&&[char], *&[u8], *, *), (&&[char], &str, *, *), (&&[char], &mut &str, *, *), (&&[char], &HammingResult, *, *), (&&[char], &mut f64, *, *), (&&[char], &[char], *, *), (&&[char], *const usize, *, *), (*const HammingResult, HammingResult, *, *), (*const HammingResult, &mut HammingResult, *, *), (*const HammingResult, *const &[char], *, *), (*const HammingResult, *const f64, *, *), (*const HammingResult, *const &str, *, *), (*const HammingResult, &mut &[u8], *, *), (*const HammingResult, &&str, *, *), (*const HammingResult, f64, *, *), (*const HammingResult, *&str, *, *), (*const HammingResult, &&[u8], *, *), (*const HammingResult, *HammingResult, *, *), (*const HammingResult, *const HammingResult, *, *), (*const HammingResult, &&[char], *, *), (*const HammingResult, usize, *, *), (*const HammingResult, &mut usize, *, *), (*const HammingResult, *const &[u8], *, *), (*const HammingResult, &[u8], *, *), (*const HammingResult, &usize, *, *), (*const HammingResult, *f64, *, *), (*const HammingResult, *usize, *, *), (*const HammingResult, u8, *, *), (*const HammingResult, &mut &[char], *, *), (*const HammingResult, &f64, *, *), (*const HammingResult, *&[char], *, *), (*const HammingResult, *&[u8], *, *), (*const HammingResult, &str, *, *), (*const HammingResult, &mut &str, *, *), (*const HammingResult, &HammingResult, *, *), (*const HammingResult, &mut f64, *, *), (*const HammingResult, &[char], *, *), (*const HammingResult, *const usize, *, *), (*const f64, HammingResult, *, *), (*const f64, &mut HammingResult, *, *), (*const f64, *const &[char], *, *), (*const f64, *const f64, *, *), (*const f64, *const &str, *, *), (*const f64, &mut &[u8], *, *), (*const f64, &&str, *, *), (*const f64, f64, *, *), (*const f64, *&str, *, *), (*const f64, &&[u8], *, *), (*const f64, *HammingResult, *, *), (*const f64, *const HammingResult, *, *), (*const f64, &&[char], *, *), (*const f64, usize, *, *), (*const f64, &mut usize, *, *), (*const f64, *const &[u8], *, *), (*const f64, &[u8], *, *), (*const f64, &usize, *, *), (*const f64, *f64, *, *), (*const f64, *usize, *, *), (*const f64, u8, *, *), (*const f64, &mut &[char], *, *), (*const f64, &f64, *, *), (*const f64, *&[char], *, *), (*const f64, *&[u8], *, *), (*const f64, &str, *, *), (*const f64, &mut &str, *, *), (*const f64, &HammingResult, *, *), (*const f64, &mut f64, *, *), (*const f64, &[char], *, *), (*const f64, *const usize, *, *), (*&[char], HammingResult, *, *), (*&[char], &mut HammingResult, *, *), (*&[char], *const &[char], *, *), (*&[char], *const f64, *, *), (*&[char], *const &str, *, *), (*&[char], &mut &[u8], *, *), (*&[char], &&str, *, *), (*&[char], f64, *, *), (*&[char], *&str, *, *), (*&[char], &&[u8], *, *), (*&[char], *HammingResult, *, *), (*&[char], *const HammingResult, *, *), (*&[char], &&[char], *, *), (*&[char], usize, *, *), (*&[char], &mut usize, *, *), (*&[char], *const &[u8], *, *), (*&[char], &[u8], *, *), (*&[char], &usize, *, *), (*&[char], *f64, *, *), (*&[char], *usize, *, *), (*&[char], u8, *, *), (*&[char], &mut &[char], *, *), (*&[char], &f64, *, *), (*&[char], *&[char], *, *), (*&[char], *&[u8], *, *), (*&[char], &str, *, *), (*&[char], &mut &str, *, *), (*&[char], &HammingResult, *, *), (*&[char], &mut f64, *, *), (*&[char], &[char], *, *), (*&[char], *const usize, *, *), (&mut &[char], HammingResult, *, *), (&mut &[char], &mut HammingResult, *, *), (&mut &[char], *const &[char], *, *), (&mut &[char], *const f64, *, *), (&mut &[char], *const &str, *, *), (&mut &[char], &mut &[u8], *, *), (&mut &[char], &&str, *, *), (&mut &[char], f64, *, *), (&mut &[char], *&str, *, *), (&mut &[char], &&[u8], *, *), (&mut &[char], *HammingResult, *, *), (&mut &[char], *const HammingResult, *, *), (&mut &[char], &&[char], *, *), (&mut &[char], usize, *, *), (&mut &[char], &mut usize, *, *), (&mut &[char], *const &[u8], *, *), (&mut &[char], &[u8], *, *), (&mut &[char], &usize, *, *), (&mut &[char], *f64, *, *), (&mut &[char], *usize, *, *), (&mut &[char], u8, *, *), (&mut &[char], &mut &[char], *, *), (&mut &[char], &f64, *, *), (&mut &[char], *&[char], *, *), (&mut &[char], *&[u8], *, *), (&mut &[char], &str, *, *), (&mut &[char], &mut &str, *, *), (&mut &[char], &HammingResult, *, *), (&mut &[char], &mut f64, *, *), (&mut &[char], &[char], *, *), (&mut &[char], *const usize, *, *), (&f64, HammingResult, *, *), (&f64, &mut HammingResult, *, *), (&f64, *const &[char], *, *), (&f64, *const f64, *, *), (&f64, *const &str, *, *), (&f64, &mut &[u8], *, *), (&f64, &&str, *, *), (&f64, f64, *, *), (&f64, *&str, *, *), (&f64, &&[u8], *, *), (&f64, *HammingResult, *, *), (&f64, *const HammingResult, *, *), (&f64, &&[char], *, *), (&f64, usize, *, *), (&f64, &mut usize, *, *), (&f64, *const &[u8], *, *), (&f64, &[u8], *, *), (&f64, &usize, *, *), (&f64, *f64, *, *), (&f64, *usize, *, *), (&f64, u8, *, *), (&f64, &mut &[char], *, *), (&f64, &f64, *, *), (&f64, *&[char], *, *), (&f64, *&[u8], *, *), (&f64, &str, *, *), (&f64, &mut &str, *, *), (&f64, &HammingResult, *, *), (&f64, &mut f64, *, *), (&f64, &[char], *, *), (&f64, *const usize, *, *), (&usize, HammingResult, *, *), (&usize, &mut HammingResult, *, *), (&usize, *const &[char], *, *), (&usize, *const f64, *, *), (&usize, *const &str, *, *), (&usize, &mut &[u8], *, *), (&usize, &&str, *, *), (&usize, f64, *, *), (&usize, *&str, *, *), (&usize, &&[u8], *, *), (&usize, *HammingResult, *, *), (&usize, *const HammingResult, *, *), (&usize, &&[char], *, *), (&usize, usize, *, *), (&usize, &mut usize, *, *), (&usize, *const &[u8], *, *), (&usize, &[u8], *, *), (&usize, &usize, *, *), (&usize, *f64, *, *), (&usize, *usize, *, *), (&usize, u8, *, *), (&usize, &mut &[char], *, *), (&usize, &f64, *, *), (&usize, *&[char], *, *), (&usize, *&[u8], *, *), (&usize, &str, *, *), (&usize, &mut &str, *, *), (&usize, &HammingResult, *, *), (&usize, &mut f64, *, *), (&usize, &[char], *, *), (&usize, *const usize, *, *), (&mut usize, HammingResult, *, *), (&mut usize, &mut HammingResult, *, *), (&mut usize, *const &[char], *, *), (&mut usize, *const f64, *, *), (&mut usize, *const &str, *, *), (&mut usize, &mut &[u8], *, *), (&mut usize, &&str, *, *), (&mut usize, f64, *, *), (&mut usize, *&str, *, *), (&mut usize, &&[u8], *, *), (&mut usize, *HammingResult, *, *), (&mut usize, *const HammingResult, *, *), (&mut usize, &&[char], *, *), (&mut usize, usize, *, *), (&mut usize, &mut usize, *, *), (&mut usize, *const &[u8], *, *), (&mut usize, &[u8], *, *), (&mut usize, &usize, *, *), (&mut usize, *f64, *, *), (&mut usize, *usize, *, *), (&mut usize, u8, *, *), (&mut usize, &mut &[char], *, *), (&mut usize, &f64, *, *), (&mut usize, *&[char], *, *), (&mut usize, *&[u8], *, *), (&mut usize, &str, *, *), (&mut usize, &mut &str, *, *), (&mut usize, &HammingResult, *, *), (&mut usize, &mut f64, *, *), (&mut usize, &[char], *, *), (&mut usize, *const usize, *, *), (u8, HammingResult, *, *), (u8, &mut HammingResult, *, *), (u8, *const &[char], *, *), (u8, *const f64, *, *), (u8, *const &str, *, *), (u8, &mut &[u8], *, *), (u8, &&str, *, *), (u8, f64, *, *), (u8, *&str, *, *), (u8, &&[u8], *, *), (u8, *HammingResult, *, *), (u8, *const HammingResult, *, *), (u8, &&[char], *, *), (u8, usize, *, *), (u8, &mut usize, *, *), (u8, *const &[u8], *, *), (u8, &[u8], *, *), (u8, &usize, *, *), (u8, *f64, *, *), (u8, *usize, *, *), (u8, u8, *, *), (u8, &mut &[char], *, *), (u8, &f64, *, *), (u8, *&[char], *, *), (u8, *&[u8], *, *), (u8, &str, *, *), (u8, &mut &str, *, *), (u8, &HammingResult, *, *), (u8, &mut f64, *, *), (u8, &[char], *, *), (u8, *const usize, *, *), (HammingResult, HammingResult, *, *), (HammingResult, &mut HammingResult, *, *), (HammingResult, *const &[char], *, *), (HammingResult, *const f64, *, *), (HammingResult, *const &str, *, *), (HammingResult, &mut &[u8], *, *), (HammingResult, &&str, *, *), (HammingResult, f64, *, *), (HammingResult, *&str, *, *), (HammingResult, &&[u8], *, *), (HammingResult, *HammingResult, *, *), (HammingResult, *const HammingResult, *, *), (HammingResult, &&[char], *, *), (HammingResult, usize, *, *), (HammingResult, &mut usize, *, *), (HammingResult, *const &[u8], *, *), (HammingResult, &[u8], *, *), (HammingResult, &usize, *, *), (HammingResult, *f64, *, *), (HammingResult, *usize, *, *), (HammingResult, u8, *, *), (HammingResult, &mut &[char], *, *), (HammingResult, &f64, *, *), (HammingResult, *&[char], *, *), (HammingResult, *&[u8], *, *), (HammingResult, &str, *, *), (HammingResult, &mut &str, *, *), (HammingResult, &HammingResult, *, *), (HammingResult, &mut f64, *, *), (HammingResult, &[char], *, *), (HammingResult, *const usize, *, *), (usize, HammingResult, *, *), (usize, &mut HammingResult, *, *), (usize, *const &[char], *, *), (usize, *const f64, *, *), (usize, *const &str, *, *), (usize, &mut &[u8], *, *), (usize, &&str, *, *), (usize, f64, *, *), (usize, *&str, *, *), (usize, &&[u8], *, *), (usize, *HammingResult, *, *), (usize, *const HammingResult, *, *), (usize, &&[char], *, *), (usize, usize, *, *), (usize, &mut usize, *, *), (usize, *const &[u8], *, *), (usize, &[u8], *, *), (usize, &usize, *, *), (usize, *f64, *, *), (usize, *usize, *, *), (usize, u8, *, *), (usize, &mut &[char], *, *), (usize, &f64, *, *), (usize, *&[char], *, *), (usize, *&[u8], *, *), (usize, &str, *, *), (usize, &mut &str, *, *), (usize, &HammingResult, *, *), (usize, &mut f64, *, *), (usize, &[char], *, *), (usize, *const usize, *, *), (*const &[char], HammingResult, *, *), (*const &[char], &mut HammingResult, *, *), (*const &[char], *const &[char], *, *), (*const &[char], *const f64, *, *), (*const &[char], *const &str, *, *), (*const &[char], &mut &[u8], *, *), (*const &[char], &&str, *, *), (*const &[char], f64, *, *), (*const &[char], *&str, *, *), (*const &[char], &&[u8], *, *), (*const &[char], *HammingResult, *, *), (*const &[char], *const HammingResult, *, *), (*const &[char], &&[char], *, *), (*const &[char], usize, *, *), (*const &[char], &mut usize, *, *), (*const &[char], *const &[u8], *, *), (*const &[char], &[u8], *, *), (*const &[char], &usize, *, *), (*const &[char], *f64, *, *), (*const &[char], *usize, *, *), (*const &[char], u8, *, *), (*const &[char], &mut &[char], *, *), (*const &[char], &f64, *, *), (*const &[char], *&[char], *, *), (*const &[char], *&[u8], *, *), (*const &[char], &str, *, *), (*const &[char], &mut &str, *, *), (*const &[char], &HammingResult, *, *), (*const &[char], &mut f64, *, *), (*const &[char], &[char], *, *), (*const &[char], *const usize, *, *), (&mut HammingResult, HammingResult, *, *), (&mut HammingResult, &mut HammingResult, *, *), (&mut HammingResult, *const &[char], *, *), (&mut HammingResult, *const f64, *, *), (&mut HammingResult, *const &str, *, *), (&mut HammingResult, &mut &[u8], *, *), (&mut HammingResult, &&str, *, *), (&mut HammingResult, f64, *, *), (&mut HammingResult, *&str, *, *), (&mut HammingResult, &&[u8], *, *), (&mut HammingResult, *HammingResult, *, *), (&mut HammingResult, *const HammingResult, *, *), (&mut HammingResult, &&[char], *, *), (&mut HammingResult, usize, *, *), (&mut HammingResult, &mut usize, *, *), (&mut HammingResult, *const &[u8], *, *), (&mut HammingResult, &[u8], *, *), (&mut HammingResult, &usize, *, *), (&mut HammingResult, *f64, *, *), (&mut HammingResult, *usize, *, *), (&mut HammingResult, u8, *, *), (&mut HammingResult, &mut &[char], *, *), (&mut HammingResult, &f64, *, *), (&mut HammingResult, *&[char], *, *), (&mut HammingResult, *&[u8], *, *), (&mut HammingResult, &str, *, *), (&mut HammingResult, &mut &str, *, *), (&mut HammingResult, &HammingResult, *, *), (&mut HammingResult, &mut f64, *, *), (&mut HammingResult, &[char], *, *), (&mut HammingResult, *const usize, *, *), (*const &[u8], HammingResult, *, *), (*const &[u8], &mut HammingResult, *, *), (*const &[u8], *const &[char], *, *), (*const &[u8], *const f64, *, *), (*const &[u8], *const &str, *, *), (*const &[u8], &mut &[u8], *, *), (*const &[u8], &&str, *, *), (*const &[u8], f64, *, *), (*const &[u8], *&str, *, *), (*const &[u8], &&[u8], *, *), (*const &[u8], *HammingResult, *, *), (*const &[u8], *const HammingResult, *, *), (*const &[u8], &&[char], *, *), (*const &[u8], usize, *, *), (*const &[u8], &mut usize, *, *), (*const &[u8], *const &[u8], *, *), (*const &[u8], &[u8], *, *), (*const &[u8], &usize, *, *), (*const &[u8], *f64, *, *), (*const &[u8], *usize, *, *), (*const &[u8], u8, *, *), (*const &[u8], &mut &[char], *, *), (*const &[u8], &f64, *, *), (*const &[u8], *&[char], *, *), (*const &[u8], *&[u8], *, *), (*const &[u8], &str, *, *), (*const &[u8], &mut &str, *, *), (*const &[u8], &HammingResult, *, *), (*const &[u8], &mut f64, *, *), (*const &[u8], &[char], *, *), (*const &[u8], *const usize, *, *), (*f64, HammingResult, *, *), (*f64, &mut HammingResult, *, *), (*f64, *const &[char], *, *), (*f64, *const f64, *, *), (*f64, *const &str, *, *), (*f64, &mut &[u8], *, *), (*f64, &&str, *, *), (*f64, f64, *, *), (*f64, *&str, *, *), (*f64, &&[u8], *, *), (*f64, *HammingResult, *, *), (*f64, *const HammingResult, *, *), (*f64, &&[char], *, *), (*f64, usize, *, *), (*f64, &mut usize, *, *), (*f64, *const &[u8], *, *), (*f64, &[u8], *, *), (*f64, &usize, *, *), (*f64, *f64, *, *), (*f64, *usize, *, *), (*f64, u8, *, *), (*f64, &mut &[char], *, *), (*f64, &f64, *, *), (*f64, *&[char], *, *), (*f64, *&[u8], *, *), (*f64, &str, *, *), (*f64, &mut &str, *, *), (*f64, &HammingResult, *, *), (*f64, &mut f64, *, *), (*f64, &[char], *, *), (*f64, *const usize, *, *), (&HammingResult, HammingResult, *, *), (&HammingResult, &mut HammingResult, *, *), (&HammingResult, *const &[char], *, *), (&HammingResult, *const f64, *, *), (&HammingResult, *const &str, *, *), (&HammingResult, &mut &[u8], *, *), (&HammingResult, &&str, *, *), (&HammingResult, f64, *, *), (&HammingResult, *&str, *, *), (&HammingResult, &&[u8], *, *), (&HammingResult, *HammingResult, *, *), (&HammingResult, *const HammingResult, *, *), (&HammingResult, &&[char], *, *), (&HammingResult, usize, *, *), (&HammingResult, &mut usize, *, *), (&HammingResult, *const &[u8], *, *), (&HammingResult, &[u8], *, *), (&HammingResult, &usize, *, *), (&HammingResult, *f64, *, *), (&HammingResult, *usize, *, *), (&HammingResult, u8, *, *), (&HammingResult, &mut &[char], *, *), (&HammingResult, &f64, *, *), (&HammingResult, *&[char], *, *), (&HammingResult, *&[u8], *, *), (&HammingResult, &str, *, *), (&HammingResult, &mut &str, *, *), (&HammingResult, &HammingResult, *, *), (&HammingResult, &mut f64, *, *), (&HammingResult, &[char], *, *), (&HammingResult, *const usize, *, *), (&str, HammingResult, *, *), (&str, &mut HammingResult, *, *), (&str, *const &[char], *, *), (&str, *const f64, *, *), (&str, *const &str, *, *), (&str, &mut &[u8], *, *), (&str, &&str, *, *), (&str, f64, *, *), (&str, *&str, *, *), (&str, &&[u8], *, *), (&str, *HammingResult, *, *), (&str, *const HammingResult, *, *), (&str, &&[char], *, *), (&str, usize, *, *), (&str, &mut usize, *, *), (&str, *const &[u8], *, *), (&str, &[u8], *, *), (&str, &usize, *, *), (&str, *f64, *, *), (&str, *usize, *, *), (&str, u8, *, *), (&str, &mut &[char], *, *), (&str, &f64, *, *), (&str, *&[char], *, *), (&str, *&[u8], *, *), (&str, &str, *, *), (&str, &mut &str, *, *), (&str, &HammingResult, *, *), (&str, &mut f64, *, *), (&str, &[char], *, *), (&str, *const usize, *, *), (&mut &[u8], HammingResult, *, *), (&mut &[u8], &mut HammingResult, *, *), (&mut &[u8], *const &[char], *, *), (&mut &[u8], *const f64, *, *), (&mut &[u8], *const &str, *, *), (&mut &[u8], &mut &[u8], *, *), (&mut &[u8], &&str, *, *), (&mut &[u8], f64, *, *), (&mut &[u8], *&str, *, *), (&mut &[u8], &&[u8], *, *), (&mut &[u8], *HammingResult, *, *), (&mut &[u8], *const HammingResult, *, *), (&mut &[u8], &&[char], *, *), (&mut &[u8], usize, *, *), (&mut &[u8], &mut usize, *, *), (&mut &[u8], *const &[u8], *, *), (&mut &[u8], &[u8], *, *), (&mut &[u8], &usize, *, *), (&mut &[u8], *f64, *, *), (&mut &[u8], *usize, *, *), (&mut &[u8], u8, *, *), (&mut &[u8], &mut &[char], *, *), (&mut &[u8], &f64, *, *), (&mut &[u8], *&[char], *, *), (&mut &[u8], *&[u8], *, *), (&mut &[u8], &str, *, *), (&mut &[u8], &mut &str, *, *), (&mut &[u8], &HammingResult, *, *), (&mut &[u8], &mut f64, *, *), (&mut &[u8], &[char], *, *), (&mut &[u8], *const usize, *, *), (*const &str, HammingResult, *, *), (*const &str, &mut HammingResult, *, *), (*const &str, *const &[char], *, *), (*const &str, *const f64, *, *), (*const &str, *const &str, *, *), (*const &str, &mut &[u8], *, *), (*const &str, &&str, *, *), (*const &str, f64, *, *), (*const &str, *&str, *, *), (*const &str, &&[u8], *, *), (*const &str, *HammingResult, *, *), (*const &str, *const HammingResult, *, *), (*const &str, &&[char], *, *), (*const &str, usize, *, *), (*const &str, &mut usize, *, *), (*const &str, *const &[u8], *, *), (*const &str, &[u8], *, *), (*const &str, &usize, *, *), (*const &str, *f64, *, *), (*const &str, *usize, *, *), (*const &str, u8, *, *), (*const &str, &mut &[char], *, *), (*const &str, &f64, *, *), (*const &str, *&[char], *, *), (*const &str, *&[u8], *, *), (*const &str, &str, *, *), (*const &str, &mut &str, *, *), (*const &str, &HammingResult, *, *), (*const &str, &mut f64, *, *), (*const &str, &[char], *, *), (*const &str, *const usize, *, *), (&&str, HammingResult, *, *), (&&str, &mut HammingResult, *, *), (&&str, *const &[char], *, *), (&&str, *const f64, *, *), (&&str, *const &str, *, *), (&&str, &mut &[u8], *, *), (&&str, &&str, *, *), (&&str, f64, *, *), (&&str, *&str, *, *), (&&str, &&[u8], *, *), (&&str, *HammingResult, *, *), (&&str, *const HammingResult, *, *), (&&str, &&[char], *, *), (&&str, usize, *, *), (&&str, &mut usize, *, *), (&&str, *const &[u8], *, *), (&&str, &[u8], *, *), (&&str, &usize, *, *), (&&str, *f64, *, *), (&&str, *usize, *, *), (&&str, u8, *, *), (&&str, &mut &[char], *, *), (&&str, &f64, *, *), (&&str, *&[char], *, *), (&&str, *&[u8], *, *), (&&str, &str, *, *), (&&str, &mut &str, *, *), (&&str, &HammingResult, *, *), (&&str, &mut f64, *, *), (&&str, &[char], *, *), (&&str, *const usize, *, *), (*HammingResult, HammingResult, *, *), (*HammingResult, &mut HammingResult, *, *), (*HammingResult, *const &[char], *, *), (*HammingResult, *const f64, *, *), (*HammingResult, *const &str, *, *), (*HammingResult, &mut &[u8], *, *), (*HammingResult, &&str, *, *), (*HammingResult, f64, *, *), (*HammingResult, *&str, *, *), (*HammingResult, &&[u8], *, *), (*HammingResult, *HammingResult, *, *), (*HammingResult, *const HammingResult, *, *), (*HammingResult, &&[char], *, *), (*HammingResult, usize, *, *), (*HammingResult, &mut usize, *, *), (*HammingResult, *const &[u8], *, *), (*HammingResult, &[u8], *, *), (*HammingResult, &usize, *, *), (*HammingResult, *f64, *, *), (*HammingResult, *usize, *, *), (*HammingResult, u8, *, *), (*HammingResult, &mut &[char], *, *), (*HammingResult, &f64, *, *), (*HammingResult, *&[char], *, *), (*HammingResult, *&[u8], *, *), (*HammingResult, &str, *, *), (*HammingResult, &mut &str, *, *), (*HammingResult, &HammingResult, *, *), (*HammingResult, &mut f64, *, *), (*HammingResult, &[char], *, *), (*HammingResult, *const usize, *, *), (&[u8], HammingResult, *, *), (&[u8], &mut HammingResult, *, *), (&[u8], *const &[char], *, *), (&[u8], *const f64, *, *), (&[u8], *const &str, *, *), (&[u8], &mut &[u8], *, *), (&[u8], &&str, *, *), (&[u8], f64, *, *), (&[u8], *&str, *, *), (&[u8], &&[u8], *, *), (&[u8], *HammingResult, *, *), (&[u8], *const HammingResult, *, *), (&[u8], &&[char], *, *), (&[u8], usize, *, *), (&[u8], &mut usize, *, *), (&[u8], *const &[u8], *, *), (&[u8], &[u8], *, *), (&[u8], &usize, *, *), (&[u8], *f64, *, *), (&[u8], *usize, *, *), (&[u8], u8, *, *), (&[u8], &mut &[char], *, *), (&[u8], &f64, *, *), (&[u8], *&[char], *, *), (&[u8], *&[u8], *, *), (&[u8], &str, *, *), (&[u8], &mut &str, *, *), (&[u8], &HammingResult, *, *), (&[u8], &mut f64, *, *), (&[u8], &[char], *, *), (&[u8], *const usize, *, *), (&mut &str, HammingResult, *, *), (&mut &str, &mut HammingResult, *, *), (&mut &str, *const &[char], *, *), (&mut &str, *const f64, *, *), (&mut &str, *const &str, *, *), (&mut &str, &mut &[u8], *, *), (&mut &str, &&str, *, *), (&mut &str, f64, *, *), (&mut &str, *&str, *, *), (&mut &str, &&[u8], *, *), (&mut &str, *HammingResult, *, *), (&mut &str, *const HammingResult, *, *), (&mut &str, &&[char], *, *), (&mut &str, usize, *, *), (&mut &str, &mut usize, *, *), (&mut &str, *const &[u8], *, *), (&mut &str, &[u8], *, *), (&mut &str, &usize, *, *), (&mut &str, *f64, *, *), (&mut &str, *usize, *, *), (&mut &str, u8, *, *), (&mut &str, &mut &[char], *, *), (&mut &str, &f64, *, *), (&mut &str, *&[char], *, *), (&mut &str, *&[u8], *, *), (&mut &str, &str, *, *), (&mut &str, &mut &str, *, *), (&mut &str, &HammingResult, *, *), (&mut &str, &mut f64, *, *), (&mut &str, &[char], *, *), (&mut &str, *const usize, *, *), (*const usize, HammingResult, *, *), (*const usize, &mut HammingResult, *, *), (*const usize, *const &[char], *, *), (*const usize, *const f64, *, *), (*const usize, *const &str, *, *), (*const usize, &mut &[u8], *, *), (*const usize, &&str, *, *), (*const usize, f64, *, *), (*const usize, *&str, *, *), (*const usize, &&[u8], *, *), (*const usize, *HammingResult, *, *), (*const usize, *const HammingResult, *, *), (*const usize, &&[char], *, *), (*const usize, usize, *, *), (*const usize, &mut usize, *, *), (*const usize, *const &[u8], *, *), (*const usize, &[u8], *, *), (*const usize, &usize, *, *), (*const usize, *f64, *, *), (*const usize, *usize, *, *), (*const usize, u8, *, *), (*const usize, &mut &[char], *, *), (*const usize, &f64, *, *), (*const usize, *&[char], *, *), (*const usize, *&[u8], *, *), (*const usize, &str, *, *), (*const usize, &mut &str, *, *), (*const usize, &HammingResult, *, *), (*const usize, &mut f64, *, *), (*const usize, &[char], *, *), (*const usize, *const usize, *, *), (&mut f64, HammingResult, *, *), (&mut f64, &mut HammingResult, *, *), (&mut f64, *const &[char], *, *), (&mut f64, *const f64, *, *), (&mut f64, *const &str, *, *), (&mut f64, &mut &[u8], *, *), (&mut f64, &&str, *, *), (&mut f64, f64, *, *), (&mut f64, *&str, *, *), (&mut f64, &&[u8], *, *), (&mut f64, *HammingResult, *, *), (&mut f64, *const HammingResult, *, *), (&mut f64, &&[char], *, *), (&mut f64, usize, *, *), (&mut f64, &mut usize, *, *), (&mut f64, *const &[u8], *, *), (&mut f64, &[u8], *, *), (&mut f64, &usize, *, *), (&mut f64, *f64, *, *), (&mut f64, *usize, *, *), (&mut f64, u8, *, *), (&mut f64, &mut &[char], *, *), (&mut f64, &f64, *, *), (&mut f64, *&[char], *, *), (&mut f64, *&[u8], *, *), (&mut f64, &str, *, *), (&mut f64, &mut &str, *, *), (&mut f64, &HammingResult, *, *), (&mut f64, &mut f64, *, *), (&mut f64, &[char], *, *), (&mut f64, *const usize, *, *), (f64, HammingResult, *, *), (f64, &mut HammingResult, *, *), (f64, *const &[char], *, *), (f64, *const f64, *, *), (f64, *const &str, *, *), (f64, &mut &[u8], *, *), (f64, &&str, *, *), (f64, f64, *, *), (f64, *&str, *, *), (f64, &&[u8], *, *), (f64, *HammingResult, *, *), (f64, *const HammingResult, *, *), (f64, &&[char], *, *), (f64, usize, *, *), (f64, &mut usize, *, *), (f64, *const &[u8], *, *), (f64, &[u8], *, *), (f64, &usize, *, *), (f64, *f64, *, *), (f64, *usize, *, *), (f64, u8, *, *), (f64, &mut &[char], *, *), (f64, &f64, *, *), (f64, *&[char], *, *), (f64, *&[u8], *, *), (f64, &str, *, *), (f64, &mut &str, *, *), (f64, &HammingResult, *, *), (f64, &mut f64, *, *), (f64, &[char], *, *), (f64, *const usize, *, *), (*&str, HammingResult, *, *), (*&str, &mut HammingResult, *, *), (*&str, *const &[char], *, *), (*&str, *const f64, *, *), (*&str, *const &str, *, *), (*&str, &mut &[u8], *, *), (*&str, &&str, *, *), (*&str, f64, *, *), (*&str, *&str, *, *), (*&str, &&[u8], *, *), (*&str, *HammingResult, *, *), (*&str, *const HammingResult, *, *), (*&str, &&[char], *, *), (*&str, usize, *, *), (*&str, &mut usize, *, *), (*&str, *const &[u8], *, *), (*&str, &[u8], *, *), (*&str, &usize, *, *), (*&str, *f64, *, *), (*&str, *usize, *, *), (*&str, u8, *, *), (*&str, &mut &[char], *, *), (*&str, &f64, *, *), (*&str, *&[char], *, *), (*&str, *&[u8], *, *), (*&str, &str, *, *), (*&str, &mut &str, *, *), (*&str, &HammingResult, *, *), (*&str, &mut f64, *, *), (*&str, &[char], *, *), (*&str, *const usize, *, *), (&[char], HammingResult, *, *), (&[char], &mut HammingResult, *, *), (&[char], *const &[char], *, *), (&[char], *const f64, *, *), (&[char], *const &str, *, *), (&[char], &mut &[u8], *, *), (&[char], &&str, *, *), (&[char], f64, *, *), (&[char], *&str, *, *), (&[char], &&[u8], *, *), (&[char], *HammingResult, *, *), (&[char], *const HammingResult, *, *), (&[char], &&[char], *, *), (&[char], usize, *, *), (&[char], &mut usize, *, *), (&[char], *const &[u8], *, *), (&[char], &[u8], *, *), (&[char], &usize, *, *), (&[char], *f64, *, *), (&[char], *usize, *, *), (&[char], u8, *, *), (&[char], &mut &[char], *, *), (&[char], &f64, *, *), (&[char], *&[char], *, *), (&[char], *&[u8], *, *), (&[char], &str, *, *), (&[char], &mut &str, *, *), (&[char], &HammingResult, *, *), (&[char], &mut f64, *, *), (&[char], &[char], *, *), (&[char], *const usize, *, *), (&&[u8], HammingResult, *, *), (&&[u8], &mut HammingResult, *, *), (&&[u8], *const &[char], *, *), (&&[u8], *const f64, *, *), (&&[u8], *const &str, *, *), (&&[u8], &mut &[u8], *, *), (&&[u8], &&str, *, *), (&&[u8], f64, *, *), (&&[u8], *&str, *, *), (&&[u8], &&[u8], *, *), (&&[u8], *HammingResult, *, *), (&&[u8], *const HammingResult, *, *), (&&[u8], &&[char], *, *), (&&[u8], usize, *, *), (&&[u8], &mut usize, *, *), (&&[u8], *const &[u8], *, *), (&&[u8], &[u8], *, *), (&&[u8], &usize, *, *), (&&[u8], *f64, *, *), (&&[u8], *usize, *, *), (&&[u8], u8, *, *), (&&[u8], &mut &[char], *, *), (&&[u8], &f64, *, *), (&&[u8], *&[char], *, *), (&&[u8], *&[u8], *, *), (&&[u8], &str, *, *), (&&[u8], &mut &str, *, *), (&&[u8], &HammingResult, *, *), (&&[u8], &mut f64, *, *), (&&[u8], &[char], *, *), (&&[u8], *const usize, *, *), (*&[u8], HammingResult, *, *), (*&[u8], &mut HammingResult, *, *), (*&[u8], *const &[char], *, *), (*&[u8], *const f64, *, *), (*&[u8], *const &str, *, *), (*&[u8], &mut &[u8], *, *), (*&[u8], &&str, *, *), (*&[u8], f64, *, *), (*&[u8], *&str, *, *), (*&[u8], &&[u8], *, *), (*&[u8], *HammingResult, *, *), (*&[u8], *const HammingResult, *, *), (*&[u8], &&[char], *, *), (*&[u8], usize, *, *), (*&[u8], &mut usize, *, *), (*&[u8], *const &[u8], *, *), (*&[u8], &[u8], *, *), (*&[u8], &usize, *, *), (*&[u8], *f64, *, *), (*&[u8], *usize, *, *), (*&[u8], u8, *, *), (*&[u8], &mut &[char], *, *), (*&[u8], &f64, *, *), (*&[u8], *&[char], *, *), (*&[u8], *&[u8], *, *), (*&[u8], &str, *, *), (*&[u8], &mut &str, *, *), (*&[u8], &HammingResult, *, *), (*&[u8], &mut f64, *, *), (*&[u8], &[char], *, *), (*&[u8], *const usize, *, *)`
[Solver] mark function as unsolvable
[Solver] Running solve() took 1 ms.
===== all reachable func =====
fn strsim::sorensen_dice(&str, &str) -> f64
fn strsim::normalized_damerau_levenshtein(&str, &str) -> f64
fn strsim::damerau_levenshtein(&str, &str) -> usize
fn strsim::osa_distance(&str, &str) -> usize
fn strsim::normalized_levenshtein(&str, &str) -> f64
fn strsim::levenshtein(&str, &str) -> usize
fn strsim::jaro_winkler(&str, &str) -> f64
fn strsim::jaro(&str, &str) -> f64
fn strsim::hamming(&str, &str) -> strsim::HammingResult
===== !all reachable func =====
[Solver] init diverse solution for fn strsim::generic_damerau_levenshtein(&[Elem], &[Elem]) -> usize
[Solver] init diverse solution for fn strsim::generic_levenshtein(&Iter1, &Iter2) -> usize
[Solver] init diverse solution for fn strsim::generic_jaro_winkler(&Iter1, &Iter2) -> f64
[Solver] init diverse solution for fn strsim::generic_jaro(&Iter1, &Iter2) -> f64
[Solver] init diverse solution for fn strsim::generic_hamming(Iter1, Iter2) -> strsim::HammingResult
===== diverse types =====
===== !diverse types =====
propagate start
===== diverse types =====
===== !diverse types =====
unsolve generic function:
fn strsim::generic_damerau_levenshtein(&[Elem], &[Elem]) -> usize
Where:
Elem: , 
Type Pred:
Elem: std::cmp::Eq + std::hash::Hash + std::clone::Clone

[unsolvable]fn strsim::generic_levenshtein(&Iter1, &Iter2) -> usize
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
&'a Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
&'b Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

[unsolvable]fn strsim::generic_jaro_winkler(&Iter1, &Iter2) -> f64
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
&'a Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
&'b Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

[unsolvable]fn strsim::generic_jaro(&Iter1, &Iter2) -> f64
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
&'a Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
&'b Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

[unsolvable]fn strsim::generic_hamming(Iter1, Iter2) -> strsim::HammingResult
Where:
Iter1: , 
Iter2: , 
Elem2: , 
Elem1: , 
Type Pred:
Iter1: std::iter::traits::collect::IntoIterator::<Item=Elem1>
Iter2: std::iter::traits::collect::IntoIterator::<Item=Elem2>
Elem1: std::cmp::PartialEq::<Elem2>

all mono function:
====== statistic ======
GENERIC_API: 5
RPG_COVERED_API: 9
COVERED API: 9
RPG_COVERED_GENERIC: 0
RESERVE: 0
RPG_GENERIC: 5
PRUNE_ITERS: 1
ITERS: 1
UNSAFE: 0
RPG_API: 14
CANDIDATES: 31
MONO_FUNS: 0
API: 15
UNSOLVABLE: 4
TRAIT_IMPLS: 907
COVERED GENERIC: 0
BLANKET_IMPLS: 0
======  advance  ======
MONO_PER_FUNCS: NaN
GENERIC COVERAGE: 0
API COVERAGE: 0.6
=======================
using bfs end point
0, 1, 2, 3, 4, 5, 6, 7, 8, 
reverse search can not cover more nodes
after backward search
targets = 27
total length = 54
average time to visit = 6
edge covered by reverse search = 0
total functions in crate : 10
total generic functions in crate : 5
0:fn strsim::sorensen_dice(&str, &str) -> f64
1:fn strsim::normalized_damerau_levenshtein(&str, &str) -> f64
2:fn strsim::damerau_levenshtein(&str, &str) -> usize
3:fn strsim::osa_distance(&str, &str) -> usize
4:fn strsim::normalized_levenshtein(&str, &str) -> f64
5:fn strsim::levenshtein(&str, &str) -> usize
6:fn strsim::jaro_winkler(&str, &str) -> f64
7:fn strsim::jaro(&str, &str) -> f64
8:fn strsim::hamming(&str, &str) -> strsim::HammingResult
9:fn <strsim::StrSimError as std::cmp::PartialEq>::eq(&strsim::StrSimError, &strsim::StrSimError) -> bool
======
total test sequences : 28
There are total 9 nodes need to be covered.
There are total 0 edges need to be covered.
There are toatl 28 sequences.
There are toatl 9 valid sequences for fuzz.
-----------STATISTICS-----------
total nodes: 10
total edges: 0
covered nodes: 9

covered monos: 0
covered edges: 0
node coverage: 0.9
edge coverage: NaN
targets covered by reverse search: 0
total targets: 9
max length = 0
total length = 9
average time to fuzz each api = 1
--------------------------------
test_file_path: "/home/rumono/strsim-rs/fuzz_target/test_files"
reproduce_file_path: "/home/rumono/strsim-rs/fuzz_target/replay_files"
Fuzz Target Generator exits successfully.
Total time cost: 242 ms
