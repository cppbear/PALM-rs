Fuzz Target Generator for Rust Libraries: v0.1.0
Fuzz Target Renderer Init
crate: fastrand
[TypeContext] add candidate #0: u8 => Primitive(U8)
[TypeContext] add candidate #1: &[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
Add function: fn fastrand::choose_multiple(I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
visibility: Some(Public)
Add function: fn fastrand::f64() -> f64
visibility: Some(Public)
Add function: fn fastrand::f32() -> f32
visibility: Some(Public)
Add function: fn fastrand::char(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(Char))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> char
visibility: Some(Public)
Add function: fn fastrand::isize(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(Isize))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> isize
visibility: Some(Public)
Add function: fn fastrand::usize(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> usize
visibility: Some(Public)
Add function: fn fastrand::i128(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I128))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i128
visibility: Some(Public)
Add function: fn fastrand::u128(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U128))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u128
visibility: Some(Public)
Add function: fn fastrand::i64(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I64))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i64
visibility: Some(Public)
Add function: fn fastrand::u64(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U64))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u64
visibility: Some(Public)
Add function: fn fastrand::i32(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I32))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i32
visibility: Some(Public)
Add function: fn fastrand::u32(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U32))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u32
visibility: Some(Public)
Add function: fn fastrand::i16(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I16))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i16
visibility: Some(Public)
Add function: fn fastrand::u16(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U16))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u16
visibility: Some(Public)
Add function: fn fastrand::i8(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I8))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i8
visibility: Some(Public)
Add function: fn fastrand::u8(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U8))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u8
visibility: Some(Public)
Add function: fn fastrand::fill(&mut [u8]) -> ()
visibility: Some(Public)
input fail#0: &mut [u8]
fn fastrand::fill(&mut [u8]) -> () contain unsupported fuzzable type
Add function: fn fastrand::shuffle(&mut [T]) -> ()
visibility: Some(Public)
Add function: fn fastrand::digit(u32) -> char
visibility: Some(Public)
Add function: fn fastrand::choice(I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
visibility: Some(Public)
Add function: fn fastrand::uppercase() -> char
visibility: Some(Public)
Add function: fn fastrand::lowercase() -> char
visibility: Some(Public)
Add function: fn fastrand::alphanumeric() -> char
visibility: Some(Public)
Add function: fn fastrand::alphabetic() -> char
visibility: Some(Public)
Add function: fn fastrand::bool() -> bool
visibility: Some(Public)
Add function: fn fastrand::get_seed() -> u64
visibility: Some(Public)
Add function: fn fastrand::seed(u64) -> ()
visibility: Some(Public)
analyse struct: Item { name: Some("Rng"), item_id: DefId(DefId(0:155 ~ fastrand[57b2]::Rng)), kind: Struct, docs: "A random number generator." }
analyse struct: StructItem(Struct { ctor_kind: Some(Fn), generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("0"), item_id: DefId(DefId(0:157 ~ fastrand[57b2]::Rng::0)), kind: StructField, docs: "" }] })
Add function: fn fastrand::global_rng::choose_multiple(I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
visibility: Some(Public)
Add function: fn fastrand::global_rng::f64() -> f64
visibility: Some(Public)
Add function: fn fastrand::global_rng::f32() -> f32
visibility: Some(Public)
Add function: fn fastrand::global_rng::char(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(Char))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> char
visibility: Some(Public)
Add function: fn fastrand::global_rng::isize(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(Isize))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> isize
visibility: Some(Public)
Add function: fn fastrand::global_rng::usize(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(Usize))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> usize
visibility: Some(Public)
Add function: fn fastrand::global_rng::i128(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I128))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i128
visibility: Some(Public)
Add function: fn fastrand::global_rng::u128(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U128))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u128
visibility: Some(Public)
Add function: fn fastrand::global_rng::i64(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I64))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i64
visibility: Some(Public)
Add function: fn fastrand::global_rng::u64(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U64))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u64
visibility: Some(Public)
Add function: fn fastrand::global_rng::i32(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I32))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i32
visibility: Some(Public)
Add function: fn fastrand::global_rng::u32(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U32))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u32
visibility: Some(Public)
Add function: fn fastrand::global_rng::i16(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I16))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i16
visibility: Some(Public)
Add function: fn fastrand::global_rng::u16(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U16))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u16
visibility: Some(Public)
Add function: fn fastrand::global_rng::i8(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(I8))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> i8
visibility: Some(Public)
Add function: fn fastrand::global_rng::u8(impl GenericParamMap { inner: {"impl": [Path { res: Def(Trait, DefId(1:3712 ~ core[b693]::ops::range::RangeBounds)), segments: [PathSegment { name: "RangeBounds", args: AngleBracketed { args: [Type(Primitive(U8))], constraints: [] } }] }]}, generic_defs: ["impl"], type_pred: [] }) -> u8
visibility: Some(Public)
Add function: fn fastrand::global_rng::fill(&mut [u8]) -> ()
visibility: Some(Public)
input fail#0: &mut [u8]
fn fastrand::global_rng::fill(&mut [u8]) -> () contain unsupported fuzzable type
Add function: fn fastrand::global_rng::shuffle(&mut [T]) -> ()
visibility: Some(Public)
Add function: fn fastrand::global_rng::digit(u32) -> char
visibility: Some(Public)
Add function: fn fastrand::global_rng::choice(I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
visibility: Some(Public)
Add function: fn fastrand::global_rng::uppercase() -> char
visibility: Some(Public)
Add function: fn fastrand::global_rng::lowercase() -> char
visibility: Some(Public)
Add function: fn fastrand::global_rng::alphanumeric() -> char
visibility: Some(Public)
Add function: fn fastrand::global_rng::alphabetic() -> char
visibility: Some(Public)
Add function: fn fastrand::global_rng::bool() -> bool
visibility: Some(Public)
Add function: fn fastrand::global_rng::get_seed() -> u64
visibility: Some(Public)
Add function: fn fastrand::global_rng::seed(u64) -> ()
visibility: Some(Public)
==== run after krate ====
bounds to facts ignore lifetime: Lifetime("'static")
ignore RegionPredicate: RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }
ignore const: GenericParamDef { name: "N", def_id: DefId(1:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(1:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(1:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(1:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(1:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }
ignore const: GenericParamDef { name: "N", def_id: DefId(1:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:236 ~ alloc[2c7c]::boxed::thin::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:212 ~ alloc[2c7c]::boxed::thin::ThinBox)), segments: [PathSegment { name: "ThinBox", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::boxed::thin::ThinBox")
type_def_id: Some(DefId(4:212 ~ alloc[2c7c]::boxed::thin::ThinBox))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:235 ~ alloc[2c7c]::boxed::thin::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::thin::ThinBox"
std::boxed::thin::ThinBox::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:237 ~ alloc[2c7c]::boxed::thin::{impl#6}::Target)), kind: AssocType, docs: "" }
"fn <std::boxed::thin::ThinBox::<T> as std::ops::Deref>::deref(&std::boxed::thin::ThinBox::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7793 ~ alloc[2c7c]::string::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7794 ~ alloc[2c7c]::string::{impl#82}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7792 ~ alloc[2c7c]::string::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::string::String>>::eq(&str, &std::string::String) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::string::String>>::ne(&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7803 ~ alloc[2c7c]::string::{impl#84}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7804 ~ alloc[2c7c]::string::{impl#84}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7802 ~ alloc[2c7c]::string::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
[TypeContext] add candidate #2: &str => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
[TypeContext] add candidate #3: &mut &str => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #4: &&str => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #5: *&str => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[TypeContext] add candidate #6: *const &str => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
assoc types:
"fn <&str as std::cmp::PartialEq::<std::string::String>>::eq(&&str, &std::string::String) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::string::String>>::ne(&&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:7759 ~ alloc[2c7c]::string::String)), segments: [PathSegment { name: "String", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::string::String")
type_def_id: Some(DefId(4:7759 ~ alloc[2c7c]::string::String))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:5941 ~ alloc[2c7c]::string::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::string::String"
std::string::String is not fuzzable
assoc types:
Target: str
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:5942 ~ alloc[2c7c]::string::{impl#28}::Target)), kind: AssocType, docs: "" }
"fn <std::string::String as std::ops::Deref>::deref(&std::string::String) -> &str" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7813 ~ alloc[2c7c]::string::{impl#86}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7814 ~ alloc[2c7c]::string::{impl#86}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7812 ~ alloc[2c7c]::string::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7823 ~ alloc[2c7c]::string::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7824 ~ alloc[2c7c]::string::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7822 ~ alloc[2c7c]::string::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("B")])
impl generics: Generics { params: [GenericParamDef { name: "B", def_id: DefId(4:803 ~ alloc[2c7c]::borrow::{impl#4}::B), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("B"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }, BoundPredicate { ty: QPath(QPathData { assoc: PathSegment { name: "Owned", args: AngleBracketed { args: [], constraints: [] } }, self_type: Generic("B"), should_show_cast: true, trait_: Some(Path { res: Def(Trait, DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }) }), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Enum, DefId(4:783 ~ alloc[2c7c]::borrow::Cow)), segments: [PathSegment { name: "Cow", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("B"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::borrow::Cow")
type_def_id: Some(DefId(4:783 ~ alloc[2c7c]::borrow::Cow))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:802 ~ alloc[2c7c]::borrow::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::borrow::Cow"
std::borrow::Cow::<'_, B> is not fuzzable
assoc types:
Target: B
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:804 ~ alloc[2c7c]::borrow::{impl#4}::Target)), kind: AssocType, docs: "" }
"fn <std::borrow::Cow::<'_, B> as std::ops::Deref>::deref(&std::borrow::Cow::<'_, B>) -> &B" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8161 ~ std[d8a0]::ffi::os_str::{impl#77}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8162 ~ std[d8a0]::ffi::os_str::{impl#77}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8160 ~ std[d8a0]::ffi::os_str::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9074 ~ std[d8a0]::path::{impl#178}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9075 ~ std[d8a0]::path::{impl#178}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9073 ~ std[d8a0]::path::{impl#178})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8958 ~ std[d8a0]::path::{impl#135}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8959 ~ std[d8a0]::path::{impl#135}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8957 ~ std[d8a0]::path::{impl#135})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9118 ~ std[d8a0]::path::{impl#191}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9119 ~ std[d8a0]::path::{impl#191}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9117 ~ std[d8a0]::path::{impl#191})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9042 ~ std[d8a0]::path::{impl#166}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9041 ~ std[d8a0]::path::{impl#166})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8945 ~ std[d8a0]::path::{impl#131}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8944 ~ std[d8a0]::path::{impl#131})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8177 ~ std[d8a0]::ffi::os_str::{impl#81}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8178 ~ std[d8a0]::ffi::os_str::{impl#81}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8176 ~ std[d8a0]::ffi::os_str::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9105 ~ std[d8a0]::path::{impl#187}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9104 ~ std[d8a0]::path::{impl#187})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9111 ~ std[d8a0]::path::{impl#189}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9110 ~ std[d8a0]::path::{impl#189})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8185 ~ std[d8a0]::ffi::os_str::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8186 ~ std[d8a0]::ffi::os_str::{impl#83}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8184 ~ std[d8a0]::ffi::os_str::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8951 ~ std[d8a0]::path::{impl#133}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8950 ~ std[d8a0]::path::{impl#133})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8169 ~ std[d8a0]::ffi::os_str::{impl#79}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8170 ~ std[d8a0]::ffi::os_str::{impl#79}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8168 ~ std[d8a0]::ffi::os_str::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9082 ~ std[d8a0]::path::{impl#180}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9083 ~ std[d8a0]::path::{impl#180}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9081 ~ std[d8a0]::path::{impl#180})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9048 ~ std[d8a0]::path::{impl#168}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9047 ~ std[d8a0]::path::{impl#168})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8966 ~ std[d8a0]::path::{impl#137}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8967 ~ std[d8a0]::path::{impl#137}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8965 ~ std[d8a0]::path::{impl#137})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9126 ~ std[d8a0]::path::{impl#193}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9127 ~ std[d8a0]::path::{impl#193}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9125 ~ std[d8a0]::path::{impl#193})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:7679 ~ alloc[2c7c]::ffi::c_str::CString)), segments: [PathSegment { name: "CString", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::ffi::c_str::CString")
type_def_id: Some(DefId(4:7679 ~ alloc[2c7c]::ffi::c_str::CString))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:4811 ~ alloc[2c7c]::ffi::c_str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CString"
std::ffi::CString is not fuzzable
assoc types:
Target: std::ffi::CStr
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:4812 ~ alloc[2c7c]::ffi::c_str::{impl#3}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::CString as std::ops::Deref>::deref(&std::ffi::CString) -> &std::ffi::CStr" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:502 ~ alloc[2c7c]::boxed::{impl#38}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:503 ~ alloc[2c7c]::boxed::{impl#38}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:297 ~ alloc[2c7c]::boxed::Box)), segments: [PathSegment { name: "Box", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::boxed::Box")
type_def_id: Some(DefId(4:297 ~ alloc[2c7c]::boxed::Box))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:501 ~ alloc[2c7c]::boxed::{impl#38})
is_local_impl: false
is_external_type: true
type_name: "std::boxed::Box"
std::boxed::Box::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:504 ~ alloc[2c7c]::boxed::{impl#38}::Target)), kind: AssocType, docs: "" }
"fn <std::boxed::Box::<T, A> as std::ops::Deref>::deref(&std::boxed::Box::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:6292 ~ alloc[2c7c]::sync::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:6293 ~ alloc[2c7c]::sync::{impl#29}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:6105 ~ alloc[2c7c]::sync::Arc)), segments: [PathSegment { name: "Arc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::sync::Arc")
type_def_id: Some(DefId(4:6105 ~ alloc[2c7c]::sync::Arc))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:6291 ~ alloc[2c7c]::sync::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::sync::Arc"
std::sync::Arc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:6294 ~ alloc[2c7c]::sync::{impl#29}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::Arc::<T, A> as std::ops::Deref>::deref(&std::sync::Arc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:898 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:899 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:883 ~ alloc[2c7c]::collections::binary_heap::PeekMut)), segments: [PathSegment { name: "PeekMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::collections::binary_heap::PeekMut")
type_def_id: Some(DefId(4:883 ~ alloc[2c7c]::collections::binary_heap::PeekMut))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:897 ~ alloc[2c7c]::collections::binary_heap::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::collections::binary_heap::PeekMut"
std::collections::binary_heap::PeekMut::<'_, T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:900 ~ alloc[2c7c]::collections::binary_heap::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::collections::binary_heap::PeekMut::<'_, T, A> as std::ops::Deref>::deref(&std::collections::binary_heap::PeekMut::<'_, T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:8072 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(4:8073 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:8074 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:8060 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(4:8061 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:8062 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:8054 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(4:8055 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:8056 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:7330 ~ alloc[2c7c]::vec::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:7331 ~ alloc[2c7c]::vec::{impl#8}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:7185 ~ alloc[2c7c]::vec::Vec)), segments: [PathSegment { name: "Vec", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::vec::Vec")
type_def_id: Some(DefId(4:7185 ~ alloc[2c7c]::vec::Vec))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:7329 ~ alloc[2c7c]::vec::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::vec::Vec"
std::vec::Vec::<T, A> is not fuzzable
assoc types:
Target: [T]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:7332 ~ alloc[2c7c]::vec::{impl#8}::Target)), kind: AssocType, docs: "" }
"fn <std::vec::Vec::<T, A> as std::ops::Deref>::deref(&std::vec::Vec::<T, A>) -> &[T]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5150 ~ alloc[2c7c]::rc::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:5151 ~ alloc[2c7c]::rc::{impl#25}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:4981 ~ alloc[2c7c]::rc::Rc)), segments: [PathSegment { name: "Rc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::rc::Rc")
type_def_id: Some(DefId(4:4981 ~ alloc[2c7c]::rc::Rc))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:5149 ~ alloc[2c7c]::rc::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::rc::Rc"
std::rc::Rc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:5152 ~ alloc[2c7c]::rc::{impl#25}::Target)), kind: AssocType, docs: "" }
"fn <std::rc::Rc::<T, A> as std::ops::Deref>::deref(&std::rc::Rc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("A")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5393 ~ alloc[2c7c]::rc::{impl#79}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:5394 ~ alloc[2c7c]::rc::{impl#79}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(4:7747 ~ alloc[2c7c]::rc::UniqueRc)), segments: [PathSegment { name: "UniqueRc", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("A"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("alloc::rc::UniqueRc")
type_def_id: Some(DefId(4:7747 ~ alloc[2c7c]::rc::UniqueRc))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(4:5392 ~ alloc[2c7c]::rc::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::rc::UniqueRc"
std::rc::UniqueRc::<T, A> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(4:5395 ~ alloc[2c7c]::rc::{impl#79}::Target)), kind: AssocType, docs: "" }
"fn <std::rc::UniqueRc::<T, A> as std::ops::Deref>::deref(&std::rc::UniqueRc::<T, A>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "crate", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: None
impl_def_id: DefId(0:21 ~ fastrand[57b2]::global_rng::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
fastrand::Rng is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: None
impl_def_id: DefId(0:91 ~ fastrand[57b2]::{impl#2})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
fastrand::Rng is not fuzzable
assoc types:
input fail#0: &mut [u8]
fn fastrand::Rng::fill(&mut fastrand::Rng, &mut [u8]) -> () contain unsupported fuzzable type
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(1:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(1:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(1:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(1:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(1:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(1:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(1:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(1:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(1:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:779 ~ alloc[2c7c]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(4:778 ~ alloc[2c7c]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(0:163 ~ fastrand[57b2]::{impl#6})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
fastrand::Rng is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(0:160 ~ fastrand[57b2]::{impl#4})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
fastrand::Rng is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "crate", args: AngleBracketed { args: [], constraints: [] } }, PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(0:19 ~ fastrand[57b2]::global_rng::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
fastrand::Rng is not fuzzable
assoc types:
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(0:158 ~ fastrand[57b2]::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:76 ~ fastrand[57b2]::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("fastrand::Rng")
type_def_id: Some(DefId(0:155 ~ fastrand[57b2]::Rng))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(0:161 ~ fastrand[57b2]::{impl#5})
is_local_impl: true
is_external_type: false
type_name: "fastrand::Rng"
fastrand::Rng is not fuzzable
assoc types:
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <fastrand::Rng as std::cmp::PartialEq>::ne(&fastrand::Rng, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:5268 ~ core[b693]::ffi::c_str::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::PartialOrd>::partial_cmp(&std::ffi::CStr, &std::ffi::CStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::CStr as std::cmp::PartialOrd>::lt(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::CStr as std::cmp::PartialOrd>::le(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::CStr as std::cmp::PartialOrd>::gt(&std::ffi::CStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::CStr as std::cmp::PartialOrd>::ge(&std::ffi::CStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:41118 ~ core[b693]::ffi::c_str::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::hash::Hash>::hash(&std::ffi::CStr, &mut __H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::ffi::CStr as std::hash::Hash>::hash_slice(&[std::ffi::CStr], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:5242 ~ core[b693]::ffi::c_str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(1:5272 ~ core[b693]::ffi::c_str::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Output: std::ffi::CStr
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:5273 ~ core[b693]::ffi::c_str::{impl#11}::Output)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::ops::Index::<std::ops::range::RangeFrom::<usize>>>::index(&std::ffi::CStr, std::ops::range::RangeFrom::<usize>) -> &std::ffi::CStr" is filtered.
Add std::ops::Index::<std::ops::range::RangeFrom::<usize>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:5267 ~ core[b693]::ffi::c_str::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:5265 ~ core[b693]::ffi::c_str::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::PartialEq>::eq(&std::ffi::CStr, &std::ffi::CStr) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::CStr as std::cmp::PartialEq>::ne(&std::ffi::CStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:5244 ~ core[b693]::ffi::c_str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
&std::ffi::CStr is not fuzzable
assoc types:
"fn <&std::ffi::CStr as std::default::Default>::default() -> &std::ffi::CStr" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:5270 ~ core[b693]::ffi::c_str::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::cmp::Ord>::cmp(&std::ffi::CStr, &std::ffi::CStr) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::ffi::CStr as std::cmp::Ord>::max(std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
[Impl] add default impl: min
"fn <std::ffi::CStr as std::cmp::Ord>::min(std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
[Impl] add default impl: clamp
"fn <std::ffi::CStr as std::cmp::Ord>::clamp(std::ffi::CStr, std::ffi::CStr, std::ffi::CStr) -> std::ffi::CStr" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:5275 ~ core[b693]::ffi::c_str::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn <std::ffi::CStr as std::convert::AsRef::<std::ffi::CStr>>::as_ref(&std::ffi::CStr) -> &std::ffi::CStr" is filtered.
Add std::convert::AsRef::<std::ffi::CStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: None
impl_def_id: DefId(1:5249 ~ core[b693]::ffi::c_str::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn std::ffi::CStr::from_ptr(*const i8) -> &'a std::ffi::CStr" is filtered.
"fn std::ffi::CStr::from_bytes_until_nul(&[u8]) -> std::result::Result::<&std::ffi::CStr, std::ffi::FromBytesUntilNulError>" is filtered.
"fn std::ffi::CStr::from_bytes_with_nul(&[u8]) -> std::result::Result::<&std::ffi::CStr, std::ffi::FromBytesWithNulError>" is filtered.
"fn std::ffi::CStr::from_bytes_with_nul_unchecked(&[u8]) -> &std::ffi::CStr" is filtered.
"fn std::ffi::CStr::as_ptr(&std::ffi::CStr) -> *const i8" is filtered.
"fn std::ffi::CStr::count_bytes(&std::ffi::CStr) -> usize" is filtered.
"fn std::ffi::CStr::is_empty(&std::ffi::CStr) -> bool" is filtered.
"fn std::ffi::CStr::to_bytes(&std::ffi::CStr) -> &[u8]" is filtered.
"fn std::ffi::CStr::to_bytes_with_nul(&std::ffi::CStr) -> &[u8]" is filtered.
"fn std::ffi::CStr::bytes(&std::ffi::CStr) -> std::ffi::Bytes::<'_>" is filtered.
"fn std::ffi::CStr::to_str(&std::ffi::CStr) -> std::result::Result::<&str, std::str::error::Utf8Error>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: None
impl_def_id: DefId(4:4883 ~ alloc[2c7c]::ffi::c_str::{impl#34})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
"fn std::ffi::CStr::to_string_lossy(&std::ffi::CStr) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::ffi::CStr::into_c_string(std::boxed::Box::<std::ffi::CStr>) -> std::ffi::CString" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(4:4872 ~ alloc[2c7c]::ffi::c_str::{impl#30})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Owned: std::ffi::CString
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(4:4873 ~ alloc[2c7c]::ffi::c_str::{impl#30}::Owned)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::borrow::ToOwned>::to_owned(&std::ffi::CStr) -> std::ffi::CString" is filtered.
"fn <std::ffi::CStr as std::borrow::ToOwned>::clone_into(&std::ffi::CStr, &mut std::ffi::CString) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4904 ~ core[b693]::cell::{impl#45}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4897 ~ core[b693]::cell::RefMut)), segments: [PathSegment { name: "RefMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::RefMut")
type_def_id: Some(DefId(1:4897 ~ core[b693]::cell::RefMut))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4903 ~ core[b693]::cell::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::cell::RefMut"
std::cell::RefMut::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4905 ~ core[b693]::cell::{impl#45}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::RefMut::<'_, T> as std::ops::Deref>::deref(&std::cell::RefMut::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:946 ~ core[b693]::num::nonzero::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:945 ~ core[b693]::num::nonzero::{impl#8})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:957 ~ core[b693]::num::nonzero::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:34630 ~ core[b693]::ops::bit::BitOr)), segments: [PathSegment { name: "BitOr", args: AngleBracketed { args: [], constraints: [AssocItemConstraint { assoc: PathSegment { name: "Output", args: AngleBracketed { args: [], constraints: [] } }, kind: Equality { term: Type(Generic("T")) } }] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::bit::BitOr
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::bit::BitOr")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:34630 ~ core[b693]::ops::bit::BitOr))
impl_def_id: DefId(1:956 ~ core[b693]::num::nonzero::{impl#11})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4847 ~ core[b693]::cell::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4841 ~ core[b693]::cell::Ref)), segments: [PathSegment { name: "Ref", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::Ref")
type_def_id: Some(DefId(1:4841 ~ core[b693]::cell::Ref))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4846 ~ core[b693]::cell::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::cell::Ref"
std::cell::Ref::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4848 ~ core[b693]::cell::{impl#37}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::Ref::<'_, T> as std::ops::Deref>::deref(&std::cell::Ref::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:1974 ~ core[b693]::mem::manually_drop::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop)), segments: [PathSegment { name: "ManuallyDrop", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::mem::manually_drop::ManuallyDrop")
type_def_id: Some(DefId(1:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:1973 ~ core[b693]::mem::manually_drop::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::mem::manually_drop::ManuallyDrop"
std::mem::manually_drop::ManuallyDrop::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:1975 ~ core[b693]::mem::manually_drop::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::mem::manually_drop::ManuallyDrop::<T> as std::ops::Deref>::deref(&std::mem::manually_drop::ManuallyDrop::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:41177 ~ core[b693]::ffi::va_list::{impl#8}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:41176 ~ core[b693]::ffi::va_list::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5333 ~ core[b693]::ffi::va_list::{impl#6}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:5332 ~ core[b693]::ffi::va_list::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5336 ~ core[b693]::ffi::va_list::{impl#7}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::drop::Drop
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::drop::Drop")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:3580 ~ core[b693]::ops::drop::Drop))
impl_def_id: DefId(1:5335 ~ core[b693]::ffi::va_list::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5305 ~ core[b693]::ffi::va_list::{impl#0}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(1:5304 ~ core[b693]::ffi::va_list::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::as_va_list(&'a mut std::ffi::va_list::VaListImpl::<'_>) -> std::ffi::va_list::VaList::<'a, 'f>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5325 ~ core[b693]::ffi::va_list::{impl#5}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(1:5324 ~ core[b693]::ffi::va_list::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::arg(&mut std::ffi::va_list::VaListImpl::<'_>) -> T" is filtered.
"fn std::ffi::va_list::VaListImpl::<'_>::with_copy(&std::ffi::va_list::VaListImpl::<'_>, F) -> R" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::index::Index
impl for: Path { path: Path { res: Def(Struct, DefId(1:41116 ~ core[b693]::ffi::c_str::CStr)), segments: [PathSegment { name: "CStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("core::ffi::c_str::CStr")
type_def_id: Some(DefId(1:41116 ~ core[b693]::ffi::c_str::CStr))
trait_def_id: Some(DefId(1:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(1:5272 ~ core[b693]::ffi::c_str::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::CStr"
std::ffi::CStr is not fuzzable
assoc types:
Output: std::ffi::CStr
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:5273 ~ core[b693]::ffi::c_str::{impl#11}::Output)), kind: AssocType, docs: "" }
"fn <std::ffi::CStr as std::ops::Index::<std::ops::range::RangeFrom::<usize>>>::index(&std::ffi::CStr, std::ops::range::RangeFrom::<usize>) -> &std::ffi::CStr" is filtered.
Add std::ops::Index::<std::ops::range::RangeFrom::<usize>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("Ptr")])
impl generics: Generics { params: [GenericParamDef { name: "Ptr", def_id: DefId(1:9693 ~ core[b693]::pin::{impl#13}::Ptr), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Ptr"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:42704 ~ core[b693]::pin::Pin)), segments: [PathSegment { name: "Pin", args: AngleBracketed { args: [Type(Generic("Ptr"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::pin::Pin")
type_def_id: Some(DefId(1:42704 ~ core[b693]::pin::Pin))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:9692 ~ core[b693]::pin::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::pin::Pin"
std::pin::Pin::<Ptr> is not fuzzable
assoc types:
Target: <Ptr as std::ops::Deref>::Target
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:9694 ~ core[b693]::pin::{impl#13}::Target)), kind: AssocType, docs: "" }
"fn <std::pin::Pin::<Ptr> as std::ops::Deref>::deref(&std::pin::Pin::<Ptr>) -> &<Ptr as std::ops::Deref>::Target" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4629 ~ core[b693]::cell::lazy::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(1:4630 ~ core[b693]::cell::lazy::{impl#2}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4613 ~ core[b693]::cell::lazy::LazyCell)), segments: [PathSegment { name: "LazyCell", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::lazy::LazyCell")
type_def_id: Some(DefId(1:4613 ~ core[b693]::cell::lazy::LazyCell))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4628 ~ core[b693]::cell::lazy::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::cell::lazy::LazyCell"
std::cell::lazy::LazyCell::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4631 ~ core[b693]::cell::lazy::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::lazy::LazyCell::<T, F> as std::ops::Deref>::deref(&std::cell::lazy::LazyCell::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:9524 ~ core[b693]::panic::unwind_safe::{impl#21}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(1:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:9523 ~ core[b693]::panic::unwind_safe::{impl#21})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:9525 ~ core[b693]::panic::unwind_safe::{impl#21}::Target)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::ops::Deref>::deref(&std::panic::unwind_safe::AssertUnwindSafe::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:5309 ~ core[b693]::ffi::va_list::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'f", def_id: DefId(1:5310 ~ core[b693]::ffi::va_list::{impl#1}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:41179 ~ core[b693]::ffi::va_list::VaList)), segments: [PathSegment { name: "VaList", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::ffi::va_list::VaList")
type_def_id: Some(DefId(1:41179 ~ core[b693]::ffi::va_list::VaList))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:5308 ~ core[b693]::ffi::va_list::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaList"
std::ffi::va_list::VaList::<'_, '_> is not fuzzable
assoc types:
Target: std::ffi::va_list::VaListImpl::<'f>
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:5311 ~ core[b693]::ffi::va_list::{impl#1}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::va_list::VaList::<'_, '_> as std::ops::Deref>::deref(&std::ffi::va_list::VaList::<'_, '_>) -> &std::ffi::va_list::VaListImpl::<'f>" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7055 ~ std[d8a0]::sync::rwlock::{impl#28}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:9461 ~ std[d8a0]::sync::rwlock::MappedRwLockReadGuard)), segments: [PathSegment { name: "MappedRwLockReadGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::MappedRwLockReadGuard")
type_def_id: Some(DefId(5:9461 ~ std[d8a0]::sync::rwlock::MappedRwLockReadGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:7054 ~ std[d8a0]::sync::rwlock::{impl#28})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::MappedRwLockReadGuard"
std::sync::rwlock::MappedRwLockReadGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:7056 ~ std[d8a0]::sync::rwlock::{impl#28}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::MappedRwLockReadGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::MappedRwLockReadGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9023 ~ std[d8a0]::path::{impl#159})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9021 ~ std[d8a0]::path::{impl#158})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9053 ~ std[d8a0]::path::{impl#170})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8933 ~ std[d8a0]::path::{impl#127}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8932 ~ std[d8a0]::path::{impl#127})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9030 ~ std[d8a0]::path::{impl#162}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9029 ~ std[d8a0]::path::{impl#162})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::eq(&std::path::Path, &&'a std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9074 ~ std[d8a0]::path::{impl#178}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9075 ~ std[d8a0]::path::{impl#178}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9073 ~ std[d8a0]::path::{impl#178})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:5560 ~ std[d8a0]::path::{impl#68})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq>::eq(&std::path::Path, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8958 ~ std[d8a0]::path::{impl#135}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8959 ~ std[d8a0]::path::{impl#135}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8957 ~ std[d8a0]::path::{impl#135})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8923 ~ std[d8a0]::path::{impl#123})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9042 ~ std[d8a0]::path::{impl#166}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9041 ~ std[d8a0]::path::{impl#166})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9033 ~ std[d8a0]::path::{impl#163}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9032 ~ std[d8a0]::path::{impl#163})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9090 ~ std[d8a0]::path::{impl#182}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9089 ~ std[d8a0]::path::{impl#182})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8945 ~ std[d8a0]::path::{impl#131}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8944 ~ std[d8a0]::path::{impl#131})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9065 ~ std[d8a0]::path::{impl#175}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9064 ~ std[d8a0]::path::{impl#175})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::eq(&std::ffi::OsStr, &&'a std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9062 ~ std[d8a0]::path::{impl#174}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9061 ~ std[d8a0]::path::{impl#174})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: None
impl_def_id: DefId(5:5485 ~ std[d8a0]::path::{impl#63})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn std::path::Path::new(&S) -> &std::path::Path" is filtered.
"fn std::path::Path::as_os_str(&std::path::Path) -> &std::ffi::OsStr" is filtered.
"fn std::path::Path::as_mut_os_str(&mut std::path::Path) -> &mut std::ffi::OsStr" is filtered.
"fn std::path::Path::to_str(&std::path::Path) -> std::option::Option::<&str>" is filtered.
"fn std::path::Path::to_string_lossy(&std::path::Path) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::path::Path::to_path_buf(&std::path::Path) -> std::path::PathBuf" is filtered.
"fn std::path::Path::is_absolute(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_relative(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::has_root(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::parent(&std::path::Path) -> std::option::Option::<&std::path::Path>" is filtered.
"fn std::path::Path::ancestors(&std::path::Path) -> std::path::Ancestors::<'_>" is filtered.
"fn std::path::Path::file_name(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::strip_prefix(&std::path::Path, P) -> std::result::Result::<&std::path::Path, std::path::StripPrefixError>" is filtered.
"fn std::path::Path::starts_with(&std::path::Path, P) -> bool" is filtered.
"fn std::path::Path::ends_with(&std::path::Path, P) -> bool" is filtered.
"fn std::path::Path::file_stem(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::file_prefix(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::extension(&std::path::Path) -> std::option::Option::<&std::ffi::OsStr>" is filtered.
"fn std::path::Path::join(&std::path::Path, P) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_file_name(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_extension(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::with_added_extension(&std::path::Path, S) -> std::path::PathBuf" is filtered.
"fn std::path::Path::components(&std::path::Path) -> std::path::Components::<'_>" is filtered.
"fn std::path::Path::iter(&std::path::Path) -> std::path::Iter::<'_>" is filtered.
"fn std::path::Path::display(&std::path::Path) -> std::path::Display::<'_>" is filtered.
"fn std::path::Path::metadata(&std::path::Path) -> std::result::Result::<std::fs::Metadata, std::io::Error>" is filtered.
"fn std::path::Path::symlink_metadata(&std::path::Path) -> std::result::Result::<std::fs::Metadata, std::io::Error>" is filtered.
"fn std::path::Path::canonicalize(&std::path::Path) -> std::result::Result::<std::path::PathBuf, std::io::Error>" is filtered.
"fn std::path::Path::read_link(&std::path::Path) -> std::result::Result::<std::path::PathBuf, std::io::Error>" is filtered.
"fn std::path::Path::read_dir(&std::path::Path) -> std::result::Result::<std::fs::ReadDir, std::io::Error>" is filtered.
"fn std::path::Path::exists(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::try_exists(&std::path::Path) -> std::result::Result::<bool, std::io::Error>" is filtered.
"fn std::path::Path::is_file(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_dir(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::is_symlink(&std::path::Path) -> bool" is filtered.
"fn std::path::Path::into_path_buf(std::boxed::Box::<std::path::Path>) -> std::path::PathBuf" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:5467 ~ std[d8a0]::path::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
Owned: std::path::PathBuf
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:5468 ~ std[d8a0]::path::{impl#56}::Owned)), kind: AssocType, docs: "" }
"fn <std::path::Path as std::borrow::ToOwned>::to_owned(&std::path::Path) -> std::path::PathBuf" is filtered.
"fn <std::path::Path as std::borrow::ToOwned>::clone_into(&std::path::Path, &mut std::path::PathBuf) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(5:5551 ~ std[d8a0]::path::{impl#65})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5572 ~ std[d8a0]::path::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::path::Path>>::as_ref(&std::ffi::OsStr) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5549 ~ std[d8a0]::path::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::path::Path) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5570 ~ std[d8a0]::path::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::path::Path>>::as_ref(&std::path::Path) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5578 ~ std[d8a0]::path::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::path::Path>>::as_ref(&str) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(5:5568 ~ std[d8a0]::path::{impl#72})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::Ord>::cmp(&std::path::Path, &std::path::Path) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::path::Path as std::cmp::Ord>::max(std::path::Path, std::path::Path) -> std::path::Path" is filtered.
[Impl] add default impl: min
"fn <std::path::Path as std::cmp::Ord>::min(std::path::Path, std::path::Path) -> std::path::Path" is filtered.
[Impl] add default impl: clamp
"fn <std::path::Path as std::cmp::Ord>::clamp(std::path::Path, std::path::Path, std::path::Path) -> std::path::Path" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8927 ~ std[d8a0]::path::{impl#125})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8939 ~ std[d8a0]::path::{impl#129}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8938 ~ std[d8a0]::path::{impl#129})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8951 ~ std[d8a0]::path::{impl#133}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8950 ~ std[d8a0]::path::{impl#133})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9096 ~ std[d8a0]::path::{impl#184}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9095 ~ std[d8a0]::path::{impl#184})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9068 ~ std[d8a0]::path::{impl#176}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9067 ~ std[d8a0]::path::{impl#176})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9039 ~ std[d8a0]::path::{impl#165}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9038 ~ std[d8a0]::path::{impl#165})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9036 ~ std[d8a0]::path::{impl#164}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9035 ~ std[d8a0]::path::{impl#164})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::partial_cmp(&std::path::Path, &&'a std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9082 ~ std[d8a0]::path::{impl#180}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9083 ~ std[d8a0]::path::{impl#180}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9081 ~ std[d8a0]::path::{impl#180})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'b, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9048 ~ std[d8a0]::path::{impl#168}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9047 ~ std[d8a0]::path::{impl#168})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::path::Path, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8966 ~ std[d8a0]::path::{impl#137}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8967 ~ std[d8a0]::path::{impl#137}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8965 ~ std[d8a0]::path::{impl#137})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::path::Path, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9025 ~ std[d8a0]::path::{impl#160})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9071 ~ std[d8a0]::path::{impl#177}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9070 ~ std[d8a0]::path::{impl#177})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::partial_cmp(&std::ffi::OsStr, &&'a std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9027 ~ std[d8a0]::path::{impl#161})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:5566 ~ std[d8a0]::path::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd>::partial_cmp(&std::path::Path, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9057 ~ std[d8a0]::path::{impl#172})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:5590 ~ std[d8a0]::path::{impl#81}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(5:5589 ~ std[d8a0]::path::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(5:5562 ~ std[d8a0]::path::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::hash::Hash>::hash(&std::path::Path, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::path::Path as std::hash::Hash>::hash_slice(&[std::path::Path], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(5:5565 ~ std[d8a0]::path::{impl#70})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11475 ~ core[b693]::slice::cmp::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialOrd
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:11474 ~ core[b693]::slice::cmp::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialOrd>::partial_cmp(&[T], &[T]) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <[T] as std::cmp::PartialOrd>::lt(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <[T] as std::cmp::PartialOrd>::le(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <[T] as std::cmp::PartialOrd>::gt(&[T], &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <[T] as std::cmp::PartialOrd>::ge(&[T], &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:13570 ~ core[b693]::str::pattern::{impl#24}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:13571 ~ core[b693]::str::pattern::{impl#24}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::str::pattern::Pattern
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Slice(Primitive(Char)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::pattern::Pattern")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:13443 ~ core[b693]::str::pattern::Pattern))
impl_def_id: DefId(1:13569 ~ core[b693]::str::pattern::{impl#24})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[char] is fuzzable
[TypeContext] add candidate #7: &[char] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }
[TypeContext] add candidate #8: &mut &[char] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) } }
[TypeContext] add candidate #9: &&[char] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) } }
[TypeContext] add candidate #10: *&[char] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) })
[TypeContext] add candidate #11: *const &[char] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) })
assoc types:
Searcher: std::str::pattern::CharSliceSearcher::<'a, 'b>
not covered item Item { name: Some("Searcher"), item_id: DefId(DefId(1:45083 ~ core[b693]::str::pattern::{impl#24}::Searcher)), kind: AssocType, docs: "" }
"fn <&[char] as std::str::pattern::Pattern::<'_>>::into_searcher(&[char], &'a str) -> std::str::pattern::CharSliceSearcher::<'a, 'b>" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_contained_in(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_prefix_of(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::strip_prefix_of(&[char], &'a str) -> std::option::Option::<&'a str>" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::is_suffix_of(&[char], &'a str) -> bool" is filtered.
"fn <&[char] as std::str::pattern::Pattern::<'_>>::strip_suffix_of(&[char], &'a str) -> std::option::Option::<&'a str>" is filtered.
Add std::str::pattern::Pattern::<'a> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:32841 ~ core[b693]::marker::{impl#35}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(1:32840 ~ core[b693]::marker::{impl#35})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:10972 ~ core[b693]::hash::impls::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::hash::Hash
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:10971 ~ core[b693]::hash::impls::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::hash::Hash>::hash(&[T], &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <[T] as std::hash::Hash>::hash_slice(&[[T]], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:11729 ~ core[b693]::slice::iter::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(1:11730 ~ core[b693]::slice::iter::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(1:11728 ~ core[b693]::slice::iter::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:11735 ~ core[b693]::slice::iter::{impl#2}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "T", def_id: DefId(1:11736 ~ core[b693]::slice::iter::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::collect::IntoIterator
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::collect::IntoIterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:8325 ~ core[b693]::iter::traits::collect::IntoIterator))
impl_def_id: DefId(1:11734 ~ core[b693]::slice::iter::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2824 ~ core[b693]::clone::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2823 ~ core[b693]::clone::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::clone::CloneToUninit>::clone_to_uninit(&[T], *[T]) -> ()" is filtered.
Add std::clone::CloneToUninit Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2827 ~ core[b693]::clone::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2826 ~ core[b693]::clone::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::clone::CloneToUninit>::clone_to_uninit(&[T], *[T]) -> ()" is filtered.
Add std::clone::CloneToUninit Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:10802 ~ core[b693]::fmt::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::fmt::Debug
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:10801 ~ core[b693]::fmt::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:32929 ~ core[b693]::marker::{impl#93}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32908 ~ core[b693]::marker::ConstParamTy)), segments: [PathSegment { name: "ConstParamTy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::marker::ConstParamTy
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::ConstParamTy")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:32908 ~ core[b693]::marker::ConstParamTy))
impl_def_id: DefId(1:32928 ~ core[b693]::marker::{impl#93})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::marker::ConstParamTy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11527 ~ core[b693]::slice::index::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "I", def_id: DefId(1:11528 ~ core[b693]::slice::index::{impl#1}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::IndexMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(1:11526 ~ core[b693]::slice::index::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::ops::IndexMut::<I>>::index_mut(&mut [T], I) -> &mut <I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
Add std::ops::IndexMut::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11522 ~ core[b693]::slice::index::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "I", def_id: DefId(1:11523 ~ core[b693]::slice::index::{impl#0}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::Index
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(1:11521 ~ core[b693]::slice::index::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Output: <I as std::slice::index::SliceIndex::<[T]>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:11524 ~ core[b693]::slice::index::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[T] as std::ops::Index::<I>>::index(&[T], I) -> &<I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
Add std::ops::Index::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11470 ~ core[b693]::slice::cmp::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Eq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:11469 ~ core[b693]::slice::cmp::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3114 ~ core[b693]::convert::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::AsMut
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(1:3113 ~ core[b693]::convert::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::convert::AsMut::<[T]>>::as_mut(&mut [T]) -> &mut [T]" is filtered.
Add std::convert::AsMut::<[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:12934 ~ core[b693]::slice::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::slice::SlicePattern
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::slice::SlicePattern")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:12930 ~ core[b693]::slice::SlicePattern))
impl_def_id: DefId(1:12933 ~ core[b693]::slice::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Item: T
not covered item Item { name: Some("Item"), item_id: DefId(DefId(1:12935 ~ core[b693]::slice::{impl#8}::Item)), kind: AssocType, docs: "" }
"fn <[T] as std::slice::SlicePattern>::as_slice(&[T]) -> &[<[T] as std::slice::SlicePattern>::Item]" is filtered.
Add std::slice::SlicePattern Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4123 ~ core[b693]::array::equality::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:4124 ~ core[b693]::array::equality::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:4122 ~ core[b693]::array::equality::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::eq(&&mut [T], &[U;N]) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::ne(&&mut [T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4099 ~ core[b693]::array::equality::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:4100 ~ core[b693]::array::equality::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:4098 ~ core[b693]::array::equality::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::eq(&[T], &[U;N]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::ne(&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4111 ~ core[b693]::array::equality::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:4112 ~ core[b693]::array::equality::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:4110 ~ core[b693]::array::equality::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::eq(&&[T], &[U;N]) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::ne(&&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11465 ~ core[b693]::slice::cmp::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:11466 ~ core[b693]::slice::cmp::{impl#0}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:11464 ~ core[b693]::slice::cmp::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U]>>::eq(&[T], &[U]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U]>>::ne(&[T], &[U]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:12928 ~ core[b693]::slice::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:12927 ~ core[b693]::slice::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::default::Default>::default() -> &mut [T]" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:12925 ~ core[b693]::slice::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:12924 ~ core[b693]::slice::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::default::Default>::default() -> &[T]" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11472 ~ core[b693]::slice::cmp::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::Ord
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:11471 ~ core[b693]::slice::cmp::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::Ord>::cmp(&[T], &[T]) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <[T] as std::cmp::Ord>::max([T], [T]) -> [T]" is filtered.
[Impl] add default impl: min
"fn <[T] as std::cmp::Ord>::min([T], [T]) -> [T]" is filtered.
[Impl] add default impl: clamp
"fn <[T] as std::cmp::Ord>::clamp([T], [T], [T]) -> [T]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:11727 ~ core[b693]::slice::iter::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::iter::traits::iterator::Iterator
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::iter::traits::iterator::Iterator")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:8501 ~ core[b693]::iter::traits::iterator::Iterator))
impl_def_id: DefId(1:11726 ~ core[b693]::slice::iter::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3111 ~ core[b693]::convert::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:3110 ~ core[b693]::convert::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::convert::AsRef::<[T]>>::as_ref(&[T]) -> &[T]" is filtered.
Add std::convert::AsRef::<[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:13877 ~ core[b693]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<[u8]>>::as_ref(&str) -> &[u8]" is filtered.
Add std::convert::AsRef::<[u8]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:8072 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(4:8073 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:8074 ~ alloc[2c7c]::vec::partial_eq::{impl#6}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:8060 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(4:8061 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:8062 ~ alloc[2c7c]::vec::partial_eq::{impl#4}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&mut [T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:8054 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(4:8055 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "A", def_id: DefId(4:8056 ~ alloc[2c7c]::vec::partial_eq::{impl#3}::A), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("A"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::eq(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<std::vec::Vec::<U, A>>>::ne(&&[T], &std::vec::Vec::<U, A>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::vec::Vec::<U, A>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Path { path: Path { res: Def(Enum, DefId(1:40484 ~ core[b693]::ascii::ascii_char::AsciiChar)), segments: [PathSegment { name: "AsciiChar", args: AngleBracketed { args: [], constraints: [] } }] } })
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:4441 ~ core[b693]::ascii::ascii_char::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[std::ascii::ascii_char::AsciiChar] is not fuzzable
assoc types:
"fn [std::ascii::ascii_char::AsciiChar]::as_str(&[std::ascii::ascii_char::AsciiChar]) -> &str" is filtered.
"fn [std::ascii::ascii_char::AsciiChar]::as_bytes(&[std::ascii::ascii_char::AsciiChar]) -> &[u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:12907 ~ core[b693]::slice::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:12908 ~ core[b693]::slice::{impl#1}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Array(Generic("T"), "N"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:12906 ~ core[b693]::slice::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[[T;N]] is not fuzzable
assoc types:
"fn [[T;N]]::as_flattened(&[[T;N]]) -> &[T]" is filtered.
"fn [[T;N]]::as_flattened_mut(&mut [[T;N]]) -> &mut [T]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(F32))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:12911 ~ core[b693]::slice::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [f32]
[f32] is not fuzzable
assoc types:
"fn [f32]::sort_floats(&mut [f32]) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(F64))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:12913 ~ core[b693]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [f64]
[f64] is not fuzzable
assoc types:
"fn [f64]::sort_floats(&mut [f64]) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:12703 ~ core[b693]::slice::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:12702 ~ core[b693]::slice::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn [T]::len(&[T]) -> usize" is filtered.
"fn [T]::is_empty(&[T]) -> bool" is filtered.
"fn [T]::first(&[T]) -> std::option::Option::<&T>" is filtered.
"fn [T]::first_mut(&mut [T]) -> std::option::Option::<&mut T>" is filtered.
"fn [T]::split_first(&[T]) -> std::option::Option::<(&T ,&[T])>" is filtered.
"fn [T]::split_first_mut(&mut [T]) -> std::option::Option::<(&mut T ,&mut [T])>" is filtered.
"fn [T]::split_last(&[T]) -> std::option::Option::<(&T ,&[T])>" is filtered.
"fn [T]::split_last_mut(&mut [T]) -> std::option::Option::<(&mut T ,&mut [T])>" is filtered.
"fn [T]::last(&[T]) -> std::option::Option::<&T>" is filtered.
"fn [T]::last_mut(&mut [T]) -> std::option::Option::<&mut T>" is filtered.
"fn [T]::first_chunk(&[T]) -> std::option::Option::<&[T;N]>" is filtered.
"fn [T]::first_chunk_mut(&mut [T]) -> std::option::Option::<&mut [T;N]>" is filtered.
"fn [T]::split_first_chunk(&[T]) -> std::option::Option::<(&[T;N] ,&[T])>" is filtered.
"fn [T]::split_first_chunk_mut(&mut [T]) -> std::option::Option::<(&mut [T;N] ,&mut [T])>" is filtered.
"fn [T]::split_last_chunk(&[T]) -> std::option::Option::<(&[T] ,&[T;N])>" is filtered.
"fn [T]::split_last_chunk_mut(&mut [T]) -> std::option::Option::<(&mut [T] ,&mut [T;N])>" is filtered.
"fn [T]::last_chunk(&[T]) -> std::option::Option::<&[T;N]>" is filtered.
"fn [T]::last_chunk_mut(&mut [T]) -> std::option::Option::<&mut [T;N]>" is filtered.
"fn [T]::get(&[T], I) -> std::option::Option::<&<I as std::slice::index::SliceIndex::<[T]>>::Output>" is filtered.
"fn [T]::get_mut(&mut [T], I) -> std::option::Option::<&mut <I as std::slice::index::SliceIndex::<[T]>>::Output>" is filtered.
"fn [T]::get_unchecked(&[T], I) -> &<I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
"fn [T]::get_unchecked_mut(&mut [T], I) -> &mut <I as std::slice::index::SliceIndex::<[T]>>::Output" is filtered.
"fn [T]::as_ptr(&[T]) -> *const T" is filtered.
"fn [T]::as_mut_ptr(&mut [T]) -> *T" is filtered.
"fn [T]::as_ptr_range(&[T]) -> std::ops::range::Range::<*const T>" is filtered.
"fn [T]::as_mut_ptr_range(&mut [T]) -> std::ops::range::Range::<*T>" is filtered.
"fn [T]::swap(&mut [T], usize, usize) -> ()" is filtered.
"fn [T]::swap_unchecked(&mut [T], usize, usize) -> ()" is filtered.
"fn [T]::reverse(&mut [T]) -> ()" is filtered.
"fn [T]::iter(&[T]) -> std::slice::iter::Iter::<'_, T>" is filtered.
"fn [T]::iter_mut(&mut [T]) -> std::slice::iter::IterMut::<'_, T>" is filtered.
"fn [T]::windows(&[T], usize) -> std::slice::iter::Windows::<'_, T>" is filtered.
"fn [T]::chunks(&[T], usize) -> std::slice::iter::Chunks::<'_, T>" is filtered.
"fn [T]::chunks_mut(&mut [T], usize) -> std::slice::iter::ChunksMut::<'_, T>" is filtered.
"fn [T]::chunks_exact(&[T], usize) -> std::slice::iter::ChunksExact::<'_, T>" is filtered.
"fn [T]::chunks_exact_mut(&mut [T], usize) -> std::slice::iter::ChunksExactMut::<'_, T>" is filtered.
"fn [T]::as_chunks_unchecked(&[T]) -> &[[T;N]]" is filtered.
"fn [T]::as_chunks(&[T]) -> (&[[T;N]] ,&[T])" is filtered.
"fn [T]::as_rchunks(&[T]) -> (&[T] ,&[[T;N]])" is filtered.
"fn [T]::array_chunks(&[T]) -> std::slice::iter::ArrayChunks::<'_, T, <const>>" is filtered.
"fn [T]::as_chunks_unchecked_mut(&mut [T]) -> &mut [[T;N]]" is filtered.
"fn [T]::as_chunks_mut(&mut [T]) -> (&mut [[T;N]] ,&mut [T])" is filtered.
"fn [T]::as_rchunks_mut(&mut [T]) -> (&mut [T] ,&mut [[T;N]])" is filtered.
"fn [T]::array_chunks_mut(&mut [T]) -> std::slice::iter::ArrayChunksMut::<'_, T, <const>>" is filtered.
"fn [T]::array_windows(&[T]) -> std::slice::iter::ArrayWindows::<'_, T, <const>>" is filtered.
"fn [T]::rchunks(&[T], usize) -> std::slice::iter::RChunks::<'_, T>" is filtered.
"fn [T]::rchunks_mut(&mut [T], usize) -> std::slice::iter::RChunksMut::<'_, T>" is filtered.
"fn [T]::rchunks_exact(&[T], usize) -> std::slice::iter::RChunksExact::<'_, T>" is filtered.
"fn [T]::rchunks_exact_mut(&mut [T], usize) -> std::slice::iter::RChunksExactMut::<'_, T>" is filtered.
"fn [T]::chunk_by(&[T], F) -> std::slice::iter::ChunkBy::<'_, T, F>" is filtered.
"fn [T]::chunk_by_mut(&mut [T], F) -> std::slice::iter::ChunkByMut::<'_, T, F>" is filtered.
"fn [T]::split_at(&[T], usize) -> (&[T] ,&[T])" is filtered.
"fn [T]::split_at_mut(&mut [T], usize) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::split_at_unchecked(&[T], usize) -> (&[T] ,&[T])" is filtered.
"fn [T]::split_at_mut_unchecked(&mut [T], usize) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::split_at_checked(&[T], usize) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::split_at_mut_checked(&mut [T], usize) -> std::option::Option::<(&mut [T] ,&mut [T])>" is filtered.
"fn [T]::split(&[T], F) -> std::slice::iter::Split::<'_, T, F>" is filtered.
"fn [T]::split_mut(&mut [T], F) -> std::slice::iter::SplitMut::<'_, T, F>" is filtered.
"fn [T]::split_inclusive(&[T], F) -> std::slice::iter::SplitInclusive::<'_, T, F>" is filtered.
"fn [T]::split_inclusive_mut(&mut [T], F) -> std::slice::iter::SplitInclusiveMut::<'_, T, F>" is filtered.
"fn [T]::rsplit(&[T], F) -> std::slice::iter::RSplit::<'_, T, F>" is filtered.
"fn [T]::rsplit_mut(&mut [T], F) -> std::slice::iter::RSplitMut::<'_, T, F>" is filtered.
"fn [T]::splitn(&[T], usize, F) -> std::slice::iter::SplitN::<'_, T, F>" is filtered.
"fn [T]::splitn_mut(&mut [T], usize, F) -> std::slice::iter::SplitNMut::<'_, T, F>" is filtered.
"fn [T]::rsplitn(&[T], usize, F) -> std::slice::iter::RSplitN::<'_, T, F>" is filtered.
"fn [T]::rsplitn_mut(&mut [T], usize, F) -> std::slice::iter::RSplitNMut::<'_, T, F>" is filtered.
"fn [T]::split_once(&[T], F) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::rsplit_once(&[T], F) -> std::option::Option::<(&[T] ,&[T])>" is filtered.
"fn [T]::contains(&[T], &T) -> bool" is filtered.
"fn [T]::starts_with(&[T], &[T]) -> bool" is filtered.
"fn [T]::ends_with(&[T], &[T]) -> bool" is filtered.
"fn [T]::strip_prefix(&[T], &P) -> std::option::Option::<&[T]>" is filtered.
"fn [T]::strip_suffix(&[T], &P) -> std::option::Option::<&[T]>" is filtered.
"fn [T]::binary_search(&[T], &T) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::binary_search_by(&'a [T], F) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::binary_search_by_key(&'a [T], &B, F) -> std::result::Result::<usize, usize>" is filtered.
"fn [T]::sort_unstable(&mut [T]) -> ()" is filtered.
"fn [T]::sort_unstable_by(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_unstable_by_key(&mut [T], F) -> ()" is filtered.
"fn [T]::select_nth_unstable(&mut [T], usize) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::select_nth_unstable_by(&mut [T], usize, F) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::select_nth_unstable_by_key(&mut [T], usize, F) -> (&mut [T] ,&mut T ,&mut [T])" is filtered.
"fn [T]::partition_dedup(&mut [T]) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::partition_dedup_by(&mut [T], F) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::partition_dedup_by_key(&mut [T], F) -> (&mut [T] ,&mut [T])" is filtered.
"fn [T]::rotate_left(&mut [T], usize) -> ()" is filtered.
"fn [T]::rotate_right(&mut [T], usize) -> ()" is filtered.
"fn [T]::fill(&mut [T], T) -> ()" is filtered.
"fn [T]::fill_with(&mut [T], F) -> ()" is filtered.
"fn [T]::clone_from_slice(&mut [T], &[T]) -> ()" is filtered.
"fn [T]::copy_from_slice(&mut [T], &[T]) -> ()" is filtered.
"fn [T]::copy_within(&mut [T], R, usize) -> ()" is filtered.
"fn [T]::swap_with_slice(&mut [T], &mut [T]) -> ()" is filtered.
"fn [T]::align_to(&[T]) -> (&[T] ,&[U] ,&[T])" is filtered.
"fn [T]::align_to_mut(&mut [T]) -> (&mut [T] ,&mut [U] ,&mut [T])" is filtered.
"fn [T]::as_simd(&[T]) -> (&[T] ,&[std::core_simd::vector::Simd::<T, <const>>] ,&[T])" is filtered.
"fn [T]::as_simd_mut(&mut [T]) -> (&mut [T] ,&mut [std::core_simd::vector::Simd::<T, <const>>] ,&mut [T])" is filtered.
"fn [T]::is_sorted(&[T]) -> bool" is filtered.
"fn [T]::is_sorted_by(&'a [T], F) -> bool" is filtered.
"fn [T]::is_sorted_by_key(&'a [T], F) -> bool" is filtered.
"fn [T]::partition_point(&[T], P) -> usize" is filtered.
"fn [T]::take(&mut &'a [T], R) -> std::option::Option::<&'a [T]>" is filtered.
"fn [T]::take_mut(&mut &'a mut [T], R) -> std::option::Option::<&'a mut [T]>" is filtered.
"fn [T]::take_first(&mut &'a [T]) -> std::option::Option::<&'a T>" is filtered.
"fn [T]::take_first_mut(&mut &'a mut [T]) -> std::option::Option::<&'a mut T>" is filtered.
"fn [T]::take_last(&mut &'a [T]) -> std::option::Option::<&'a T>" is filtered.
"fn [T]::take_last_mut(&mut &'a mut [T]) -> std::option::Option::<&'a mut T>" is filtered.
"fn [T]::get_many_unchecked_mut(&mut [T], [usize;N]) -> [&mut T;N]" is filtered.
"fn [T]::get_many_mut(&mut [T], [usize;N]) -> std::result::Result::<[&mut T;N], std::slice::GetManyMutError::<<const>>>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:11412 ~ core[b693]::slice::ascii::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::is_ascii(&[u8]) -> bool" is filtered.
"fn [u8]::as_ascii(&[u8]) -> std::option::Option::<&[std::ascii::ascii_char::AsciiChar]>" is filtered.
"fn [u8]::as_ascii_unchecked(&[u8]) -> &[std::ascii::ascii_char::AsciiChar]" is filtered.
"fn [u8]::eq_ignore_ascii_case(&[u8], &[u8]) -> bool" is filtered.
"fn [u8]::make_ascii_uppercase(&mut [u8]) -> ()" is filtered.
"fn [u8]::make_ascii_lowercase(&mut [u8]) -> ()" is filtered.
"fn [u8]::escape_ascii(&[u8]) -> std::slice::ascii::EscapeAscii::<'_>" is filtered.
"fn [u8]::trim_ascii_start(&[u8]) -> &[u8]" is filtered.
"fn [u8]::trim_ascii_end(&[u8]) -> &[u8]" is filtered.
"fn [u8]::trim_ascii(&[u8]) -> &[u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(1:13662 ~ core[b693]::str::lossy::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::utf8_chunks(&[u8]) -> std::str::lossy::Utf8Chunks::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5522 ~ alloc[2c7c]::slice::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: none
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(4:5521 ~ alloc[2c7c]::slice::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn [T]::sort(&mut [T]) -> ()" is filtered.
"fn [T]::sort_by(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_by_key(&mut [T], F) -> ()" is filtered.
"fn [T]::sort_by_cached_key(&mut [T], F) -> ()" is filtered.
"fn [T]::to_vec(&[T]) -> std::vec::Vec::<T>" is filtered.
"fn [T]::to_vec_in(&[T], A) -> std::vec::Vec::<T, A>" is filtered.
"fn [T]::into_vec(std::boxed::Box::<[T], A>) -> std::vec::Vec::<T, A>" is filtered.
"fn [T]::repeat(&[T], usize) -> std::vec::Vec::<T>" is filtered.
"fn [T]::concat(&[T]) -> <[T] as std::slice::Concat::<Item>>::Output" is filtered.
"fn [T]::join(&[T], Separator) -> <[T] as std::slice::Join::<Separator>>::Output" is filtered.
"fn [T]::connect(&[T], Separator) -> <[T] as std::slice::Join::<Separator>>::Output" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: None
impl_def_id: DefId(4:5548 ~ alloc[2c7c]::slice::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
"fn [u8]::to_ascii_uppercase(&[u8]) -> std::vec::Vec::<u8>" is filtered.
"fn [u8]::to_ascii_lowercase(&[u8]) -> std::vec::Vec::<u8>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(4:5681 ~ alloc[2c7c]::str::{impl#1}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(4:5680 ~ alloc[2c7c]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5682 ~ alloc[2c7c]::str::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&str>>::join(&[S], &str) -> std::string::String" is filtered.
Add std::slice::Join::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5566 ~ alloc[2c7c]::slice::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(4:5567 ~ alloc[2c7c]::slice::{impl#3}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(4:5565 ~ alloc[2c7c]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5568 ~ alloc[2c7c]::slice::{impl#3}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&T>>::join(&[V], &T) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5572 ~ alloc[2c7c]::slice::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(4:5573 ~ alloc[2c7c]::slice::{impl#4}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(4:5571 ~ alloc[2c7c]::slice::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5574 ~ alloc[2c7c]::slice::{impl#4}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&[T]>>::join(&[V], &[T]) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&[T]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(4:5677 ~ alloc[2c7c]::str::{impl#0}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(4:5676 ~ alloc[2c7c]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5678 ~ alloc[2c7c]::str::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Concat::<str>>::concat(&[S]) -> std::string::String" is filtered.
Add std::slice::Concat::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5560 ~ alloc[2c7c]::slice::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(4:5561 ~ alloc[2c7c]::slice::{impl#2}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(4:5559 ~ alloc[2c7c]::slice::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5562 ~ alloc[2c7c]::slice::{impl#2}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Concat::<T>>::concat(&[V]) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Concat::<T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5598 ~ alloc[2c7c]::slice::{impl#9}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::borrow::ToOwned
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(4:5597 ~ alloc[2c7c]::slice::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
Owned: std::vec::Vec::<T>
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(4:5599 ~ alloc[2c7c]::slice::{impl#9}::Owned)), kind: AssocType, docs: "" }
"fn <[T] as std::borrow::ToOwned>::to_owned(&[T]) -> std::vec::Vec::<T>" is filtered.
"fn <[T] as std::borrow::ToOwned>::clone_into(&[T], &mut std::vec::Vec::<T>) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::Write
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Write")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:3664 ~ std[d8a0]::io::Write))
impl_def_id: DefId(5:3237 ~ std[d8a0]::io::impls::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: &mut [u8]
&mut [u8] is not fuzzable
assoc types:
"fn <&mut [u8] as std::io::Write>::write(&mut &mut [u8], &[u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::write_vectored(&mut &mut [u8], &[std::io::IoSlice::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::is_write_vectored(&&mut [u8]) -> bool" is filtered.
"fn <&mut [u8] as std::io::Write>::write_all(&mut &mut [u8], &[u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&mut [u8] as std::io::Write>::flush(&mut &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
Add std::io::Write Provide Method. is_local=false
[Impl] add default impl: write_all_vectored
"fn <&mut [u8] as std::io::Write>::write_all_vectored(&mut &mut [u8], &mut [std::io::IoSlice::<'_>]) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: write_fmt
"fn <&mut [u8] as std::io::Write>::write_fmt(&mut &mut [u8], std::fmt::Arguments::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
[Impl] add default impl: by_ref
"fn <&mut [u8] as std::io::Write>::by_ref(&mut &mut [u8]) -> &mut &mut [u8]" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:3889 ~ std[d8a0]::net::socket_addr::{impl#13}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: std::net::socket_addr::ToSocketAddrs
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Slice(Path { path: Path { res: Def(Enum, DefId(1:42520 ~ core[b693]::net::socket_addr::SocketAddr)), segments: [PathSegment { name: "SocketAddr", args: AngleBracketed { args: [], constraints: [] } }] } }) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::net::socket_addr::ToSocketAddrs")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:3856 ~ std[d8a0]::net::socket_addr::ToSocketAddrs))
impl_def_id: DefId(5:3888 ~ std[d8a0]::net::socket_addr::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[std::net::SocketAddr] is not fuzzable
assoc types:
Iter: std::iter::adapters::cloned::Cloned::<std::slice::iter::Iter::<'a, std::net::SocketAddr>>
not covered item Item { name: Some("Iter"), item_id: DefId(DefId(5:3890 ~ std[d8a0]::net::socket_addr::{impl#13}::Iter)), kind: AssocType, docs: "" }
"fn <&[std::net::SocketAddr] as std::net::ToSocketAddrs>::to_socket_addrs(&&[std::net::SocketAddr]) -> std::result::Result::<<&'a [std::net::SocketAddr] as std::net::ToSocketAddrs>::Iter, std::io::Error>" is filtered.
Add std::net::ToSocketAddrs Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:2259 ~ std[d8a0]::ffi::os_str::{impl#51}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:2258 ~ std[d8a0]::ffi::os_str::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::ffi::OsString
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:2260 ~ std[d8a0]::ffi::os_str::{impl#51}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&std::ffi::OsStr>>::join(&[S], &std::ffi::OsStr) -> std::ffi::OsString" is filtered.
Add std::slice::Join::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::BufRead
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::BufRead")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:3692 ~ std[d8a0]::io::BufRead))
impl_def_id: DefId(5:3234 ~ std[d8a0]::io::impls::{impl#9})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
[TypeContext] add candidate #12: &mut &[u8] => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) } }
[TypeContext] add candidate #13: &&[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) } }
[TypeContext] add candidate #14: *&[u8] => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })
[TypeContext] add candidate #15: *const &[u8] => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) })
assoc types:
"fn <&[u8] as std::io::BufRead>::fill_buf(&mut &[u8]) -> std::result::Result::<&[u8], std::io::Error>" is filtered.
"fn <&[u8] as std::io::BufRead>::consume(&mut &[u8], usize) -> ()" is filtered.
Add std::io::BufRead Provide Method. is_local=false
[Impl] add default impl: has_data_left
"fn <&[u8] as std::io::BufRead>::has_data_left(&mut &[u8]) -> std::result::Result::<bool, std::io::Error>" is filtered.
[Impl] add default impl: read_until
"fn <&[u8] as std::io::BufRead>::read_until(&mut &[u8], u8, &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: skip_until
"fn <&[u8] as std::io::BufRead>::skip_until(&mut &[u8], u8) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: read_line
"fn <&[u8] as std::io::BufRead>::read_line(&mut &[u8], &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
[Impl] add default impl: split
"fn <&[u8] as std::io::BufRead>::split(&[u8], u8) -> std::io::Split::<&[u8]>" is filtered.
[Impl] add default impl: lines
"fn <&[u8] as std::io::BufRead>::lines(&[u8]) -> std::io::Lines::<&[u8]>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::io::Read
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::io::Read")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:3607 ~ std[d8a0]::io::Read))
impl_def_id: DefId(5:3224 ~ std[d8a0]::io::impls::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
&[u8] is fuzzable
assoc types:
"fn <&[u8] as std::io::Read>::read(&mut &[u8], &mut [u8]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_buf(&mut &[u8], std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_vectored(&mut &[u8], &mut [std::io::IoSliceMut::<'_>]) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::is_read_vectored(&&[u8]) -> bool" is filtered.
"fn <&[u8] as std::io::Read>::read_exact(&mut &[u8], &mut [u8]) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_buf_exact(&mut &[u8], std::io::borrowed_buf::BorrowedCursor::<'_>) -> std::result::Result::<(), std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_to_end(&mut &[u8], &mut std::vec::Vec::<u8>) -> std::result::Result::<usize, std::io::Error>" is filtered.
"fn <&[u8] as std::io::Read>::read_to_string(&mut &[u8], &mut std::string::String) -> std::result::Result::<usize, std::io::Error>" is filtered.
Add std::io::Read Provide Method. is_local=false
[Impl] add default impl: by_ref
"fn <&[u8] as std::io::Read>::by_ref(&mut &[u8]) -> &mut &[u8]" is filtered.
[Impl] add default impl: bytes
"fn <&[u8] as std::io::Read>::bytes(&[u8]) -> std::io::Bytes::<&[u8]>" is filtered.
[Impl] add default impl: chain
"fn <&[u8] as std::io::Read>::chain(&[u8], R) -> std::io::Chain::<&[u8], R>" is filtered.
[Impl] add default impl: take
"fn <&[u8] as std::io::Read>::take(&[u8], u64) -> std::io::Take::<&[u8]>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::ascii::AsciiExt
impl for: Slice(Primitive(U8))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::ascii::AsciiExt")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(5:646 ~ std[d8a0]::ascii::AsciiExt))
impl_def_id: DefId(5:659 ~ std[d8a0]::ascii::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
input fail#0: [u8]
[u8] is not fuzzable
assoc types:
Owned: std::vec::Vec::<u8>
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:660 ~ std[d8a0]::ascii::{impl#2}::Owned)), kind: AssocType, docs: "" }
"fn <[u8] as std::ascii::AsciiExt>::is_ascii(&[u8]) -> bool" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::to_ascii_uppercase(&[u8]) -> <[u8] as std::ascii::AsciiExt>::Owned" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::to_ascii_lowercase(&[u8]) -> <[u8] as std::ascii::AsciiExt>::Owned" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::eq_ignore_ascii_case(&[u8], &[u8]) -> bool" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::make_ascii_uppercase(&mut [u8]) -> ()" is filtered.
"fn <[u8] as std::ascii::AsciiExt>::make_ascii_lowercase(&mut [u8]) -> ()" is filtered.
Add std::ascii::AsciiExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9023 ~ std[d8a0]::path::{impl#159})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9021 ~ std[d8a0]::path::{impl#158})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8161 ~ std[d8a0]::ffi::os_str::{impl#77}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8162 ~ std[d8a0]::ffi::os_str::{impl#77}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8160 ~ std[d8a0]::ffi::os_str::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8983 ~ std[d8a0]::path::{impl#143})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2230 ~ std[d8a0]::ffi::os_str::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::eq(&std::ffi::OsStr, &str) -> bool" is filtered.
Add std::cmp::PartialEq::<str> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9030 ~ std[d8a0]::path::{impl#162}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9029 ~ std[d8a0]::path::{impl#162})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::eq(&std::path::Path, &&'a std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<&std::ffi::OsStr>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8145 ~ std[d8a0]::ffi::os_str::{impl#73}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8146 ~ std[d8a0]::ffi::os_str::{impl#73}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8144 ~ std[d8a0]::ffi::os_str::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8993 ~ std[d8a0]::path::{impl#147}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8992 ~ std[d8a0]::path::{impl#147})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2228 ~ std[d8a0]::ffi::os_str::{impl#40})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq>::eq(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9118 ~ std[d8a0]::path::{impl#191}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9119 ~ std[d8a0]::path::{impl#191}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9117 ~ std[d8a0]::path::{impl#191})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9033 ~ std[d8a0]::path::{impl#163}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9032 ~ std[d8a0]::path::{impl#163})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::eq(&&std::ffi::OsStr, &std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::Path>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2232 ~ std[d8a0]::ffi::os_str::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&str, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9065 ~ std[d8a0]::path::{impl#175}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9064 ~ std[d8a0]::path::{impl#175})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::eq(&std::ffi::OsStr, &&'a std::path::Path) -> bool" is filtered.
Add std::cmp::PartialEq::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<&std::path::Path>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8129 ~ std[d8a0]::ffi::os_str::{impl#69}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8130 ~ std[d8a0]::ffi::os_str::{impl#69}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8128 ~ std[d8a0]::ffi::os_str::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9062 ~ std[d8a0]::path::{impl#174}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9061 ~ std[d8a0]::path::{impl#174})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&&std::path::Path, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8177 ~ std[d8a0]::ffi::os_str::{impl#81}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8178 ~ std[d8a0]::ffi::os_str::{impl#81}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8176 ~ std[d8a0]::ffi::os_str::{impl#81})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::eq(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9105 ~ std[d8a0]::path::{impl#187}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9104 ~ std[d8a0]::path::{impl#187})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::eq(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::borrow::Cow::<'_, std::path::Path>>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: None
impl_def_id: DefId(5:2167 ~ std[d8a0]::ffi::os_str::{impl#23})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn std::ffi::OsStr::new(&S) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::from_encoded_bytes_unchecked(&[u8]) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::to_str(&std::ffi::OsStr) -> std::option::Option::<&str>" is filtered.
"fn std::ffi::OsStr::to_string_lossy(&std::ffi::OsStr) -> std::borrow::Cow::<'_, str>" is filtered.
"fn std::ffi::OsStr::to_os_string(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::is_empty(&std::ffi::OsStr) -> bool" is filtered.
"fn std::ffi::OsStr::len(&std::ffi::OsStr) -> usize" is filtered.
"fn std::ffi::OsStr::into_os_string(std::boxed::Box::<std::ffi::OsStr>) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::as_encoded_bytes(&std::ffi::OsStr) -> &[u8]" is filtered.
"fn std::ffi::OsStr::slice_encoded_bytes(&std::ffi::OsStr, R) -> &std::ffi::OsStr" is filtered.
"fn std::ffi::OsStr::make_ascii_lowercase(&mut std::ffi::OsStr) -> ()" is filtered.
"fn std::ffi::OsStr::make_ascii_uppercase(&mut std::ffi::OsStr) -> ()" is filtered.
"fn std::ffi::OsStr::to_ascii_lowercase(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::to_ascii_uppercase(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn std::ffi::OsStr::is_ascii(&std::ffi::OsStr) -> bool" is filtered.
"fn std::ffi::OsStr::eq_ignore_ascii_case(&std::ffi::OsStr, S) -> bool" is filtered.
"fn std::ffi::OsStr::display(&std::ffi::OsStr) -> std::ffi::Display::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(5:2265 ~ std[d8a0]::ffi::os_str::{impl#53})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
Owned: std::ffi::OsString
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:2266 ~ std[d8a0]::ffi::os_str::{impl#53}::Owned)), kind: AssocType, docs: "" }
"fn <std::ffi::OsStr as std::borrow::ToOwned>::to_owned(&std::ffi::OsStr) -> std::ffi::OsString" is filtered.
"fn <std::ffi::OsStr as std::borrow::ToOwned>::clone_into(&std::ffi::OsStr, &mut std::ffi::OsString) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(5:2249 ~ std[d8a0]::ffi::os_str::{impl#48})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:2269 ~ std[d8a0]::ffi::os_str::{impl#54})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::ffi::OsStr) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:2273 ~ std[d8a0]::ffi::os_str::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&str) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5572 ~ std[d8a0]::path::{impl#74})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::convert::AsRef::<std::path::Path>>::as_ref(&std::ffi::OsStr) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5549 ~ std[d8a0]::path::{impl#64})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&std::path::Path) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(5:2243 ~ std[d8a0]::ffi::os_str::{impl#46})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::Ord>::cmp(&std::ffi::OsStr, &std::ffi::OsStr) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <std::ffi::OsStr as std::cmp::Ord>::max(std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
[Impl] add default impl: min
"fn <std::ffi::OsStr as std::cmp::Ord>::min(std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
[Impl] add default impl: clamp
"fn <std::ffi::OsStr as std::cmp::Ord>::clamp(std::ffi::OsStr, std::ffi::OsStr, std::ffi::OsStr) -> std::ffi::OsStr" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9111 ~ std[d8a0]::path::{impl#189}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9110 ~ std[d8a0]::path::{impl#189})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8185 ~ std[d8a0]::ffi::os_str::{impl#83}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8186 ~ std[d8a0]::ffi::os_str::{impl#83}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8184 ~ std[d8a0]::ffi::os_str::{impl#83})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:2235 ~ std[d8a0]::ffi::os_str::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::lt(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::le(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::gt(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
"fn <std::ffi::OsStr as std::cmp::PartialOrd>::ge(&std::ffi::OsStr, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:2241 ~ std[d8a0]::ffi::os_str::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::partial_cmp(&std::ffi::OsStr, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<str> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8987 ~ std[d8a0]::path::{impl#145})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8169 ~ std[d8a0]::ffi::os_str::{impl#79}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8170 ~ std[d8a0]::ffi::os_str::{impl#79}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8168 ~ std[d8a0]::ffi::os_str::{impl#79})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::partial_cmp(&std::ffi::OsStr, &std::borrow::Cow::<'a, std::ffi::OsStr>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::ffi::OsStr>>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9068 ~ std[d8a0]::path::{impl#176}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9067 ~ std[d8a0]::path::{impl#176})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8153 ~ std[d8a0]::ffi::os_str::{impl#75}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8154 ~ std[d8a0]::ffi::os_str::{impl#75}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8152 ~ std[d8a0]::ffi::os_str::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9039 ~ std[d8a0]::path::{impl#165}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9038 ~ std[d8a0]::path::{impl#165})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9036 ~ std[d8a0]::path::{impl#164}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9035 ~ std[d8a0]::path::{impl#164})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::partial_cmp(&std::path::Path, &&'a std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<&std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8137 ~ std[d8a0]::ffi::os_str::{impl#71}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8138 ~ std[d8a0]::ffi::os_str::{impl#71}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8136 ~ std[d8a0]::ffi::os_str::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9025 ~ std[d8a0]::path::{impl#160})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::partial_cmp(&std::path::Path, &std::ffi::OsStr) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsStr>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8999 ~ std[d8a0]::path::{impl#149}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8998 ~ std[d8a0]::path::{impl#149})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9071 ~ std[d8a0]::path::{impl#177}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9070 ~ std[d8a0]::path::{impl#177})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::partial_cmp(&std::ffi::OsStr, &&'a std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<&'a std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<&std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9027 ~ std[d8a0]::path::{impl#161})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::partial_cmp(&std::ffi::OsStr, &std::path::Path) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::Path> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::Path>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9126 ~ std[d8a0]::path::{impl#193}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:9127 ~ std[d8a0]::path::{impl#193}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9125 ~ std[d8a0]::path::{impl#193})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::partial_cmp(&&std::ffi::OsStr, &std::borrow::Cow::<'a, std::path::Path>) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::borrow::Cow::<'_, std::path::Path>>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:2221 ~ std[d8a0]::ffi::os_str::{impl#37}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:2220 ~ std[d8a0]::ffi::os_str::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Error: std::str::error::Utf8Error
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:2222 ~ std[d8a0]::ffi::os_str::{impl#37}::Error)), kind: AssocType, docs: "" }
"fn <&str as std::convert::TryFrom::<&std::ffi::OsStr>>::try_from(&'a std::ffi::OsStr) -> std::result::Result::<&'a str, <&'a str as std::convert::TryFrom::<&'a std::ffi::OsStr>>::Error>" is filtered.
Add std::convert::TryFrom::<&'a std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::os::unix::ffi::os_str::OsStrExt
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::os::unix::ffi::os_str::OsStrExt")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(5:4124 ~ std[d8a0]::os::unix::ffi::os_str::OsStrExt))
impl_def_id: DefId(5:4127 ~ std[d8a0]::os::unix::ffi::os_str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::os::unix::ffi::os_str::OsStrExt>::from_bytes(&[u8]) -> &std::ffi::OsStr" is filtered.
"fn <std::ffi::OsStr as std::os::unix::ffi::os_str::OsStrExt>::as_bytes(&std::ffi::OsStr) -> &[u8]" is filtered.
Add std::os::unix::ffi::os_str::OsStrExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(5:2259 ~ std[d8a0]::ffi::os_str::{impl#51}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(5:2258 ~ std[d8a0]::ffi::os_str::{impl#51})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::ffi::OsString
not covered item Item { name: Some("Output"), item_id: DefId(DefId(5:2260 ~ std[d8a0]::ffi::os_str::{impl#51}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&std::ffi::OsStr>>::join(&[S], &std::ffi::OsStr) -> std::ffi::OsString" is filtered.
Add std::slice::Join::<&std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(5:2226 ~ std[d8a0]::ffi::os_str::{impl#39})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::default::Default>::default() -> &std::ffi::OsStr" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(5:2246 ~ std[d8a0]::ffi::os_str::{impl#47})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::hash::Hash>::hash(&std::ffi::OsStr, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <std::ffi::OsStr as std::hash::Hash>::hash_slice(&[std::ffi::OsStr], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(5:2234 ~ std[d8a0]::ffi::os_str::{impl#43})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8933 ~ std[d8a0]::path::{impl#127}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8932 ~ std[d8a0]::path::{impl#127})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8983 ~ std[d8a0]::path::{impl#143})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8993 ~ std[d8a0]::path::{impl#147}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8992 ~ std[d8a0]::path::{impl#147})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&&std::ffi::OsStr, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8923 ~ std[d8a0]::path::{impl#123})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::eq(&std::path::Path, &std::path::PathBuf) -> bool" is filtered.
Add std::cmp::PartialEq::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::path::PathBuf>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:5367 ~ std[d8a0]::path::PathBuf)), segments: [PathSegment { name: "PathBuf", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::path::PathBuf")
type_def_id: Some(DefId(5:5367 ~ std[d8a0]::path::PathBuf))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:5438 ~ std[d8a0]::path::{impl#44})
is_local_impl: false
is_external_type: true
type_name: "std::path::PathBuf"
std::path::PathBuf is not fuzzable
assoc types:
Target: std::path::Path
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:5439 ~ std[d8a0]::path::{impl#44}::Target)), kind: AssocType, docs: "" }
"fn <std::path::PathBuf as std::ops::Deref>::deref(&std::path::PathBuf) -> &std::path::Path" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8927 ~ std[d8a0]::path::{impl#125})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8939 ~ std[d8a0]::path::{impl#129}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8938 ~ std[d8a0]::path::{impl#129})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::path::Path, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8987 ~ std[d8a0]::path::{impl#145})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8999 ~ std[d8a0]::path::{impl#149}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8998 ~ std[d8a0]::path::{impl#149})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::partial_cmp(&&std::ffi::OsStr, &std::path::PathBuf) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::path::PathBuf> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::path::PathBuf>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7059 ~ std[d8a0]::sync::rwlock::{impl#29}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:9466 ~ std[d8a0]::sync::rwlock::MappedRwLockWriteGuard)), segments: [PathSegment { name: "MappedRwLockWriteGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::MappedRwLockWriteGuard")
type_def_id: Some(DefId(5:9466 ~ std[d8a0]::sync::rwlock::MappedRwLockWriteGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:7058 ~ std[d8a0]::sync::rwlock::{impl#29})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::MappedRwLockWriteGuard"
std::sync::rwlock::MappedRwLockWriteGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:7060 ~ std[d8a0]::sync::rwlock::{impl#29}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::MappedRwLockWriteGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::MappedRwLockWriteGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4123 ~ core[b693]::array::equality::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:4124 ~ core[b693]::array::equality::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:4125 ~ core[b693]::array::equality::{impl#6}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:4122 ~ core[b693]::array::equality::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&mut [T] is not fuzzable
assoc types:
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::eq(&&mut [T], &[U;N]) -> bool" is filtered.
"fn <&mut [T] as std::cmp::PartialEq::<[U;N]>>::ne(&&mut [T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4099 ~ core[b693]::array::equality::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:4100 ~ core[b693]::array::equality::{impl#2}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:4101 ~ core[b693]::array::equality::{impl#2}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: Slice(Generic("T"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:4098 ~ core[b693]::array::equality::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
[T] is not fuzzable
assoc types:
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::eq(&[T], &[U;N]) -> bool" is filtered.
"fn <[T] as std::cmp::PartialEq::<[U;N]>>::ne(&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4111 ~ core[b693]::array::equality::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:4112 ~ core[b693]::array::equality::{impl#4}::U), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "N", def_id: DefId(1:4113 ~ core[b693]::array::equality::{impl#4}::N), kind: Const { ty: Primitive(Usize), default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Generic("T")) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:4110 ~ core[b693]::array::equality::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "T"
&[T] is not fuzzable
assoc types:
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::eq(&&[T], &[U;N]) -> bool" is filtered.
"fn <&[T] as std::cmp::PartialEq::<[U;N]>>::ne(&&[T], &[U;N]) -> bool" is filtered.
Add std::cmp::PartialEq::<[U;N]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(4:5566 ~ alloc[2c7c]::slice::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "V", def_id: DefId(4:5567 ~ alloc[2c7c]::slice::{impl#3}::V), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }, BoundPredicate { ty: Generic("V"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("V"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(4:5565 ~ alloc[2c7c]::slice::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "V"
[V] is not fuzzable
assoc types:
Output: std::vec::Vec::<T>
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5568 ~ alloc[2c7c]::slice::{impl#3}::Output)), kind: AssocType, docs: "" }
"fn <[V] as std::slice::Join::<&T>>::join(&[V], &T) -> std::vec::Vec::<T>" is filtered.
Add std::slice::Join::<&T> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:3661 ~ std[d8a0]::io::{impl#11}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:8510 ~ std[d8a0]::io::IoSlice)), segments: [PathSegment { name: "IoSlice", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::io::IoSlice")
type_def_id: Some(DefId(5:8510 ~ std[d8a0]::io::IoSlice))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:3660 ~ std[d8a0]::io::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::io::IoSlice"
std::io::IoSlice::<'_> is not fuzzable
assoc types:
Target: [u8]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:3662 ~ std[d8a0]::io::{impl#11}::Target)), kind: AssocType, docs: "" }
"fn <std::io::IoSlice::<'_> as std::ops::Deref>::deref(&std::io::IoSlice::<'_>) -> &[u8]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:6096 ~ std[d8a0]::sync::lazy_lock::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(5:6097 ~ std[d8a0]::sync::lazy_lock::{impl#3}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:6075 ~ std[d8a0]::sync::lazy_lock::LazyLock)), segments: [PathSegment { name: "LazyLock", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::lazy_lock::LazyLock")
type_def_id: Some(DefId(5:6075 ~ std[d8a0]::sync::lazy_lock::LazyLock))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:6095 ~ std[d8a0]::sync::lazy_lock::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::sync::lazy_lock::LazyLock"
std::sync::lazy_lock::LazyLock::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:6098 ~ std[d8a0]::sync::lazy_lock::{impl#3}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::lazy_lock::LazyLock::<T, F> as std::ops::Deref>::deref(&std::sync::lazy_lock::LazyLock::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9053 ~ std[d8a0]::path::{impl#170})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8145 ~ std[d8a0]::ffi::os_str::{impl#73}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8146 ~ std[d8a0]::ffi::os_str::{impl#73}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8144 ~ std[d8a0]::ffi::os_str::{impl#73})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2144 ~ std[d8a0]::ffi::os_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9090 ~ std[d8a0]::path::{impl#182}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:9089 ~ std[d8a0]::path::{impl#182})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&std::path::Path, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&std::path::Path as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:2149 ~ std[d8a0]::ffi::os_str::{impl#16}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2148 ~ std[d8a0]::ffi::os_str::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8129 ~ std[d8a0]::ffi::os_str::{impl#69}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8130 ~ std[d8a0]::ffi::os_str::{impl#69}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:8128 ~ std[d8a0]::ffi::os_str::{impl#69})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&std::ffi::OsStr, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:2089 ~ std[d8a0]::ffi::os_str::OsString)), segments: [PathSegment { name: "OsString", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::ffi::os_str::OsString")
type_def_id: Some(DefId(5:2089 ~ std[d8a0]::ffi::os_str::OsString))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:2128 ~ std[d8a0]::ffi::os_str::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsString"
std::ffi::OsString is not fuzzable
assoc types:
Target: std::ffi::OsStr
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:2129 ~ std[d8a0]::ffi::os_str::{impl#7}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::OsString as std::ops::Deref>::deref(&std::ffi::OsString) -> &std::ffi::OsStr" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:9096 ~ std[d8a0]::path::{impl#184}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9095 ~ std[d8a0]::path::{impl#184})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
&std::path::Path is not fuzzable
assoc types:
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8153 ~ std[d8a0]::ffi::os_str::{impl#75}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8154 ~ std[d8a0]::ffi::os_str::{impl#75}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8152 ~ std[d8a0]::ffi::os_str::{impl#75})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
&std::ffi::OsStr is not fuzzable
assoc types:
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <&std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:8137 ~ std[d8a0]::ffi::os_str::{impl#71}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(5:8138 ~ std[d8a0]::ffi::os_str::{impl#71}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:8136 ~ std[d8a0]::ffi::os_str::{impl#71})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::ffi::OsStr, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:5483 ~ std[d8a0]::path::Path)), segments: [PathSegment { name: "Path", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::path::Path")
type_def_id: Some(DefId(5:5483 ~ std[d8a0]::path::Path))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:9057 ~ std[d8a0]::path::{impl#172})
is_local_impl: false
is_external_type: true
type_name: "std::path::Path"
std::path::Path is not fuzzable
assoc types:
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::partial_cmp(&std::path::Path, &std::ffi::OsString) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::lt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::le(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::gt(&std::path::Path, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::path::Path as std::cmp::PartialOrd::<std::ffi::OsString>>::ge(&std::path::Path, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:6654 ~ std[d8a0]::sync::mutex::{impl#12}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:9423 ~ std[d8a0]::sync::mutex::MutexGuard)), segments: [PathSegment { name: "MutexGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::mutex::MutexGuard")
type_def_id: Some(DefId(5:9423 ~ std[d8a0]::sync::mutex::MutexGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:6653 ~ std[d8a0]::sync::mutex::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::sync::mutex::MutexGuard"
std::sync::mutex::MutexGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:6655 ~ std[d8a0]::sync::mutex::{impl#12}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::mutex::MutexGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::mutex::MutexGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3098 ~ core[b693]::convert::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:3097 ~ core[b693]::convert::{impl#5})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:6933 ~ std[d8a0]::sync::reentrant_lock::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:6905 ~ std[d8a0]::sync::reentrant_lock::ReentrantLockGuard)), segments: [PathSegment { name: "ReentrantLockGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::reentrant_lock::ReentrantLockGuard")
type_def_id: Some(DefId(5:6905 ~ std[d8a0]::sync::reentrant_lock::ReentrantLockGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:6932 ~ std[d8a0]::sync::reentrant_lock::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::sync::reentrant_lock::ReentrantLockGuard"
std::sync::reentrant_lock::ReentrantLockGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:6934 ~ std[d8a0]::sync::reentrant_lock::{impl#11}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::reentrant_lock::ReentrantLockGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::reentrant_lock::ReentrantLockGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:6685 ~ std[d8a0]::sync::mutex::{impl#18}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:9428 ~ std[d8a0]::sync::mutex::MappedMutexGuard)), segments: [PathSegment { name: "MappedMutexGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::mutex::MappedMutexGuard")
type_def_id: Some(DefId(5:9428 ~ std[d8a0]::sync::mutex::MappedMutexGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:6684 ~ std[d8a0]::sync::mutex::{impl#18})
is_local_impl: false
is_external_type: true
type_name: "std::sync::mutex::MappedMutexGuard"
std::sync::mutex::MappedMutexGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:6686 ~ std[d8a0]::sync::mutex::{impl#18}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::mutex::MappedMutexGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::mutex::MappedMutexGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7048 ~ std[d8a0]::sync::rwlock::{impl#26}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:9456 ~ std[d8a0]::sync::rwlock::RwLockWriteGuard)), segments: [PathSegment { name: "RwLockWriteGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::RwLockWriteGuard")
type_def_id: Some(DefId(5:9456 ~ std[d8a0]::sync::rwlock::RwLockWriteGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:7047 ~ std[d8a0]::sync::rwlock::{impl#26})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::RwLockWriteGuard"
std::sync::rwlock::RwLockWriteGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:7049 ~ std[d8a0]::sync::rwlock::{impl#26}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::RwLockWriteGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::RwLockWriteGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:3642 ~ std[d8a0]::io::{impl#5}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:3625 ~ std[d8a0]::io::IoSliceMut)), segments: [PathSegment { name: "IoSliceMut", args: AngleBracketed { args: [Lifetime(Lifetime("'a"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::io::IoSliceMut")
type_def_id: Some(DefId(5:3625 ~ std[d8a0]::io::IoSliceMut))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:3641 ~ std[d8a0]::io::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::io::IoSliceMut"
std::io::IoSliceMut::<'_> is not fuzzable
assoc types:
Target: [u8]
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:3643 ~ std[d8a0]::io::{impl#5}::Target)), kind: AssocType, docs: "" }
"fn <std::io::IoSliceMut::<'_> as std::ops::Deref>::deref(&std::io::IoSliceMut::<'_>) -> &[u8]" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(1:13307 ~ core[b693]::str::traits::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialOrd>::partial_cmp(&str, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd Provide Method. is_local=false
[Impl] add default impl: lt
"fn <str as std::cmp::PartialOrd>::lt(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <str as std::cmp::PartialOrd>::le(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <str as std::cmp::PartialOrd>::gt(&str, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <str as std::cmp::PartialOrd>::ge(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::error::Error
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::error::Error")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3153 ~ core[b693]::error::Error))
impl_def_id: DefId(1:13883 ~ core[b693]::str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Add std::error::Error Provide Method. is_local=false
[Impl] add default impl: source
"fn <&str as std::error::Error>::source(&&str) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], Some(Lifetime(\"'static\")))>" is filtered.
[Impl] add default impl: description
"fn <&str as std::error::Error>::description(&&str) -> &str" is filtered.
[Impl] add default impl: cause
"fn <&str as std::error::Error>::cause(&&str) -> std::option::Option::<&Currently not supported: DynTrait([PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3153 ~ core[b693]::error::Error)), segments: [PathSegment { name: \"Error\", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }], None)>" is filtered.
[Impl] add default impl: provide
"fn <&str as std::error::Error>::provide(&'a &str, &mut std::error::Request::<'a>) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:13592 ~ core[b693]::str::pattern::{impl#31}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(1:13593 ~ core[b693]::str::pattern::{impl#31}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::str::pattern::Pattern
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::str::pattern::Pattern")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:13443 ~ core[b693]::str::pattern::Pattern))
impl_def_id: DefId(1:13591 ~ core[b693]::str::pattern::{impl#31})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Searcher: std::str::pattern::StrSearcher::<'a, 'b>
not covered item Item { name: Some("Searcher"), item_id: DefId(DefId(1:13594 ~ core[b693]::str::pattern::{impl#31}::Searcher)), kind: AssocType, docs: "" }
"fn <&str as std::str::pattern::Pattern::<'_>>::into_searcher(&str, &'a str) -> std::str::pattern::StrSearcher::<'a, 'b>" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_prefix_of(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_contained_in(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::strip_prefix_of(&str, &'a str) -> std::option::Option::<&'a str>" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::is_suffix_of(&str, &'a str) -> bool" is filtered.
"fn <&str as std::str::pattern::Pattern::<'_>>::strip_suffix_of(&str, &'a str) -> std::option::Option::<&'a str>" is filtered.
Add std::str::pattern::Pattern::<'a> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::StructuralPartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::StructuralPartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:32820 ~ core[b693]::marker::StructuralPartialEq))
impl_def_id: DefId(1:32835 ~ core[b693]::marker::{impl#32})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::marker::StructuralPartialEq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::hash::Hash
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::hash::Hash")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:10878 ~ core[b693]::hash::Hash))
impl_def_id: DefId(1:10962 ~ core[b693]::hash::impls::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::hash::Hash>::hash(&str, &mut H) -> ()" is filtered.
Add std::hash::Hash Provide Method. is_local=false
[Impl] add default impl: hash_slice
"fn <str as std::hash::Hash>::hash_slice(&[str], &mut H) -> ()" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Display
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Display")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:10665 ~ core[b693]::fmt::Display))
impl_def_id: DefId(1:10771 ~ core[b693]::fmt::{impl#17})
is_local_impl: false
is_external_type: true
type_name: "std::str"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:10767 ~ core[b693]::fmt::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::ConstParamTy
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::ConstParamTy")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:32908 ~ core[b693]::marker::ConstParamTy))
impl_def_id: DefId(1:32923 ~ core[b693]::marker::{impl#90})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::marker::ConstParamTy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(1:13314 ~ core[b693]::str::traits::{impl#5}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::IndexMut
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::IndexMut")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3621 ~ core[b693]::ops::index::IndexMut))
impl_def_id: DefId(1:13313 ~ core[b693]::str::traits::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::ops::IndexMut::<I>>::index_mut(&mut str, I) -> &mut <I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
Add std::ops::IndexMut::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "I", def_id: DefId(1:13310 ~ core[b693]::str::traits::{impl#4}::I), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("I"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::index::Index
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::index::Index")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:40131 ~ core[b693]::ops::index::Index))
impl_def_id: DefId(1:13309 ~ core[b693]::str::traits::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Output: <I as std::slice::index::SliceIndex::<str>>::Output
not covered item Item { name: Some("Output"), item_id: DefId(DefId(1:13311 ~ core[b693]::str::traits::{impl#4}::Output)), kind: AssocType, docs: "" }
"fn <str as std::ops::Index::<I>>::index(&str, I) -> &<I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
Add std::ops::Index::<I> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Eq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Eq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2872 ~ core[b693]::cmp::Eq))
impl_def_id: DefId(1:13306 ~ core[b693]::str::traits::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Add std::cmp::Eq Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsMut
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsMut")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3061 ~ core[b693]::convert::AsMut))
impl_def_id: DefId(1:3118 ~ core[b693]::convert::{impl#11})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsMut::<str>>::as_mut(&mut str) -> &mut str" is filtered.
Add std::convert::AsMut::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(1:13304 ~ core[b693]::str::traits::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq>::eq(&str, &str) -> bool" is filtered.
Add std::cmp::PartialEq Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:13881 ~ core[b693]::str::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&mut str is not fuzzable
assoc types:
"fn <&mut str as std::default::Default>::default() -> &mut str" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(1:13879 ~ core[b693]::str::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::default::Default>::default() -> &str" is filtered.
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::Ord
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::Ord")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2903 ~ core[b693]::cmp::Ord))
impl_def_id: DefId(1:13302 ~ core[b693]::str::traits::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::Ord>::cmp(&str, &str) -> std::cmp::Ordering" is filtered.
Add std::cmp::Ord Provide Method. is_local=false
[Impl] add default impl: max
"fn <str as std::cmp::Ord>::max(str, str) -> str" is filtered.
[Impl] add default impl: min
"fn <str as std::cmp::Ord>::min(str, str) -> str" is filtered.
[Impl] add default impl: clamp
"fn <str as std::cmp::Ord>::clamp(str, str, str) -> str" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:13877 ~ core[b693]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<[u8]>>::as_ref(&str) -> &[u8]" is filtered.
Add std::convert::AsRef::<[u8]> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(1:3116 ~ core[b693]::convert::{impl#10})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<str>>::as_ref(&str) -> &str" is filtered.
Add std::convert::AsRef::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7793 ~ alloc[2c7c]::string::{impl#82}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7794 ~ alloc[2c7c]::string::{impl#82}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7792 ~ alloc[2c7c]::string::{impl#82})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::string::String>>::eq(&str, &std::string::String) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::string::String>>::ne(&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7813 ~ alloc[2c7c]::string::{impl#86}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7814 ~ alloc[2c7c]::string::{impl#86}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7812 ~ alloc[2c7c]::string::{impl#86})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7823 ~ alloc[2c7c]::string::{impl#88}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7824 ~ alloc[2c7c]::string::{impl#88}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'b")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7822 ~ alloc[2c7c]::string::{impl#88})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::eq(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::borrow::Cow::<'_, str>>>::ne(&&str, &std::borrow::Cow::<'a, str>) -> bool" is filtered.
Add std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(4:7803 ~ alloc[2c7c]::string::{impl#84}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'b", def_id: DefId(4:7804 ~ alloc[2c7c]::string::{impl#84}::'b), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(4:7802 ~ alloc[2c7c]::string::{impl#84})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::string::String>>::eq(&&str, &std::string::String) -> bool" is filtered.
"fn <&str as std::cmp::PartialEq::<std::string::String>>::ne(&&str, &std::string::String) -> bool" is filtered.
Add std::cmp::PartialEq::<std::string::String> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Primitive(Str)
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: None
impl_def_id: DefId(1:13742 ~ core[b693]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn str::len(&str) -> usize" is filtered.
"fn str::is_empty(&str) -> bool" is filtered.
"fn str::is_char_boundary(&str, usize) -> bool" is filtered.
"fn str::floor_char_boundary(&str, usize) -> usize" is filtered.
"fn str::ceil_char_boundary(&str, usize) -> usize" is filtered.
"fn str::as_bytes(&str) -> &[u8]" is filtered.
"fn str::as_bytes_mut(&mut str) -> &mut [u8]" is filtered.
"fn str::as_ptr(&str) -> *const u8" is filtered.
"fn str::as_mut_ptr(&mut str) -> *u8" is filtered.
"fn str::get(&str, I) -> std::option::Option::<&<I as std::slice::index::SliceIndex::<str>>::Output>" is filtered.
"fn str::get_mut(&mut str, I) -> std::option::Option::<&mut <I as std::slice::index::SliceIndex::<str>>::Output>" is filtered.
"fn str::get_unchecked(&str, I) -> &<I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
"fn str::get_unchecked_mut(&mut str, I) -> &mut <I as std::slice::index::SliceIndex::<str>>::Output" is filtered.
"fn str::slice_unchecked(&str, usize, usize) -> &str" is filtered.
"fn str::slice_mut_unchecked(&mut str, usize, usize) -> &mut str" is filtered.
"fn str::split_at(&str, usize) -> (&str ,&str)" is filtered.
"fn str::split_at_mut(&mut str, usize) -> (&mut str ,&mut str)" is filtered.
"fn str::split_at_checked(&str, usize) -> std::option::Option::<(&str ,&str)>" is filtered.
"fn str::split_at_mut_checked(&mut str, usize) -> std::option::Option::<(&mut str ,&mut str)>" is filtered.
"fn str::chars(&str) -> std::str::iter::Chars::<'_>" is filtered.
"fn str::char_indices(&str) -> std::str::iter::CharIndices::<'_>" is filtered.
"fn str::bytes(&str) -> std::str::iter::Bytes::<'_>" is filtered.
"fn str::split_whitespace(&str) -> std::str::iter::SplitWhitespace::<'_>" is filtered.
"fn str::split_ascii_whitespace(&str) -> std::str::iter::SplitAsciiWhitespace::<'_>" is filtered.
"fn str::lines(&str) -> std::str::iter::Lines::<'_>" is filtered.
"fn str::lines_any(&str) -> std::str::iter::LinesAny::<'_>" is filtered.
"fn str::encode_utf16(&str) -> std::str::iter::EncodeUtf16::<'_>" is filtered.
"fn str::contains(&'a str, P) -> bool" is filtered.
"fn str::starts_with(&'a str, P) -> bool" is filtered.
"fn str::ends_with(&'a str, P) -> bool" is filtered.
"fn str::find(&'a str, P) -> std::option::Option::<usize>" is filtered.
"fn str::rfind(&'a str, P) -> std::option::Option::<usize>" is filtered.
"fn str::split(&'a str, P) -> std::str::iter::Split::<'a, P>" is filtered.
"fn str::split_inclusive(&'a str, P) -> std::str::iter::SplitInclusive::<'a, P>" is filtered.
"fn str::rsplit(&'a str, P) -> std::str::iter::RSplit::<'a, P>" is filtered.
"fn str::split_terminator(&'a str, P) -> std::str::iter::SplitTerminator::<'a, P>" is filtered.
"fn str::rsplit_terminator(&'a str, P) -> std::str::iter::RSplitTerminator::<'a, P>" is filtered.
"fn str::splitn(&'a str, usize, P) -> std::str::iter::SplitN::<'a, P>" is filtered.
"fn str::rsplitn(&'a str, usize, P) -> std::str::iter::RSplitN::<'a, P>" is filtered.
"fn str::split_once(&'a str, P) -> std::option::Option::<(&'a str ,&'a str)>" is filtered.
"fn str::rsplit_once(&'a str, P) -> std::option::Option::<(&'a str ,&'a str)>" is filtered.
"fn str::matches(&'a str, P) -> std::str::iter::Matches::<'a, P>" is filtered.
"fn str::rmatches(&'a str, P) -> std::str::iter::RMatches::<'a, P>" is filtered.
"fn str::match_indices(&'a str, P) -> std::str::iter::MatchIndices::<'a, P>" is filtered.
"fn str::rmatch_indices(&'a str, P) -> std::str::iter::RMatchIndices::<'a, P>" is filtered.
"fn str::trim(&str) -> &str" is filtered.
"fn str::trim_start(&str) -> &str" is filtered.
"fn str::trim_end(&str) -> &str" is filtered.
"fn str::trim_left(&str) -> &str" is filtered.
"fn str::trim_right(&str) -> &str" is filtered.
"fn str::trim_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_start_matches(&'a str, P) -> &'a str" is filtered.
"fn str::strip_prefix(&'a str, P) -> std::option::Option::<&'a str>" is filtered.
"fn str::strip_suffix(&'a str, P) -> std::option::Option::<&'a str>" is filtered.
"fn str::trim_end_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_left_matches(&'a str, P) -> &'a str" is filtered.
"fn str::trim_right_matches(&'a str, P) -> &'a str" is filtered.
"fn str::parse(&str) -> std::result::Result::<F, <F as std::str::FromStr>::Err>" is filtered.
"fn str::is_ascii(&str) -> bool" is filtered.
"fn str::as_ascii(&str) -> std::option::Option::<&[std::ascii::ascii_char::AsciiChar]>" is filtered.
"fn str::eq_ignore_ascii_case(&str, &str) -> bool" is filtered.
"fn str::make_ascii_uppercase(&mut str) -> ()" is filtered.
"fn str::make_ascii_lowercase(&mut str) -> ()" is filtered.
"fn str::trim_ascii_start(&str) -> &str" is filtered.
"fn str::trim_ascii_end(&str) -> &str" is filtered.
"fn str::trim_ascii(&str) -> &str" is filtered.
"fn str::escape_debug(&str) -> std::str::iter::EscapeDebug::<'_>" is filtered.
"fn str::escape_default(&str) -> std::str::iter::EscapeDefault::<'_>" is filtered.
"fn str::escape_unicode(&str) -> std::str::iter::EscapeUnicode::<'_>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Primitive(Str)
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: None
impl_def_id: DefId(4:5701 ~ alloc[2c7c]::str::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn str::into_boxed_bytes(std::boxed::Box::<str>) -> std::boxed::Box::<[u8]>" is filtered.
"fn str::replace(&'a str, P, &str) -> std::string::String" is filtered.
"fn str::replacen(&'a str, P, &str, usize) -> std::string::String" is filtered.
"fn str::to_lowercase(&str) -> std::string::String" is filtered.
"fn str::to_uppercase(&str) -> std::string::String" is filtered.
"fn str::into_string(std::boxed::Box::<str>) -> std::string::String" is filtered.
"fn str::repeat(&str, usize) -> std::string::String" is filtered.
"fn str::to_ascii_uppercase(&str) -> std::string::String" is filtered.
"fn str::to_ascii_lowercase(&str) -> std::string::String" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(4:5681 ~ alloc[2c7c]::str::{impl#1}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Join
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Join")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5555 ~ alloc[2c7c]::slice::Join))
impl_def_id: DefId(4:5680 ~ alloc[2c7c]::str::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5682 ~ alloc[2c7c]::str::{impl#1}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Join::<&str>>::join(&[S], &str) -> std::string::String" is filtered.
Add std::slice::Join::<&str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "S", def_id: DefId(4:5677 ~ alloc[2c7c]::str::{impl#0}::S), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("S"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: alloc::slice::Concat
impl for: Slice(Generic("S"))
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::slice::Concat")
type_full_name: Some("std::slice")
type_def_id: Some(DefId(5:12497 ~ std[d8a0]::prim_slice))
trait_def_id: Some(DefId(4:5551 ~ alloc[2c7c]::slice::Concat))
impl_def_id: DefId(4:5676 ~ alloc[2c7c]::str::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::slice"
[fuzzable_call_type] generic type = "S"
[S] is not fuzzable
assoc types:
Output: std::string::String
not covered item Item { name: Some("Output"), item_id: DefId(DefId(4:5678 ~ alloc[2c7c]::str::{impl#0}::Output)), kind: AssocType, docs: "" }
"fn <[S] as std::slice::Concat::<str>>::concat(&[S]) -> std::string::String" is filtered.
Add std::slice::Concat::<str> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: alloc::borrow::ToOwned
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("alloc::borrow::ToOwned")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned))
impl_def_id: DefId(4:5697 ~ alloc[2c7c]::str::{impl#4})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Owned: std::string::String
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(4:5698 ~ alloc[2c7c]::str::{impl#4}::Owned)), kind: AssocType, docs: "" }
"fn <str as std::borrow::ToOwned>::to_owned(&str) -> std::string::String" is filtered.
"fn <str as std::borrow::ToOwned>::clone_into(&str, &mut std::string::String) -> ()" is filtered.
Add std::borrow::ToOwned Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2230 ~ std[d8a0]::ffi::os_str::{impl#41})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::eq(&std::ffi::OsStr, &str) -> bool" is filtered.
Add std::cmp::PartialEq::<str> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <std::ffi::OsStr as std::cmp::PartialEq::<str>>::ne(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2144 ~ std[d8a0]::ffi::os_str::{impl#14})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2232 ~ std[d8a0]::ffi::os_str::{impl#42})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::eq(&str, &std::ffi::OsStr) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsStr> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <str as std::cmp::PartialEq::<std::ffi::OsStr>>::ne(&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:2149 ~ std[d8a0]::ffi::os_str::{impl#16}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::cmp::PartialEq
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialEq")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:2867 ~ core[b693]::cmp::PartialEq))
impl_def_id: DefId(5:2148 ~ std[d8a0]::ffi::os_str::{impl#16})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::eq(&&str, &std::ffi::OsString) -> bool" is filtered.
Add std::cmp::PartialEq::<std::ffi::OsString> Provide Method. is_local=false
[Impl] add default impl: ne
"fn <&str as std::cmp::PartialEq::<std::ffi::OsString>>::ne(&&str, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:2273 ~ std[d8a0]::ffi::os_str::{impl#56})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::ffi::OsStr>>::as_ref(&str) -> &std::ffi::OsStr" is filtered.
Add std::convert::AsRef::<std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::convert::AsRef
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::AsRef")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3058 ~ core[b693]::convert::AsRef))
impl_def_id: DefId(5:5578 ~ std[d8a0]::path::{impl#77})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
"fn <str as std::convert::AsRef::<std::path::Path>>::as_ref(&str) -> &std::path::Path" is filtered.
Add std::convert::AsRef::<std::path::Path> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::cmp::PartialOrd
impl for: Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::cmp::PartialOrd")
type_full_name: Some("std::ffi::os_str::OsStr")
type_def_id: Some(DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr))
trait_def_id: Some(DefId(1:2909 ~ core[b693]::cmp::PartialOrd))
impl_def_id: DefId(5:2241 ~ std[d8a0]::ffi::os_str::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::OsStr"
std::ffi::OsStr is not fuzzable
assoc types:
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::partial_cmp(&std::ffi::OsStr, &str) -> std::option::Option::<std::cmp::Ordering>" is filtered.
Add std::cmp::PartialOrd::<str> Provide Method. is_local=false
[Impl] add default impl: lt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::lt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: le
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::le(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: gt
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::gt(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
[Impl] add default impl: ge
"fn <std::ffi::OsStr as std::cmp::PartialOrd::<str>>::ge(&std::ffi::OsStr, &Rhs) -> bool" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(5:2221 ~ std[d8a0]::ffi::os_str::{impl#37}::'a), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::convert::TryFrom
impl for: BorrowedRef { lifetime: Some(Lifetime("'a")), mutability: Not, type_: Primitive(Str) }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(1:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(5:2220 ~ std[d8a0]::ffi::os_str::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::str"
&str is fuzzable
assoc types:
Error: std::str::error::Utf8Error
not covered item Item { name: Some("Error"), item_id: DefId(DefId(5:2222 ~ std[d8a0]::ffi::os_str::{impl#37}::Error)), kind: AssocType, docs: "" }
"fn <&str as std::convert::TryFrom::<&std::ffi::OsStr>>::try_from(&'a std::ffi::OsStr) -> std::result::Result::<&'a str, <&'a str as std::convert::TryFrom::<&'a std::ffi::OsStr>>::Error>" is filtered.
Add std::convert::TryFrom::<&'a std::ffi::OsStr> Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::net::socket_addr::ToSocketAddrs
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::net::socket_addr::ToSocketAddrs")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(5:3856 ~ std[d8a0]::net::socket_addr::ToSocketAddrs))
impl_def_id: DefId(5:3885 ~ std[d8a0]::net::socket_addr::{impl#12})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Iter: std::vec::into_iter::IntoIter::<std::net::SocketAddr>
not covered item Item { name: Some("Iter"), item_id: DefId(DefId(5:3886 ~ std[d8a0]::net::socket_addr::{impl#12}::Iter)), kind: AssocType, docs: "" }
"fn <str as std::net::ToSocketAddrs>::to_socket_addrs(&str) -> std::result::Result::<std::vec::into_iter::IntoIter::<std::net::SocketAddr>, std::io::Error>" is filtered.
Add std::net::ToSocketAddrs Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: std::ascii::AsciiExt
impl for: Primitive(Str)
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("std::ascii::AsciiExt")
type_full_name: Some("std::str")
type_def_id: Some(DefId(5:12498 ~ std[d8a0]::prim_str))
trait_def_id: Some(DefId(5:646 ~ std[d8a0]::ascii::AsciiExt))
impl_def_id: DefId(5:661 ~ std[d8a0]::ascii::{impl#3})
is_local_impl: false
is_external_type: true
type_name: "std::str"
str is not fuzzable
assoc types:
Owned: std::string::String
not covered item Item { name: Some("Owned"), item_id: DefId(DefId(5:662 ~ std[d8a0]::ascii::{impl#3}::Owned)), kind: AssocType, docs: "" }
"fn <str as std::ascii::AsciiExt>::is_ascii(&str) -> bool" is filtered.
"fn <str as std::ascii::AsciiExt>::to_ascii_uppercase(&str) -> <str as std::ascii::AsciiExt>::Owned" is filtered.
"fn <str as std::ascii::AsciiExt>::to_ascii_lowercase(&str) -> <str as std::ascii::AsciiExt>::Owned" is filtered.
"fn <str as std::ascii::AsciiExt>::eq_ignore_ascii_case(&str, &str) -> bool" is filtered.
"fn <str as std::ascii::AsciiExt>::make_ascii_uppercase(&mut str) -> ()" is filtered.
"fn <str as std::ascii::AsciiExt>::make_ascii_lowercase(&mut str) -> ()" is filtered.
Add std::ascii::AsciiExt Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(5:7044 ~ std[d8a0]::sync::rwlock::{impl#25}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(5:9451 ~ std[d8a0]::sync::rwlock::RwLockReadGuard)), segments: [PathSegment { name: "RwLockReadGuard", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("std::sync::rwlock::RwLockReadGuard")
type_def_id: Some(DefId(5:9451 ~ std[d8a0]::sync::rwlock::RwLockReadGuard))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(5:7043 ~ std[d8a0]::sync::rwlock::{impl#25})
is_local_impl: false
is_external_type: true
type_name: "std::sync::rwlock::RwLockReadGuard"
std::sync::rwlock::RwLockReadGuard::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(5:7045 ~ std[d8a0]::sync::rwlock::{impl#25}::Target)), kind: AssocType, docs: "" }
"fn <std::sync::rwlock::RwLockReadGuard::<'_, T> as std::ops::Deref>::deref(&std::sync::rwlock::RwLockReadGuard::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<

visibility: ModVisibity { crate_name: "fastrand", inner: {"fastrand": Public, "fastrand::global_rng": Restricted(DefId(0:0 ~ fastrand[57b2]))} }

type std::sync::rwlock::MappedRwLockWriteGuard implement 1 traits: 
DefId(5:7058 ~ std[d8a0]::sync::rwlock::{impl#29}): impl std::ops::Deref for std::sync::rwlock::MappedRwLockWriteGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::path::PathBuf implement 1 traits: 
DefId(5:5438 ~ std[d8a0]::path::{impl#44}): impl std::ops::Deref for std::path::PathBuf
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::path::Path implement 55 traits: 
DefId(5:9073 ~ std[d8a0]::path::{impl#178}): impl std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8957 ~ std[d8a0]::path::{impl#135}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9041 ~ std[d8a0]::path::{impl#166}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8944 ~ std[d8a0]::path::{impl#131}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8950 ~ std[d8a0]::path::{impl#133}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9081 ~ std[d8a0]::path::{impl#180}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9047 ~ std[d8a0]::path::{impl#168}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8965 ~ std[d8a0]::path::{impl#137}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9021 ~ std[d8a0]::path::{impl#158}): impl std::cmp::PartialEq::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9053 ~ std[d8a0]::path::{impl#170}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8932 ~ std[d8a0]::path::{impl#127}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9029 ~ std[d8a0]::path::{impl#162}): impl std::cmp::PartialEq::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9073 ~ std[d8a0]::path::{impl#178}): impl std::cmp::PartialEq::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5560 ~ std[d8a0]::path::{impl#68}): impl std::cmp::PartialEq for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8957 ~ std[d8a0]::path::{impl#135}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8923 ~ std[d8a0]::path::{impl#123}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9041 ~ std[d8a0]::path::{impl#166}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9089 ~ std[d8a0]::path::{impl#182}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8944 ~ std[d8a0]::path::{impl#131}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9061 ~ std[d8a0]::path::{impl#174}): impl std::cmp::PartialEq::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5467 ~ std[d8a0]::path::{impl#56}): impl std::borrow::ToOwned for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5551 ~ std[d8a0]::path::{impl#65}): impl std::fmt::Debug for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5549 ~ std[d8a0]::path::{impl#64}): impl std::convert::AsRef::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5570 ~ std[d8a0]::path::{impl#73}): impl std::convert::AsRef::<std::path::Path> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5568 ~ std[d8a0]::path::{impl#72}): impl std::cmp::Ord for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8927 ~ std[d8a0]::path::{impl#125}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8938 ~ std[d8a0]::path::{impl#129}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8950 ~ std[d8a0]::path::{impl#133}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9095 ~ std[d8a0]::path::{impl#184}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9067 ~ std[d8a0]::path::{impl#176}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9035 ~ std[d8a0]::path::{impl#164}): impl std::cmp::PartialOrd::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9081 ~ std[d8a0]::path::{impl#180}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'b, std::ffi::OsStr>> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9047 ~ std[d8a0]::path::{impl#168}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8965 ~ std[d8a0]::path::{impl#137}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9025 ~ std[d8a0]::path::{impl#160}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5566 ~ std[d8a0]::path::{impl#71}): impl std::cmp::PartialOrd for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9057 ~ std[d8a0]::path::{impl#172}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5589 ~ std[d8a0]::path::{impl#81}): impl std::iter::traits::collect::IntoIterator for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5562 ~ std[d8a0]::path::{impl#69}): impl std::hash::Hash for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5565 ~ std[d8a0]::path::{impl#70}): impl std::cmp::Eq for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9021 ~ std[d8a0]::path::{impl#158}): impl std::cmp::PartialEq::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9029 ~ std[d8a0]::path::{impl#162}): impl std::cmp::PartialEq::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9061 ~ std[d8a0]::path::{impl#174}): impl std::cmp::PartialEq::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5549 ~ std[d8a0]::path::{impl#64}): impl std::convert::AsRef::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9067 ~ std[d8a0]::path::{impl#176}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9035 ~ std[d8a0]::path::{impl#164}): impl std::cmp::PartialOrd::<&'a std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9025 ~ std[d8a0]::path::{impl#160}): impl std::cmp::PartialOrd::<std::ffi::OsStr> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8932 ~ std[d8a0]::path::{impl#127}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8923 ~ std[d8a0]::path::{impl#123}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8927 ~ std[d8a0]::path::{impl#125}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8938 ~ std[d8a0]::path::{impl#129}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9053 ~ std[d8a0]::path::{impl#170}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9089 ~ std[d8a0]::path::{impl#182}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9095 ~ std[d8a0]::path::{impl#184}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9057 ~ std[d8a0]::path::{impl#172}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::path::Path
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::rwlock::RwLockReadGuard implement 1 traits: 
DefId(5:7043 ~ std[d8a0]::sync::rwlock::{impl#25}): impl std::ops::Deref for std::sync::rwlock::RwLockReadGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::c_str::CStr implement 11 traits: 
DefId(1:5268 ~ core[b693]::ffi::c_str::{impl#9}): impl std::cmp::PartialOrd for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:41118 ~ core[b693]::ffi::c_str::{impl#18}): impl std::hash::Hash for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5242 ~ core[b693]::ffi::c_str::{impl#3}): impl std::fmt::Debug for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5272 ~ core[b693]::ffi::c_str::{impl#11}): impl std::ops::Index::<std::ops::range::RangeFrom::<usize>> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5267 ~ core[b693]::ffi::c_str::{impl#8}): impl std::cmp::Eq for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5265 ~ core[b693]::ffi::c_str::{impl#7}): impl std::cmp::PartialEq for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5244 ~ core[b693]::ffi::c_str::{impl#4}): impl std::default::Default for &std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5270 ~ core[b693]::ffi::c_str::{impl#10}): impl std::cmp::Ord for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5275 ~ core[b693]::ffi::c_str::{impl#12}): impl std::convert::AsRef::<std::ffi::CStr> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:4872 ~ alloc[2c7c]::ffi::c_str::{impl#30}): impl std::borrow::ToOwned for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5272 ~ core[b693]::ffi::c_str::{impl#11}): impl std::ops::Index::<std::ops::range::RangeFrom::<usize>> for std::ffi::CStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::sync::Arc implement 1 traits: 
DefId(4:6291 ~ alloc[2c7c]::sync::{impl#29}): impl std::ops::Deref for std::sync::Arc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::pin::Pin implement 1 traits: 
DefId(1:9692 ~ core[b693]::pin::{impl#13}): impl std::ops::Deref for std::pin::Pin::<Ptr>
bounds: GenericParamMap { inner: {"Ptr": []}, generic_defs: ["Ptr"], type_pred: [(Generic("Ptr"), [Path { res: Def(Trait, DefId(1:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::panic::unwind_safe::AssertUnwindSafe implement 1 traits: 
DefId(1:9523 ~ core[b693]::panic::unwind_safe::{impl#21}): impl std::ops::Deref for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }

type std::io::IoSlice implement 1 traits: 
DefId(5:3660 ~ std[d8a0]::io::{impl#11}): impl std::ops::Deref for std::io::IoSlice::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::lazy_lock::LazyLock implement 1 traits: 
DefId(5:6095 ~ std[d8a0]::sync::lazy_lock::{impl#3}): impl std::ops::Deref for std::sync::lazy_lock::LazyLock::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type std::sync::rwlock::MappedRwLockReadGuard implement 1 traits: 
DefId(5:7054 ~ std[d8a0]::sync::rwlock::{impl#28}): impl std::ops::Deref for std::sync::rwlock::MappedRwLockReadGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::rc::Rc implement 1 traits: 
DefId(4:5149 ~ alloc[2c7c]::rc::{impl#25}): impl std::ops::Deref for std::rc::Rc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::ffi::os_str::OsStr implement 60 traits: 
DefId(5:8160 ~ std[d8a0]::ffi::os_str::{impl#77}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9117 ~ std[d8a0]::path::{impl#191}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8176 ~ std[d8a0]::ffi::os_str::{impl#81}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9104 ~ std[d8a0]::path::{impl#187}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9110 ~ std[d8a0]::path::{impl#189}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8184 ~ std[d8a0]::ffi::os_str::{impl#83}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8168 ~ std[d8a0]::ffi::os_str::{impl#79}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9125 ~ std[d8a0]::path::{impl#193}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9023 ~ std[d8a0]::path::{impl#159}): impl std::cmp::PartialEq::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9032 ~ std[d8a0]::path::{impl#163}): impl std::cmp::PartialEq::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9064 ~ std[d8a0]::path::{impl#175}): impl std::cmp::PartialEq::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5572 ~ std[d8a0]::path::{impl#74}): impl std::convert::AsRef::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9038 ~ std[d8a0]::path::{impl#165}): impl std::cmp::PartialOrd::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9070 ~ std[d8a0]::path::{impl#177}): impl std::cmp::PartialOrd::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9027 ~ std[d8a0]::path::{impl#161}): impl std::cmp::PartialOrd::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9023 ~ std[d8a0]::path::{impl#159}): impl std::cmp::PartialEq::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8160 ~ std[d8a0]::ffi::os_str::{impl#77}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8983 ~ std[d8a0]::path::{impl#143}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2230 ~ std[d8a0]::ffi::os_str::{impl#41}): impl std::cmp::PartialEq::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8144 ~ std[d8a0]::ffi::os_str::{impl#73}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8992 ~ std[d8a0]::path::{impl#147}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2228 ~ std[d8a0]::ffi::os_str::{impl#40}): impl std::cmp::PartialEq for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9117 ~ std[d8a0]::path::{impl#191}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9032 ~ std[d8a0]::path::{impl#163}): impl std::cmp::PartialEq::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9064 ~ std[d8a0]::path::{impl#175}): impl std::cmp::PartialEq::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8128 ~ std[d8a0]::ffi::os_str::{impl#69}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8176 ~ std[d8a0]::ffi::os_str::{impl#81}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9104 ~ std[d8a0]::path::{impl#187}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2265 ~ std[d8a0]::ffi::os_str::{impl#53}): impl std::borrow::ToOwned for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2249 ~ std[d8a0]::ffi::os_str::{impl#48}): impl std::fmt::Debug for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2269 ~ std[d8a0]::ffi::os_str::{impl#54}): impl std::convert::AsRef::<std::ffi::OsStr> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5572 ~ std[d8a0]::path::{impl#74}): impl std::convert::AsRef::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2243 ~ std[d8a0]::ffi::os_str::{impl#46}): impl std::cmp::Ord for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9110 ~ std[d8a0]::path::{impl#189}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8184 ~ std[d8a0]::ffi::os_str::{impl#83}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2235 ~ std[d8a0]::ffi::os_str::{impl#44}): impl std::cmp::PartialOrd for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2241 ~ std[d8a0]::ffi::os_str::{impl#45}): impl std::cmp::PartialOrd::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8987 ~ std[d8a0]::path::{impl#145}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8168 ~ std[d8a0]::ffi::os_str::{impl#79}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::ffi::OsStr>> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8152 ~ std[d8a0]::ffi::os_str::{impl#75}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9038 ~ std[d8a0]::path::{impl#165}): impl std::cmp::PartialOrd::<std::path::Path> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8136 ~ std[d8a0]::ffi::os_str::{impl#71}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8998 ~ std[d8a0]::path::{impl#149}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9070 ~ std[d8a0]::path::{impl#177}): impl std::cmp::PartialOrd::<&'a std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9027 ~ std[d8a0]::path::{impl#161}): impl std::cmp::PartialOrd::<std::path::Path> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:9125 ~ std[d8a0]::path::{impl#193}): impl std::cmp::PartialOrd::<std::borrow::Cow::<'a, std::path::Path>> for &'b std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:4127 ~ std[d8a0]::os::unix::ffi::os_str::{impl#1}): impl std::os::unix::ffi::os_str::OsStrExt for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2226 ~ std[d8a0]::ffi::os_str::{impl#39}): impl std::default::Default for &std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2246 ~ std[d8a0]::ffi::os_str::{impl#47}): impl std::hash::Hash for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2234 ~ std[d8a0]::ffi::os_str::{impl#43}): impl std::cmp::Eq for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8983 ~ std[d8a0]::path::{impl#143}): impl std::cmp::PartialEq::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8992 ~ std[d8a0]::path::{impl#147}): impl std::cmp::PartialEq::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8987 ~ std[d8a0]::path::{impl#145}): impl std::cmp::PartialOrd::<std::path::PathBuf> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8998 ~ std[d8a0]::path::{impl#149}): impl std::cmp::PartialOrd::<std::path::PathBuf> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8144 ~ std[d8a0]::ffi::os_str::{impl#73}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8128 ~ std[d8a0]::ffi::os_str::{impl#69}): impl std::cmp::PartialEq::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8152 ~ std[d8a0]::ffi::os_str::{impl#75}): impl std::cmp::PartialOrd::<std::ffi::OsString> for &'a std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:8136 ~ std[d8a0]::ffi::os_str::{impl#71}): impl std::cmp::PartialOrd::<std::ffi::OsString> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2230 ~ std[d8a0]::ffi::os_str::{impl#41}): impl std::cmp::PartialEq::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2241 ~ std[d8a0]::ffi::os_str::{impl#45}): impl std::cmp::PartialOrd::<str> for std::ffi::OsStr
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::Ref implement 1 traits: 
DefId(1:4846 ~ core[b693]::cell::{impl#37}): impl std::ops::Deref for std::cell::Ref::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::boxed::Box implement 1 traits: 
DefId(4:501 ~ alloc[2c7c]::boxed::{impl#38}): impl std::ops::Deref for std::boxed::Box::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::ffi::os_str::OsString implement 1 traits: 
DefId(5:2128 ~ std[d8a0]::ffi::os_str::{impl#7}): impl std::ops::Deref for std::ffi::OsString
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::io::IoSliceMut implement 1 traits: 
DefId(5:3641 ~ std[d8a0]::io::{impl#5}): impl std::ops::Deref for std::io::IoSliceMut::<'a>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::boxed::thin::ThinBox implement 1 traits: 
DefId(4:235 ~ alloc[2c7c]::boxed::thin::{impl#6}): impl std::ops::Deref for std::boxed::thin::ThinBox::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::slice implement 49 traits: 
DefId(4:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(4:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(4:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &[T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:11474 ~ core[b693]::slice::cmp::{impl#3}): impl std::cmp::PartialOrd for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2909 ~ core[b693]::cmp::PartialOrd)), segments: [PathSegment { name: "PartialOrd", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:13569 ~ core[b693]::str::pattern::{impl#24}): impl std::str::pattern::Pattern::<'a> for &'b [char]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:32840 ~ core[b693]::marker::{impl#35}): impl std::marker::StructuralPartialEq for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:10971 ~ core[b693]::hash::impls::{impl#4}): impl std::hash::Hash for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:10878 ~ core[b693]::hash::Hash)), segments: [PathSegment { name: "Hash", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}): impl std::iter::traits::collect::IntoIterator for &'a [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:11734 ~ core[b693]::slice::iter::{impl#2}): impl std::iter::traits::collect::IntoIterator for &'a mut [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:2823 ~ core[b693]::clone::{impl#2}): impl std::clone::CloneToUninit for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2826 ~ core[b693]::clone::{impl#3}): impl std::clone::CloneToUninit for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:10801 ~ core[b693]::fmt::{impl#26}): impl std::fmt::Debug for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:10660 ~ core[b693]::fmt::Debug)), segments: [PathSegment { name: "Debug", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:32928 ~ core[b693]::marker::{impl#93}): impl std::marker::ConstParamTy for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32908 ~ core[b693]::marker::ConstParamTy)), segments: [PathSegment { name: "ConstParamTy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:11526 ~ core[b693]::slice::index::{impl#1}): impl std::ops::IndexMut::<I> for [T]
bounds: GenericParamMap { inner: {"T": [], "I": []}, generic_defs: ["T", "I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(1:11521 ~ core[b693]::slice::index::{impl#0}): impl std::ops::Index::<I> for [T]
bounds: GenericParamMap { inner: {"T": [], "I": []}, generic_defs: ["T", "I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(1:11469 ~ core[b693]::slice::cmp::{impl#1}): impl std::cmp::Eq for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2872 ~ core[b693]::cmp::Eq)), segments: [PathSegment { name: "Eq", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:3113 ~ core[b693]::convert::{impl#9}): impl std::convert::AsMut::<[T]> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:12933 ~ core[b693]::slice::{impl#8}): impl std::slice::SlicePattern for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:4122 ~ core[b693]::array::equality::{impl#6}): impl std::cmp::PartialEq::<[U;N]> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:4098 ~ core[b693]::array::equality::{impl#2}): impl std::cmp::PartialEq::<[U;N]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:4110 ~ core[b693]::array::equality::{impl#4}): impl std::cmp::PartialEq::<[U;N]> for &[T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:11464 ~ core[b693]::slice::cmp::{impl#0}): impl std::cmp::PartialEq::<[U]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:12927 ~ core[b693]::slice::{impl#7}): impl std::default::Default for &mut [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:12924 ~ core[b693]::slice::{impl#6}): impl std::default::Default for &[T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:11471 ~ core[b693]::slice::cmp::{impl#2}): impl std::cmp::Ord for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:11726 ~ core[b693]::slice::iter::{impl#0}): impl std::iter::traits::iterator::Iterator for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:3110 ~ core[b693]::convert::{impl#8}): impl std::convert::AsRef::<[T]> for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(4:8071 ~ alloc[2c7c]::vec::partial_eq::{impl#6}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(4:8059 ~ alloc[2c7c]::vec::partial_eq::{impl#4}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(4:8053 ~ alloc[2c7c]::vec::partial_eq::{impl#3}): impl std::cmp::PartialEq::<std::vec::Vec::<U, A>> for &[T]
bounds: GenericParamMap { inner: {"T": [], "A": [], "U": []}, generic_defs: ["T", "U", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(4:5680 ~ alloc[2c7c]::str::{impl#1}): impl std::slice::Join::<&str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(4:5565 ~ alloc[2c7c]::slice::{impl#3}): impl std::slice::Join::<&T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(4:5571 ~ alloc[2c7c]::slice::{impl#4}): impl std::slice::Join::<&[T]> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(4:5676 ~ alloc[2c7c]::str::{impl#0}): impl std::slice::Concat::<str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(4:5559 ~ alloc[2c7c]::slice::{impl#2}): impl std::slice::Concat::<T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(4:5597 ~ alloc[2c7c]::slice::{impl#9}): impl std::borrow::ToOwned for [T]
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(5:3237 ~ std[d8a0]::io::impls::{impl#10}): impl std::io::Write for &mut [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:3888 ~ std[d8a0]::net::socket_addr::{impl#13}): impl std::net::ToSocketAddrs for &'a [std::net::SocketAddr]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2258 ~ std[d8a0]::ffi::os_str::{impl#51}): impl std::slice::Join::<&std::ffi::OsStr> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }])] }
DefId(5:3234 ~ std[d8a0]::io::impls::{impl#9}): impl std::io::BufRead for &[u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:3224 ~ std[d8a0]::io::impls::{impl#8}): impl std::io::Read for &[u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:659 ~ std[d8a0]::ascii::{impl#2}): impl std::ascii::AsciiExt for [u8]
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2258 ~ std[d8a0]::ffi::os_str::{impl#51}): impl std::slice::Join::<&std::ffi::OsStr> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Path { path: Path { res: Def(Struct, DefId(5:2092 ~ std[d8a0]::ffi::os_str::OsStr)), segments: [PathSegment { name: "OsStr", args: AngleBracketed { args: [], constraints: [] } }] } })], constraints: [] } }] }])] }
DefId(1:4122 ~ core[b693]::array::equality::{impl#6}): impl std::cmp::PartialEq::<[U;N]> for &mut [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:4098 ~ core[b693]::array::equality::{impl#2}): impl std::cmp::PartialEq::<[U;N]> for [T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(1:4110 ~ core[b693]::array::equality::{impl#4}): impl std::cmp::PartialEq::<[U;N]> for &[T]
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2867 ~ core[b693]::cmp::PartialEq)), segments: [PathSegment { name: "PartialEq", args: AngleBracketed { args: [Type(Generic("U"))], constraints: [] } }] }])] }
DefId(4:5565 ~ alloc[2c7c]::slice::{impl#3}): impl std::slice::Join::<&T> for [V]
bounds: GenericParamMap { inner: {"T": [], "V": []}, generic_defs: ["T", "V"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("V"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Slice(Generic("T")))], constraints: [] } }] }])] }
DefId(4:5680 ~ alloc[2c7c]::str::{impl#1}): impl std::slice::Join::<&str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(4:5676 ~ alloc[2c7c]::str::{impl#0}): impl std::slice::Concat::<str> for [S]
bounds: GenericParamMap { inner: {"S": []}, generic_defs: ["S"], type_pred: [(Generic("S"), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }

type alloc::vec::Vec implement 1 traits: 
DefId(4:7329 ~ alloc[2c7c]::vec::{impl#8}): impl std::ops::Deref for std::vec::Vec::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::va_list::VaListImpl implement 3 traits: 
DefId(1:41176 ~ core[b693]::ffi::va_list::{impl#8}): impl std::fmt::Debug for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5332 ~ core[b693]::ffi::va_list::{impl#6}): impl std::clone::Clone for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5335 ~ core[b693]::ffi::va_list::{impl#7}): impl std::ops::drop::Drop for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::sync::mutex::MappedMutexGuard implement 1 traits: 
DefId(5:6684 ~ std[d8a0]::sync::mutex::{impl#18}): impl std::ops::Deref for std::sync::mutex::MappedMutexGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::cell::lazy::LazyCell implement 1 traits: 
DefId(1:4628 ~ core[b693]::cell::lazy::{impl#2}): impl std::ops::Deref for std::cell::lazy::LazyCell::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type alloc::ffi::c_str::CString implement 1 traits: 
DefId(4:4811 ~ alloc[2c7c]::ffi::c_str::{impl#3}): impl std::ops::Deref for std::ffi::CString
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::mem::manually_drop::ManuallyDrop implement 1 traits: 
DefId(1:1973 ~ core[b693]::mem::manually_drop::{impl#2}): impl std::ops::Deref for std::mem::manually_drop::ManuallyDrop::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::sync::reentrant_lock::ReentrantLockGuard implement 1 traits: 
DefId(5:6932 ~ std[d8a0]::sync::reentrant_lock::{impl#11}): impl std::ops::Deref for std::sync::reentrant_lock::ReentrantLockGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::collections::binary_heap::PeekMut implement 1 traits: 
DefId(4:897 ~ alloc[2c7c]::collections::binary_heap::{impl#2}): impl std::ops::Deref for std::collections::binary_heap::PeekMut::<'_, T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2903 ~ core[b693]::cmp::Ord)), segments: [PathSegment { name: "Ord", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type std::sync::rwlock::RwLockWriteGuard implement 1 traits: 
DefId(5:7047 ~ std[d8a0]::sync::rwlock::{impl#26}): impl std::ops::Deref for std::sync::rwlock::RwLockWriteGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::cell::RefMut implement 1 traits: 
DefId(1:4903 ~ core[b693]::cell::{impl#45}): impl std::ops::Deref for std::cell::RefMut::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type fastrand::Rng implement 21 traits: 
DefId(1:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:32818 ~ core[b693]::marker::Send): impl std::marker::Send for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for fastrand::Rng
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for fastrand::Rng
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for fastrand::Rng
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for fastrand::Rng
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for fastrand::Rng
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for fastrand::Rng
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for fastrand::Rng
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for fastrand::Rng
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(4:778 ~ alloc[2c7c]::borrow::{impl#1}): impl std::borrow::ToOwned for fastrand::Rng
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:163 ~ fastrand[57b2]::{impl#6}): impl std::cmp::Eq for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:160 ~ fastrand[57b2]::{impl#4}): impl std::marker::StructuralPartialEq for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:19 ~ fastrand[57b2]::global_rng::{impl#0}): impl std::default::Default for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:158 ~ fastrand[57b2]::{impl#3}): impl std::fmt::Debug for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:76 ~ fastrand[57b2]::{impl#0}): impl std::clone::Clone for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:161 ~ fastrand[57b2]::{impl#5}): impl std::cmp::PartialEq for fastrand::Rng
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::ffi::va_list::VaList implement 1 traits: 
DefId(1:5308 ~ core[b693]::ffi::va_list::{impl#1}): impl std::ops::Deref for std::ffi::va_list::VaList::<'a, 'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type std::str implement 42 traits: 
DefId(4:7792 ~ alloc[2c7c]::string::{impl#82}): impl std::cmp::PartialEq::<std::string::String> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7802 ~ alloc[2c7c]::string::{impl#84}): impl std::cmp::PartialEq::<std::string::String> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7812 ~ alloc[2c7c]::string::{impl#86}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7822 ~ alloc[2c7c]::string::{impl#88}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5578 ~ std[d8a0]::path::{impl#77}): impl std::convert::AsRef::<std::path::Path> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13877 ~ core[b693]::str::{impl#1}): impl std::convert::AsRef::<[u8]> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2232 ~ std[d8a0]::ffi::os_str::{impl#42}): impl std::cmp::PartialEq::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2273 ~ std[d8a0]::ffi::os_str::{impl#56}): impl std::convert::AsRef::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2220 ~ std[d8a0]::ffi::os_str::{impl#37}): impl std::convert::TryFrom::<&'a std::ffi::OsStr> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2144 ~ std[d8a0]::ffi::os_str::{impl#14}): impl std::cmp::PartialEq::<std::ffi::OsString> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2148 ~ std[d8a0]::ffi::os_str::{impl#16}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13307 ~ core[b693]::str::traits::{impl#3}): impl std::cmp::PartialOrd for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13883 ~ core[b693]::str::{impl#4}): impl std::error::Error for &str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13591 ~ core[b693]::str::pattern::{impl#31}): impl std::str::pattern::Pattern::<'a> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:32835 ~ core[b693]::marker::{impl#32}): impl std::marker::StructuralPartialEq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:10962 ~ core[b693]::hash::impls::{impl#2}): impl std::hash::Hash for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:10771 ~ core[b693]::fmt::{impl#17}): impl std::fmt::Display for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:10767 ~ core[b693]::fmt::{impl#16}): impl std::fmt::Debug for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:32923 ~ core[b693]::marker::{impl#90}): impl std::marker::ConstParamTy for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13313 ~ core[b693]::str::traits::{impl#5}): impl std::ops::IndexMut::<I> for str
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(1:13309 ~ core[b693]::str::traits::{impl#4}): impl std::ops::Index::<I> for str
bounds: GenericParamMap { inner: {"I": []}, generic_defs: ["I"], type_pred: [(Generic("I"), [Path { res: Def(Trait, DefId(1:11566 ~ core[b693]::slice::index::SliceIndex)), segments: [PathSegment { name: "SliceIndex", args: AngleBracketed { args: [Type(Primitive(Str))], constraints: [] } }] }])] }
DefId(1:13306 ~ core[b693]::str::traits::{impl#2}): impl std::cmp::Eq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3118 ~ core[b693]::convert::{impl#11}): impl std::convert::AsMut::<str> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13304 ~ core[b693]::str::traits::{impl#1}): impl std::cmp::PartialEq for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13881 ~ core[b693]::str::{impl#3}): impl std::default::Default for &mut str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13879 ~ core[b693]::str::{impl#2}): impl std::default::Default for &str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13302 ~ core[b693]::str::traits::{impl#0}): impl std::cmp::Ord for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:13877 ~ core[b693]::str::{impl#1}): impl std::convert::AsRef::<[u8]> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3116 ~ core[b693]::convert::{impl#10}): impl std::convert::AsRef::<str> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7792 ~ alloc[2c7c]::string::{impl#82}): impl std::cmp::PartialEq::<std::string::String> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7812 ~ alloc[2c7c]::string::{impl#86}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7822 ~ alloc[2c7c]::string::{impl#88}): impl std::cmp::PartialEq::<std::borrow::Cow::<'a, str>> for &'b str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:7802 ~ alloc[2c7c]::string::{impl#84}): impl std::cmp::PartialEq::<std::string::String> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(4:5697 ~ alloc[2c7c]::str::{impl#4}): impl std::borrow::ToOwned for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2144 ~ std[d8a0]::ffi::os_str::{impl#14}): impl std::cmp::PartialEq::<std::ffi::OsString> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2232 ~ std[d8a0]::ffi::os_str::{impl#42}): impl std::cmp::PartialEq::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2148 ~ std[d8a0]::ffi::os_str::{impl#16}): impl std::cmp::PartialEq::<std::ffi::OsString> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2273 ~ std[d8a0]::ffi::os_str::{impl#56}): impl std::convert::AsRef::<std::ffi::OsStr> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:5578 ~ std[d8a0]::path::{impl#77}): impl std::convert::AsRef::<std::path::Path> for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:2220 ~ std[d8a0]::ffi::os_str::{impl#37}): impl std::convert::TryFrom::<&'a std::ffi::OsStr> for &'a str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:3885 ~ std[d8a0]::net::socket_addr::{impl#12}): impl std::net::ToSocketAddrs for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(5:661 ~ std[d8a0]::ascii::{impl#3}): impl std::ascii::AsciiExt for str
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::string::String implement 1 traits: 
DefId(4:5941 ~ alloc[2c7c]::string::{impl#28}): impl std::ops::Deref for std::string::String
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type alloc::borrow::Cow implement 1 traits: 
DefId(4:802 ~ alloc[2c7c]::borrow::{impl#4}): impl std::ops::Deref for std::borrow::Cow::<'_, B>
bounds: GenericParamMap { inner: {"B": []}, generic_defs: ["B"], type_pred: [(Generic("B"), [Path { res: Def(Trait, DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }, Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }]), (QPath(QPathData { assoc: PathSegment { name: "Owned", args: AngleBracketed { args: [], constraints: [] } }, self_type: Generic("B"), should_show_cast: true, trait_: Some(Path { res: Def(Trait, DefId(4:774 ~ alloc[2c7c]::borrow::ToOwned)), segments: [PathSegment { name: "ToOwned", args: AngleBracketed { args: [], constraints: [] } }] }) }), [Path { res: Def(Trait, DefId(1:2779 ~ core[b693]::borrow::Borrow)), segments: [PathSegment { name: "Borrow", args: AngleBracketed { args: [Type(Generic("B"))], constraints: [] } }] }])] }

type std::sync::mutex::MutexGuard implement 1 traits: 
DefId(5:6653 ~ std[d8a0]::sync::mutex::{impl#12}): impl std::ops::Deref for std::sync::mutex::MutexGuard::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type alloc::rc::UniqueRc implement 1 traits: 
DefId(4:5392 ~ alloc[2c7c]::rc::{impl#79}): impl std::ops::Deref for std::rc::UniqueRc::<T, A>
bounds: GenericParamMap { inner: {"T": [], "A": []}, generic_defs: ["T", "A"], type_pred: [(Generic("A"), [Path { res: Def(Trait, DefId(1:14472 ~ core[b693]::alloc::Allocator)), segments: [PathSegment { name: "Allocator", args: AngleBracketed { args: [], constraints: [] } }] }]), (Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
Type Candidate #0: (11)&mut &str
Type Candidate #1: (11)&&str
Type Candidate #2: (2)*&[u8]
Type Candidate #3: (2)*const &[u8]
Type Candidate #4: (11)*&str
Type Candidate #5: (1)&mut &[char]
Type Candidate #6: (3)&[u8]
Type Candidate #7: (1)&&[char]
Type Candidate #8: (1)u8
Type Candidate #9: (11)*const &str
Type Candidate #10: (11)&str
Type Candidate #11: (2)&mut &[u8]
Type Candidate #12: (2)&&[u8]
Type Candidate #13: (1)&[char]
Type Candidate #14: (1)*const &[char]
Type Candidate #15: (1)*&[char]
unsupport function:
[ApiGraph] Resolve this function
fn fastrand::choose_multiple(I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
Where:
I: std::iter::traits::collect::IntoIterator, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::char(ImplTrait0) -> char
Where:
ImplTrait0: std::ops::range::RangeBounds::<char>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::isize(ImplTrait0) -> isize
Where:
ImplTrait0: std::ops::range::RangeBounds::<isize>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::usize(ImplTrait0) -> usize
Where:
ImplTrait0: std::ops::range::RangeBounds::<usize>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::i128(ImplTrait0) -> i128
Where:
ImplTrait0: std::ops::range::RangeBounds::<i128>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::u128(ImplTrait0) -> u128
Where:
ImplTrait0: std::ops::range::RangeBounds::<u128>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::i64(ImplTrait0) -> i64
Where:
ImplTrait0: std::ops::range::RangeBounds::<i64>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::u64(ImplTrait0) -> u64
Where:
ImplTrait0: std::ops::range::RangeBounds::<u64>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::i32(ImplTrait0) -> i32
Where:
ImplTrait0: std::ops::range::RangeBounds::<i32>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::u32(ImplTrait0) -> u32
Where:
ImplTrait0: std::ops::range::RangeBounds::<u32>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::i16(ImplTrait0) -> i16
Where:
ImplTrait0: std::ops::range::RangeBounds::<i16>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::u16(ImplTrait0) -> u16
Where:
ImplTrait0: std::ops::range::RangeBounds::<u16>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::i8(ImplTrait0) -> i8
Where:
ImplTrait0: std::ops::range::RangeBounds::<i8>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::u8(ImplTrait0) -> u8
Where:
ImplTrait0: std::ops::range::RangeBounds::<u8>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::shuffle(&mut [T]) -> ()
Where:
T: , 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::choice(I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
Where:
I: , 
Type Pred:
I: std::iter::traits::collect::IntoIterator
<I as std::iter::traits::collect::IntoIterator>::IntoIter: std::iter::traits::exact_size::ExactSizeIterator

[ApiGraph] Resolve this function
fn fastrand::Rng::choose_multiple(&mut fastrand::Rng, I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
Where:
I: std::iter::traits::collect::IntoIterator, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::i8(&mut fastrand::Rng, ImplTrait0) -> i8
Where:
ImplTrait0: std::ops::range::RangeBounds::<i8>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::i16(&mut fastrand::Rng, ImplTrait0) -> i16
Where:
ImplTrait0: std::ops::range::RangeBounds::<i16>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::i32(&mut fastrand::Rng, ImplTrait0) -> i32
Where:
ImplTrait0: std::ops::range::RangeBounds::<i32>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::i64(&mut fastrand::Rng, ImplTrait0) -> i64
Where:
ImplTrait0: std::ops::range::RangeBounds::<i64>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::i128(&mut fastrand::Rng, ImplTrait0) -> i128
Where:
ImplTrait0: std::ops::range::RangeBounds::<i128>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::isize(&mut fastrand::Rng, ImplTrait0) -> isize
Where:
ImplTrait0: std::ops::range::RangeBounds::<isize>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::choice(&mut fastrand::Rng, I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
Where:
I: , 
Type Pred:
I: std::iter::traits::collect::IntoIterator
<I as std::iter::traits::collect::IntoIterator>::IntoIter: std::iter::traits::exact_size::ExactSizeIterator

[ApiGraph] Resolve this function
fn fastrand::Rng::shuffle(&mut fastrand::Rng, &mut [T]) -> ()
Where:
T: , 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::u8(&mut fastrand::Rng, ImplTrait0) -> u8
Where:
ImplTrait0: std::ops::range::RangeBounds::<u8>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::u16(&mut fastrand::Rng, ImplTrait0) -> u16
Where:
ImplTrait0: std::ops::range::RangeBounds::<u16>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::u32(&mut fastrand::Rng, ImplTrait0) -> u32
Where:
ImplTrait0: std::ops::range::RangeBounds::<u32>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::u64(&mut fastrand::Rng, ImplTrait0) -> u64
Where:
ImplTrait0: std::ops::range::RangeBounds::<u64>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::u128(&mut fastrand::Rng, ImplTrait0) -> u128
Where:
ImplTrait0: std::ops::range::RangeBounds::<u128>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::usize(&mut fastrand::Rng, ImplTrait0) -> usize
Where:
ImplTrait0: std::ops::range::RangeBounds::<usize>, 
Type Pred:

[ApiGraph] Resolve this function
fn fastrand::Rng::char(&mut fastrand::Rng, ImplTrait0) -> char
Where:
ImplTrait0: std::ops::range::RangeBounds::<char>, 
Type Pred:

=====Iteration #0=====
num of func: 25
num of reachable: 25
num of reachable type: 25
[Reachable]fn fastrand::f64() -> f64 is reachable
[TypeContext] add candidate #16: f64 => Primitive(F64)
[TypeContext] add candidate #17: &mut f64 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(F64) }
[TypeContext] add candidate #18: &f64 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(F64) }
[TypeContext] add candidate #19: *f64 => RawPointer(Mut, Primitive(F64))
[TypeContext] add candidate #20: *const f64 => RawPointer(Not, Primitive(F64))
[Reachable]fn fastrand::f32() -> f32 is reachable
[TypeContext] add candidate #21: f32 => Primitive(F32)
[TypeContext] add candidate #22: &mut f32 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(F32) }
[TypeContext] add candidate #23: &f32 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(F32) }
[TypeContext] add candidate #24: *f32 => RawPointer(Mut, Primitive(F32))
[TypeContext] add candidate #25: *const f32 => RawPointer(Not, Primitive(F32))
[Reachable]fn fastrand::digit(u32) -> char is reachable
[TypeContext] add candidate #26: char => Primitive(Char)
[TypeContext] add candidate #27: &mut char => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Char) }
[TypeContext] add candidate #28: &char => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Char) }
[TypeContext] add candidate #29: *char => RawPointer(Mut, Primitive(Char))
[TypeContext] add candidate #30: *const char => RawPointer(Not, Primitive(Char))
[Reachable]fn fastrand::uppercase() -> char is reachable
[Reachable]fn fastrand::lowercase() -> char is reachable
[Reachable]fn fastrand::alphanumeric() -> char is reachable
[Reachable]fn fastrand::alphabetic() -> char is reachable
[Reachable]fn fastrand::bool() -> bool is reachable
[TypeContext] add candidate #31: bool => Primitive(Bool)
[TypeContext] add candidate #32: &mut bool => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Bool) }
[TypeContext] add candidate #33: &bool => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Bool) }
[TypeContext] add candidate #34: *bool => RawPointer(Mut, Primitive(Bool))
[TypeContext] add candidate #35: *const bool => RawPointer(Not, Primitive(Bool))
[Reachable]fn fastrand::get_seed() -> u64 is reachable
[TypeContext] add candidate #36: u64 => Primitive(U64)
[TypeContext] add candidate #37: &mut u64 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(U64) }
[TypeContext] add candidate #38: &u64 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(U64) }
[TypeContext] add candidate #39: *u64 => RawPointer(Mut, Primitive(U64))
[TypeContext] add candidate #40: *const u64 => RawPointer(Not, Primitive(U64))
[Reachable]fn fastrand::seed(u64) -> () is reachable
[TypeContext] add candidate #41: () => Tuple([])
[TypeContext] add candidate #42: &mut () => BorrowedRef { lifetime: None, mutability: Mut, type_: Tuple([]) }
[TypeContext] add candidate #43: &() => BorrowedRef { lifetime: None, mutability: Not, type_: Tuple([]) }
[TypeContext] add candidate #44: *() => RawPointer(Mut, Tuple([]))
[TypeContext] add candidate #45: *const () => RawPointer(Not, Tuple([]))
[Reachable]fn fastrand::Rng::new() -> fastrand::Rng is reachable
[TypeContext] add candidate #46: Rng => Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #47: &mut Rng => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #48: &Rng => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #49: *Rng => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #50: *const Rng => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:155 ~ fastrand[57b2]::Rng)), segments: [PathSegment { name: "Rng", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn fastrand::Rng::with_seed(u64) -> fastrand::Rng is reachable
[Reachable]fn fastrand::Rng::fork(&mut fastrand::Rng) -> fastrand::Rng is reachable
[Reachable]fn fastrand::Rng::alphabetic(&mut fastrand::Rng) -> char is reachable
[Reachable]fn fastrand::Rng::alphanumeric(&mut fastrand::Rng) -> char is reachable
[Reachable]fn fastrand::Rng::bool(&mut fastrand::Rng) -> bool is reachable
[Reachable]fn fastrand::Rng::digit(&mut fastrand::Rng, u32) -> char is reachable
[Reachable]fn fastrand::Rng::f32(&mut fastrand::Rng) -> f32 is reachable
[Reachable]fn fastrand::Rng::f64(&mut fastrand::Rng) -> f64 is reachable
[Reachable]fn fastrand::Rng::lowercase(&mut fastrand::Rng) -> char is reachable
[Reachable]fn fastrand::Rng::seed(&mut fastrand::Rng, u64) -> () is reachable
[Reachable]fn fastrand::Rng::get_seed(&fastrand::Rng) -> u64 is reachable
[Reachable]fn fastrand::Rng::uppercase(&mut fastrand::Rng) -> char is reachable
[Reachable]fn <fastrand::Rng as std::default::Default>::default() -> fastrand::Rng is reachable
[Reachable]fn <fastrand::Rng as std::cmp::PartialEq>::eq(&fastrand::Rng, &fastrand::Rng) -> bool is reachable
===== Candidates =====
Type Candidate #0: (4)*const u64
Type Candidate #1: (4)&mut ()
Type Candidate #2: (11)&mut &str
Type Candidate #3: (8)*const fastrand::Rng
Type Candidate #4: (4)u64
Type Candidate #5: (2)*const &[u8]
Type Candidate #6: (20)char
Type Candidate #7: (11)*&str
Type Candidate #8: (1)&mut &[char]
Type Candidate #9: (1)&&[char]
Type Candidate #10: (20)&mut char
Type Candidate #11: (4)*f32
Type Candidate #12: (6)&bool
Type Candidate #13: (4)&()
Type Candidate #14: (11)*const &str
Type Candidate #15: (4)&f32
Type Candidate #16: (6)*bool
Type Candidate #17: (4)&u64
Type Candidate #18: (4)&mut f32
Type Candidate #19: (8)*fastrand::Rng
Type Candidate #20: (8)fastrand::Rng
Type Candidate #21: (2)&mut &[u8]
Type Candidate #22: (2)&&[u8]
Type Candidate #23: (6)bool
Type Candidate #24: (4)()
Type Candidate #25: (1)*const &[char]
Type Candidate #26: (6)&mut bool
Type Candidate #27: (20)&char
Type Candidate #28: (11)&&str
Type Candidate #29: (2)*&[u8]
Type Candidate #30: (6)*const bool
Type Candidate #31: (4)*const f64
Type Candidate #32: (4)*const f32
Type Candidate #33: (20)*char
Type Candidate #34: (3)&[u8]
Type Candidate #35: (4)&mut f64
Type Candidate #36: (4)*u64
Type Candidate #37: (1)u8
Type Candidate #38: (4)*const ()
Type Candidate #39: (4)f32
Type Candidate #40: (4)f64
Type Candidate #41: (8)&fastrand::Rng
Type Candidate #42: (8)&mut fastrand::Rng
Type Candidate #43: (4)*()
Type Candidate #44: (4)*f64
Type Candidate #45: (11)&str
Type Candidate #46: (1)&[char]
Type Candidate #47: (20)*const char
Type Candidate #48: (4)&f64
Type Candidate #49: (4)&mut u64
Type Candidate #50: (1)*&[char]
===== !Candidates =====
[Solver] find solution for fn fastrand::choose_multiple(I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 0 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Recursively check: do we have impl std::iter::traits::collect::IntoIterator for &'a [T]?
[TraitImpl] solution: (char), generic_defs: ["T"]
[GenericParam] Check pred succ : (T=char)
[GenericParam] visited={}
[GenericParam] Check pred succ : (I=&[char])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::choose_multiple#mono(&[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Recursively check: do we have impl std::iter::traits::collect::IntoIterator for &'a [T]?
[TraitImpl] solution: (u8), generic_defs: ["T"]
[GenericParam] Check pred succ : (T=u8)
[GenericParam] visited={}
[GenericParam] Check pred succ : (I=&[u8])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::choose_multiple#mono(&[u8], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::char(ImplTrait0) -> char, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::isize(ImplTrait0) -> isize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::usize(ImplTrait0) -> usize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i128(ImplTrait0) -> i128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u128(ImplTrait0) -> u128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i64(ImplTrait0) -> i64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u64(ImplTrait0) -> u64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i32(ImplTrait0) -> i32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u32(ImplTrait0) -> u32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i16(ImplTrait0) -> i16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u16(ImplTrait0) -> u16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i8(ImplTrait0) -> i8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u8(ImplTrait0) -> u8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::shuffle(&mut [T]) -> (), already have 0 solutions
[Solver] generic params: ["T"]
[Solver] Start solve()
[Solver] search for input argument &mut [T]:
set A: `(*)`
set B: ``
Merge: ``
[Solver] Solution Set = ``
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::choice(I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 0 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &str fail
[Solver] Check Solution: (&[char])
[GenericParam] Check pred succ : (I=&[char])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::choice#mono(&[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut u64 fail
[Solver] Check Solution: (&[u8])
[GenericParam] Check pred succ : (I=&[u8])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::choice#mono(&[u8]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::choose_multiple(&mut fastrand::Rng, I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 0 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &str fail
[Solver] Check Solution: (&[char])
[GenericParam] Check pred succ : (I=&[char])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::Rng::choose_multiple#mono(&mut fastrand::Rng, &[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut u64 fail
[Solver] Check Solution: (&[u8])
[GenericParam] Check pred succ : (I=&[u8])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::Rng::choose_multiple#mono(&mut fastrand::Rng, &[u8], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i8(&mut fastrand::Rng, ImplTrait0) -> i8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i8> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i16(&mut fastrand::Rng, ImplTrait0) -> i16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i16> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i32(&mut fastrand::Rng, ImplTrait0) -> i32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i32> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i64(&mut fastrand::Rng, ImplTrait0) -> i64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i64> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i128(&mut fastrand::Rng, ImplTrait0) -> i128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<i128> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::isize(&mut fastrand::Rng, ImplTrait0) -> isize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<isize> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::choice(&mut fastrand::Rng, I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 0 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut &str fail
[Solver] Check Solution: (&[char])
[GenericParam] Check pred succ : (I=&[char])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::Rng::choice#mono(&mut fastrand::Rng, &[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(Char)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut u64 fail
[Solver] Check Solution: (&[u8])
[GenericParam] Check pred succ : (I=&[u8])
[GenericParam] visited={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] find mono function: fn fastrand::Rng::choice#mono(&mut fastrand::Rng, &[u8]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] mono solution: [BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }]
[Solver] impls={Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::iter::traits::collect::IntoIterator for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::shuffle(&mut fastrand::Rng, &mut [T]) -> (), already have 0 solutions
[Solver] generic params: ["T"]
[Solver] Start solve()
[Solver] search for input argument &mut [T]:
set A: `(*)`
set B: ``
Merge: ``
[Solver] Solution Set = ``
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u8(&mut fastrand::Rng, ImplTrait0) -> u8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u8> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u16(&mut fastrand::Rng, ImplTrait0) -> u16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u16> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u32(&mut fastrand::Rng, ImplTrait0) -> u32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u32> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u64(&mut fastrand::Rng, ImplTrait0) -> u64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u64> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u128(&mut fastrand::Rng, ImplTrait0) -> u128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<u128> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::usize(&mut fastrand::Rng, ImplTrait0) -> usize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<usize> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::char(&mut fastrand::Rng, ImplTrait0) -> char, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &u64 fail
[Solver] Check Solution: (u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for u64 fail
[Solver] Check Solution: (&mut &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut &[u8] fail
[Solver] Check Solution: (f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for f32 fail
[Solver] Check Solution: (())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for () fail
[Solver] Check Solution: (&&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &&[u8] fail
[Solver] Check Solution: (&Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &fastrand::Rng fail
[Solver] Check Solution: (*())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *() fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const u64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *&str fail
[Solver] Check Solution: (&())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &() fail
[Solver] Check Solution: (Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for fastrand::Rng fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const f32 fail
[Solver] Check Solution: (&mut char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut char fail
[Solver] Check Solution: (*char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *char fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const &str fail
[Solver] Check Solution: (*Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *fastrand::Rng fail
[Solver] Check Solution: (*const bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const bool fail
[Solver] Check Solution: (*const ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const () fail
[Solver] Check Solution: (&&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &&[char] fail
[Solver] Check Solution: (bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for bool fail
[Solver] Check Solution: (&char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &char fail
[Solver] Check Solution: (&mut &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut &[char] fail
[Solver] Check Solution: (&mut bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut bool fail
[Solver] Check Solution: (&mut ())
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut () fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &&str fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut f32 fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut f64 fail
[Solver] Check Solution: (*const Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const fastrand::Rng fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *f32 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *u64 fail
[Solver] Check Solution: (*const char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const char fail
[Solver] Check Solution: (f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for f64 fail
[Solver] Check Solution: (*const &[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const &[u8] fail
[Solver] Check Solution: (*&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *&[u8] fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for u8 fail
[Solver] Check Solution: (char)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for char fail
[Solver] Check Solution: (*&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *&[char] fail
[Solver] Check Solution: (*const &[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const &[char] fail
[Solver] Check Solution: (*bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *bool fail
[Solver] Check Solution: (&bool)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &bool fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for *const f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut &str fail
[Solver] Check Solution: (&[char])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &[char] fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut u64 fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &[u8] fail
[Solver] Check Solution: (&mut Rng)
[TraitImpl] Check trait std::ops::range::RangeBounds::<char> for &mut fastrand::Rng fail
[Solver] Running solve() took 0 ms.
=====Iteration #1=====
num of func: 25
num of reachable: 25
num of reachable type: 25
===== Candidates =====
Type Candidate #0: (4)*const u64
Type Candidate #1: (4)&mut ()
Type Candidate #2: (11)&mut &str
Type Candidate #3: (8)*const fastrand::Rng
Type Candidate #4: (4)u64
Type Candidate #5: (2)*const &[u8]
Type Candidate #6: (20)char
Type Candidate #7: (11)*&str
Type Candidate #8: (1)&mut &[char]
Type Candidate #9: (1)&&[char]
Type Candidate #10: (20)&mut char
Type Candidate #11: (4)*f32
Type Candidate #12: (6)&bool
Type Candidate #13: (4)&()
Type Candidate #14: (11)*const &str
Type Candidate #15: (4)&f32
Type Candidate #16: (6)*bool
Type Candidate #17: (4)&u64
Type Candidate #18: (4)&mut f32
Type Candidate #19: (8)*fastrand::Rng
Type Candidate #20: (8)fastrand::Rng
Type Candidate #21: (2)&mut &[u8]
Type Candidate #22: (2)&&[u8]
Type Candidate #23: (6)bool
Type Candidate #24: (4)()
Type Candidate #25: (1)*const &[char]
Type Candidate #26: (6)&mut bool
Type Candidate #27: (20)&char
Type Candidate #28: (11)&&str
Type Candidate #29: (2)*&[u8]
Type Candidate #30: (6)*const bool
Type Candidate #31: (4)*const f64
Type Candidate #32: (4)*const f32
Type Candidate #33: (20)*char
Type Candidate #34: (3)&[u8]
Type Candidate #35: (4)&mut f64
Type Candidate #36: (4)*u64
Type Candidate #37: (1)u8
Type Candidate #38: (4)*const ()
Type Candidate #39: (4)f32
Type Candidate #40: (4)f64
Type Candidate #41: (8)&fastrand::Rng
Type Candidate #42: (8)&mut fastrand::Rng
Type Candidate #43: (4)*()
Type Candidate #44: (4)*f64
Type Candidate #45: (11)&str
Type Candidate #46: (1)&[char]
Type Candidate #47: (20)*const char
Type Candidate #48: (4)&f64
Type Candidate #49: (4)&mut u64
Type Candidate #50: (1)*&[char]
===== !Candidates =====
[Solver] find solution for fn fastrand::choose_multiple(I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 2 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::char(ImplTrait0) -> char, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::isize(ImplTrait0) -> isize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::usize(ImplTrait0) -> usize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i128(ImplTrait0) -> i128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u128(ImplTrait0) -> u128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i64(ImplTrait0) -> i64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u64(ImplTrait0) -> u64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i32(ImplTrait0) -> i32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u32(ImplTrait0) -> u32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i16(ImplTrait0) -> i16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u16(ImplTrait0) -> u16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::i8(ImplTrait0) -> i8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::u8(ImplTrait0) -> u8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::shuffle(&mut [T]) -> (), already have 0 solutions
[Solver] generic params: ["T"]
[Solver] Start solve()
[Solver] search for input argument &mut [T]:
set A: `(*)`
set B: ``
Merge: ``
[Solver] Solution Set = ``
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::choice(I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 2 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::choose_multiple(&mut fastrand::Rng, I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 2 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i8(&mut fastrand::Rng, ImplTrait0) -> i8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i16(&mut fastrand::Rng, ImplTrait0) -> i16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i32(&mut fastrand::Rng, ImplTrait0) -> i32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i64(&mut fastrand::Rng, ImplTrait0) -> i64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::i128(&mut fastrand::Rng, ImplTrait0) -> i128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::isize(&mut fastrand::Rng, ImplTrait0) -> isize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::choice(&mut fastrand::Rng, I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>, already have 2 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::shuffle(&mut fastrand::Rng, &mut [T]) -> (), already have 0 solutions
[Solver] generic params: ["T"]
[Solver] Start solve()
[Solver] search for input argument &mut [T]:
set A: `(*)`
set B: ``
Merge: ``
[Solver] Solution Set = ``
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u8(&mut fastrand::Rng, ImplTrait0) -> u8, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u16(&mut fastrand::Rng, ImplTrait0) -> u16, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u32(&mut fastrand::Rng, ImplTrait0) -> u32, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u64(&mut fastrand::Rng, ImplTrait0) -> u64, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::u128(&mut fastrand::Rng, ImplTrait0) -> u128, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::usize(&mut fastrand::Rng, ImplTrait0) -> usize, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn fastrand::Rng::char(&mut fastrand::Rng, ImplTrait0) -> char, already have 0 solutions
[Solver] generic params: ["ImplTrait0"]
[Solver] Start solve()
[Solver] search for input argument ImplTrait0:
set A: `(*)`
set B: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
Merge: `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Solution Set = `(&u64), (u64), (&mut &[u8]), (f32), (()), (&&[u8]), (&Rng), (*()), (*const u64), (*&str), (&()), (Rng), (*const f32), (&mut char), (*char), (&f32), (&f64), (*f64), (*const &str), (*Rng), (*const bool), (*const ()), (&&[char]), (bool), (&char), (&mut &[char]), (&mut bool), (&mut ()), (&&str), (&mut f32), (&mut f64), (*const Rng), (*f32), (*u64), (*const char), (f64), (*const &[u8]), (*&[u8]), (u8), (char), (*&[char]), (*const &[char]), (*bool), (&bool), (*const f64), (&str), (&mut &str), (&[char]), (&mut u64), (&[u8]), (&mut Rng)`
[Solver] Running solve() took 0 ms.
===== all reachable func =====
fn fastrand::f64() -> f64
fn fastrand::f32() -> f32
fn fastrand::digit(u32) -> char
fn fastrand::uppercase() -> char
fn fastrand::lowercase() -> char
fn fastrand::alphanumeric() -> char
fn fastrand::alphabetic() -> char
fn fastrand::bool() -> bool
fn fastrand::get_seed() -> u64
fn fastrand::seed(u64) -> ()
fn fastrand::Rng::new() -> fastrand::Rng
fn fastrand::Rng::with_seed(u64) -> fastrand::Rng
fn fastrand::Rng::fork(&mut fastrand::Rng) -> fastrand::Rng
fn fastrand::Rng::alphabetic(&mut fastrand::Rng) -> char
fn fastrand::Rng::alphanumeric(&mut fastrand::Rng) -> char
fn fastrand::Rng::bool(&mut fastrand::Rng) -> bool
fn fastrand::Rng::digit(&mut fastrand::Rng, u32) -> char
fn fastrand::Rng::f32(&mut fastrand::Rng) -> f32
fn fastrand::Rng::f64(&mut fastrand::Rng) -> f64
fn fastrand::Rng::lowercase(&mut fastrand::Rng) -> char
fn fastrand::Rng::seed(&mut fastrand::Rng, u64) -> ()
fn fastrand::Rng::get_seed(&fastrand::Rng) -> u64
fn fastrand::Rng::uppercase(&mut fastrand::Rng) -> char
fn <fastrand::Rng as std::default::Default>::default() -> fastrand::Rng
fn <fastrand::Rng as std::cmp::PartialEq>::eq(&fastrand::Rng, &fastrand::Rng) -> bool
===== !all reachable func =====
[Solver] init diverse solution for fn fastrand::choose_multiple(I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] reserve mono: fn fastrand::choose_multiple#mono(&[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>, {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}, all={}
[Solver] init diverse solution for fn fastrand::char(ImplTrait0) -> char
[Solver] init diverse solution for fn fastrand::isize(ImplTrait0) -> isize
[Solver] init diverse solution for fn fastrand::usize(ImplTrait0) -> usize
[Solver] init diverse solution for fn fastrand::i128(ImplTrait0) -> i128
[Solver] init diverse solution for fn fastrand::u128(ImplTrait0) -> u128
[Solver] init diverse solution for fn fastrand::i64(ImplTrait0) -> i64
[Solver] init diverse solution for fn fastrand::u64(ImplTrait0) -> u64
[Solver] init diverse solution for fn fastrand::i32(ImplTrait0) -> i32
[Solver] init diverse solution for fn fastrand::u32(ImplTrait0) -> u32
[Solver] init diverse solution for fn fastrand::i16(ImplTrait0) -> i16
[Solver] init diverse solution for fn fastrand::u16(ImplTrait0) -> u16
[Solver] init diverse solution for fn fastrand::i8(ImplTrait0) -> i8
[Solver] init diverse solution for fn fastrand::u8(ImplTrait0) -> u8
[Solver] init diverse solution for fn fastrand::shuffle(&mut [T]) -> ()
[Solver] init diverse solution for fn fastrand::choice(I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] reserve mono: fn fastrand::choice#mono(&[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>, {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}, all={}
[Solver] init diverse solution for fn fastrand::Rng::choose_multiple(&mut fastrand::Rng, I, usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] reserve mono: fn fastrand::Rng::choose_multiple#mono(&mut fastrand::Rng, &[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item>, {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}, all={}
[Solver] init diverse solution for fn fastrand::Rng::i8(&mut fastrand::Rng, ImplTrait0) -> i8
[Solver] init diverse solution for fn fastrand::Rng::i16(&mut fastrand::Rng, ImplTrait0) -> i16
[Solver] init diverse solution for fn fastrand::Rng::i32(&mut fastrand::Rng, ImplTrait0) -> i32
[Solver] init diverse solution for fn fastrand::Rng::i64(&mut fastrand::Rng, ImplTrait0) -> i64
[Solver] init diverse solution for fn fastrand::Rng::i128(&mut fastrand::Rng, ImplTrait0) -> i128
[Solver] init diverse solution for fn fastrand::Rng::isize(&mut fastrand::Rng, ImplTrait0) -> isize
[Solver] init diverse solution for fn fastrand::Rng::choice(&mut fastrand::Rng, I) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>
[Solver] reserve mono: fn fastrand::Rng::choice#mono(&mut fastrand::Rng, &[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item>, {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}, all={}
[Solver] init diverse solution for fn fastrand::Rng::shuffle(&mut fastrand::Rng, &mut [T]) -> ()
[Solver] init diverse solution for fn fastrand::Rng::u8(&mut fastrand::Rng, ImplTrait0) -> u8
[Solver] init diverse solution for fn fastrand::Rng::u16(&mut fastrand::Rng, ImplTrait0) -> u16
[Solver] init diverse solution for fn fastrand::Rng::u32(&mut fastrand::Rng, ImplTrait0) -> u32
[Solver] init diverse solution for fn fastrand::Rng::u64(&mut fastrand::Rng, ImplTrait0) -> u64
[Solver] init diverse solution for fn fastrand::Rng::u128(&mut fastrand::Rng, ImplTrait0) -> u128
[Solver] init diverse solution for fn fastrand::Rng::usize(&mut fastrand::Rng, ImplTrait0) -> usize
[Solver] init diverse solution for fn fastrand::Rng::char(&mut fastrand::Rng, ImplTrait0) -> char
===== diverse types =====
usize: false
&[char]: false
&mut Rng: false
===== !diverse types =====
[Diverse]fn fastrand::f64() -> f64 is diverse
[Diverse]fn fastrand::Rng::new() -> fastrand::Rng is diverse
propagate start
===== diverse types =====
usize: true
&[char]: false
&mut Rng: true
===== !diverse types =====
unsolve generic function:
fn fastrand::char(ImplTrait0) -> char
Where:
ImplTrait0: std::ops::range::RangeBounds::<char>, 
Type Pred:

fn fastrand::isize(ImplTrait0) -> isize
Where:
ImplTrait0: std::ops::range::RangeBounds::<isize>, 
Type Pred:

fn fastrand::usize(ImplTrait0) -> usize
Where:
ImplTrait0: std::ops::range::RangeBounds::<usize>, 
Type Pred:

fn fastrand::i128(ImplTrait0) -> i128
Where:
ImplTrait0: std::ops::range::RangeBounds::<i128>, 
Type Pred:

fn fastrand::u128(ImplTrait0) -> u128
Where:
ImplTrait0: std::ops::range::RangeBounds::<u128>, 
Type Pred:

fn fastrand::i64(ImplTrait0) -> i64
Where:
ImplTrait0: std::ops::range::RangeBounds::<i64>, 
Type Pred:

fn fastrand::u64(ImplTrait0) -> u64
Where:
ImplTrait0: std::ops::range::RangeBounds::<u64>, 
Type Pred:

fn fastrand::i32(ImplTrait0) -> i32
Where:
ImplTrait0: std::ops::range::RangeBounds::<i32>, 
Type Pred:

fn fastrand::u32(ImplTrait0) -> u32
Where:
ImplTrait0: std::ops::range::RangeBounds::<u32>, 
Type Pred:

fn fastrand::i16(ImplTrait0) -> i16
Where:
ImplTrait0: std::ops::range::RangeBounds::<i16>, 
Type Pred:

fn fastrand::u16(ImplTrait0) -> u16
Where:
ImplTrait0: std::ops::range::RangeBounds::<u16>, 
Type Pred:

fn fastrand::i8(ImplTrait0) -> i8
Where:
ImplTrait0: std::ops::range::RangeBounds::<i8>, 
Type Pred:

fn fastrand::u8(ImplTrait0) -> u8
Where:
ImplTrait0: std::ops::range::RangeBounds::<u8>, 
Type Pred:

fn fastrand::shuffle(&mut [T]) -> ()
Where:
T: , 
Type Pred:

fn fastrand::Rng::i8(&mut fastrand::Rng, ImplTrait0) -> i8
Where:
ImplTrait0: std::ops::range::RangeBounds::<i8>, 
Type Pred:

fn fastrand::Rng::i16(&mut fastrand::Rng, ImplTrait0) -> i16
Where:
ImplTrait0: std::ops::range::RangeBounds::<i16>, 
Type Pred:

fn fastrand::Rng::i32(&mut fastrand::Rng, ImplTrait0) -> i32
Where:
ImplTrait0: std::ops::range::RangeBounds::<i32>, 
Type Pred:

fn fastrand::Rng::i64(&mut fastrand::Rng, ImplTrait0) -> i64
Where:
ImplTrait0: std::ops::range::RangeBounds::<i64>, 
Type Pred:

fn fastrand::Rng::i128(&mut fastrand::Rng, ImplTrait0) -> i128
Where:
ImplTrait0: std::ops::range::RangeBounds::<i128>, 
Type Pred:

fn fastrand::Rng::isize(&mut fastrand::Rng, ImplTrait0) -> isize
Where:
ImplTrait0: std::ops::range::RangeBounds::<isize>, 
Type Pred:

fn fastrand::Rng::shuffle(&mut fastrand::Rng, &mut [T]) -> ()
Where:
T: , 
Type Pred:

fn fastrand::Rng::u8(&mut fastrand::Rng, ImplTrait0) -> u8
Where:
ImplTrait0: std::ops::range::RangeBounds::<u8>, 
Type Pred:

fn fastrand::Rng::u16(&mut fastrand::Rng, ImplTrait0) -> u16
Where:
ImplTrait0: std::ops::range::RangeBounds::<u16>, 
Type Pred:

fn fastrand::Rng::u32(&mut fastrand::Rng, ImplTrait0) -> u32
Where:
ImplTrait0: std::ops::range::RangeBounds::<u32>, 
Type Pred:

fn fastrand::Rng::u64(&mut fastrand::Rng, ImplTrait0) -> u64
Where:
ImplTrait0: std::ops::range::RangeBounds::<u64>, 
Type Pred:

fn fastrand::Rng::u128(&mut fastrand::Rng, ImplTrait0) -> u128
Where:
ImplTrait0: std::ops::range::RangeBounds::<u128>, 
Type Pred:

fn fastrand::Rng::usize(&mut fastrand::Rng, ImplTrait0) -> usize
Where:
ImplTrait0: std::ops::range::RangeBounds::<usize>, 
Type Pred:

fn fastrand::Rng::char(&mut fastrand::Rng, ImplTrait0) -> char
Where:
ImplTrait0: std::ops::range::RangeBounds::<char>, 
Type Pred:

all mono function:
[ ] monofun#1:fn fastrand::choose_multiple#mono(&[u8], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[R] monofun#2:fn fastrand::choose_multiple#mono(&[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
fn fastrand::choose_multiple#mono(&[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item> contain unsupported fuzzable type
[ ] monofun#3:fn fastrand::choice#mono(&[u8]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[R] monofun#4:fn fastrand::choice#mono(&[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
fn fastrand::choice#mono(&[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item> contain unsupported fuzzable type
[ ] monofun#5:fn fastrand::Rng::choose_multiple#mono(&mut fastrand::Rng, &[u8], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[R] monofun#6:fn fastrand::Rng::choose_multiple#mono(&mut fastrand::Rng, &[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
fn fastrand::Rng::choose_multiple#mono(&mut fastrand::Rng, &[char], usize) -> std::vec::Vec::<<I as std::iter::traits::collect::IntoIterator>::Item> contain unsupported fuzzable type
[ ] monofun#7:fn fastrand::Rng::choice#mono(&mut fastrand::Rng, &[u8]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
[R] monofun#8:fn fastrand::Rng::choice#mono(&mut fastrand::Rng, &[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item> : {Id(DefId(1:11728 ~ core[b693]::slice::iter::{impl#1}))}
fn fastrand::Rng::choice#mono(&mut fastrand::Rng, &[char]) -> std::option::Option::<<I as std::iter::traits::collect::IntoIterator>::Item> contain unsupported fuzzable type
====== statistic ======
GENERIC_API: 32
RPG_COVERED_API: 27
COVERED API: 29
RPG_COVERED_GENERIC: 4
RESERVE: 4
RPG_GENERIC: 32
PRUNE_ITERS: 1
ITERS: 2
UNSAFE: 0
RPG_API: 55
CANDIDATES: 51
MONO_FUNS: 8
API: 57
UNSOLVABLE: 0
TRAIT_IMPLS: 858
COVERED GENERIC: 4
BLANKET_IMPLS: 0
======  advance  ======
MONO_PER_FUNCS: 2
GENERIC COVERAGE: 0.125
API COVERAGE: 0.50877196
=======================
using bfs end point
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 
after backward search
targets = 427
total length = 1241
average time to visit = 49.64
edge covered by reverse search = 50
total functions in crate : 25
total generic functions in crate : 32
0:fn fastrand::f64() -> f64
1:fn fastrand::f32() -> f32
2:fn fastrand::digit(u32) -> char
3:fn fastrand::uppercase() -> char
4:fn fastrand::lowercase() -> char
5:fn fastrand::alphanumeric() -> char
6:fn fastrand::alphabetic() -> char
7:fn fastrand::bool() -> bool
8:fn fastrand::get_seed() -> u64
9:fn fastrand::seed(u64) -> ()
10:fn fastrand::Rng::new() -> fastrand::Rng
11:fn fastrand::Rng::with_seed(u64) -> fastrand::Rng
12:fn fastrand::Rng::fork(&mut fastrand::Rng) -> fastrand::Rng
13:fn fastrand::Rng::alphabetic(&mut fastrand::Rng) -> char
14:fn fastrand::Rng::alphanumeric(&mut fastrand::Rng) -> char
15:fn fastrand::Rng::bool(&mut fastrand::Rng) -> bool
16:fn fastrand::Rng::digit(&mut fastrand::Rng, u32) -> char
17:fn fastrand::Rng::f32(&mut fastrand::Rng) -> f32
18:fn fastrand::Rng::f64(&mut fastrand::Rng) -> f64
19:fn fastrand::Rng::lowercase(&mut fastrand::Rng) -> char
20:fn fastrand::Rng::seed(&mut fastrand::Rng, u64) -> ()
21:fn fastrand::Rng::get_seed(&fastrand::Rng) -> u64
22:fn fastrand::Rng::uppercase(&mut fastrand::Rng) -> char
23:fn <fastrand::Rng as std::default::Default>::default() -> fastrand::Rng
24:fn <fastrand::Rng as std::cmp::PartialEq>::eq(&fastrand::Rng, &fastrand::Rng) -> bool
======
total test sequences : 734
There are total 17 nodes need to be covered.
There are total 56 edges need to be covered.
There are toatl 734 sequences.
There are toatl 38 valid sequences for fuzz.
sequences with dynamic length can not cover more nodes
-----------STATISTICS-----------
total nodes: 25
total edges: 56
covered nodes: 17

covered monos: 0
covered edges: 15
node coverage: 0.68
edge coverage: 0.26785714285714285
targets covered by reverse search: 0
total targets: 13
max length = 0
total length = 28
average time to fuzz each api = 1.6470588235294117
--------------------------------
test_file_path: "/home/rumono/fastrand/fuzz_target/test_files"
reproduce_file_path: "/home/rumono/fastrand/fuzz_target/replay_files"
Fuzz Target Generator exits successfully.
Total time cost: 254 ms
