Fuzz Target Generator for Rust Libraries: v0.1.0
Fuzz Target Renderer Init
crate: ryu
[TypeContext] add candidate #0: u8 => Primitive(U8)
[TypeContext] add candidate #1: &[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
analyse struct: Item { name: Some("Buffer"), item_id: DefId(DefId(0:13 ~ ryu[5249]::buffer::Buffer)), kind: Struct, docs: "Safe API for formatting floating point numbers to text.\n\n## Example\n\n```\nlet mut buffer = ryu::Buffer::new();\nlet printed = buffer.format_finite(1.234);\nassert_eq!(printed, \"1.234\");\n```" }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("bytes"), item_id: DefId(DefId(0:14 ~ ryu[5249]::buffer::Buffer::bytes)), kind: StructField, docs: "" }] })
Add function: fn ryu::raw::format64(f64, *u8) -> usize
visibility: Some(Public)
Add function: fn ryu::raw::format32(f32, *u8) -> usize
visibility: Some(Public)
Add function: fn ryu::pretty::format32(f32, *u8) -> usize
visibility: Some(Public)
Add function: fn ryu::pretty::format64(f64, *u8) -> usize
visibility: Some(Public)
analyse struct: Item { name: Some("Buffer"), item_id: DefId(DefId(0:13 ~ ryu[5249]::buffer::Buffer)), kind: Struct, docs: "Safe API for formatting floating point numbers to text.\n\n## Example\n\n```\nlet mut buffer = ryu::Buffer::new();\nlet printed = buffer.format_finite(1.234);\nassert_eq!(printed, \"1.234\");\n```" }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("bytes"), item_id: DefId(DefId(0:14 ~ ryu[5249]::buffer::Buffer::bytes)), kind: StructField, docs: "" }] })
==== run after krate ====
bounds to facts ignore lifetime: Lifetime("'static")
ignore RegionPredicate: RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: None
impl_def_id: DefId(0:16 ~ ryu[5249]::buffer::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "ryu::Buffer"
ryu::Buffer is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(1:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(1:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(1:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(1:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(1:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(1:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(1:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2821 ~ core[b693]::clone::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2820 ~ core[b693]::clone::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(1:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(1:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(0:26 ~ ryu[5249]::buffer::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "ryu::Buffer"
ryu::Buffer is not fuzzable
assoc types:
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(0:23 ~ ryu[5249]::buffer::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "ryu::Buffer"
ryu::Buffer is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("ryu::Buffer")
type_def_id: Some(DefId(0:13 ~ ryu[5249]::buffer::Buffer))
trait_def_id: Some(DefId(1:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:24 ~ ryu[5249]::buffer::{impl#2})
is_local_impl: true
is_external_type: false
type_name: "ryu::Buffer"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3098 ~ core[b693]::convert::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:3097 ~ core[b693]::convert::{impl#5})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: ryu::Float
impl for: Primitive(F64)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("ryu::Float")
type_full_name: Some("core::f64")
type_def_id: Some(DefId(1:53386 ~ core[b693]::prim_f64))
trait_def_id: Some(DefId(0:28 ~ ryu[5249]::buffer::Float))
impl_def_id: DefId(0:30 ~ ryu[5249]::buffer::{impl#5})
is_local_impl: true
is_external_type: true
type_name: "std::f64"
f64 is fuzzable
[TypeContext] add candidate #2: f64 => Primitive(F64)
[TypeContext] add candidate #3: &mut f64 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(F64) }
[TypeContext] add candidate #4: &f64 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(F64) }
[TypeContext] add candidate #5: *f64 => RawPointer(Mut, Primitive(F64))
[TypeContext] add candidate #6: *const f64 => RawPointer(Not, Primitive(F64))
assoc types:
Add ryu::Float Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4904 ~ core[b693]::cell::{impl#45}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4897 ~ core[b693]::cell::RefMut)), segments: [PathSegment { name: "RefMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::RefMut")
type_def_id: Some(DefId(1:4897 ~ core[b693]::cell::RefMut))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4903 ~ core[b693]::cell::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::cell::RefMut"
std::cell::RefMut::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4905 ~ core[b693]::cell::{impl#45}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::RefMut::<'_, T> as std::ops::Deref>::deref(&std::cell::RefMut::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: ryu::Float
impl for: Primitive(F32)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("ryu::Float")
type_full_name: Some("core::f32")
type_def_id: Some(DefId(1:53385 ~ core[b693]::prim_f32))
trait_def_id: Some(DefId(0:28 ~ ryu[5249]::buffer::Float))
impl_def_id: DefId(0:29 ~ ryu[5249]::buffer::{impl#4})
is_local_impl: true
is_external_type: true
type_name: "std::f32"
f32 is fuzzable
[TypeContext] add candidate #7: f32 => Primitive(F32)
[TypeContext] add candidate #8: &mut f32 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(F32) }
[TypeContext] add candidate #9: &f32 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(F32) }
[TypeContext] add candidate #10: *f32 => RawPointer(Mut, Primitive(F32))
[TypeContext] add candidate #11: *const f32 => RawPointer(Not, Primitive(F32))
assoc types:
Add ryu::Float Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:946 ~ core[b693]::num::nonzero::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:945 ~ core[b693]::num::nonzero::{impl#8})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:957 ~ core[b693]::num::nonzero::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:34630 ~ core[b693]::ops::bit::BitOr)), segments: [PathSegment { name: "BitOr", args: AngleBracketed { args: [], constraints: [AssocItemConstraint { assoc: PathSegment { name: "Output", args: AngleBracketed { args: [], constraints: [] } }, kind: Equality { term: Type(Generic("T")) } }] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::bit::BitOr
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::bit::BitOr")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:34630 ~ core[b693]::ops::bit::BitOr))
impl_def_id: DefId(1:956 ~ core[b693]::num::nonzero::{impl#11})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4847 ~ core[b693]::cell::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4841 ~ core[b693]::cell::Ref)), segments: [PathSegment { name: "Ref", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::Ref")
type_def_id: Some(DefId(1:4841 ~ core[b693]::cell::Ref))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4846 ~ core[b693]::cell::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::cell::Ref"
std::cell::Ref::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4848 ~ core[b693]::cell::{impl#37}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::Ref::<'_, T> as std::ops::Deref>::deref(&std::cell::Ref::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:1974 ~ core[b693]::mem::manually_drop::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop)), segments: [PathSegment { name: "ManuallyDrop", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::mem::manually_drop::ManuallyDrop")
type_def_id: Some(DefId(1:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:1973 ~ core[b693]::mem::manually_drop::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::mem::manually_drop::ManuallyDrop"
std::mem::manually_drop::ManuallyDrop::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:1975 ~ core[b693]::mem::manually_drop::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::mem::manually_drop::ManuallyDrop::<T> as std::ops::Deref>::deref(&std::mem::manually_drop::ManuallyDrop::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:41177 ~ core[b693]::ffi::va_list::{impl#8}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:41176 ~ core[b693]::ffi::va_list::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5333 ~ core[b693]::ffi::va_list::{impl#6}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:5332 ~ core[b693]::ffi::va_list::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5336 ~ core[b693]::ffi::va_list::{impl#7}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::drop::Drop
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::drop::Drop")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:3580 ~ core[b693]::ops::drop::Drop))
impl_def_id: DefId(1:5335 ~ core[b693]::ffi::va_list::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5305 ~ core[b693]::ffi::va_list::{impl#0}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(1:5304 ~ core[b693]::ffi::va_list::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::as_va_list(&'a mut std::ffi::va_list::VaListImpl::<'_>) -> std::ffi::va_list::VaList::<'a, 'f>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5325 ~ core[b693]::ffi::va_list::{impl#5}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(1:5324 ~ core[b693]::ffi::va_list::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::arg(&mut std::ffi::va_list::VaListImpl::<'_>) -> T" is filtered.
"fn std::ffi::va_list::VaListImpl::<'_>::with_copy(&std::ffi::va_list::VaListImpl::<'_>, F) -> R" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("Ptr")])
impl generics: Generics { params: [GenericParamDef { name: "Ptr", def_id: DefId(1:9693 ~ core[b693]::pin::{impl#13}::Ptr), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Ptr"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:42704 ~ core[b693]::pin::Pin)), segments: [PathSegment { name: "Pin", args: AngleBracketed { args: [Type(Generic("Ptr"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::pin::Pin")
type_def_id: Some(DefId(1:42704 ~ core[b693]::pin::Pin))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:9692 ~ core[b693]::pin::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::pin::Pin"
std::pin::Pin::<Ptr> is not fuzzable
assoc types:
Target: <Ptr as std::ops::Deref>::Target
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:9694 ~ core[b693]::pin::{impl#13}::Target)), kind: AssocType, docs: "" }
"fn <std::pin::Pin::<Ptr> as std::ops::Deref>::deref(&std::pin::Pin::<Ptr>) -> &<Ptr as std::ops::Deref>::Target" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4629 ~ core[b693]::cell::lazy::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(1:4630 ~ core[b693]::cell::lazy::{impl#2}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4613 ~ core[b693]::cell::lazy::LazyCell)), segments: [PathSegment { name: "LazyCell", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::lazy::LazyCell")
type_def_id: Some(DefId(1:4613 ~ core[b693]::cell::lazy::LazyCell))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4628 ~ core[b693]::cell::lazy::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::cell::lazy::LazyCell"
std::cell::lazy::LazyCell::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4631 ~ core[b693]::cell::lazy::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::lazy::LazyCell::<T, F> as std::ops::Deref>::deref(&std::cell::lazy::LazyCell::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:9524 ~ core[b693]::panic::unwind_safe::{impl#21}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(1:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:9523 ~ core[b693]::panic::unwind_safe::{impl#21})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:9525 ~ core[b693]::panic::unwind_safe::{impl#21}::Target)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::ops::Deref>::deref(&std::panic::unwind_safe::AssertUnwindSafe::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:5309 ~ core[b693]::ffi::va_list::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'f", def_id: DefId(1:5310 ~ core[b693]::ffi::va_list::{impl#1}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:41179 ~ core[b693]::ffi::va_list::VaList)), segments: [PathSegment { name: "VaList", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::ffi::va_list::VaList")
type_def_id: Some(DefId(1:41179 ~ core[b693]::ffi::va_list::VaList))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:5308 ~ core[b693]::ffi::va_list::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaList"
std::ffi::va_list::VaList::<'_, '_> is not fuzzable
assoc types:
Target: std::ffi::va_list::VaListImpl::<'f>
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:5311 ~ core[b693]::ffi::va_list::{impl#1}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::va_list::VaList::<'_, '_> as std::ops::Deref>::deref(&std::ffi::va_list::VaList::<'_, '_>) -> &std::ffi::va_list::VaListImpl::<'f>" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<

visibility: ModVisibity { crate_name: "ryu", inner: {"ryu::raw": Public, "ryu::digit_table": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::d2s_intrinsics": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::pretty::exponent": Restricted(DefId(0:132 ~ ryu[5249]::pretty)), "ryu::d2s_full_table": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::pretty": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::f2s_intrinsics": Restricted(DefId(0:0 ~ ryu[5249])), "ryu": Public, "ryu::d2s": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::pretty::mantissa": Restricted(DefId(0:132 ~ ryu[5249]::pretty)), "ryu::common": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::buffer": Restricted(DefId(0:0 ~ ryu[5249])), "ryu::f2s": Restricted(DefId(0:0 ~ ryu[5249]))} }

type core::pin::Pin implement 1 traits: 
DefId(1:9692 ~ core[b693]::pin::{impl#13}): impl std::ops::Deref for std::pin::Pin::<Ptr>
bounds: GenericParamMap { inner: {"Ptr": []}, generic_defs: ["Ptr"], type_pred: [(Generic("Ptr"), [Path { res: Def(Trait, DefId(1:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type ryu::Buffer implement 18 traits: 
DefId(1:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:32818 ~ core[b693]::marker::Send): impl std::marker::Send for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for ryu::Buffer
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for ryu::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for ryu::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for ryu::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2820 ~ core[b693]::clone::{impl#1}): impl std::clone::CloneToUninit for ryu::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for ryu::Buffer
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for ryu::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for ryu::Buffer
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for ryu::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:26 ~ ryu[5249]::buffer::{impl#3}): impl std::default::Default for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:23 ~ ryu[5249]::buffer::{impl#1}): impl std::marker::Copy for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:24 ~ ryu[5249]::buffer::{impl#2}): impl std::clone::Clone for ryu::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::f64 implement 1 traits: 
DefId(0:30 ~ ryu[5249]::buffer::{impl#5}): impl ryu::Float for f64
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::panic::unwind_safe::AssertUnwindSafe implement 1 traits: 
DefId(1:9523 ~ core[b693]::panic::unwind_safe::{impl#21}): impl std::ops::Deref for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }

type core::ffi::va_list::VaListImpl implement 3 traits: 
DefId(1:41176 ~ core[b693]::ffi::va_list::{impl#8}): impl std::fmt::Debug for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5332 ~ core[b693]::ffi::va_list::{impl#6}): impl std::clone::Clone for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5335 ~ core[b693]::ffi::va_list::{impl#7}): impl std::ops::drop::Drop for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::RefMut implement 1 traits: 
DefId(1:4903 ~ core[b693]::cell::{impl#45}): impl std::ops::Deref for std::cell::RefMut::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::va_list::VaList implement 1 traits: 
DefId(1:5308 ~ core[b693]::ffi::va_list::{impl#1}): impl std::ops::Deref for std::ffi::va_list::VaList::<'a, 'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::lazy::LazyCell implement 1 traits: 
DefId(1:4628 ~ core[b693]::cell::lazy::{impl#2}): impl std::ops::Deref for std::cell::lazy::LazyCell::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type core::mem::manually_drop::ManuallyDrop implement 1 traits: 
DefId(1:1973 ~ core[b693]::mem::manually_drop::{impl#2}): impl std::ops::Deref for std::mem::manually_drop::ManuallyDrop::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::f32 implement 1 traits: 
DefId(0:29 ~ ryu[5249]::buffer::{impl#4}): impl ryu::Float for f32
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::Ref implement 1 traits: 
DefId(1:4846 ~ core[b693]::cell::{impl#37}): impl std::ops::Deref for std::cell::Ref::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
Type Candidate #0: (1)f64
Type Candidate #1: (1)*f32
Type Candidate #2: (1)&f32
Type Candidate #3: (1)&mut f32
Type Candidate #4: (1)*const f64
Type Candidate #5: (1)*const f32
Type Candidate #6: (1)*f64
Type Candidate #7: (1)&[u8]
Type Candidate #8: (1)&mut f64
Type Candidate #9: (1)u8
Type Candidate #10: (1)&f64
Type Candidate #11: (1)f32
unsupport function:
[ApiGraph] Resolve this function
fn ryu::Buffer::format(&mut ryu::Buffer, F) -> &str
Where:
F: ryu::Float, 
Type Pred:

[ApiGraph] Resolve this function
fn ryu::Buffer::format_finite(&mut ryu::Buffer, F) -> &str
Where:
F: ryu::Float, 
Type Pred:

=====Iteration #0=====
num of func: 4
num of reachable: 4
num of reachable type: 4
[Reachable]fn ryu::raw::format64(f64, *u8) -> usize is reachable
[TypeContext] add candidate #12: usize => Primitive(Usize)
[TypeContext] add candidate #13: &mut usize => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Usize) }
[TypeContext] add candidate #14: &usize => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Usize) }
[TypeContext] add candidate #15: *usize => RawPointer(Mut, Primitive(Usize))
[TypeContext] add candidate #16: *const usize => RawPointer(Not, Primitive(Usize))
[Reachable]fn ryu::raw::format32(f32, *u8) -> usize is reachable
[Reachable]fn ryu::Buffer::new() -> ryu::Buffer is reachable
[TypeContext] add candidate #17: Buffer => Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #18: &mut Buffer => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #19: &Buffer => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #20: *Buffer => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #21: *const Buffer => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:13 ~ ryu[5249]::buffer::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn <ryu::Buffer as std::default::Default>::default() -> ryu::Buffer is reachable
===== Candidates =====
Type Candidate #0: (4)&mut ryu::Buffer
Type Candidate #1: (4)*usize
Type Candidate #2: (4)ryu::Buffer
Type Candidate #3: (4)*const ryu::Buffer
Type Candidate #4: (1)*const f64
Type Candidate #5: (1)*const f32
Type Candidate #6: (4)&ryu::Buffer
Type Candidate #7: (1)&[u8]
Type Candidate #8: (1)&mut f64
Type Candidate #9: (1)u8
Type Candidate #10: (1)*f32
Type Candidate #11: (1)f32
Type Candidate #12: (1)f64
Type Candidate #13: (4)*ryu::Buffer
Type Candidate #14: (1)&f32
Type Candidate #15: (4)&mut usize
Type Candidate #16: (1)&mut f32
Type Candidate #17: (4)&usize
Type Candidate #18: (4)usize
Type Candidate #19: (1)*f64
Type Candidate #20: (1)&f64
Type Candidate #21: (4)*const usize
===== !Candidates =====
[Solver] find solution for fn ryu::Buffer::format(&mut ryu::Buffer, F) -> &str, already have 0 solutions
[Solver] generic params: ["F"]
[Solver] Start solve()
[Solver] search for input argument F:
set A: `(*)`
set B: `(Buffer), (*Buffer), (f32), (&mut usize), (usize), (*const Buffer), (&mut f64), (&mut f32), (*const f32), (&Buffer), (*f32), (f64), (&mut Buffer), (u8), (&f32), (&f64), (*const f64), (*f64), (&usize), (*usize), (&[u8]), (*const usize)`
Merge: `(Buffer), (*Buffer), (f32), (&mut usize), (usize), (*const Buffer), (&mut f64), (&mut f32), (*const f32), (&Buffer), (*f32), (f64), (&mut Buffer), (u8), (&f32), (&f64), (*const f64), (*f64), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Solution Set = `(Buffer), (*Buffer), (f32), (&mut usize), (usize), (*const Buffer), (&mut f64), (&mut f32), (*const f32), (&Buffer), (*f32), (f64), (&mut Buffer), (u8), (&f32), (&f64), (*const f64), (*f64), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Check Solution: (Buffer)
[TraitImpl] Check trait ryu::Float for ryu::Buffer fail
[Solver] Check Solution: (*Buffer)
[TraitImpl] Check trait ryu::Float for *ryu::Buffer fail
[Solver] Check Solution: (f32)
[TraitImpl] Recursively check: do we have impl ryu::Float for f32?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (F=f32)
[GenericParam] visited={Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
[Solver] find mono function: fn ryu::Buffer::format#mono(&mut ryu::Buffer, f32) -> &str
[Solver] mono solution: [Primitive(F32)]
[Solver] impls={Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
[Solver] output depth = 2
[TypeContext] add candidate #22: &str => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
[TypeContext] add candidate #23: &mut &str => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #24: &&str => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #25: *&str => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[TypeContext] add candidate #26: *const &str => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait ryu::Float for &mut usize fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait ryu::Float for usize fail
[Solver] Check Solution: (*const Buffer)
[TraitImpl] Check trait ryu::Float for *const ryu::Buffer fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait ryu::Float for &mut f64 fail
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait ryu::Float for &mut f32 fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait ryu::Float for *const f32 fail
[Solver] Check Solution: (&Buffer)
[TraitImpl] Check trait ryu::Float for &ryu::Buffer fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait ryu::Float for *f32 fail
[Solver] Check Solution: (f64)
[TraitImpl] Recursively check: do we have impl ryu::Float for f64?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (F=f64)
[GenericParam] visited={Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}
[Solver] find mono function: fn ryu::Buffer::format#mono(&mut ryu::Buffer, f64) -> &str
[Solver] mono solution: [Primitive(F64)]
[Solver] impls={Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut Buffer)
[TraitImpl] Check trait ryu::Float for &mut ryu::Buffer fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait ryu::Float for u8 fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait ryu::Float for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait ryu::Float for &f64 fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait ryu::Float for *const f64 fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait ryu::Float for *f64 fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait ryu::Float for &usize fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait ryu::Float for *usize fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait ryu::Float for &[u8] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait ryu::Float for *const usize fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn ryu::Buffer::format_finite(&mut ryu::Buffer, F) -> &str, already have 0 solutions
[Solver] generic params: ["F"]
[Solver] Start solve()
[Solver] search for input argument F:
set A: `(*)`
set B: `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
Merge: `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Solution Set = `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Check Solution: (Buffer)
[TraitImpl] Check trait ryu::Float for ryu::Buffer fail
[Solver] Check Solution: (*Buffer)
[TraitImpl] Check trait ryu::Float for *ryu::Buffer fail
[Solver] Check Solution: (f32)
[GenericParam] Check pred succ : (F=f32)
[GenericParam] visited={Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
[Solver] find mono function: fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f32) -> &str
[Solver] mono solution: [Primitive(F32)]
[Solver] impls={Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
[Solver] output depth = 2
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait ryu::Float for &&str fail
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait ryu::Float for &mut usize fail
[Solver] Check Solution: (usize)
[TraitImpl] Check trait ryu::Float for usize fail
[Solver] Check Solution: (*const Buffer)
[TraitImpl] Check trait ryu::Float for *const ryu::Buffer fail
[Solver] Check Solution: (&mut f64)
[TraitImpl] Check trait ryu::Float for &mut f64 fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait ryu::Float for *&str fail
[Solver] Check Solution: (*f32)
[TraitImpl] Check trait ryu::Float for *f32 fail
[Solver] Check Solution: (*const f32)
[TraitImpl] Check trait ryu::Float for *const f32 fail
[Solver] Check Solution: (&Buffer)
[TraitImpl] Check trait ryu::Float for &ryu::Buffer fail
[Solver] Check Solution: (&mut Buffer)
[TraitImpl] Check trait ryu::Float for &mut ryu::Buffer fail
[Solver] Check Solution: (f64)
[GenericParam] Check pred succ : (F=f64)
[GenericParam] visited={Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}
[Solver] find mono function: fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f64) -> &str
[Solver] mono solution: [Primitive(F64)]
[Solver] impls={Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut f32)
[TraitImpl] Check trait ryu::Float for &mut f32 fail
[Solver] Check Solution: (u8)
[TraitImpl] Check trait ryu::Float for u8 fail
[Solver] Check Solution: (&f32)
[TraitImpl] Check trait ryu::Float for &f32 fail
[Solver] Check Solution: (&f64)
[TraitImpl] Check trait ryu::Float for &f64 fail
[Solver] Check Solution: (*const f64)
[TraitImpl] Check trait ryu::Float for *const f64 fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait ryu::Float for *const &str fail
[Solver] Check Solution: (*f64)
[TraitImpl] Check trait ryu::Float for *f64 fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait ryu::Float for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait ryu::Float for &mut &str fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait ryu::Float for &usize fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait ryu::Float for *usize fail
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait ryu::Float for &[u8] fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait ryu::Float for *const usize fail
[Solver] Running solve() took 0 ms.
=====Iteration #1=====
num of func: 4
num of reachable: 4
num of reachable type: 4
===== Candidates =====
Type Candidate #0: (4)&mut ryu::Buffer
Type Candidate #1: (4)*usize
Type Candidate #2: (4)ryu::Buffer
Type Candidate #3: (4)&mut &str
Type Candidate #4: (4)&&str
Type Candidate #5: (4)*const ryu::Buffer
Type Candidate #6: (1)*const f64
Type Candidate #7: (1)*const f32
Type Candidate #8: (4)&ryu::Buffer
Type Candidate #9: (1)&[u8]
Type Candidate #10: (1)&mut f64
Type Candidate #11: (4)*&str
Type Candidate #12: (1)u8
Type Candidate #13: (1)*f32
Type Candidate #14: (1)f32
Type Candidate #15: (1)f64
Type Candidate #16: (4)*ryu::Buffer
Type Candidate #17: (1)&f32
Type Candidate #18: (4)&mut usize
Type Candidate #19: (4)*const &str
Type Candidate #20: (1)&mut f32
Type Candidate #21: (4)&usize
Type Candidate #22: (4)usize
Type Candidate #23: (1)*f64
Type Candidate #24: (4)&str
Type Candidate #25: (1)&f64
Type Candidate #26: (4)*const usize
===== !Candidates =====
[Solver] find solution for fn ryu::Buffer::format(&mut ryu::Buffer, F) -> &str, already have 2 solutions
[Solver] generic params: ["F"]
[Solver] Start solve()
[Solver] search for input argument F:
set A: `(*)`
set B: `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
Merge: `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Solution Set = `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait ryu::Float for &&str fail
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait ryu::Float for *&str fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait ryu::Float for *const &str fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait ryu::Float for &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait ryu::Float for &mut &str fail
[Solver] Running solve() took 0 ms.
[Solver] find solution for fn ryu::Buffer::format_finite(&mut ryu::Buffer, F) -> &str, already have 2 solutions
[Solver] generic params: ["F"]
[Solver] Start solve()
[Solver] search for input argument F:
set A: `(*)`
set B: `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
Merge: `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Solution Set = `(Buffer), (*Buffer), (f32), (&&str), (&mut usize), (usize), (*const Buffer), (&mut f64), (*&str), (*f32), (*const f32), (&Buffer), (&mut Buffer), (f64), (&mut f32), (u8), (&f32), (&f64), (*const f64), (*const &str), (*f64), (&str), (&mut &str), (&usize), (*usize), (&[u8]), (*const usize)`
[Solver] Running solve() took 0 ms.
===== all reachable func =====
fn ryu::raw::format64(f64, *u8) -> usize
fn ryu::raw::format32(f32, *u8) -> usize
fn ryu::Buffer::new() -> ryu::Buffer
fn <ryu::Buffer as std::default::Default>::default() -> ryu::Buffer
===== !all reachable func =====
[Solver] init diverse solution for fn ryu::Buffer::format(&mut ryu::Buffer, F) -> &str
[Solver] reserve mono: fn ryu::Buffer::format#mono(&mut ryu::Buffer, f32) -> &str, {Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}, all={}
[Solver] reserve mono: fn ryu::Buffer::format#mono(&mut ryu::Buffer, f64) -> &str, {Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}, all={Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
[Solver] init diverse solution for fn ryu::Buffer::format_finite(&mut ryu::Buffer, F) -> &str
[Solver] reserve mono: fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f32) -> &str, {Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}, all={}
[Solver] reserve mono: fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f64) -> &str, {Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}, all={Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
===== diverse types =====
&mut Buffer: false
f64: false
f32: false
===== !diverse types =====
[Diverse]fn ryu::raw::format64(f64, *u8) -> usize is diverse
[Diverse]fn ryu::Buffer::new() -> ryu::Buffer is diverse
[Diverse]fn ryu::raw::format32(f32, *u8) -> usize is diverse
propagate start
===== diverse types =====
&mut Buffer: true
f64: true
*u8: true
f32: true
===== !diverse types =====
unsolve generic function:
all mono function:
[R] monofun#1:fn ryu::Buffer::format#mono(&mut ryu::Buffer, f64) -> &str : {Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}
[R] monofun#2:fn ryu::Buffer::format#mono(&mut ryu::Buffer, f32) -> &str : {Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
[R] monofun#3:fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f64) -> &str : {Id(DefId(0:30 ~ ryu[5249]::buffer::{impl#5}))}
[R] monofun#4:fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f32) -> &str : {Id(DefId(0:29 ~ ryu[5249]::buffer::{impl#4}))}
====== statistic ======
GENERIC_API: 2
RPG_COVERED_API: 5
COVERED API: 6
RPG_COVERED_GENERIC: 2
RESERVE: 4
RPG_GENERIC: 2
PRUNE_ITERS: 1
ITERS: 2
UNSAFE: 4
RPG_API: 5
CANDIDATES: 27
MONO_FUNS: 4
API: 6
UNSOLVABLE: 0
TRAIT_IMPLS: 41
COVERED GENERIC: 2
BLANKET_IMPLS: 0
======  advance  ======
MONO_PER_FUNCS: 2
GENERIC COVERAGE: 1
API COVERAGE: 1
=======================
using bfs end point
0, 1, 2, 3, 4, 5, 6, 7, 
after backward search
targets = 158
total length = 450
average time to visit = 56.25
edge covered by reverse search = 8
total functions in crate : 8
total generic functions in crate : 2
0:fn ryu::raw::format64(f64, *u8) -> usize
1:fn ryu::raw::format32(f32, *u8) -> usize
2:fn ryu::Buffer::new() -> ryu::Buffer
3:fn <ryu::Buffer as std::default::Default>::default() -> ryu::Buffer
4:fn ryu::Buffer::format#mono(&mut ryu::Buffer, f64) -> &str
5:fn ryu::Buffer::format#mono(&mut ryu::Buffer, f32) -> &str
6:fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f64) -> &str
7:fn ryu::Buffer::format_finite#mono(&mut ryu::Buffer, f32) -> &str
======
total test sequences : 173
There are total 8 nodes need to be covered.
There are total 16 edges need to be covered.
There are toatl 173 sequences.
There are toatl 10 valid sequences for fuzz.
sequences with dynamic length can not cover more nodes
-----------STATISTICS-----------
total nodes: 8
total edges: 16
covered nodes: 8
7, 4, 5, 6, 
covered monos: 4
covered edges: 4
node coverage: 1
edge coverage: 0.25
targets covered by reverse search: 0
total targets: 6
max length = 0
total length = 10
average time to fuzz each api = 1.25
--------------------------------
test_file_path: "/home/rumono/ryu/fuzz_target/test_files"
reproduce_file_path: "/home/rumono/ryu/fuzz_target/replay_files"
Fuzz Target Generator exits successfully.
Total time cost: 162 ms
