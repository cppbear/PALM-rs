Fuzz Target Generator for Rust Libraries: v0.1.0
Fuzz Target Renderer Init
crate: itoa
[TypeContext] add candidate #0: u8 => Primitive(U8)
[TypeContext] add candidate #1: &[u8] => BorrowedRef { lifetime: None, mutability: Not, type_: Slice(Primitive(U8)) }
analyse struct: Item { name: Some("Buffer"), item_id: DefId(DefId(0:13 ~ itoa[c0ce]::Buffer)), kind: Struct, docs: "A correctly sized stack allocation for the formatted integer to be written\ninto.\n\n# Example\n\n```\nlet mut buffer = itoa::Buffer::new();\nlet printed = buffer.format(1234);\nassert_eq!(printed, \"1234\");\n```" }
analyse struct: StructItem(Struct { ctor_kind: None, generics: Generics { params: [], where_predicates: [] }, fields: [Item { name: Some("bytes"), item_id: DefId(DefId(0:14 ~ itoa[c0ce]::Buffer::bytes)), kind: StructField, docs: "" }] })
==== run after krate ====
ignore RegionPredicate: RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }
bounds to facts ignore lifetime: Lifetime("'static")

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(Isize)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::isize")
type_def_id: Some(DefId(1:53398 ~ core[b693]::prim_isize))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:94 ~ itoa[c0ce]::{impl#20})
is_local_impl: true
is_external_type: true
type_name: "std::isize"
isize is fuzzable
[TypeContext] add candidate #2: isize => Primitive(Isize)
[TypeContext] add candidate #3: &mut isize => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Isize) }
[TypeContext] add candidate #4: &isize => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Isize) }
[TypeContext] add candidate #5: *isize => RawPointer(Mut, Primitive(Isize))
[TypeContext] add candidate #6: *const isize => RawPointer(Not, Primitive(Isize))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:95 ~ itoa[c0ce]::{impl#20}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3098 ~ core[b693]::convert::{impl#5}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:3097 ~ core[b693]::convert::{impl#5})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4904 ~ core[b693]::cell::{impl#45}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4897 ~ core[b693]::cell::RefMut)), segments: [PathSegment { name: "RefMut", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::RefMut")
type_def_id: Some(DefId(1:4897 ~ core[b693]::cell::RefMut))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4903 ~ core[b693]::cell::{impl#45})
is_local_impl: false
is_external_type: true
type_name: "std::cell::RefMut"
std::cell::RefMut::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4905 ~ core[b693]::cell::{impl#45}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::RefMut::<'_, T> as std::ops::Deref>::deref(&std::cell::RefMut::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(I8)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::i8")
type_def_id: Some(DefId(1:53388 ~ core[b693]::prim_i8))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:38 ~ itoa[c0ce]::{impl#4})
is_local_impl: true
is_external_type: true
type_name: "std::i8"
i8 is fuzzable
[TypeContext] add candidate #7: i8 => Primitive(I8)
[TypeContext] add candidate #8: &mut i8 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(I8) }
[TypeContext] add candidate #9: &i8 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(I8) }
[TypeContext] add candidate #10: *i8 => RawPointer(Mut, Primitive(I8))
[TypeContext] add candidate #11: *const i8 => RawPointer(Not, Primitive(I8))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:39 ~ itoa[c0ce]::{impl#4}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(Usize)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::usize")
type_def_id: Some(DefId(1:53399 ~ core[b693]::prim_usize))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:99 ~ itoa[c0ce]::{impl#22})
is_local_impl: true
is_external_type: true
type_name: "std::usize"
usize is fuzzable
[TypeContext] add candidate #12: usize => Primitive(Usize)
[TypeContext] add candidate #13: &mut usize => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(Usize) }
[TypeContext] add candidate #14: &usize => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Usize) }
[TypeContext] add candidate #15: *usize => RawPointer(Mut, Primitive(Usize))
[TypeContext] add candidate #16: *const usize => RawPointer(Not, Primitive(Usize))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:100 ~ itoa[c0ce]::{impl#22}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(U16)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::u16")
type_def_id: Some(DefId(1:53394 ~ core[b693]::prim_u16))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:59 ~ itoa[c0ce]::{impl#10})
is_local_impl: true
is_external_type: true
type_name: "std::u16"
u16 is fuzzable
[TypeContext] add candidate #17: u16 => Primitive(U16)
[TypeContext] add candidate #18: &mut u16 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(U16) }
[TypeContext] add candidate #19: &u16 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(U16) }
[TypeContext] add candidate #20: *u16 => RawPointer(Mut, Primitive(U16))
[TypeContext] add candidate #21: *const u16 => RawPointer(Not, Primitive(U16))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:60 ~ itoa[c0ce]::{impl#10}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:946 ~ core[b693]::num::nonzero::{impl#8}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::From
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:945 ~ core[b693]::num::nonzero::{impl#8})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
for type is full generic
self generics: None
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:957 ~ core[b693]::num::nonzero::{impl#11}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:906 ~ core[b693]::num::nonzero::ZeroablePrimitive)), segments: [PathSegment { name: "ZeroablePrimitive", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:34630 ~ core[b693]::ops::bit::BitOr)), segments: [PathSegment { name: "BitOr", args: AngleBracketed { args: [], constraints: [AssocItemConstraint { assoc: PathSegment { name: "Output", args: AngleBracketed { args: [], constraints: [] } }, kind: Equality { term: Type(Generic("T")) } }] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::bit::BitOr
impl for: Generic("T")
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::bit::BitOr")
type_full_name: None
type_def_id: None
trait_def_id: Some(DefId(1:34630 ~ core[b693]::ops::bit::BitOr))
impl_def_id: DefId(1:956 ~ core[b693]::num::nonzero::{impl#11})
is_local_impl: false
ignore this impl for pure generic

>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(I64)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::i64")
type_def_id: Some(DefId(1:53391 ~ core[b693]::prim_i64))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:80 ~ itoa[c0ce]::{impl#16})
is_local_impl: true
is_external_type: true
type_name: "std::i64"
i64 is fuzzable
[TypeContext] add candidate #22: i64 => Primitive(I64)
[TypeContext] add candidate #23: &mut i64 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(I64) }
[TypeContext] add candidate #24: &i64 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(I64) }
[TypeContext] add candidate #25: *i64 => RawPointer(Mut, Primitive(I64))
[TypeContext] add candidate #26: *const i64 => RawPointer(Not, Primitive(I64))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:81 ~ itoa[c0ce]::{impl#16}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(I32)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::i32")
type_def_id: Some(DefId(1:53390 ~ core[b693]::prim_i32))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:66 ~ itoa[c0ce]::{impl#12})
is_local_impl: true
is_external_type: true
type_name: "std::i32"
i32 is fuzzable
[TypeContext] add candidate #27: i32 => Primitive(I32)
[TypeContext] add candidate #28: &mut i32 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(I32) }
[TypeContext] add candidate #29: &i32 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(I32) }
[TypeContext] add candidate #30: *i32 => RawPointer(Mut, Primitive(I32))
[TypeContext] add candidate #31: *const i32 => RawPointer(Not, Primitive(I32))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:67 ~ itoa[c0ce]::{impl#12}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(U128)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::u128")
type_def_id: Some(DefId(1:53397 ~ core[b693]::prim_u128))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:113 ~ itoa[c0ce]::{impl#26})
is_local_impl: true
is_external_type: true
type_name: "std::u128"
u128 is fuzzable
[TypeContext] add candidate #32: u128 => Primitive(U128)
[TypeContext] add candidate #33: &mut u128 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(U128) }
[TypeContext] add candidate #34: &u128 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(U128) }
[TypeContext] add candidate #35: *u128 => RawPointer(Mut, Primitive(U128))
[TypeContext] add candidate #36: *const u128 => RawPointer(Not, Primitive(U128))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:114 ~ itoa[c0ce]::{impl#26}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4847 ~ core[b693]::cell::{impl#37}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4841 ~ core[b693]::cell::Ref)), segments: [PathSegment { name: "Ref", args: AngleBracketed { args: [Lifetime(Lifetime("'_")), Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::Ref")
type_def_id: Some(DefId(1:4841 ~ core[b693]::cell::Ref))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4846 ~ core[b693]::cell::{impl#37})
is_local_impl: false
is_external_type: true
type_name: "std::cell::Ref"
std::cell::Ref::<'_, T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4848 ~ core[b693]::cell::{impl#37}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::Ref::<'_, T> as std::ops::Deref>::deref(&std::cell::Ref::<'_, T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:1974 ~ core[b693]::mem::manually_drop::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop)), segments: [PathSegment { name: "ManuallyDrop", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::mem::manually_drop::ManuallyDrop")
type_def_id: Some(DefId(1:31167 ~ core[b693]::mem::manually_drop::ManuallyDrop))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:1973 ~ core[b693]::mem::manually_drop::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::mem::manually_drop::ManuallyDrop"
std::mem::manually_drop::ManuallyDrop::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:1975 ~ core[b693]::mem::manually_drop::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::mem::manually_drop::ManuallyDrop::<T> as std::ops::Deref>::deref(&std::mem::manually_drop::ManuallyDrop::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:41177 ~ core[b693]::ffi::va_list::{impl#8}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::fmt::Debug
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::fmt::Debug")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:10660 ~ core[b693]::fmt::Debug))
impl_def_id: DefId(1:41176 ~ core[b693]::ffi::va_list::{impl#8})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5333 ~ core[b693]::ffi::va_list::{impl#6}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(1:5332 ~ core[b693]::ffi::va_list::{impl#6})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5336 ~ core[b693]::ffi::va_list::{impl#7}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: core::ops::drop::Drop
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::drop::Drop")
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: Some(DefId(1:3580 ~ core[b693]::ops::drop::Drop))
impl_def_id: DefId(1:5335 ~ core[b693]::ffi::va_list::{impl#7})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5305 ~ core[b693]::ffi::va_list::{impl#0}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(1:5304 ~ core[b693]::ffi::va_list::{impl#0})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::as_va_list(&'a mut std::ffi::va_list::VaListImpl::<'_>) -> std::ffi::va_list::VaList::<'a, 'f>" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'f", def_id: DefId(1:5325 ~ core[b693]::ffi::va_list::{impl#5}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl)), segments: [PathSegment { name: "VaListImpl", args: AngleBracketed { args: [Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("core::ffi::va_list::VaListImpl")
type_def_id: Some(DefId(1:41169 ~ core[b693]::ffi::va_list::VaListImpl))
trait_def_id: None
impl_def_id: DefId(1:5324 ~ core[b693]::ffi::va_list::{impl#5})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaListImpl"
std::ffi::va_list::VaListImpl::<'_> is not fuzzable
assoc types:
"fn std::ffi::va_list::VaListImpl::<'_>::arg(&mut std::ffi::va_list::VaListImpl::<'_>) -> T" is filtered.
"fn std::ffi::va_list::VaListImpl::<'_>::with_copy(&std::ffi::va_list::VaListImpl::<'_>, F) -> R" is filtered.
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(I128)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::i128")
type_def_id: Some(DefId(1:53392 ~ core[b693]::prim_i128))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:104 ~ itoa[c0ce]::{impl#24})
is_local_impl: true
is_external_type: true
type_name: "std::i128"
i128 is fuzzable
[TypeContext] add candidate #37: i128 => Primitive(I128)
[TypeContext] add candidate #38: &mut i128 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(I128) }
[TypeContext] add candidate #39: &i128 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(I128) }
[TypeContext] add candidate #40: *i128 => RawPointer(Mut, Primitive(I128))
[TypeContext] add candidate #41: *const i128 => RawPointer(Not, Primitive(I128))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:105 ~ itoa[c0ce]::{impl#24}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("Ptr")])
impl generics: Generics { params: [GenericParamDef { name: "Ptr", def_id: DefId(1:9693 ~ core[b693]::pin::{impl#13}::Ptr), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("Ptr"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:42704 ~ core[b693]::pin::Pin)), segments: [PathSegment { name: "Pin", args: AngleBracketed { args: [Type(Generic("Ptr"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::pin::Pin")
type_def_id: Some(DefId(1:42704 ~ core[b693]::pin::Pin))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:9692 ~ core[b693]::pin::{impl#13})
is_local_impl: false
is_external_type: true
type_name: "std::pin::Pin"
std::pin::Pin::<Ptr> is not fuzzable
assoc types:
Target: <Ptr as std::ops::Deref>::Target
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:9694 ~ core[b693]::pin::{impl#13}::Target)), kind: AssocType, docs: "" }
"fn <std::pin::Pin::<Ptr> as std::ops::Deref>::deref(&std::pin::Pin::<Ptr>) -> &<Ptr as std::ops::Deref>::Target" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(U32)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::u32")
type_def_id: Some(DefId(1:53395 ~ core[b693]::prim_u32))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:73 ~ itoa[c0ce]::{impl#14})
is_local_impl: true
is_external_type: true
type_name: "std::u32"
u32 is fuzzable
[TypeContext] add candidate #42: u32 => Primitive(U32)
[TypeContext] add candidate #43: &mut u32 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(U32) }
[TypeContext] add candidate #44: &u32 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(U32) }
[TypeContext] add candidate #45: *u32 => RawPointer(Mut, Primitive(U32))
[TypeContext] add candidate #46: *const u32 => RawPointer(Not, Primitive(U32))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:74 ~ itoa[c0ce]::{impl#14}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(I16)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::i16")
type_def_id: Some(DefId(1:53389 ~ core[b693]::prim_i16))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:52 ~ itoa[c0ce]::{impl#8})
is_local_impl: true
is_external_type: true
type_name: "std::i16"
i16 is fuzzable
[TypeContext] add candidate #47: i16 => Primitive(I16)
[TypeContext] add candidate #48: &mut i16 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(I16) }
[TypeContext] add candidate #49: &i16 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(I16) }
[TypeContext] add candidate #50: *i16 => RawPointer(Mut, Primitive(I16))
[TypeContext] add candidate #51: *const i16 => RawPointer(Not, Primitive(I16))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:53 ~ itoa[c0ce]::{impl#8}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(U8)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::u8")
type_def_id: Some(DefId(1:53393 ~ core[b693]::prim_u8))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:45 ~ itoa[c0ce]::{impl#6})
is_local_impl: true
is_external_type: true
type_name: "std::u8"
u8 is fuzzable
[TypeContext] add candidate #52: &mut u8 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(U8) }
[TypeContext] add candidate #53: &u8 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(U8) }
[TypeContext] add candidate #54: *u8 => RawPointer(Mut, Primitive(U8))
[TypeContext] add candidate #55: *const u8 => RawPointer(Not, Primitive(U8))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:46 ~ itoa[c0ce]::{impl#6}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: None
impl generics: Generics { params: [], where_predicates: [] }
impl trait: itoa::Integer
impl for: Primitive(U64)
impl kind: Normal
is trait(local): true(true)
trait_full_name: Some("itoa::Integer")
type_full_name: Some("core::u64")
type_def_id: Some(DefId(1:53396 ~ core[b693]::prim_u64))
trait_def_id: Some(DefId(0:27 ~ itoa[c0ce]::Integer))
impl_def_id: DefId(0:87 ~ itoa[c0ce]::{impl#18})
is_local_impl: true
is_external_type: true
type_name: "std::u64"
u64 is fuzzable
[TypeContext] add candidate #56: u64 => Primitive(U64)
[TypeContext] add candidate #57: &mut u64 => BorrowedRef { lifetime: None, mutability: Mut, type_: Primitive(U64) }
[TypeContext] add candidate #58: &u64 => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(U64) }
[TypeContext] add candidate #59: *u64 => RawPointer(Mut, Primitive(U64))
[TypeContext] add candidate #60: *const u64 => RawPointer(Not, Primitive(U64))
assoc types:
not covered item Item { name: Some("MAX_STR_LEN"), item_id: DefId(DefId(0:88 ~ itoa[c0ce]::{impl#18}::MAX_STR_LEN)), kind: AssocConst, docs: "" }
Add itoa::Integer Provide Method. is_local=true
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T"), Generic("F")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:4629 ~ core[b693]::cell::lazy::{impl#2}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "F", def_id: DefId(1:4630 ~ core[b693]::cell::lazy::{impl#2}::F), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("F"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:4613 ~ core[b693]::cell::lazy::LazyCell)), segments: [PathSegment { name: "LazyCell", args: AngleBracketed { args: [Type(Generic("T")), Type(Generic("F"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::cell::lazy::LazyCell")
type_def_id: Some(DefId(1:4613 ~ core[b693]::cell::lazy::LazyCell))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:4628 ~ core[b693]::cell::lazy::{impl#2})
is_local_impl: false
is_external_type: true
type_name: "std::cell::lazy::LazyCell"
std::cell::lazy::LazyCell::<T, F> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:4631 ~ core[b693]::cell::lazy::{impl#2}::Target)), kind: AssocType, docs: "" }
"fn <std::cell::lazy::LazyCell::<T, F> as std::ops::Deref>::deref(&std::cell::lazy::LazyCell::<T, F>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([Generic("T")])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:9524 ~ core[b693]::panic::unwind_safe::{impl#21}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe)), segments: [PathSegment { name: "AssertUnwindSafe", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::panic::unwind_safe::AssertUnwindSafe")
type_def_id: Some(DefId(1:9488 ~ core[b693]::panic::unwind_safe::AssertUnwindSafe))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:9523 ~ core[b693]::panic::unwind_safe::{impl#21})
is_local_impl: false
is_external_type: true
type_name: "std::panic::unwind_safe::AssertUnwindSafe"
std::panic::unwind_safe::AssertUnwindSafe::<T> is not fuzzable
assoc types:
Target: T
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:9525 ~ core[b693]::panic::unwind_safe::{impl#21}::Target)), kind: AssocType, docs: "" }
"fn <std::panic::unwind_safe::AssertUnwindSafe::<T> as std::ops::Deref>::deref(&std::panic::unwind_safe::AssertUnwindSafe::<T>) -> &T" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "'a", def_id: DefId(1:5309 ~ core[b693]::ffi::va_list::{impl#1}::'a), kind: Lifetime { outlives: [] } }, GenericParamDef { name: "'f", def_id: DefId(1:5310 ~ core[b693]::ffi::va_list::{impl#1}::'f), kind: Lifetime { outlives: [] } }], where_predicates: [RegionPredicate { lifetime: Lifetime("'f"), bounds: [Outlives(Lifetime("'a"))] }] }
impl trait: core::ops::deref::Deref
impl for: Path { path: Path { res: Def(Struct, DefId(1:41179 ~ core[b693]::ffi::va_list::VaList)), segments: [PathSegment { name: "VaList", args: AngleBracketed { args: [Lifetime(Lifetime("'a")), Lifetime(Lifetime("'f"))], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::ops::deref::Deref")
type_full_name: Some("core::ffi::va_list::VaList")
type_def_id: Some(DefId(1:41179 ~ core[b693]::ffi::va_list::VaList))
trait_def_id: Some(DefId(1:3551 ~ core[b693]::ops::deref::Deref))
impl_def_id: DefId(1:5308 ~ core[b693]::ffi::va_list::{impl#1})
is_local_impl: false
is_external_type: true
type_name: "std::ffi::va_list::VaList"
std::ffi::va_list::VaList::<'_, '_> is not fuzzable
assoc types:
Target: std::ffi::va_list::VaListImpl::<'f>
not covered item Item { name: Some("Target"), item_id: DefId(DefId(1:5311 ~ core[b693]::ffi::va_list::{impl#1}::Target)), kind: AssocType, docs: "" }
"fn <std::ffi::va_list::VaList::<'_, '_> as std::ops::Deref>::deref(&std::ffi::va_list::VaList::<'_, '_>) -> &std::ffi::va_list::VaListImpl::<'f>" is filtered.
Add std::ops::Deref Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: none
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): false(false)
trait_full_name: None
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: None
impl_def_id: DefId(0:21 ~ itoa[c0ce]::{impl#3})
is_local_impl: true
is_external_type: false
type_name: "itoa::Buffer"
itoa::Buffer is not fuzzable
assoc types:
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Unpin
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Unpin")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:32876 ~ core[b693]::marker::Unpin))
impl_def_id: DefId(1:32876 ~ core[b693]::marker::Unpin)
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::UnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::UnwindSafe")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe))
impl_def_id: DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Sync
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Sync")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3316 ~ core[b693]::marker::Sync))
impl_def_id: DefId(1:3316 ~ core[b693]::marker::Sync)
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Send
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Send")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:32818 ~ core[b693]::marker::Send))
impl_def_id: DefId(1:32818 ~ core[b693]::marker::Send)
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::panic::unwind_safe::RefUnwindSafe
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::panic::unwind_safe::RefUnwindSafe")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe))
impl_def_id: DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe)
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Freeze
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Auto
is trait(local): true(false)
trait_full_name: Some("core::marker::Freeze")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3351 ~ core[b693]::marker::Freeze))
impl_def_id: DefId(1:3351 ~ core[b693]::marker::Freeze)
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3091 ~ core[b693]::convert::{impl#3}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3092 ~ core[b693]::convert::{impl#3}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::Into
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::Into")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3064 ~ core[b693]::convert::Into))
impl_def_id: DefId(1:3090 ~ core[b693]::convert::{impl#3})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3960 ~ core[b693]::any::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [Outlives(Lifetime("'static")), TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::any::Any
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::any::Any")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3957 ~ core[b693]::any::Any))
impl_def_id: DefId(1:3959 ~ core[b693]::any::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2789 ~ core[b693]::borrow::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::BorrowMut
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::BorrowMut")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:2782 ~ core[b693]::borrow::BorrowMut))
impl_def_id: DefId(1:2788 ~ core[b693]::borrow::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2818 ~ core[b693]::clone::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2817 ~ core[b693]::clone::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2821 ~ core[b693]::clone::{impl#1}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::clone::CloneToUninit
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::clone::CloneToUninit")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:2815 ~ core[b693]::clone::CloneToUninit))
impl_def_id: DefId(1:2820 ~ core[b693]::clone::{impl#1})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3101 ~ core[b693]::convert::{impl#6}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3102 ~ core[b693]::convert::{impl#6}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryInto
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryInto")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3070 ~ core[b693]::convert::TryInto))
impl_def_id: DefId(1:3100 ~ core[b693]::convert::{impl#6})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3095 ~ core[b693]::convert::{impl#4}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [] }
impl trait: core::convert::From
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::From")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3067 ~ core[b693]::convert::From))
impl_def_id: DefId(1:3094 ~ core[b693]::convert::{impl#4})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:3106 ~ core[b693]::convert::{impl#7}::T), kind: Type { bounds: [], default: None, synthetic: false } }, GenericParamDef { name: "U", def_id: DefId(1:3107 ~ core[b693]::convert::{impl#7}::U), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("U"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }, generic_params: [] }, None)], bound_params: [] }] }
impl trait: core::convert::TryFrom
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::convert::TryFrom")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3074 ~ core[b693]::convert::TryFrom))
impl_def_id: DefId(1:3105 ~ core[b693]::convert::{impl#7})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [GenericParamDef { name: "T", def_id: DefId(1:2786 ~ core[b693]::borrow::{impl#0}::T), kind: Type { bounds: [], default: None, synthetic: false } }], where_predicates: [BoundPredicate { ty: Generic("T"), bounds: [TraitBound(PolyTrait { trait_: Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }, generic_params: [] }, Maybe)], bound_params: [] }] }
impl trait: core::borrow::Borrow
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Blanket(Generic("T"))
is trait(local): true(false)
trait_full_name: Some("core::borrow::Borrow")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:2779 ~ core[b693]::borrow::Borrow))
impl_def_id: DefId(1:2785 ~ core[b693]::borrow::{impl#0})
is_local_impl: false
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for external impl

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::clone::Clone
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::clone::Clone")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:2805 ~ core[b693]::clone::Clone))
impl_def_id: DefId(0:19 ~ itoa[c0ce]::{impl#2})
is_local_impl: true
is_external_type: false
type_name: "itoa::Buffer"
ignore this impl for ignore trait

>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::default::Default
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::default::Default")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3142 ~ core[b693]::default::Default))
impl_def_id: DefId(0:16 ~ itoa[c0ce]::{impl#0})
is_local_impl: true
is_external_type: false
type_name: "itoa::Buffer"
itoa::Buffer is not fuzzable
assoc types:
Add std::default::Default Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<


>>>>> IMPL BLOCK INFO <<<<<
self generics: Some([])
impl generics: Generics { params: [], where_predicates: [] }
impl trait: core::marker::Copy
impl for: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
impl kind: Normal
is trait(local): true(false)
trait_full_name: Some("core::marker::Copy")
type_full_name: Some("itoa::Buffer")
type_def_id: Some(DefId(0:13 ~ itoa[c0ce]::Buffer))
trait_def_id: Some(DefId(1:3311 ~ core[b693]::marker::Copy))
impl_def_id: DefId(0:18 ~ itoa[c0ce]::{impl#1})
is_local_impl: true
is_external_type: false
type_name: "itoa::Buffer"
itoa::Buffer is not fuzzable
assoc types:
Add std::marker::Copy Provide Method. is_local=false
>>>>>>>>>>       <<<<<<<<<<

visibility: ModVisibity { crate_name: "itoa", inner: {"itoa": Public, "itoa::private": Restricted(DefId(0:0 ~ itoa[c0ce])), "itoa::udiv128": Restricted(DefId(0:0 ~ itoa[c0ce]))} }

type core::usize implement 1 traits: 
DefId(0:99 ~ itoa[c0ce]::{impl#22}): impl itoa::Integer for usize
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::u64 implement 1 traits: 
DefId(0:87 ~ itoa[c0ce]::{impl#18}): impl itoa::Integer for u64
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::ffi::va_list::VaListImpl implement 3 traits: 
DefId(1:41176 ~ core[b693]::ffi::va_list::{impl#8}): impl std::fmt::Debug for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5332 ~ core[b693]::ffi::va_list::{impl#6}): impl std::clone::Clone for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:5335 ~ core[b693]::ffi::va_list::{impl#7}): impl std::ops::drop::Drop for std::ffi::va_list::VaListImpl::<'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::i32 implement 1 traits: 
DefId(0:66 ~ itoa[c0ce]::{impl#12}): impl itoa::Integer for i32
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::u8 implement 1 traits: 
DefId(0:45 ~ itoa[c0ce]::{impl#6}): impl itoa::Integer for u8
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::lazy::LazyCell implement 1 traits: 
DefId(1:4628 ~ core[b693]::cell::lazy::{impl#2}): impl std::ops::Deref for std::cell::lazy::LazyCell::<T, F>
bounds: GenericParamMap { inner: {"T": [], "F": []}, generic_defs: ["T", "F"], type_pred: [(Generic("F"), [Path { res: Def(Trait, DefId(1:3592 ~ core[b693]::ops::function::FnOnce)), segments: [PathSegment { name: "FnOnce", args: Parenthesized { inputs: [], output: Some(Generic("T")) } }] }])] }

type core::mem::manually_drop::ManuallyDrop implement 1 traits: 
DefId(1:1973 ~ core[b693]::mem::manually_drop::{impl#2}): impl std::ops::Deref for std::mem::manually_drop::ManuallyDrop::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::isize implement 1 traits: 
DefId(0:94 ~ itoa[c0ce]::{impl#20}): impl itoa::Integer for isize
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::u32 implement 1 traits: 
DefId(0:73 ~ itoa[c0ce]::{impl#14}): impl itoa::Integer for u32
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::i128 implement 1 traits: 
DefId(0:104 ~ itoa[c0ce]::{impl#24}): impl itoa::Integer for i128
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::pin::Pin implement 1 traits: 
DefId(1:9692 ~ core[b693]::pin::{impl#13}): impl std::ops::Deref for std::pin::Pin::<Ptr>
bounds: GenericParamMap { inner: {"Ptr": []}, generic_defs: ["Ptr"], type_pred: [(Generic("Ptr"), [Path { res: Def(Trait, DefId(1:3551 ~ core[b693]::ops::deref::Deref)), segments: [PathSegment { name: "Deref", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::i16 implement 1 traits: 
DefId(0:52 ~ itoa[c0ce]::{impl#8}): impl itoa::Integer for i16
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::panic::unwind_safe::AssertUnwindSafe implement 1 traits: 
DefId(1:9523 ~ core[b693]::panic::unwind_safe::{impl#21}): impl std::ops::Deref for std::panic::unwind_safe::AssertUnwindSafe::<T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }

type itoa::Buffer implement 18 traits: 
DefId(1:32876 ~ core[b693]::marker::Unpin): impl std::marker::Unpin for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:42673 ~ core[b693]::panic::unwind_safe::UnwindSafe): impl std::panic::unwind_safe::UnwindSafe for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3316 ~ core[b693]::marker::Sync): impl std::marker::Sync for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:32818 ~ core[b693]::marker::Send): impl std::marker::Send for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:42674 ~ core[b693]::panic::unwind_safe::RefUnwindSafe): impl std::panic::unwind_safe::RefUnwindSafe for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3351 ~ core[b693]::marker::Freeze): impl std::marker::Freeze for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(1:3090 ~ core[b693]::convert::{impl#3}): impl std::convert::Into::<U> for itoa::Buffer
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3067 ~ core[b693]::convert::From)), segments: [PathSegment { name: "From", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:3959 ~ core[b693]::any::{impl#0}): impl std::any::Any for itoa::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2788 ~ core[b693]::borrow::{impl#1}): impl std::borrow::BorrowMut::<T> for itoa::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2817 ~ core[b693]::clone::{impl#0}): impl std::clone::CloneToUninit for itoa::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:2805 ~ core[b693]::clone::Clone)), segments: [PathSegment { name: "Clone", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:2820 ~ core[b693]::clone::{impl#1}): impl std::clone::CloneToUninit for itoa::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:3311 ~ core[b693]::marker::Copy)), segments: [PathSegment { name: "Copy", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(1:3100 ~ core[b693]::convert::{impl#6}): impl std::convert::TryInto::<U> for itoa::Buffer
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3074 ~ core[b693]::convert::TryFrom)), segments: [PathSegment { name: "TryFrom", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:3094 ~ core[b693]::convert::{impl#4}): impl std::convert::From::<T> for itoa::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [] }
DefId(1:3105 ~ core[b693]::convert::{impl#7}): impl std::convert::TryFrom::<U> for itoa::Buffer
bounds: GenericParamMap { inner: {"T": [], "U": []}, generic_defs: ["T", "U"], type_pred: [(Generic("U"), [Path { res: Def(Trait, DefId(1:3064 ~ core[b693]::convert::Into)), segments: [PathSegment { name: "Into", args: AngleBracketed { args: [Type(Generic("T"))], constraints: [] } }] }])] }
DefId(1:2785 ~ core[b693]::borrow::{impl#0}): impl std::borrow::Borrow::<T> for itoa::Buffer
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
DefId(0:19 ~ itoa[c0ce]::{impl#2}): impl std::clone::Clone for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:16 ~ itoa[c0ce]::{impl#0}): impl std::default::Default for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }
DefId(0:18 ~ itoa[c0ce]::{impl#1}): impl std::marker::Copy for itoa::Buffer
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::RefMut implement 1 traits: 
DefId(1:4903 ~ core[b693]::cell::{impl#45}): impl std::ops::Deref for std::cell::RefMut::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }

type core::ffi::va_list::VaList implement 1 traits: 
DefId(1:5308 ~ core[b693]::ffi::va_list::{impl#1}): impl std::ops::Deref for std::ffi::va_list::VaList::<'a, 'f>
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::u128 implement 1 traits: 
DefId(0:113 ~ itoa[c0ce]::{impl#26}): impl itoa::Integer for u128
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::u16 implement 1 traits: 
DefId(0:59 ~ itoa[c0ce]::{impl#10}): impl itoa::Integer for u16
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::i64 implement 1 traits: 
DefId(0:80 ~ itoa[c0ce]::{impl#16}): impl itoa::Integer for i64
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::i8 implement 1 traits: 
DefId(0:38 ~ itoa[c0ce]::{impl#4}): impl itoa::Integer for i8
bounds: GenericParamMap { inner: {}, generic_defs: [], type_pred: [] }

type core::cell::Ref implement 1 traits: 
DefId(1:4846 ~ core[b693]::cell::{impl#37}): impl std::ops::Deref for std::cell::Ref::<'_, T>
bounds: GenericParamMap { inner: {"T": []}, generic_defs: ["T"], type_pred: [(Generic("T"), [Path { res: Def(Trait, DefId(1:32819 ~ core[b693]::marker::Sized)), segments: [PathSegment { name: "Sized", args: AngleBracketed { args: [], constraints: [] } }] }])] }
Type Candidate #0: (1)&u8
Type Candidate #1: (1)*const u64
Type Candidate #2: (1)i64
Type Candidate #3: (1)u64
Type Candidate #4: (1)*i64
Type Candidate #5: (1)*i16
Type Candidate #6: (1)*u16
Type Candidate #7: (1)&u64
Type Candidate #8: (1)&mut usize
Type Candidate #9: (1)&isize
Type Candidate #10: (1)*const i8
Type Candidate #11: (1)&usize
Type Candidate #12: (1)&mut u16
Type Candidate #13: (1)i128
Type Candidate #14: (1)u128
Type Candidate #15: (1)*i8
Type Candidate #16: (1)&u32
Type Candidate #17: (1)&mut u8
Type Candidate #18: (1)*const isize
Type Candidate #19: (1)&i128
Type Candidate #20: (1)&mut u32
Type Candidate #21: (1)i16
Type Candidate #22: (1)u16
Type Candidate #23: (1)*isize
Type Candidate #24: (1)&u16
Type Candidate #25: (1)*const u32
Type Candidate #26: (1)&mut isize
Type Candidate #27: (1)*const i32
Type Candidate #28: (1)&i64
Type Candidate #29: (1)*const i128
Type Candidate #30: (1)i32
Type Candidate #31: (1)&mut u64
Type Candidate #32: (1)u32
Type Candidate #33: (1)*u8
Type Candidate #34: (1)*u128
Type Candidate #35: (1)&mut i8
Type Candidate #36: (1)*const u16
Type Candidate #37: (1)&mut u128
Type Candidate #38: (1)&i32
Type Candidate #39: (1)*const i64
Type Candidate #40: (1)isize
Type Candidate #41: (1)*const i16
Type Candidate #42: (1)usize
Type Candidate #43: (1)*usize
Type Candidate #44: (1)*u64
Type Candidate #45: (1)*const u128
Type Candidate #46: (1)&mut i16
Type Candidate #47: (1)&mut i64
Type Candidate #48: (1)&i16
Type Candidate #49: (1)&[u8]
Type Candidate #50: (1)i8
Type Candidate #51: (1)*const u8
Type Candidate #52: (2)u8
Type Candidate #53: (1)*i128
Type Candidate #54: (1)*i32
Type Candidate #55: (1)*u32
Type Candidate #56: (1)&mut i32
Type Candidate #57: (1)&u128
Type Candidate #58: (1)&mut i128
Type Candidate #59: (1)&i8
Type Candidate #60: (1)*const usize
unsupport function:
[ApiGraph] Resolve this function
fn itoa::Buffer::format(&mut itoa::Buffer, I) -> &str
Where:
I: itoa::Integer, 
Type Pred:

=====Iteration #0=====
num of func: 2
num of reachable: 2
num of reachable type: 2
[Reachable]fn itoa::Buffer::new() -> itoa::Buffer is reachable
[TypeContext] add candidate #61: Buffer => Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } }
[TypeContext] add candidate #62: &mut Buffer => BorrowedRef { lifetime: None, mutability: Mut, type_: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #63: &Buffer => BorrowedRef { lifetime: None, mutability: Not, type_: Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } } }
[TypeContext] add candidate #64: *Buffer => RawPointer(Mut, Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } })
[TypeContext] add candidate #65: *const Buffer => RawPointer(Not, Path { path: Path { res: Def(Struct, DefId(0:13 ~ itoa[c0ce]::Buffer)), segments: [PathSegment { name: "Buffer", args: AngleBracketed { args: [], constraints: [] } }] } })
[Reachable]fn <itoa::Buffer as std::default::Default>::default() -> itoa::Buffer is reachable
===== Candidates =====
Type Candidate #0: (1)&u8
Type Candidate #1: (1)*const u64
Type Candidate #2: (1)i64
Type Candidate #3: (1)u64
Type Candidate #4: (4)*const itoa::Buffer
Type Candidate #5: (1)*i64
Type Candidate #6: (1)*i16
Type Candidate #7: (1)*u16
Type Candidate #8: (1)&u64
Type Candidate #9: (1)&mut usize
Type Candidate #10: (1)&isize
Type Candidate #11: (1)*const i8
Type Candidate #12: (1)&usize
Type Candidate #13: (1)&mut u16
Type Candidate #14: (1)i128
Type Candidate #15: (4)&itoa::Buffer
Type Candidate #16: (1)u128
Type Candidate #17: (1)*i8
Type Candidate #18: (1)&u32
Type Candidate #19: (1)&mut u8
Type Candidate #20: (1)*const isize
Type Candidate #21: (1)&i128
Type Candidate #22: (1)&mut u32
Type Candidate #23: (1)i16
Type Candidate #24: (1)u16
Type Candidate #25: (4)itoa::Buffer
Type Candidate #26: (1)*isize
Type Candidate #27: (4)*itoa::Buffer
Type Candidate #28: (1)&u16
Type Candidate #29: (1)*const u32
Type Candidate #30: (1)&mut isize
Type Candidate #31: (1)*const i32
Type Candidate #32: (1)&i64
Type Candidate #33: (1)*const i128
Type Candidate #34: (1)i32
Type Candidate #35: (1)&mut u64
Type Candidate #36: (1)u32
Type Candidate #37: (1)*u8
Type Candidate #38: (1)*u128
Type Candidate #39: (1)&mut i8
Type Candidate #40: (1)*const u16
Type Candidate #41: (1)&mut u128
Type Candidate #42: (1)&i32
Type Candidate #43: (1)*const i64
Type Candidate #44: (1)isize
Type Candidate #45: (1)*const i16
Type Candidate #46: (1)usize
Type Candidate #47: (4)&mut itoa::Buffer
Type Candidate #48: (1)*usize
Type Candidate #49: (1)*u64
Type Candidate #50: (1)*const u128
Type Candidate #51: (1)&mut i16
Type Candidate #52: (1)&mut i64
Type Candidate #53: (1)&i16
Type Candidate #54: (1)&[u8]
Type Candidate #55: (1)i8
Type Candidate #56: (1)*const u8
Type Candidate #57: (2)u8
Type Candidate #58: (1)*i128
Type Candidate #59: (1)*i32
Type Candidate #60: (1)*u32
Type Candidate #61: (1)&mut i32
Type Candidate #62: (1)&u128
Type Candidate #63: (1)&mut i128
Type Candidate #64: (1)&i8
Type Candidate #65: (1)*const usize
===== !Candidates =====
[Solver] find solution for fn itoa::Buffer::format(&mut itoa::Buffer, I) -> &str, already have 0 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&mut usize), (u64), (&[u8]), (isize), (&i128), (usize), (&u32), (*const i64), (*const u64), (*const Buffer), (&isize), (*Buffer), (*u128), (&mut u8), (u32), (&mut i8), (&mut u128), (*i128), (i128), (*const i32), (*const u32), (&mut Buffer), (&mut u16), (*i64), (&i8), (*u64), (&mut i64), (u16), (&Buffer), (i64), (*const i16), (*const u16), (&mut u32), (&usize), (*i32), (*u32), (&mut i128), (&u64), (i32), (*const i8), (Buffer), (*const u8), (&u8), (*i16), (*u16), (&mut i16), (&u128), (i16), (*const isize), (*const usize), (*i8), (&i64), (*u8), (&i16), (&u16), (&mut i32), (u128), (i8), (u8), (*const i128), (*const u128), (*isize), (&mut u64), (&i32), (&mut isize), (*usize)`
Merge: `(&mut usize), (u64), (&[u8]), (isize), (&i128), (usize), (&u32), (*const i64), (*const u64), (*const Buffer), (&isize), (*Buffer), (*u128), (&mut u8), (u32), (&mut i8), (&mut u128), (*i128), (i128), (*const i32), (*const u32), (&mut Buffer), (&mut u16), (*i64), (&i8), (*u64), (&mut i64), (u16), (&Buffer), (i64), (*const i16), (*const u16), (&mut u32), (&usize), (*i32), (*u32), (&mut i128), (&u64), (i32), (*const i8), (Buffer), (*const u8), (&u8), (*i16), (*u16), (&mut i16), (&u128), (i16), (*const isize), (*const usize), (*i8), (&i64), (*u8), (&i16), (&u16), (&mut i32), (u128), (i8), (u8), (*const i128), (*const u128), (*isize), (&mut u64), (&i32), (&mut isize), (*usize)`
[Solver] Solution Set = `(&mut usize), (u64), (&[u8]), (isize), (&i128), (usize), (&u32), (*const i64), (*const u64), (*const Buffer), (&isize), (*Buffer), (*u128), (&mut u8), (u32), (&mut i8), (&mut u128), (*i128), (i128), (*const i32), (*const u32), (&mut Buffer), (&mut u16), (*i64), (&i8), (*u64), (&mut i64), (u16), (&Buffer), (i64), (*const i16), (*const u16), (&mut u32), (&usize), (*i32), (*u32), (&mut i128), (&u64), (i32), (*const i8), (Buffer), (*const u8), (&u8), (*i16), (*u16), (&mut i16), (&u128), (i16), (*const isize), (*const usize), (*i8), (&i64), (*u8), (&i16), (&u16), (&mut i32), (u128), (i8), (u8), (*const i128), (*const u128), (*isize), (&mut u64), (&i32), (&mut isize), (*usize)`
[Solver] Check Solution: (&mut usize)
[TraitImpl] Check trait itoa::Integer for &mut usize fail
[Solver] Check Solution: (u64)
[TraitImpl] Recursively check: do we have impl itoa::Integer for u64?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=u64)
[GenericParam] visited={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u64) -> &str
[Solver] mono solution: [Primitive(U64)]
[Solver] impls={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18}))}
[Solver] output depth = 2
[TypeContext] add candidate #66: &str => BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) }
[TypeContext] add candidate #67: &mut &str => BorrowedRef { lifetime: None, mutability: Mut, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #68: &&str => BorrowedRef { lifetime: None, mutability: Not, type_: BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) } }
[TypeContext] add candidate #69: *&str => RawPointer(Mut, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[TypeContext] add candidate #70: *const &str => RawPointer(Not, BorrowedRef { lifetime: None, mutability: Not, type_: Primitive(Str) })
[Solver] Check Solution: (&[u8])
[TraitImpl] Check trait itoa::Integer for &[u8] fail
[Solver] Check Solution: (isize)
[TraitImpl] Recursively check: do we have impl itoa::Integer for isize?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=isize)
[GenericParam] visited={Id(DefId(0:94 ~ itoa[c0ce]::{impl#20}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, isize) -> &str
[Solver] mono solution: [Primitive(Isize)]
[Solver] impls={Id(DefId(0:94 ~ itoa[c0ce]::{impl#20}))}
[Solver] output depth = 2
[Solver] Check Solution: (&i128)
[TraitImpl] Check trait itoa::Integer for &i128 fail
[Solver] Check Solution: (usize)
[TraitImpl] Recursively check: do we have impl itoa::Integer for usize?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=usize)
[GenericParam] visited={Id(DefId(0:99 ~ itoa[c0ce]::{impl#22}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, usize) -> &str
[Solver] mono solution: [Primitive(Usize)]
[Solver] impls={Id(DefId(0:99 ~ itoa[c0ce]::{impl#22}))}
[Solver] output depth = 2
[Solver] Check Solution: (&u32)
[TraitImpl] Check trait itoa::Integer for &u32 fail
[Solver] Check Solution: (*const i64)
[TraitImpl] Check trait itoa::Integer for *const i64 fail
[Solver] Check Solution: (*const u64)
[TraitImpl] Check trait itoa::Integer for *const u64 fail
[Solver] Check Solution: (*const Buffer)
[TraitImpl] Check trait itoa::Integer for *const itoa::Buffer fail
[Solver] Check Solution: (&isize)
[TraitImpl] Check trait itoa::Integer for &isize fail
[Solver] Check Solution: (*Buffer)
[TraitImpl] Check trait itoa::Integer for *itoa::Buffer fail
[Solver] Check Solution: (*u128)
[TraitImpl] Check trait itoa::Integer for *u128 fail
[Solver] Check Solution: (&mut u8)
[TraitImpl] Check trait itoa::Integer for &mut u8 fail
[Solver] Check Solution: (u32)
[TraitImpl] Recursively check: do we have impl itoa::Integer for u32?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=u32)
[GenericParam] visited={Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u32) -> &str
[Solver] mono solution: [Primitive(U32)]
[Solver] impls={Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] output depth = 2
[Solver] Check Solution: (&mut i8)
[TraitImpl] Check trait itoa::Integer for &mut i8 fail
[Solver] Check Solution: (&mut u128)
[TraitImpl] Check trait itoa::Integer for &mut u128 fail
[Solver] Check Solution: (*i128)
[TraitImpl] Check trait itoa::Integer for *i128 fail
[Solver] Check Solution: (i128)
[TraitImpl] Recursively check: do we have impl itoa::Integer for i128?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=i128)
[GenericParam] visited={Id(DefId(0:104 ~ itoa[c0ce]::{impl#24}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i128) -> &str
[Solver] mono solution: [Primitive(I128)]
[Solver] impls={Id(DefId(0:104 ~ itoa[c0ce]::{impl#24}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const i32)
[TraitImpl] Check trait itoa::Integer for *const i32 fail
[Solver] Check Solution: (*const u32)
[TraitImpl] Check trait itoa::Integer for *const u32 fail
[Solver] Check Solution: (&mut Buffer)
[TraitImpl] Check trait itoa::Integer for &mut itoa::Buffer fail
[Solver] Check Solution: (&mut u16)
[TraitImpl] Check trait itoa::Integer for &mut u16 fail
[Solver] Check Solution: (*i64)
[TraitImpl] Check trait itoa::Integer for *i64 fail
[Solver] Check Solution: (&i8)
[TraitImpl] Check trait itoa::Integer for &i8 fail
[Solver] Check Solution: (*u64)
[TraitImpl] Check trait itoa::Integer for *u64 fail
[Solver] Check Solution: (&mut i64)
[TraitImpl] Check trait itoa::Integer for &mut i64 fail
[Solver] Check Solution: (u16)
[TraitImpl] Recursively check: do we have impl itoa::Integer for u16?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=u16)
[GenericParam] visited={Id(DefId(0:59 ~ itoa[c0ce]::{impl#10}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u16) -> &str
[Solver] mono solution: [Primitive(U16)]
[Solver] impls={Id(DefId(0:59 ~ itoa[c0ce]::{impl#10}))}
[Solver] output depth = 2
[Solver] Check Solution: (&Buffer)
[TraitImpl] Check trait itoa::Integer for &itoa::Buffer fail
[Solver] Check Solution: (i64)
[TraitImpl] Recursively check: do we have impl itoa::Integer for i64?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=i64)
[GenericParam] visited={Id(DefId(0:80 ~ itoa[c0ce]::{impl#16}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i64) -> &str
[Solver] mono solution: [Primitive(I64)]
[Solver] impls={Id(DefId(0:80 ~ itoa[c0ce]::{impl#16}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const i16)
[TraitImpl] Check trait itoa::Integer for *const i16 fail
[Solver] Check Solution: (*const u16)
[TraitImpl] Check trait itoa::Integer for *const u16 fail
[Solver] Check Solution: (&mut u32)
[TraitImpl] Check trait itoa::Integer for &mut u32 fail
[Solver] Check Solution: (&usize)
[TraitImpl] Check trait itoa::Integer for &usize fail
[Solver] Check Solution: (*i32)
[TraitImpl] Check trait itoa::Integer for *i32 fail
[Solver] Check Solution: (*u32)
[TraitImpl] Check trait itoa::Integer for *u32 fail
[Solver] Check Solution: (&mut i128)
[TraitImpl] Check trait itoa::Integer for &mut i128 fail
[Solver] Check Solution: (&u64)
[TraitImpl] Check trait itoa::Integer for &u64 fail
[Solver] Check Solution: (i32)
[TraitImpl] Recursively check: do we have impl itoa::Integer for i32?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=i32)
[GenericParam] visited={Id(DefId(0:66 ~ itoa[c0ce]::{impl#12}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i32) -> &str
[Solver] mono solution: [Primitive(I32)]
[Solver] impls={Id(DefId(0:66 ~ itoa[c0ce]::{impl#12}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const i8)
[TraitImpl] Check trait itoa::Integer for *const i8 fail
[Solver] Check Solution: (Buffer)
[TraitImpl] Check trait itoa::Integer for itoa::Buffer fail
[Solver] Check Solution: (*const u8)
[TraitImpl] Check trait itoa::Integer for *const u8 fail
[Solver] Check Solution: (&u8)
[TraitImpl] Check trait itoa::Integer for &u8 fail
[Solver] Check Solution: (*i16)
[TraitImpl] Check trait itoa::Integer for *i16 fail
[Solver] Check Solution: (*u16)
[TraitImpl] Check trait itoa::Integer for *u16 fail
[Solver] Check Solution: (&mut i16)
[TraitImpl] Check trait itoa::Integer for &mut i16 fail
[Solver] Check Solution: (&u128)
[TraitImpl] Check trait itoa::Integer for &u128 fail
[Solver] Check Solution: (i16)
[TraitImpl] Recursively check: do we have impl itoa::Integer for i16?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=i16)
[GenericParam] visited={Id(DefId(0:52 ~ itoa[c0ce]::{impl#8}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i16) -> &str
[Solver] mono solution: [Primitive(I16)]
[Solver] impls={Id(DefId(0:52 ~ itoa[c0ce]::{impl#8}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const isize)
[TraitImpl] Check trait itoa::Integer for *const isize fail
[Solver] Check Solution: (*const usize)
[TraitImpl] Check trait itoa::Integer for *const usize fail
[Solver] Check Solution: (*i8)
[TraitImpl] Check trait itoa::Integer for *i8 fail
[Solver] Check Solution: (&i64)
[TraitImpl] Check trait itoa::Integer for &i64 fail
[Solver] Check Solution: (*u8)
[TraitImpl] Check trait itoa::Integer for *u8 fail
[Solver] Check Solution: (&i16)
[TraitImpl] Check trait itoa::Integer for &i16 fail
[Solver] Check Solution: (&u16)
[TraitImpl] Check trait itoa::Integer for &u16 fail
[Solver] Check Solution: (&mut i32)
[TraitImpl] Check trait itoa::Integer for &mut i32 fail
[Solver] Check Solution: (u128)
[TraitImpl] Recursively check: do we have impl itoa::Integer for u128?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=u128)
[GenericParam] visited={Id(DefId(0:113 ~ itoa[c0ce]::{impl#26}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u128) -> &str
[Solver] mono solution: [Primitive(U128)]
[Solver] impls={Id(DefId(0:113 ~ itoa[c0ce]::{impl#26}))}
[Solver] output depth = 2
[Solver] Check Solution: (i8)
[TraitImpl] Recursively check: do we have impl itoa::Integer for i8?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=i8)
[GenericParam] visited={Id(DefId(0:38 ~ itoa[c0ce]::{impl#4}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i8) -> &str
[Solver] mono solution: [Primitive(I8)]
[Solver] impls={Id(DefId(0:38 ~ itoa[c0ce]::{impl#4}))}
[Solver] output depth = 2
[Solver] Check Solution: (u8)
[TraitImpl] Recursively check: do we have impl itoa::Integer for u8?
[TraitImpl] solution: (), generic_defs: []
[GenericParam] Check pred succ : (I=u8)
[GenericParam] visited={Id(DefId(0:45 ~ itoa[c0ce]::{impl#6}))}
[Solver] find mono function: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u8) -> &str
[Solver] mono solution: [Primitive(U8)]
[Solver] impls={Id(DefId(0:45 ~ itoa[c0ce]::{impl#6}))}
[Solver] output depth = 2
[Solver] Check Solution: (*const i128)
[TraitImpl] Check trait itoa::Integer for *const i128 fail
[Solver] Check Solution: (*const u128)
[TraitImpl] Check trait itoa::Integer for *const u128 fail
[Solver] Check Solution: (*isize)
[TraitImpl] Check trait itoa::Integer for *isize fail
[Solver] Check Solution: (&mut u64)
[TraitImpl] Check trait itoa::Integer for &mut u64 fail
[Solver] Check Solution: (&i32)
[TraitImpl] Check trait itoa::Integer for &i32 fail
[Solver] Check Solution: (&mut isize)
[TraitImpl] Check trait itoa::Integer for &mut isize fail
[Solver] Check Solution: (*usize)
[TraitImpl] Check trait itoa::Integer for *usize fail
[Solver] Running solve() took 0 ms.
=====Iteration #1=====
num of func: 2
num of reachable: 2
num of reachable type: 2
===== Candidates =====
Type Candidate #0: (1)&u8
Type Candidate #1: (1)*const u64
Type Candidate #2: (1)i64
Type Candidate #3: (1)u64
Type Candidate #4: (4)*const itoa::Buffer
Type Candidate #5: (1)*i64
Type Candidate #6: (1)*i16
Type Candidate #7: (1)*u16
Type Candidate #8: (1)&u64
Type Candidate #9: (1)&mut usize
Type Candidate #10: (1)&isize
Type Candidate #11: (1)*const i8
Type Candidate #12: (1)&usize
Type Candidate #13: (1)&mut u16
Type Candidate #14: (1)i128
Type Candidate #15: (4)&itoa::Buffer
Type Candidate #16: (1)u128
Type Candidate #17: (1)*i8
Type Candidate #18: (12)&&str
Type Candidate #19: (1)&u32
Type Candidate #20: (1)&mut u8
Type Candidate #21: (1)*const isize
Type Candidate #22: (1)&i128
Type Candidate #23: (1)&mut u32
Type Candidate #24: (1)i16
Type Candidate #25: (1)u16
Type Candidate #26: (4)itoa::Buffer
Type Candidate #27: (1)*isize
Type Candidate #28: (12)&str
Type Candidate #29: (4)*itoa::Buffer
Type Candidate #30: (1)&u16
Type Candidate #31: (1)*const u32
Type Candidate #32: (1)&mut isize
Type Candidate #33: (1)*const i32
Type Candidate #34: (1)&i64
Type Candidate #35: (1)*const i128
Type Candidate #36: (1)i32
Type Candidate #37: (1)&mut u64
Type Candidate #38: (1)u32
Type Candidate #39: (12)&mut &str
Type Candidate #40: (12)*&str
Type Candidate #41: (1)*u8
Type Candidate #42: (1)*u128
Type Candidate #43: (1)&mut i8
Type Candidate #44: (1)*const u16
Type Candidate #45: (1)&mut u128
Type Candidate #46: (1)&i32
Type Candidate #47: (1)*const i64
Type Candidate #48: (1)isize
Type Candidate #49: (1)*const i16
Type Candidate #50: (1)usize
Type Candidate #51: (12)*const &str
Type Candidate #52: (4)&mut itoa::Buffer
Type Candidate #53: (1)*usize
Type Candidate #54: (1)*u64
Type Candidate #55: (1)*const u128
Type Candidate #56: (1)&mut i16
Type Candidate #57: (1)&mut i64
Type Candidate #58: (1)&i16
Type Candidate #59: (1)&[u8]
Type Candidate #60: (1)i8
Type Candidate #61: (1)*const u8
Type Candidate #62: (2)u8
Type Candidate #63: (1)*i128
Type Candidate #64: (1)*i32
Type Candidate #65: (1)*u32
Type Candidate #66: (1)&mut i32
Type Candidate #67: (1)&u128
Type Candidate #68: (1)&mut i128
Type Candidate #69: (1)&i8
Type Candidate #70: (1)*const usize
===== !Candidates =====
[Solver] find solution for fn itoa::Buffer::format(&mut itoa::Buffer, I) -> &str, already have 12 solutions
[Solver] generic params: ["I"]
[Solver] Start solve()
[Solver] search for input argument I:
set A: `(*)`
set B: `(&mut usize), (u64), (&i128), (isize), (&u32), (usize), (&[u8]), (*const i64), (*const u64), (*&str), (*const Buffer), (&isize), (*Buffer), (*u128), (&mut u8), (u32), (&mut i8), (&mut u128), (*i128), (i128), (*const i32), (*const u32), (&mut Buffer), (&&str), (&mut u16), (*i64), (&i8), (*u64), (&mut i64), (u16), (&Buffer), (i64), (*const i16), (*const u16), (&str), (&mut u32), (&usize), (*i32), (*u32), (&mut i128), (&u64), (i32), (*const i8), (Buffer), (*const u8), (&u8), (*i16), (*u16), (&mut i16), (&u128), (*const &str), (i16), (*const isize), (*const usize), (*i8), (&i64), (*u8), (&i16), (&u16), (&mut i32), (u128), (i8), (u8), (*const i128), (*const u128), (&mut &str), (*isize), (&mut u64), (&i32), (&mut isize), (*usize)`
Merge: `(&mut usize), (u64), (&i128), (isize), (&u32), (usize), (&[u8]), (*const i64), (*const u64), (*&str), (*const Buffer), (&isize), (*Buffer), (*u128), (&mut u8), (u32), (&mut i8), (&mut u128), (*i128), (i128), (*const i32), (*const u32), (&mut Buffer), (&&str), (&mut u16), (*i64), (&i8), (*u64), (&mut i64), (u16), (&Buffer), (i64), (*const i16), (*const u16), (&str), (&mut u32), (&usize), (*i32), (*u32), (&mut i128), (&u64), (i32), (*const i8), (Buffer), (*const u8), (&u8), (*i16), (*u16), (&mut i16), (&u128), (*const &str), (i16), (*const isize), (*const usize), (*i8), (&i64), (*u8), (&i16), (&u16), (&mut i32), (u128), (i8), (u8), (*const i128), (*const u128), (&mut &str), (*isize), (&mut u64), (&i32), (&mut isize), (*usize)`
[Solver] Solution Set = `(&mut usize), (u64), (&i128), (isize), (&u32), (usize), (&[u8]), (*const i64), (*const u64), (*&str), (*const Buffer), (&isize), (*Buffer), (*u128), (&mut u8), (u32), (&mut i8), (&mut u128), (*i128), (i128), (*const i32), (*const u32), (&mut Buffer), (&&str), (&mut u16), (*i64), (&i8), (*u64), (&mut i64), (u16), (&Buffer), (i64), (*const i16), (*const u16), (&str), (&mut u32), (&usize), (*i32), (*u32), (&mut i128), (&u64), (i32), (*const i8), (Buffer), (*const u8), (&u8), (*i16), (*u16), (&mut i16), (&u128), (*const &str), (i16), (*const isize), (*const usize), (*i8), (&i64), (*u8), (&i16), (&u16), (&mut i32), (u128), (i8), (u8), (*const i128), (*const u128), (&mut &str), (*isize), (&mut u64), (&i32), (&mut isize), (*usize)`
[Solver] Check Solution: (*&str)
[TraitImpl] Check trait itoa::Integer for *&str fail
[Solver] Check Solution: (&&str)
[TraitImpl] Check trait itoa::Integer for &&str fail
[Solver] Check Solution: (&str)
[TraitImpl] Check trait itoa::Integer for &str fail
[Solver] Check Solution: (*const &str)
[TraitImpl] Check trait itoa::Integer for *const &str fail
[Solver] Check Solution: (&mut &str)
[TraitImpl] Check trait itoa::Integer for &mut &str fail
[Solver] Running solve() took 0 ms.
===== all reachable func =====
fn itoa::Buffer::new() -> itoa::Buffer
fn <itoa::Buffer as std::default::Default>::default() -> itoa::Buffer
===== !all reachable func =====
[Solver] init diverse solution for fn itoa::Buffer::format(&mut itoa::Buffer, I) -> &str
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u64) -> &str, {Id(DefId(0:87 ~ itoa[c0ce]::{impl#18}))}, all={}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, isize) -> &str, {Id(DefId(0:94 ~ itoa[c0ce]::{impl#20}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, usize) -> &str, {Id(DefId(0:99 ~ itoa[c0ce]::{impl#22}))}, all={Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:87 ~ itoa[c0ce]::{impl#18}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u32) -> &str, {Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}, all={Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i128) -> &str, {Id(DefId(0:104 ~ itoa[c0ce]::{impl#24}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u16) -> &str, {Id(DefId(0:59 ~ itoa[c0ce]::{impl#10}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i64) -> &str, {Id(DefId(0:80 ~ itoa[c0ce]::{impl#16}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:59 ~ itoa[c0ce]::{impl#10})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i32) -> &str, {Id(DefId(0:66 ~ itoa[c0ce]::{impl#12}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:80 ~ itoa[c0ce]::{impl#16})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:59 ~ itoa[c0ce]::{impl#10})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i16) -> &str, {Id(DefId(0:52 ~ itoa[c0ce]::{impl#8}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:80 ~ itoa[c0ce]::{impl#16})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:59 ~ itoa[c0ce]::{impl#10})), Id(DefId(0:66 ~ itoa[c0ce]::{impl#12})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u128) -> &str, {Id(DefId(0:113 ~ itoa[c0ce]::{impl#26}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:80 ~ itoa[c0ce]::{impl#16})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:59 ~ itoa[c0ce]::{impl#10})), Id(DefId(0:52 ~ itoa[c0ce]::{impl#8})), Id(DefId(0:66 ~ itoa[c0ce]::{impl#12})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, i8) -> &str, {Id(DefId(0:38 ~ itoa[c0ce]::{impl#4}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:80 ~ itoa[c0ce]::{impl#16})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:59 ~ itoa[c0ce]::{impl#10})), Id(DefId(0:52 ~ itoa[c0ce]::{impl#8})), Id(DefId(0:113 ~ itoa[c0ce]::{impl#26})), Id(DefId(0:66 ~ itoa[c0ce]::{impl#12})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[Solver] reserve mono: fn itoa::Buffer::format#mono(&mut itoa::Buffer, u8) -> &str, {Id(DefId(0:45 ~ itoa[c0ce]::{impl#6}))}, all={Id(DefId(0:87 ~ itoa[c0ce]::{impl#18})), Id(DefId(0:80 ~ itoa[c0ce]::{impl#16})), Id(DefId(0:94 ~ itoa[c0ce]::{impl#20})), Id(DefId(0:59 ~ itoa[c0ce]::{impl#10})), Id(DefId(0:52 ~ itoa[c0ce]::{impl#8})), Id(DefId(0:113 ~ itoa[c0ce]::{impl#26})), Id(DefId(0:66 ~ itoa[c0ce]::{impl#12})), Id(DefId(0:104 ~ itoa[c0ce]::{impl#24})), Id(DefId(0:38 ~ itoa[c0ce]::{impl#4})), Id(DefId(0:99 ~ itoa[c0ce]::{impl#22})), Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
===== diverse types =====
i32: false
i64: false
u32: false
u64: false
isize: false
i128: false
usize: false
u128: false
&mut Buffer: false
i8: false
i16: false
u8: false
u16: false
===== !diverse types =====
[Diverse]fn itoa::Buffer::new() -> itoa::Buffer is diverse
propagate start
===== diverse types =====
i32: false
i64: false
u32: false
u64: false
isize: false
i128: false
usize: false
u128: false
&mut Buffer: true
i8: false
i16: false
u8: false
u16: false
===== !diverse types =====
unsolve generic function:
all mono function:
[R] monofun#1:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u8) -> &str : {Id(DefId(0:45 ~ itoa[c0ce]::{impl#6}))}
[R] monofun#2:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i8) -> &str : {Id(DefId(0:38 ~ itoa[c0ce]::{impl#4}))}
[R] monofun#3:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u128) -> &str : {Id(DefId(0:113 ~ itoa[c0ce]::{impl#26}))}
[R] monofun#4:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i16) -> &str : {Id(DefId(0:52 ~ itoa[c0ce]::{impl#8}))}
[R] monofun#5:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i32) -> &str : {Id(DefId(0:66 ~ itoa[c0ce]::{impl#12}))}
[R] monofun#6:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i64) -> &str : {Id(DefId(0:80 ~ itoa[c0ce]::{impl#16}))}
[R] monofun#7:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u16) -> &str : {Id(DefId(0:59 ~ itoa[c0ce]::{impl#10}))}
[R] monofun#8:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i128) -> &str : {Id(DefId(0:104 ~ itoa[c0ce]::{impl#24}))}
[R] monofun#9:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u32) -> &str : {Id(DefId(0:73 ~ itoa[c0ce]::{impl#14}))}
[R] monofun#10:fn itoa::Buffer::format#mono(&mut itoa::Buffer, usize) -> &str : {Id(DefId(0:99 ~ itoa[c0ce]::{impl#22}))}
[R] monofun#11:fn itoa::Buffer::format#mono(&mut itoa::Buffer, isize) -> &str : {Id(DefId(0:94 ~ itoa[c0ce]::{impl#20}))}
[R] monofun#12:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u64) -> &str : {Id(DefId(0:87 ~ itoa[c0ce]::{impl#18}))}
====== statistic ======
GENERIC_API: 1
RPG_COVERED_API: 2
COVERED API: 3
RPG_COVERED_GENERIC: 1
RESERVE: 12
RPG_GENERIC: 1
PRUNE_ITERS: 1
ITERS: 2
UNSAFE: 0
RPG_API: 2
CANDIDATES: 71
MONO_FUNS: 12
API: 3
UNSOLVABLE: 0
TRAIT_IMPLS: 51
COVERED GENERIC: 1
BLANKET_IMPLS: 0
======  advance  ======
MONO_PER_FUNCS: 12
GENERIC COVERAGE: 1
API COVERAGE: 1
=======================
using bfs end point
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 
after backward search
targets = 120
total length = 336
average time to visit = 24
edge covered by reverse search = 24
total functions in crate : 14
total generic functions in crate : 1
0:fn itoa::Buffer::new() -> itoa::Buffer
1:fn <itoa::Buffer as std::default::Default>::default() -> itoa::Buffer
2:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u8) -> &str
3:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i8) -> &str
4:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u128) -> &str
5:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i16) -> &str
6:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i32) -> &str
7:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i64) -> &str
8:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u16) -> &str
9:fn itoa::Buffer::format#mono(&mut itoa::Buffer, i128) -> &str
10:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u32) -> &str
11:fn itoa::Buffer::format#mono(&mut itoa::Buffer, usize) -> &str
12:fn itoa::Buffer::format#mono(&mut itoa::Buffer, isize) -> &str
13:fn itoa::Buffer::format#mono(&mut itoa::Buffer, u64) -> &str
======
total test sequences : 135
There are total 14 nodes need to be covered.
There are total 24 edges need to be covered.
There are toatl 135 sequences.
There are toatl 24 valid sequences for fuzz.
sequences with dynamic length can not cover more nodes
-----------STATISTICS-----------
total nodes: 14
total edges: 24
covered nodes: 14
13, 10, 7, 4, 11, 8, 5, 2, 12, 9, 6, 3, 
covered monos: 12
covered edges: 12
node coverage: 1
edge coverage: 0.5
targets covered by reverse search: 0
total targets: 12
max length = 0
total length = 24
average time to fuzz each api = 1.7142857142857142
--------------------------------
test_file_path: "/home/rumono/itoa/fuzz_target/test_files"
reproduce_file_path: "/home/rumono/itoa/fuzz_target/replay_files"
Fuzz Target Generator exits successfully.
Total time cost: 150 ms
