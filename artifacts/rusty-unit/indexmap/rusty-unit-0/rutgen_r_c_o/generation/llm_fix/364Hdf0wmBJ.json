{
  "name": "indexmap::map::core::map::core::RefMut<'a, K, V>::insert_unique",
  "name_with_impl": "indexmap::map::core::{impl#3}::insert_unique",
  "mod_info": {
    "name": "map::core",
    "loc": "src/map.rs:4:1:4:10"
  },
  "visible": false,
  "loc": "src/map/core.rs:551:5:565:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: (*left_val == *right_val) is true\n",
        "// constraint: self.entries.len() == self.entries.capacity() is true\n"
      ],
      "input_infer": "0 <= hash <= MAX_HASH_VALUE, 0 < self.entries.len() <= MAX_ENTRIES_CAPACITY, 0 < key.length <= MAX_KEY_LENGTH, 0 < value.length <= MAX_VALUE_LENGTH\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                "        hash: HashValue(0),",
                "        key: 0,",
                "        value: String::from(\"value0\"),",
                "    }; 5]; // Assuming capacity is 5 for this test",
                "",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "",
                "    ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(entries.len(), 6);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(entries[5].key, 1);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(entries[5].value, \"value1\");"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert!(indices.contains_key(&HashValue(0).get()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(entries.len(), 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(entries[5].key, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(entries[5].value, \"value1\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let entry = ref_mut.insert_unique(HashValue(0), 1, String::from(\"value1\"));",
                  "    assert!(indices.contains_key(&HashValue(0).get()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `contains_key` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:763:21\n    |\n763 |     assert!(indices.contains_key(&HashValue(0).get()));\n    |                     ^^^^^^^^^^^^ method not found in `HashTable<usize>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                "        hash: HashValue(0),",
                "        key: 0,",
                "        value: String::from(\"value0\"),",
                "    }; 5]; // Assuming capacity is 5 for this test",
                "",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "",
                "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 5);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].key, 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].value, \"value0\");"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].hash.0, 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.capacity(), 5);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries.len(), 6);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries[5].key, 2);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries[5].value, \"value2\");"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries[5].hash.0, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].value, \"value0\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].hash.0, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.capacity(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries.len(), 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries[5].key, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries[5].value, \"value2\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 2, String::from(\"value2\"));",
                  "    assert_eq!(entries[5].hash.0, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                "        hash: HashValue(0),",
                "        key: 0,",
                "        value: String::from(\"value0\"),",
                "    }; 5]; // Assuming capacity is 5 for this test",
                "",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "",
                "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries.len(), 6);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[5].key, 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[5].value, String::from(\"value0\"));"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(occupied_entry.index().get(), 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries.len(), 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[5].key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[5].value, String::from(\"value0\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\"), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let occupied_entry = ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(occupied_entry.index().get(), 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for type `usize` in the current scope\n    --> src/map/core.rs:763:39\n     |\n763  |     assert_eq!(occupied_entry.index().get(), 5);\n     |                --------------         ^^^\n     |                |\n     |                method `get` is available on `&entry::OccupiedEntry<'_, usize, String>`\n     |\n    ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:208:8\n     |\n208  |     fn get(self, slice: &T) -> Option<&Self::Output>;\n     |        --- the method is available for `usize` here\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1232:5\n     |\n1232 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `SliceIndex` which provides `get` is implemented but not in scope; perhaps you want to import it\n     |\n741  +    use std::slice::SliceIndex;\n     |\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                "        hash: HashValue(0),",
                "        key: 0,",
                "        value: String::from(\"value0\"),",
                "    }; 1]; // Minimum capacity for edge-case testing",
                "",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "",
                "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries.len(), 2);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[1].hash, HashValue(0));"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[1].key, 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[1].value, String::from(\"value0\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 1]; // Minimum capacity for edge-case testing",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 1]; // Minimum capacity for edge-case testing",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 1]; // Minimum capacity for edge-case testing",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[1].hash, HashValue(0));",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 1]; // Minimum capacity for edge-case testing",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[1].key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"value0\"),",
                  "    }; 1]; // Minimum capacity for edge-case testing",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"value0\") }; 1];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(0), 0, String::from(\"value0\"));",
                  "    assert_eq!(entries[1].value, String::from(\"value0\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                "        hash: HashValue(0),",
                "        key: 0,",
                "        value: String::from(\"a\".repeat(1000)),",
                "    }; 5]; // Assuming capacity is 5 for this test",
                "",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "",
                "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 0);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 5);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.capacity(), 5);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(entries.len(), 6);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(entries[5].key, 1);"
                ],
                [
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(entries[5].value, String::from(\"b\".repeat(1000)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.capacity(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(entries.len(), 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(entries[5].key, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket {",
                  "        hash: HashValue(0),",
                  "        key: 0,",
                  "        value: String::from(\"a\".repeat(1000)),",
                  "    }; 5]; // Assuming capacity is 5 for this test",
                  "",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    let mut indices: Indices = hash_table::HashTable::default();",
                  "    let mut entries: Vec<Bucket<usize, String>> = vec![Bucket { hash: HashValue(0), key: 0, value: String::from(\"a\".repeat(1000)), }; 5];",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 1, String::from(\"b\".repeat(1000)));",
                  "    assert_eq!(entries[5].value, String::from(\"b\".repeat(1000)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: (*left_val == *right_val) is true\n",
        "// constraint: self.entries.len() == self.entries.capacity() is false\n"
      ],
      "input_infer": "(1, usize::MAX)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::new();",
                "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(1);",
                "    let key = 42;",
                "    let value = \"example\".to_string();",
                "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), 1);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[0].key, key);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[0].value, value);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(indices.len() > 0);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(entries.capacity() >= 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[0].key, key);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(1);",
                  "   let key = 42;",
                  "   let value = \"example\".to_string();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value.clone());",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(1);",
                  "   let key = 42;",
                  "   let value = \"example\".to_string();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value.clone());",
                  "   assert_eq!(entries[0].value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(1);",
                  "    let key = 42;",
                  "    let value = \"example\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(entries.capacity() >= 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                true,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::new();",
                "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                "    entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: 43,",
                "        value: \"existing\".to_string(),",
                "    });",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(3);",
                "    let key = 42;",
                "    let value = \"new_value\".to_string();",
                "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), 2);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[1].key, 42);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[1].value, \"new_value\".to_string());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_ne!(indices.len(), 0);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(indices.get(&hash_value.get()), Some(&1));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 43,",
                  "        value: \"existing\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 43,",
                  "        value: \"existing\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[1].key, 42);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 43,",
                  "        value: \"existing\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[1].value, \"new_value\".to_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 43,",
                  "        value: \"existing\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_ne!(indices.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 43,",
                  "        value: \"existing\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(2);",
                  "    entries.push(Bucket { hash: HashValue(2), key: 43, value: \"existing\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 42;",
                  "    let value = \"new_value\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(indices.get(&hash_value.get()), Some(&1));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:769:24\n    |\n769 |     assert_eq!(indices.get(&hash_value.get()), Some(&1));\n    |                        ^^^ method not found in `HashTable<usize>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::new();",
                "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                "    entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: 10,",
                "        value: \"value1\".to_string(),",
                "    });",
                "    entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: 20,",
                "        value: \"value2\".to_string(),",
                "    });",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(3);",
                "    let key = 30;",
                "    let value = \"value3\".to_string();",
                "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), 3);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[2].key, 30);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[2].value, \"value3\".to_string());"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[2].hash, HashValue(3));"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(indices.len() > 0);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(ref_mut.entries.len(), 3);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(ref_mut.entries.capacity() >= 4);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(indices.len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[2].key, 30);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[2].value, \"value3\".to_string());",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[2].hash, HashValue(3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(ref_mut.entries.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(ref_mut.entries.capacity() >= 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: 10,",
                  "        value: \"value1\".to_string(),",
                  "    });",
                  "    entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: 20,",
                  "        value: \"value2\".to_string(),",
                  "    });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(4);",
                  "    entries.push(Bucket { hash: HashValue(1), key: 10, value: \"value1\".to_string() });",
                  "    entries.push(Bucket { hash: HashValue(2), key: 20, value: \"value2\".to_string() });",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(3);",
                  "    let key = 30;",
                  "    let value = \"value3\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0382]: borrow of moved value: `ref_mut`\n   --> src/map/core.rs:775:16\n    |\n770 |     let ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ------- move occurs because `ref_mut` has type `core::RefMut<'_, i32, String>`, which does not implement the `Copy` trait\n...\n774 |     let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);\n    |                                   ------------------------------------- `ref_mut` moved due to this method call\n775 |     assert_eq!(ref_mut.entries.len(), 3);\n    |                ^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0382]: borrow of moved value: `ref_mut`\n   --> src/map/core.rs:775:13\n    |\n770 |     let ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ------- move occurs because `ref_mut` has type `core::RefMut<'_, i32, String>`, which does not implement the `Copy` trait\n...\n774 |     let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);\n    |                                   ------------------------------------- `ref_mut` moved due to this method call\n775 |     assert!(ref_mut.entries.capacity() >= 4);\n    |             ^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                true,
                true,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hash_table::HashTable::new();",
                "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(usize::MAX as usize);",
                "    let key = 99;",
                "    let value = \"boundary_hash\".to_string();",
                "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "    let initial_capacity = entries.capacity();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries.len(), initial_len + 1);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "    let initial_capacity = entries.capacity();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert!(entries.capacity() >= initial_capacity);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "    let initial_capacity = entries.capacity();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[initial_len].key, key);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "    let initial_capacity = entries.capacity();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[initial_len].value, value);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "    let initial_capacity = entries.capacity();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(entries[initial_len].hash, hash_value);"
                ],
                [
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "    let initial_capacity = entries.capacity();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    assert_eq!(indices.len(), initial_len + 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);  ",
                  "",
                  "    assert_eq!(entries.len(), initial_len + 1);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(usize::MAX as usize);",
                  "   let key = 99;",
                  "   let value = \"boundary_hash\".to_string();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   // Remove the creation of a second indices and entries.",
                  "   // Redundant re-initialization of indices and entries can cause mutable borrow issues.",
                  "   // let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   // let hash_value = HashValue(usize::MAX as usize);",
                  "   // let key = 99;",
                  "   // let value = \"boundary_hash\".to_string();",
                  "  // Move initial_len declaration here after mutable borrow",
                  "  // let initial_len = entries.len();",
                  "  let initial_capacity = entries.capacity();",
                  "   assert!(entries.capacity() >= initial_capacity);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "   let hash_value = HashValue(usize::MAX as usize);",
                  "   let key = 99;",
                  "   let value = \"boundary_hash\".to_string();",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   let initial_len = entries.len();",
                  "   let initial_capacity = entries.capacity();",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(usize::MAX as usize);",
                  "   let key = 99;",
                  "   let value = \"boundary_hash\".to_string();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   assert_eq!(entries[initial_len].key, key);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(usize::MAX as usize);",
                  "   let key = 99;",
                  "   let value = \"boundary_hash\".to_string();",
                  "  let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(usize::MAX as usize);",
                  "   let key = 99;",
                  "   let value = \"boundary_hash\".to_string();",
                  "   let initial_len = entries.len();",
                  "   let initial_capacity = entries.capacity();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, &value);",
                  "   assert_eq!(entries[initial_len].value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "    let mut indices = hash_table::HashTable::new();",
                  "    let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash_value = HashValue(usize::MAX as usize);",
                  "    let key = 99;",
                  "    let value = \"boundary_hash\".to_string();",
                  "    let initial_len = entries.len();",
                  "   let _initial_capacity = entries.capacity();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   assert_eq!(entries[initial_len].hash, hash_value);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hash_table::HashTable::new();",
                  "   let mut entries: Vec<Bucket<i32, String>> = Vec::with_capacity(1);",
                  "   {",
                  "       let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "       let hash_value = HashValue(usize::MAX as usize);",
                  "       let key = 99;",
                  "       let value = \"boundary_hash\".to_string();",
                  "       let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   }",
                  "   let initial_len = entries.len();",
                  "   let initial_capacity = entries.capacity();",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash_value = HashValue(usize::MAX as usize);",
                  "   let key = 99;",
                  "   let value = \"boundary_hash\".to_string();",
                  "   let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                  "   assert_eq!(indices.len(), initial_len + 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `entries` as immutable because it is also borrowed as mutable\n   --> src/map/core.rs:762:23\n    |\n758 |     let ref_mut = RefMut::new(&mut indices, &mut entries);\n    |                                             ------------ mutable borrow occurs here\n...\n762 |     let initial_len = entries.len();\n    |                       ^^^^^^^ immutable borrow occurs here\n763 |    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);  \n    |                          ------- mutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/core.rs:764:65\n    |\n764 |    let _occupied_entry = ref_mut.insert_unique(hash_value, key, &value);\n    |                                  -------------                  ^^^^^^ expected `String`, found `&String`\n    |                                  |\n    |                                  arguments to this method are incorrect\n    |\nhelp: the return type of this call is `&String` due to the type of the argument passed\n   --> src/map/core.rs:764:26\n    |\n764 |    let _occupied_entry = ref_mut.insert_unique(hash_value, key, &value);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------^\n    |                                                                 |\n    |                                                                 this argument influences the return type of `insert_unique`\nnote: method defined here\n   --> src/map/core.rs:551:8\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |        ^^^^^^^^^^^^^                                --------\nhelp: consider removing the borrow\n    |\n764 -    let _occupied_entry = ref_mut.insert_unique(hash_value, key, &value);\n764 +    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);\n    |\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `entries` as immutable because it is also borrowed as mutable\n   --> src/map/core.rs:762:23\n    |\n758 |     let ref_mut = RefMut::new(&mut indices, &mut entries);\n    |                                             ------------ mutable borrow occurs here\n...\n762 |     let initial_len = entries.len();\n    |                       ^^^^^^^ immutable borrow occurs here\n763 |    let _initial_capacity = entries.capacity();\n764 |    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);\n    |                          ------- mutable borrow later used here\n\nerror[E0502]: cannot borrow `entries` as immutable because it is also borrowed as mutable\n   --> src/map/core.rs:763:28\n    |\n758 |     let ref_mut = RefMut::new(&mut indices, &mut entries);\n    |                                             ------------ mutable borrow occurs here\n...\n763 |    let _initial_capacity = entries.capacity();\n    |                            ^^^^^^^ immutable borrow occurs here\n764 |    let _occupied_entry = ref_mut.insert_unique(hash_value, key, value);\n    |                          ------- mutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: (*left_val == *right_val) is false\n"
      ],
      "input_infer": "hash: HashValue(0..=u64::MAX), key: K(1..=1000), value: V(1..=1000)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hashbrown::HashTable::<usize>::new();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash = HashValue(1);",
                "    let key = 1;",
                "    let value = 2;",
                "    ref_mut.insert_unique(hash, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries.len(), 1);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].key, key);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].value, value);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_ne!(entries[0].hash, HashValue(0));"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.get(&hash.get()), Some(&0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_ne!(entries[0].hash, HashValue(0));",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(1);",
                  "    let key = 1;",
                  "    let value = 2;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.get(&hash.get()), Some(&0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for struct `HashTable` in the current scope\n   --> src/map/core.rs:763:24\n    |\n763 |     assert_eq!(indices.get(&hash.get()), Some(&0));\n    |                        ^^^ method not found in `HashTable<usize>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hashbrown::HashTable::<usize>::new();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash = HashValue(u64::MAX as usize);",
                "    let key = 2;",
                "    let value = 3;",
                "    ref_mut.insert_unique(hash, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    assert_eq!(indices.len(), 0);"
                ],
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    assert_eq!(entries.len(), 0);"
                ],
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries.len(), 1);"
                ],
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].key, key);"
                ],
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].value, value);"
                ],
                [
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].hash, hash);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let _hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let _hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    assert_eq!(indices.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "  let mut ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  " let _hash = HashValue(u64::MAX as usize);  ",
                  " let _key = 2;  ",
                  " let _value = 3;  ",
                  " ref_mut.insert_unique(_hash, _key, _value);  ",
                  " indices = hashbrown::HashTable::<usize>::new();  ",
                  " entries = Vec::new();  ",
                  " ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  " let _hash = HashValue(u64::MAX as usize);  ",
                  " let _key = 2;  ",
                  "  let _value = 3;  ",
                  "  assert_eq!(entries.len(), 0);  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "   let mut ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "   let hash = HashValue(u64::MAX as usize);  ",
                  "   let key = 2;  ",
                  "   let value = 3;  ",
                  "   ref_mut.insert_unique(hash, key, value);  ",
                  "   indices = hashbrown::HashTable::<usize>::new();  ",
                  "   entries = Vec::new();  ",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let indices = hashbrown::HashTable::<usize>::new();",
                  "    let entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "   indices = hashbrown::HashTable::<usize>::new();  ",
                  "   entries.clear();  ",
                  "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "   // let indices = hashbrown::HashTable::<usize>::new();  ",
                  "   // let entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "   // let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "    let hash = HashValue(u64::MAX as usize);",
                  "    let key = 2;",
                  "    let value = 3;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].value, value);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "  let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "  let hash = HashValue(u64::MAX as usize);",
                  "  let key = 2;",
                  "  let value = 3;",
                  "  ref_mut.insert_unique(hash, key, value);",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "  let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   let hash = HashValue(u64::MAX as usize);",
                  "   let key = 2;",
                  "   let value = 3;",
                  "   ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].hash, hash);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0425]: cannot find value `hash` in this scope\n   --> src/map/core.rs:755:27\n    |\n752 |    let _hash = HashValue(u64::MAX as usize);\n    |        ----- `_hash` defined here\n...\n755 |     ref_mut.insert_unique(hash, key, value);\n    |                           ^^^^\n    |\nhelp: the leading underscore in `_hash` marks it as unused, consider renaming it to `hash`\n    |\n752 |    let hash = HashValue(u64::MAX as usize);\n    |        ~~~~\nhelp: consider importing this function\n    |\n741 +    use std::ptr::hash;\n    |\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling syn v2.0.101\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0425]: cannot find value `hash` in this scope\n   --> src/map/core.rs:755:27\n    |\n755 |     ref_mut.insert_unique(hash, key, value);\n    |                           ^^^^ not found in this scope\n    |\nhelp: consider importing this function\n    |\n741 +    use std::ptr::hash;\n    |\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:762:5\n    |\n751 |    let ref_mut = RefMut::new(&mut indices, &mut entries);  \n    |        ------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n755 |     ref_mut.insert_unique(hash, key, value);\n    |             ------------------------------- `ref_mut` moved due to this method call\n...\n762 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hashbrown::HashTable::<usize>::new();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash = HashValue(10);",
                "    let key = 100;",
                "    let value = 200;",
                "    ref_mut.insert_unique(hash, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    assert_eq!(indices.len(), 0);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    assert_eq!(entries.len(), 0);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.len(), 1);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries.len(), 1);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].key, key);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].value, value);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_ne!(entries[0].hash, HashValue(0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    assert_eq!(indices.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    assert_eq!(entries.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_eq!(entries[0].value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    let hash = HashValue(10);",
                  "    let key = 100;",
                  "    let value = 200;",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    assert_ne!(entries[0].hash, HashValue(0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hashbrown::HashTable::<usize>::new();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    ",
                "    for i in 1..=10 {",
                "        let hash = HashValue(i as usize);",
                "        let key = i * 10;",
                "        let value = i * 20;",
                "        ref_mut.insert_unique(hash, key, value);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 10);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 10);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].key, 10);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].key, 20);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].key, 30);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].key, 40);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].key, 50);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[5].key, 60);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[6].key, 70);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[7].key, 80);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[8].key, 90);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[9].key, 100);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].value, 20);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].value, 40);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].value, 60);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].value, 80);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].value, 100);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[5].value, 120);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[6].value, 140);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[7].value, 160);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[8].value, 180);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[9].value, 200);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let _ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let _ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   ",
                  "   for i in 1..=10 {",
                  "  let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "  let hash = HashValue(i as usize);",
                  "  let key = i * 10;",
                  "  let value = i * 20;",
                  "  ref_mut.insert_unique(hash, key, value);",
                  "  }",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "  let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   assert_eq!(entries.len(), 10);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   RefMut::new(&mut indices, &mut entries).insert_unique(HashValue(1), 10, 20);",
                  "   ",
                  "   for i in 1..=10 {",
                  "       let hash = HashValue(i as usize);",
                  "       let key = i * 10;",
                  "       let value = i * 20;",
                  "       RefMut::new(&mut indices, &mut entries).insert_unique(hash, key, value);",
                  "   }",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   RefMut::new(&mut indices, &mut entries);",
                  "   assert_eq!(entries[0].key, 10);",
                  "}"
                ],
                [
                  "{",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "  ",
                  "   for i in 1..=10 {  ",
                  "       let hash = HashValue(i as usize);  ",
                  "       let key = i * 10;  ",
                  "       let value = i * 20;  ",
                  "      let _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "      _ref_mut.insert_unique(hash, key, value);  ",
                  "  }  ",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "  let _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "  assert_eq!(entries[1].key, 20);",
                  "}"
                ],
                [
                  "{",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "  let mut ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "  ",
                  "  for i in 1..=10 {  ",
                  "      let hash = HashValue(i as usize);  ",
                  "      let key = i * 10;  ",
                  "      let value = i * 20;  ",
                  "      ref_mut.insert_unique(hash, key, value);  ",
                  "      ref_mut = RefMut::new(&mut indices, &mut entries); // Re-initialize ref_mut to retain mutable reference.",
                  "  }  ",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "  let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "}"
                ],
                [
                  "{",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "  ",
                  "  for i in 1..=10 {  ",
                  "     let _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "     let hash = HashValue(i as usize);  ",
                  "     let key = i * 10;  ",
                  "     let value = i * 20;  ",
                  "     _ref_mut.insert_unique(hash, key, value);  ",
                  " }  ",
                  " let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  " let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  " let _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "   assert_eq!(entries[3].key, 40);  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "   assert_eq!(entries[4].key, 50);  ",
                  "}"
                ],
                [
                  "{",
                  "  let mut indices = hashbrown::HashTable::<usize>::new();",
                  "  let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "  ",
                  "   for i in 1..=10 {",
                  "       let hash = HashValue(i as usize);",
                  "       let key = i * 10;",
                  "       let value = i * 20;",
                  "       let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "       ref_mut.insert_unique(hash, key, value);",
                  "   }",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "  let ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "   assert_eq!(entries[5].key, 60);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "   let mut _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "   ",
                  "   for i in 1..=10 {  ",
                  "       let hash = HashValue(i as usize);  ",
                  "       let key = i * 10;  ",
                  "       let value = i * 20;  ",
                  "       _ref_mut.insert_unique(hash, key, value);  ",
                  "   }  ",
                  "   let mut indices = hashbrown::HashTable::<usize>::new();  ",
                  "   let mut entries: Vec<Bucket<usize, usize>> = Vec::new();  ",
                  "   let mut _ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                  "   assert_eq!(entries[6].key, 70);  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[7].key, 80);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[8].key, 90);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[9].key, 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].value, 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].value, 40);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].value, 60);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].value, 80);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].value, 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[5].value, 120);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[6].value, 140);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[7].value, 160);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[8].value, 180);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=10 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 10;",
                  "        let value = i * 20;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[9].value, 200);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0425]: cannot find value `ref_mut` in this scope\n   --> src/map/core.rs:757:9\n    |\n751 |    let _ref_mut = RefMut::new(&mut indices, &mut entries);\n    |        -------- `_ref_mut` defined here\n...\n757 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^\n    |\nhelp: the leading underscore in `_ref_mut` marks it as unused, consider renaming it to `ref_mut`\n    |\n751 |    let ref_mut = RefMut::new(&mut indices, &mut entries);\n    |        ~~~~~~~\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nerror[E0425]: cannot find value `ref_mut` in this scope\n   --> src/map/core.rs:757:9\n    |\n751 |    let _ref_mut = RefMut::new(&mut indices, &mut entries);  \n    |        -------- `_ref_mut` defined here\n...\n757 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^\n    |\nhelp: the leading underscore in `_ref_mut` marks it as unused, consider renaming it to `ref_mut`\n    |\n751 |    let ref_mut = RefMut::new(&mut indices, &mut entries);  \n    |        ~~~~~~~\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0382]: use of moved value: `_ref_mut`\n   --> src/map/core.rs:757:8\n    |\n751 |    let mut _ref_mut = RefMut::new(&mut indices, &mut entries);  \n    |        ------------ move occurs because `_ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n752 |    \n753 |    for i in 1..=10 {  \n    |    --------------- inside of this loop\n...\n757 |        _ref_mut.insert_unique(hash, key, value);  \n    |        ^^^^^^^^ ------------------------------- `_ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `_ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 7 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 7 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=10 {\n    |     --------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hashbrown::HashTable::<usize>::new();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "",
                "    for i in 1..=5 {",
                "        let hash = HashValue(i as usize);",
                "        let key = 50;",
                "        let value = i * 3;",
                "        ref_mut.insert_unique(hash, key, value);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 5);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 5);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].key, 50);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].value, 3);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].key, 50);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].value, 6);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].key, 50);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].value, 9);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].key, 50);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].value, 12);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].key, 50);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].value, 15);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(indices.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].key, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[0].value, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].key, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[1].value, 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].key, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[2].value, 9);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].key, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[3].value, 12);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].key, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "",
                  "    for i in 1..=5 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = 50;",
                  "        let value = i * 3;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    assert_eq!(entries[4].value, 15);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `ref_mut`\n   --> src/map/core.rs:758:13\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ref_mut`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:758:9\n    |\n758 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:754:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |\n750 |     for i in 1..=5 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |         ^^^^^^^ ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 11 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut indices = hashbrown::HashTable::<usize>::new();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    ",
                "    for i in 1..=4 {",
                "        let hash = HashValue(i as usize);",
                "        let key = i * 100;",
                "        let value = i * 200;",
                "        ref_mut.insert_unique(hash, key, value);",
                "    }",
                "    let hash = HashValue(5);",
                "    let key = 500;",
                "    let value = 1000; ",
                "    ref_mut.insert_unique(hash, key, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries.len(), 5);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[0].key, 100);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[0].value, 200);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[1].key, 200);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[1].value, 400);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[2].key, 300);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[2].value, 600);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[3].key, 400);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[3].value, 800);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[4].key, 500);"
                ],
                [
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[4].value, 1000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[0].key, 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[0].value, 200);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[1].key, 200);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[1].value, 400);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[2].key, 300);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[2].value, 600);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[3].key, 400);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[3].value, 800);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[4].key, 500);",
                  "}"
                ],
                [
                  "{",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ",
                  "    for i in 1..=4 {",
                  "        let hash = HashValue(i as usize);",
                  "        let key = i * 100;",
                  "        let value = i * 200;",
                  "        ref_mut.insert_unique(hash, key, value);",
                  "    }",
                  "    let hash = HashValue(5);",
                  "    let key = 500;",
                  "    let value = 1000; ",
                  "    ref_mut.insert_unique(hash, key, value);",
                  "    let mut indices = hashbrown::HashTable::<usize>::new();",
                  "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(4);",
                  "    let mut ref_mut = RefMut::new(&mut indices, &mut entries);",
                  "    ref_mut.insert_unique(HashValue(1), 100, 200);",
                  "    ref_mut.insert_unique(HashValue(2), 200, 400);",
                  "    ref_mut.insert_unique(HashValue(3), 300, 600);",
                  "    ref_mut.insert_unique(HashValue(4), 400, 800);",
                  "    ref_mut.insert_unique(HashValue(5), 500, 1000);",
                  "    assert_eq!(entries[4].value, 1000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/core.rs:742:8\n    |\n742 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:748:9\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> src/map/core.rs:762:9\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----^^^^^^^\n    |         |\n    |         help: remove this `mut`\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:759:5\n    |\n748 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n749 |     \n750 |     for i in 1..=4 {\n    |     -------------- inside of this loop\n...\n754 |         ref_mut.insert_unique(hash, key, value);\n    |                 ------------------------------- `ref_mut` moved due to this method call, in previous iteration of loop\n...\n759 |     ref_mut.insert_unique(hash, key, value);\n    |     ^^^^^^^ value used here after move\n    |\nnote: `core::RefMut::<'a, K, V>::insert_unique` takes ownership of the receiver `self`, which moves `ref_mut`\n   --> src/map/core.rs:551:22\n    |\n551 |     fn insert_unique(self, hash: HashValue, key: K, value: V) -> OccupiedEntry<'a, K, V> {\n    |                      ^^^^\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:764:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:765:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n763 |     ref_mut.insert_unique(HashValue(1), 100, 200);\n764 |     ref_mut.insert_unique(HashValue(2), 200, 400);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:766:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n765 |     ref_mut.insert_unique(HashValue(3), 300, 600);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |     ^^^^^^^ value used here after move\n\nerror[E0382]: use of moved value: `ref_mut`\n   --> src/map/core.rs:767:5\n    |\n762 |     let mut ref_mut = RefMut::new(&mut indices, &mut entries);\n    |         ----------- move occurs because `ref_mut` has type `core::RefMut<'_, usize, usize>`, which does not implement the `Copy` trait\n...\n766 |     ref_mut.insert_unique(HashValue(4), 400, 800);\n    |             ------------------------------------- `ref_mut` moved due to this method call\n767 |     ref_mut.insert_unique(HashValue(5), 500, 1000);\n    |     ^^^^^^^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 5 previous errors; 10 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}