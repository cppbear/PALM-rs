{
  "name": "indexmap::map::iter::map::iter::Drain<'a, K, V>::as_slice",
  "name_with_impl": "indexmap::map::iter::{impl#32}::as_slice",
  "mod_info": {
    "name": "map::iter",
    "loc": "src/map.rs:5:1:5:10"
  },
  "visible": true,
  "loc": "src/map/iter.rs:294:5:296:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: Slice::from_slice(self.iter.as_slice())\n"
      ],
      "input_infer": "K: [0, 1000], V: [0, 500]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                "    let drain = Drain::new(vec.drain(..));",
                "    let _slice = drain.as_slice();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert!(slice.entries.is_empty());"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(std::mem::size_of_val(slice), std::mem::size_of::<Slice<i32, i32>>());"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert!(std::ptr::eq(slice.entries.as_ptr(), drain.iter.as_slice().as_ptr()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert!(slice.entries.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(std::mem::size_of_val(slice), std::mem::size_of::<Slice<i32, i32>>());",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = Vec::new();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert!(std::ptr::eq(slice.entries.as_ptr(), drain.iter.as_slice().as_ptr()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `[Bucket<i32, i32>]` cannot be known at compilation time\n   --> src/map/iter.rs:790:66\n    |\n790 |     assert_eq!(std::mem::size_of_val(slice), std::mem::size_of::<Slice<i32, i32>>());\n    |                                                                  ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `map::slice::Slice<i32, i32>`, the trait `Sized` is not implemented for `[Bucket<i32, i32>]`, which is required by `map::slice::Slice<i32, i32>: Sized`\nnote: required because it appears within the type `map::slice::Slice<i32, i32>`\n   --> src/map/slice.rs:23:12\n    |\n23  | pub struct Slice<K, V> {\n    |            ^^^^^\nnote: required by an implicit `Sized` bound in `std::mem::size_of`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:312:22\n    |\n312 | pub const fn size_of<T>() -> usize {\n    |                      ^ required by the implicit `Sized` requirement on this type parameter in `size_of`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 8 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                "    let drain = Drain::new(vec.drain(..));",
                "    let _slice = drain.as_slice();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 1);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 1);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 50);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 50);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:62\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 1, value: 50 }];\n    |                                                              ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:62\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 1, value: 50 }];\n    |                                                              ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:62\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 1, value: 50 }];\n    |                                                              ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:62\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 1, value: 50 }];\n    |                                                              ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:62\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 1, value: 50 }];\n    |                                                              ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:62\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 1, value: 50 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 1, value: 50 }];\n    |                                                              ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                "        Bucket { hash: 0, key: 1, value: 50 },",
                "        Bucket { hash: 1, key: 2, value: 100 },",
                "        Bucket { hash: 2, key: 3, value: 150 },",
                "    ];",
                "    let drain = Drain::new(vec.drain(..));",
                "    let _slice = drain.as_slice();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 3);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 1);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 50);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[1].key, 2);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[1].value, 100);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[2].key, 3);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[2].value, 150);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 50);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[1].key, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[1].value, 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[2].key, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "        Bucket { hash: 0, key: 1, value: 50 },",
                  "        Bucket { hash: 1, key: 2, value: 100 },",
                  "        Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![",
                  "    Bucket { hash: 0, key: 1, value: 50 },",
                  "    Bucket { hash: 1, key: 2, value: 100 },",
                  "    Bucket { hash: 2, key: 3, value: 150 },",
                  "    ];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[2].value, 150);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:785:24\n    |\n785 |         Bucket { hash: 0, key: 1, value: 50 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n785 |         Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:786:24\n    |\n786 |         Bucket { hash: 1, key: 2, value: 100 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n786 |         Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:24\n    |\n787 |         Bucket { hash: 2, key: 3, value: 150 },\n    |                        ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |         Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                        ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:792:20\n    |\n792 |     Bucket { hash: 0, key: 1, value: 50 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n792 |     Bucket { hash: HashValue(0), key: 1, value: 50 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:793:20\n    |\n793 |     Bucket { hash: 1, key: 2, value: 100 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n793 |     Bucket { hash: HashValue(1), key: 2, value: 100 },\n    |                    ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:794:20\n    |\n794 |     Bucket { hash: 2, key: 3, value: 150 },\n    |                    ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n794 |     Bucket { hash: HashValue(2), key: 3, value: 150 },\n    |                    ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                "    let drain = Drain::new(vec.drain(..));",
                "    let _slice = drain.as_slice();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 1000);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 0);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[999].key, 999);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 0);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[999].value, 499);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[999].key, 999);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[999].value, 499);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:75\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:75\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:75\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:75\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:75\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:75\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:75\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:75\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:75\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:75\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: i, key: i, value: i % 500 }).collect();\n    |                                                                           ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = (0..1000).map(|i| Bucket { hash: HashValue(i), key: i, value: i % 500 }).collect();\n    |                                                                           ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                "    let drain = Drain::new(vec.drain(..));",
                "    let _slice = drain.as_slice();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 1);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 0);"
                ],
                [
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let _slice = drain.as_slice();",
                  "    let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];",
                  "    let drain = Drain::new(vec.drain(..));",
                  "    let slice = drain.as_slice();",
                  "    assert_eq!(slice.entries[0].value, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:62\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 0, value: 0 }];\n    |                                                              ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:62\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 0, value: 0 }];\n    |                                                              ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:62\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 0, value: 0 }];\n    |                                                              ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:62\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 0, value: 0 }];\n    |                                                              ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `ntest::timeout`\n   --> src/map/iter.rs:780:8\n    |\n780 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:784:62\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n784 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 0, value: 0 }];\n    |                                                              ++++++++++ +\n\nerror[E0308]: mismatched types\n   --> src/map/iter.rs:787:62\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: 0, key: 0, value: 0 }];\n    |                                                              ^ expected `HashValue`, found integer\n    |\nhelp: try wrapping the expression in `HashValue`\n    |\n787 |     let mut vec: Vec<Bucket<i32, i32>> = vec![Bucket { hash: HashValue(0), key: 0, value: 0 }];\n    |                                                              ++++++++++ +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `indexmap` (lib test) generated 8 warnings\nerror: could not compile `indexmap` (lib test) due to 2 previous errors; 8 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}