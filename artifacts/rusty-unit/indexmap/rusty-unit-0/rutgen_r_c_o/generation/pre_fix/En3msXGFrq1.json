{
  "name": "indexmap::map::map::IndexMap<K, V, S>::remove",
  "name_with_impl": "indexmap::map::{impl#6}::remove",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:122:1:122:13"
  },
  "visible": true,
  "loc": "src/map.rs:828:5:833:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "0 <= K, V <= 10^6, for non-empty index maps 0 < size <= 10^5, query key type Q: &K where Q is a valid Hash + Equivalent<K>\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(1, 10);",
                "    map.insert(2, 20);",
                "    map.insert(3, 30);",
                "    let _ = map.remove(&2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&2), None);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&1), Some(&10));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&3), Some(&30));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.len(), 2);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert!(map.contains_key(&1));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert!(map.contains_key(&3));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert!(!map.contains_key(&2));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&2), None);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&1), Some(&10));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&3), Some(&30));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert!(map.contains_key(&1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert!(map.contains_key(&3));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&2);",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert!(!map.contains_key(&2));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    map.insert(1, 10);",
                "    map.insert(2, 20);",
                "    map.insert(3, 30);",
                "    let _ = map.remove(&4);",
                "}"
              ],
              "oracles": [
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.len(), 3);"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&1), Some(&10));"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&2), Some(&20));"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&3), Some(&30));"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.remove(&4), None);"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.len(), 3);"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&1), Some(&10));"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&2), Some(&20));"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&3), Some(&30));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&1), Some(&10));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&2), Some(&20));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&3), Some(&30));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.remove(&4), None);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&1), Some(&10));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&2), Some(&20));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    let _ = map.remove(&4);",
                  "    let map = IndexMap::new();",
                  "    map.insert(1, 10);",
                  "    map.insert(2, 20);",
                  "    map.insert(3, 30);",
                  "    assert_eq!(map.get(&3), Some(&30));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.9.3\n   Compiling rand_core v0.6.4\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1668:20\n     |\n1668 |     assert_eq!(map.remove(&4), None);\n     |                    ^^^^^^\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n1668 |     assert_eq!(map.remove(&4), None);\n     |                --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&4);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0596]: cannot borrow `map` as mutable, as it is not declared as mutable\n    --> src/map.rs:1664:9\n     |\n1664 |     let map = IndexMap::new();\n     |         ^^^ not mutable\n1665 |     map.insert(1, 10);\n     |     --- cannot borrow as mutable\n1666 |     map.insert(2, 20);\n     |     --- cannot borrow as mutable\n1667 |     map.insert(3, 30);\n     |     --- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1664 |     let mut map = IndexMap::new();\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                "    let _ = map.remove(&1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                  "    assert_eq!(map.remove(&1), None);"
                ],
                [
                  "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                  "    assert!(map.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                  "    let _ = map.remove(&1);",
                  "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                  "    assert_eq!(map.remove(&1), None);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                  "    let _ = map.remove(&1);",
                  "    let mut map: IndexMap<i32, i32> = IndexMap::new();",
                  "    assert!(map.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    for i in 1..=5 {",
                "        map.insert(i, i * 10);",
                "    }",
                "    let _ = map.remove(&3);",
                "    let _ = map.remove(&1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert!(map.get(&3).is_none());"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert!(map.get(&1).is_none());"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.get(&2), Some(&20));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.get(&4), Some(&40));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.get(&5), Some(&50));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&3);",
                  "    let _ = map.remove(&1);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert!(map.get(&3).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&3);",
                  "    let _ = map.remove(&1);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert!(map.get(&1).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&3);",
                  "    let _ = map.remove(&1);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.get(&2), Some(&20));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&3);",
                  "    let _ = map.remove(&1);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.get(&4), Some(&40));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&3);",
                  "    let _ = map.remove(&1);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 1..=5 {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.get(&5), Some(&50));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    for i in 0..100_000 {",
                "        map.insert(i, i as i32 * 10);",
                "    }",
                "    let _ = map.remove(&99999);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    assert_eq!(map.len(), 100_000);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    assert!(map.contains_key(&99999));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let removed_value = map.remove(&99999);",
                  "    assert!(removed_value.is_none());"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let removed_value = map.remove(&99999);",
                  "    assert_eq!(map.len(), 99_999);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let removed_value = map.remove(&99999);",
                  "    assert!(!map.contains_key(&99999));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "        map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let _ = map.remove(&99999);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    assert_eq!(map.len(), 100_000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "        map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let _ = map.remove(&99999);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    assert!(map.contains_key(&99999));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "        map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let _ = map.remove(&99999);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let removed_value = map.remove(&99999);",
                  "    assert!(removed_value.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "        map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let _ = map.remove(&99999);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let removed_value = map.remove(&99999);",
                  "    assert_eq!(map.len(), 99_999);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "        map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let _ = map.remove(&99999);",
                  "    let mut map = IndexMap::new();",
                  "    for i in 0..100_000 {",
                  "    map.insert(i, i as i32 * 10);",
                  "    }",
                  "    let removed_value = map.remove(&99999);",
                  "    assert!(!map.contains_key(&99999));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = IndexMap::new();",
                "    for i in (1..=100_000).rev() {",
                "        map.insert(i, i * 10);",
                "    }",
                "    let _ = map.remove(&100_000);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = IndexMap::new();",
                  "    assert_eq!(map.len(), 0);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.len(), 100_000);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    let result = map.remove(&100_000);",
                  "    assert_eq!(result, Some(1000000));"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    let result = map.remove(&100_000);",
                  "    assert_eq!(map.len(), 99_999);"
                ],
                [
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    let result = map.remove(&100_000);",
                  "    assert!(!map.contains_key(&100_000));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&100_000);",
                  "    let mut map = IndexMap::new();",
                  "    assert_eq!(map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&100_000);",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    assert_eq!(map.len(), 100_000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&100_000);",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    let result = map.remove(&100_000);",
                  "    assert_eq!(result, Some(1000000));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&100_000);",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    let result = map.remove(&100_000);",
                  "    assert_eq!(map.len(), 99_999);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "        map.insert(i, i * 10);",
                  "    }",
                  "    let _ = map.remove(&100_000);",
                  "    let mut map = IndexMap::new();",
                  "    for i in (1..=100_000).rev() {",
                  "    map.insert(i, i * 10);",
                  "    }",
                  "    let result = map.remove(&100_000);",
                  "    assert!(!map.contains_key(&100_000));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&100_000);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0282]: type annotations needed for `map::IndexMap<_, _>`\n    --> src/map.rs:1664:9\n     |\n1664 |     let mut map = IndexMap::new();\n     |         ^^^^^^^   --------------- type must be known at this point\n     |\nhelp: consider giving `map` an explicit type, where the type for type parameter `K` is specified\n     |\n1664 |     let mut map: map::IndexMap<K, V> = IndexMap::new();\n     |                +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 1 previous error; 9 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct NonHashable;",
                "    let mut map = IndexMap::new();",
                "    map.insert(NonHashable, 1);",
                "    let key = NonHashable;",
                "    let _ = map.remove(&key);",
                "}"
              ],
              "oracles": [
                [
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    assert!(map.get(&key).is_none());"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    let result = map.remove(&key);",
                  "    assert_eq!(result, Some(1));"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    let result = map.remove(&key);",
                  "    assert!(map.get(&key).is_none());"
                ],
                [
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    let result = map.remove(&key);",
                  "    assert_eq!(map.len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct NonHashable;",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(NonHashable, 1);",
                  "    let key = NonHashable;",
                  "    let _ = map.remove(&key);",
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    assert!(map.get(&key).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct NonHashable;",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(NonHashable, 1);",
                  "    let key = NonHashable;",
                  "    let _ = map.remove(&key);",
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct NonHashable;",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(NonHashable, 1);",
                  "    let key = NonHashable;",
                  "    let _ = map.remove(&key);",
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    let result = map.remove(&key);",
                  "    assert_eq!(result, Some(1));",
                  "}"
                ],
                [
                  "{",
                  "    struct NonHashable;",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(NonHashable, 1);",
                  "    let key = NonHashable;",
                  "    let _ = map.remove(&key);",
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    let result = map.remove(&key);",
                  "    assert!(map.get(&key).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct NonHashable;",
                  "    let mut map = IndexMap::new();",
                  "    map.insert(NonHashable, 1);",
                  "    let key = NonHashable;",
                  "    let _ = map.remove(&key);",
                  "    let map = IndexMap::new();",
                  "    let key = NonHashable;",
                  "    map.insert(NonHashable, 1);",
                  "    let result = map.remove(&key);",
                  "    assert_eq!(map.len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1666:21\n     |\n1666 |     assert!(map.get(&key).is_none());\n     |                 --- ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::get`\n    --> src/map.rs:713:21\n     |\n711  |     pub fn get<Q>(&self, key: &Q) -> Option<&V>\n     |            --- required by a bound in this associated function\n712  |     where\n713  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::get`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<_>` is not satisfied\n    --> src/map.rs:1666:21\n     |\n1666 |     assert!(map.get(&key).is_none());\n     |                 --- ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<_>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<_>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::get`\n    --> src/map.rs:713:28\n     |\n711  |     pub fn get<Q>(&self, key: &Q) -> Option<&V>\n     |            --- required by a bound in this associated function\n712  |     where\n713  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::get`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 9 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 9 warnings\nerror: could not compile `indexmap` (lib test) due to 6 previous errors; 9 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1667:22\n     |\n1667 |     let result = map.remove(&key);\n     |                      ^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1667:29\n     |\n1667 |     let result = map.remove(&key);\n     |                      ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                      |\n     |                      required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1667:29\n     |\n1667 |     let result = map.remove(&key);\n     |                      ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                      |\n     |                      required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 8 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling getrandom v0.3.2\n   Compiling zerocopy v0.8.25\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1667:22\n     |\n1667 |     let result = map.remove(&key);\n     |                      ^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1667:29\n     |\n1667 |     let result = map.remove(&key);\n     |                      ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                      |\n     |                      required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1667:29\n     |\n1667 |     let result = map.remove(&key);\n     |                      ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                      |\n     |                      required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1668:21\n     |\n1668 |     assert!(map.get(&key).is_none());\n     |                 --- ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::get`\n    --> src/map.rs:713:21\n     |\n711  |     pub fn get<Q>(&self, key: &Q) -> Option<&V>\n     |            --- required by a bound in this associated function\n712  |     where\n713  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::get`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1668:21\n     |\n1668 |     assert!(map.get(&key).is_none());\n     |                 --- ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::get`\n    --> src/map.rs:713:28\n     |\n711  |     pub fn get<Q>(&self, key: &Q) -> Option<&V>\n     |            --- required by a bound in this associated function\n712  |     where\n713  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::get`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 10 previous errors; 10 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling getrandom v0.3.2\n   Compiling quote v1.0.40\n   Compiling syn v2.0.101\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rand_core v0.9.3\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.9.0\n   Compiling rand v0.9.1\n   Compiling serde_derive v1.0.219\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling indexmap v2.9.0 (/home/abezbm/rust-utgen-test-crates-new/indexmap)\nwarning: unused import: `super::*`\n   --> src/map/slice.rs:520:9\n    |\n520 |     use super::*;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n --> src/map/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/map/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused macro definition: `move_index_oob`\n   --> src/map/tests.rs:817:14\n    |\n817 | macro_rules! move_index_oob {\n    |              ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/map.rs:1655:8\n     |\n1655 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/set/slice.rs:334:9\n    |\n334 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n --> src/set/tests.rs:1:5\n  |\n1 | use super::*;\n  |     ^^^^^^^^\n\nwarning: unused import: `std::string::String`\n --> src/set/tests.rs:2:5\n  |\n2 | use std::string::String;\n  |     ^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1661:9\n     |\n1661 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1663:17\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ^^^^^^\n     |\n     = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1663:24\n     |\n1663 |     let _ = map.remove(&key);\n     |                 ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                 |\n     |                 required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:8\n     |\n383  |     K: Hash + Eq,\n     |        ^^^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: std::cmp::Eq` is not satisfied\n    --> src/map.rs:1666:9\n     |\n1666 |     map.insert(NonHashable, 1);\n     |         ^^^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::insert`\n    --> src/map.rs:383:15\n     |\n383  |     K: Hash + Eq,\n     |               ^^ required by this bound in `IndexMap::<K, V, S>::insert`\n...\n400  |     pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n     |            ------ required by a bound in this associated function\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nwarning: use of deprecated method `map::IndexMap::<K, V, S>::remove`: `remove` disrupts the map order -- use `swap_remove` or `shift_remove` for explicit behavior.\n    --> src/map.rs:1667:22\n     |\n1667 |     let result = map.remove(&key);\n     |                      ^^^^^^\n\nerror[E0277]: the trait bound `NonHashable: Hash` is not satisfied\n    --> src/map.rs:1667:29\n     |\n1667 |     let result = map.remove(&key);\n     |                      ------ ^^^^ the trait `Hash` is not implemented for `NonHashable`\n     |                      |\n     |                      required by a bound introduced by this call\n     |\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:21\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                     ^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Hash)]`\n     |\n1659 +     #[derive(Hash)]\n1660 |     struct NonHashable;\n     |\n\nerror[E0277]: the trait bound `NonHashable: equivalent::Equivalent<NonHashable>` is not satisfied\n    --> src/map.rs:1667:29\n     |\n1667 |     let result = map.remove(&key);\n     |                      ------ ^^^^ the trait `std::cmp::Eq` is not implemented for `NonHashable`, which is required by `NonHashable: equivalent::Equivalent<NonHashable>`\n     |                      |\n     |                      required by a bound introduced by this call\n     |\n     = note: required for `NonHashable` to implement `equivalent::Equivalent<NonHashable>`\nnote: required by a bound in `map::IndexMap::<K, V, S>::remove`\n    --> src/map.rs:830:28\n     |\n828  |     pub fn remove<Q>(&mut self, key: &Q) -> Option<V>\n     |            ------ required by a bound in this associated function\n829  |     where\n830  |         Q: ?Sized + Hash + Equivalent<K>,\n     |                            ^^^^^^^^^^^^^ required by this bound in `IndexMap::<K, V, S>::remove`\nhelp: consider annotating `NonHashable` with `#[derive(Eq)]`\n     |\n1659 +     #[derive(Eq)]\n1660 |     struct NonHashable;\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `indexmap` (lib test) generated 10 warnings\nerror: could not compile `indexmap` (lib test) due to 8 previous errors; 10 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}