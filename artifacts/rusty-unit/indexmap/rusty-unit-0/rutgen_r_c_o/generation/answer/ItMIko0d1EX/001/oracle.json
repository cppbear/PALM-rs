[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
          "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
          "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
            "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
            "    assert!(map.into_iter().eq([(0, '_'), (1, 'A'), (5, 'E'), (3, 'C'), (2, 'B'), (4, 'D')]));"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
            "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
            "    assert_eq!(_removed, &[(2, 'b'), (3, 'c')]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
            "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
            "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
            "    assert!(map.into_iter().eq([(0, '_'), (1, 'A'), (5, 'E'), (3, 'C'), (2, 'B'), (4, 'D')]));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
            "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]);",
            "    let new = vec![(5, 'E'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..4, new).collect();",
            "    assert_eq!(_removed, &[(2, 'b'), (3, 'c')]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
          "    let new = vec![(3, 'E')];",
          "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(0, '_'), (1, 'a'), (2, 'b')]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(3, 'E'), (0, '_'), (1, 'a'), (2, 'b')]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    assert_eq!(_removed.len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(0, '_'), (1, 'a'), (2, 'b')]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(3, 'E'), (0, '_'), (1, 'a'), (2, 'b')]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..0, new).collect();",
            "    assert_eq!(_removed.len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
          "    let new = vec![(3, 'E')];",
          "    let _removed: Vec<_> = map.splice(2..0, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(std::panic::catch_unwind(|| {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(2..0, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(std::panic::catch_unwind(|| {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
          "    let new = vec![(3, 'E')];",
          "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.len() == 3);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&0).unwrap() == '_');"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&1).unwrap() == 'a');"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&2).unwrap() == 'b');"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&3).is_none());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&4).is_none());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&5).is_none());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&6).is_none());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&7).is_none());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&8).is_none());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&9).is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.len() == 3);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&0).unwrap() == '_');",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&1).unwrap() == 'a');",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&2).unwrap() == 'b');",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&3).is_none());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&4).is_none());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&5).is_none());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&6).is_none());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&7).is_none());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&8).is_none());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new = vec![(3, 'E')];",
            "    let _removed: Vec<_> = map.splice(0..10, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.get(&9).is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
          "    let new = vec![(4, 'E'), (5, 'F')];",
          "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let splice_result = map.splice(1..3, new);",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(0, 'a'), (4, 'E'), (5, 'F'), (3, 'd')]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let splice_result = map.splice(1..3, new);",
            "    assert_eq!(splice_result.collect::<Vec<_>>(), vec![(1, 'b'), (2, 'c')]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let splice_result = map.splice(1..3, new);",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(0, 'a'), (4, 'E'), (5, 'F'), (3, 'd')]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let splice_result = map.splice(1..3, new);",
            "    assert_eq!(splice_result.collect::<Vec<_>>(), vec![(1, 'b'), (2, 'c')]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
          "    let new: Vec<(i32, char)> = vec![];",
          "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.as_entries(), &[(0, '_'), (1, 'a'), (2, 'b')]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.entries.len(), 3);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.splice(0..3, vec![]).is_empty());"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.as_entries(), &[]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.entries.len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new: Vec<(i32, char)> = vec![];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.as_entries(), &[(0, '_'), (1, 'a'), (2, 'b')]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new: Vec<(i32, char)> = vec![];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.entries.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new: Vec<(i32, char)> = vec![];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert!(map.splice(0..3, vec![]).is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new: Vec<(i32, char)> = vec![];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.as_entries(), &[]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    let new: Vec<(i32, char)> = vec![];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b')]);",
            "    assert_eq!(map.entries.len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
          "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
          "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(0, '_'), (2, 'D'), (3, 'E'), (4, 'F')]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(removed.len(), 2);"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(removed[0], (1, 'a'));"
          ],
          [
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(removed[1], (2, 'b'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(0, '_'), (2, 'D'), (3, 'E'), (4, 'F')]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(removed.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(removed[0], (1, 'a'));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let _removed: Vec<_> = map.splice(1..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '_'), (1, 'a'), (2, 'b'), (3, 'c')]);",
            "    let new = vec![(2, 'D'), (3, 'E'), (4, 'F')];",
            "    let removed: Vec<_> = map.splice(1..3, new).collect();",
            "    assert_eq!(removed[1], (2, 'b'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
          "    let new = vec![(3, 'A')];",
          "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
            "    let new = vec![(3, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
            "    assert!(map.into_iter().eq([(0, 'X'), (1, 'Y'), (2, 'Z')]));"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
            "    let new = vec![(3, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
            "    assert_eq!(_removed, []);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
            "    let new = vec![(3, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
            "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
            "    let new = vec![(3, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
            "    assert!(map.into_iter().eq([(0, 'X'), (1, 'Y'), (2, 'Z')]));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
            "    let new = vec![(3, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
            "    let mut map = IndexMap::from([(0, 'X'), (1, 'Y'), (2, 'Z')]);",
            "    let new = vec![(3, 'A')];",
            "    let _removed: Vec<_> = map.splice(2..2, new).collect();",
            "    assert_eq!(_removed, []);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
          "    let new = vec![(4, 'E'), (5, 'F')];",
          "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(4, 'E'), (5, 'F')]);"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert_eq!(removed.len(), 4);"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(0, 'a')));"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(1, 'b')));"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(2, 'c')));"
          ],
          [
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(3, 'd')));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert_eq!(map.into_iter().collect::<Vec<_>>(), vec![(4, 'E'), (5, 'F')]);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert_eq!(removed.len(), 4);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(0, 'a')));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(1, 'b')));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(2, 'c')));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let _removed: Vec<_> = map.splice(0..4, new).collect();",
            "    let mut map = IndexMap::from([(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]);",
            "    let new = vec![(4, 'E'), (5, 'F')];",
            "    let removed: Vec<_> = map.splice(0..4, new).collect();",
            "    assert!(removed.contains(&(3, 'd')));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
          "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
          "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
            "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    assert!(map.into_iter().eq([(3, 'A'), (4, 'B'), (5, 'C')]));"
          ],
          [
            "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
            "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    assert_eq!(removed.len(), 3);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
            "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
            "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    assert!(map.into_iter().eq([(3, 'A'), (4, 'B'), (5, 'C')]));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
            "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    let mut map = IndexMap::from([(0, '1'), (1, '2'), (2, '3')]);",
            "    let new = vec![(3, 'A'), (4, 'B'), (5, 'C')];",
            "    let _removed: Vec<_> = map.splice(0..3, new).collect();",
            "    assert_eq!(removed.len(), 3);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]