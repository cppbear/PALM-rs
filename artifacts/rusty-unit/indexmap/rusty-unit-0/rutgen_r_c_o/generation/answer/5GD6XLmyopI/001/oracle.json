[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[should_panic]",
      "fn test_append_with_invalid_state() {",
      "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
      "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
      "    a.append(&mut b);",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
          "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
          "    a.append(&mut b);",
          "}"
        ],
        "oracles": [
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    assert_eq!(a.len(), 2);"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    assert_eq!(b.len(), 2);"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 4);"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(b.capacity(), old_capacity);"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert!(a.keys().eq(&[1, 2, 3, 4]));"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(a[&3], \"c\");"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(a[&4], \"d\");"
          ],
          [
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    let mut a_invalid: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b_invalid: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(std::panic::catch_unwind(|| a_invalid.append(&mut b_invalid)).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    assert_eq!(a.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    assert_eq!(b.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 4);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(b.capacity(), old_capacity);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert!(a.keys().eq(&[1, 2, 3, 4]));",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(a[&3], \"c\");",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    assert_eq!(a[&4], \"d\");",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let mut b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    a.append(&mut b);",
            "    let a = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    let b = IndexMap::from([(3, \"c\"), (4, \"d\")]);",
            "    let old_capacity = b.capacity();",
            "    a.append(&mut b);",
            "    let mut a_invalid: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b_invalid: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(std::panic::catch_unwind(|| a_invalid.append(&mut b_invalid)).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut a = IndexMap::from([(1, \"a\")]);",
          "    let mut b = IndexMap::new();",
          "    a.append(&mut b);",
          "}"
        ],
        "oracles": [
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(a.len() == 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(b.len() == 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(a.len() == 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(b.len() == 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    assert!(a.len() == 1);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    assert!(b.len() == 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(a.len() == 1);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(b.len() == 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(b.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(a.len() == 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(b.len() == 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(a.len() == 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(b.len() == 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    assert!(a.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    assert!(b.len() == 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(a.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(b.len() == 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    a.append(&mut b);",
            "    let mut a = IndexMap::from([(1, \"a\")]);",
            "    let mut b = IndexMap::new();",
            "    a.append(&mut b);",
            "    assert!(b.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut a = IndexMap::new();",
          "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
          "    a.append(&mut b);",
          "}"
        ],
        "oracles": [
          [
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    assert!(result.is_err());"
          ],
          [
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 2);"
          ],
          [
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&1], \"a\");"
          ],
          [
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&2], \"b\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&1], \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let a: IndexMap<i32, &str> = IndexMap::new();",
            "    let b: IndexMap<i32, &str> = IndexMap::new();",
            "    let result = panic::catch_unwind(|| { a.append(&mut b); });",
            "    let mut a = IndexMap::new();",
            "    let mut b = IndexMap::from([(1, \"a\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&2], \"b\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut a = IndexMap::from([(1, \"old\")]);",
          "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
          "    a.append(&mut b);",
          "}"
        ],
        "oracles": [
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(a.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(std::panic::catch_unwind(|| { a.append(&mut b); }).is_err());"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    assert_eq!(a.len(), 1);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    assert_eq!(b.len(), 2);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 3);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&1], \"new\");"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&2], \"b\");"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert!(a.keys().eq(&[1, 2]));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(a.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(std::panic::catch_unwind(|| { a.append(&mut b); }).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    assert_eq!(a.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    assert_eq!(b.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&1], \"new\");",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert_eq!(a[&2], \"b\");",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from([(1, \"old\")]);",
            "    let mut b = IndexMap::from([(1, \"new\"), (2, \"b\")]);",
            "    a.append(&mut b);",
            "    assert!(a.keys().eq(&[1, 2]));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
          "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
          "    a.append(&mut b);",
          "}"
        ],
        "oracles": [
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(a.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    assert_eq!(a.len(), 500_000);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    assert_eq!(b.len(), 500_000);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    assert_eq!(b.capacity(), a.capacity());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(a.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    assert_eq!(a.len(), 500_000);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    assert_eq!(b.len(), 500_000);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::from_iter((0..500_000).map(|i| (i, i.to_string())));",
            "    let mut b = IndexMap::from_iter((500_000..1_000_000).map(|i| (i, i.to_string())));",
            "    assert_eq!(b.capacity(), a.capacity());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut a = IndexMap::with_capacity(100);",
          "    let mut b = IndexMap::with_capacity(200);",
          "    for i in 0..50 {",
          "        a.insert(i, \"foo\");",
          "        b.insert(i + 50, \"bar\");",
          "    }",
          "    a.append(&mut b);",
          "}"
        ],
        "oracles": [
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(a.is_empty());"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(b.is_empty());"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    assert_eq!(a.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    assert!(a.insert(i, \"foo\").is_none());"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    assert!(b.insert(i + 50, \"bar\").is_none());"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 50);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(b.capacity(), 200);"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert!(a.keys().eq((0..50).chain(50..100)));"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(a.get(&50), Some(&\"bar\"));"
          ],
          [
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(a.get(&0), Some(&\"foo\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(a.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    assert!(b.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    assert_eq!(a.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    assert!(a.insert(i, \"foo\").is_none());",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    assert!(b.insert(i + 50, \"bar\").is_none());",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(a.len(), 50);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(b.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(b.capacity(), 200);",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert!(a.keys().eq((0..50).chain(50..100)));",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(a.get(&50), Some(&\"bar\"));",
            "}"
          ],
          [
            "{",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "        a.insert(i, \"foo\");",
            "        b.insert(i + 50, \"bar\");",
            "    }",
            "    a.append(&mut b);",
            "    let mut a: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut b: IndexMap<i32, &str> = IndexMap::new();",
            "    let mut a = IndexMap::with_capacity(100);",
            "    let mut b = IndexMap::with_capacity(200);",
            "    for i in 0..50 {",
            "    }",
            "    a.append(&mut b);",
            "    assert_eq!(a.get(&0), Some(&\"foo\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]