[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map1 = IndexMapCore::new();",
          "    let mut map2 = IndexMapCore::new();",
          "    map1.append_unchecked(&mut map2);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    assert_eq!(map1.len(), 0);"
          ],
          [
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    assert_eq!(map2.len(), 0);"
          ],
          [
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.len(), 0);"
          ],
          [
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map2.len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    assert_eq!(map1.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    assert_eq!(map2.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map2.len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map1 = IndexMapCore::new();",
          "    let mut map2 = IndexMapCore::with_capacity(10);",
          "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
          "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
          "    map1.append_unchecked(&mut map2);",
          "}"
        ],
        "oracles": [
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.len(), expected_map1_len);"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map2.len(), 0);"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries.len(), expected_map1_len);"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[0].key, 1);"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[0].value, \"a\");"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[1].key, 2);"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[1].value, \"b\");"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map2.indices.is_empty());"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map2.entries.is_empty());"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map1.capacity() >= map1_capacity);"
          ],
          [
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map1.capacity() >= map2_capacity);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.len(), expected_map1_len);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map2.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries.len(), expected_map1_len);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[0].key, 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[0].value, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[1].key, 2);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert_eq!(map1.entries[1].value, \"b\");",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map2.indices.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map2.entries.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map1.capacity() >= map1_capacity);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::new();",
            "    let mut map2 = IndexMapCore::with_capacity(10);",
            "    map2.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map1.append_unchecked(&mut map2);",
            "    let map1_capacity = map1.capacity();",
            "    let map2_capacity = map2.capacity();",
            "    let expected_map1_len = map1.len() + 2;",
            "    assert!(map1.capacity() >= map2_capacity);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map1 = IndexMapCore::with_capacity(10);",
          "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
          "    let mut map2 = IndexMapCore::new();",
          "    map1.append_unchecked(&mut map2);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.len(), 1);"
          ],
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.entries.len(), 1);"
          ],
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map2.len(), 0);"
          ],
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map2.entries.len(), 0);"
          ],
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.entries[0].key, 1);"
          ],
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.entries[0].value, \"a\");"
          ],
          [
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.indices.len(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.entries.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map2.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map2.entries.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.entries[0].key, 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.entries[0].value, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    let mut map1 = IndexMapCore::with_capacity(10);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    let mut map2 = IndexMapCore::new();",
            "    map1.append_unchecked(&mut map2);",
            "    assert_eq!(map1.indices.len(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map1 = IndexMapCore::with_capacity(5);",
          "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
          "    ",
          "    let mut map2 = IndexMapCore::with_capacity(5);",
          "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
          "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
          "    ",
          "    map1.append_unchecked(&mut map2);",
          "}"
        ],
        "oracles": [
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.len(), 1);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.len(), 2);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries.len(), 1);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries.len(), 2);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries[0].key, 1);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[0].key, 2);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[1].key, 3);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.indices.len(), 1);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.indices.len(), 2);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries[0].value, \"a\");"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[0].value, \"b\");"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[1].value, \"c\");"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries.len() + map2.entries.len(), 3);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert!(map2.indices.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries[0].key, 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[0].key, 2);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[1].key, 3);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.indices.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.indices.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries[0].value, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[0].value, \"b\");",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map2.entries[1].value, \"c\");",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert_eq!(map1.entries.len() + map2.entries.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(5);",
            "    map1.entries.push(Bucket { hash: HashValue::from(1), key: 1, value: \"a\" });",
            "    ",
            "    let mut map2 = IndexMapCore::with_capacity(5);",
            "    map2.entries.push(Bucket { hash: HashValue::from(2), key: 2, value: \"b\" });",
            "    map2.entries.push(Bucket { hash: HashValue::from(3), key: 3, value: \"c\" });",
            "    ",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(5);",
            "    let map2 = IndexMapCore::with_capacity(5);",
            "    assert!(map2.indices.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
          "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
          "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2) {",
          "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
          "        map2.entries.push(Bucket { hash: HashValue::from(i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2), key: i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2, value: \"value\" });",
          "    }",
          "    map1.append_unchecked(&mut map2);",
          "}"
        ],
        "oracles": [
          [
            "    let len_map1_after_append = map1.len();",
            "    let len_map2_after_append = map2.len();",
            "    let capacity_map1 = map1.capacity();",
            "    assert!(len_map1_after_append == (IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2) * 2);"
          ],
          [
            "    let len_map1_after_append = map1.len();",
            "    let len_map2_after_append = map2.len();",
            "    let capacity_map1 = map1.capacity();",
            "    assert!(len_map2_after_append == 0);"
          ],
          [
            "    let len_map1_after_append = map1.len();",
            "    let len_map2_after_append = map2.len();",
            "    let capacity_map1 = map1.capacity();",
            "    assert!(capacity_map1 >= IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "        map2.entries.push(Bucket { hash: HashValue::from(i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2), key: i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let len_map1_after_append = map1.len();",
            "    let len_map2_after_append = map2.len();",
            "    let capacity_map1 = map1.capacity();",
            "    assert!(len_map1_after_append == (IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2) * 2);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "        map2.entries.push(Bucket { hash: HashValue::from(i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2), key: i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let len_map1_after_append = map1.len();",
            "    let len_map2_after_append = map2.len();",
            "    let capacity_map1 = map1.capacity();",
            "    assert!(len_map2_after_append == 0);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "        map2.entries.push(Bucket { hash: HashValue::from(i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2), key: i + IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY / 2, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let len_map1_after_append = map1.len();",
            "    let len_map2_after_append = map2.len();",
            "    let capacity_map1 = map1.capacity();",
            "    assert!(capacity_map1 >= IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
          "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
          "    ",
          "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
          "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
          "    }",
          "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
          "        map2.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
          "    }",
          "    map1.append_unchecked(&mut map2);",
          "}"
        ],
        "oracles": [
          [
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    assert_eq!(map1.entries.len(), i);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    assert_eq!(map2.entries.len(), i);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    assert!(map1.len() < IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    assert!(map2.len() < IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);"
          ],
          [
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    assert!(std::panic::catch_unwind(|| { map1.append_unchecked(&mut map2); }).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    ",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map2.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    assert_eq!(map1.entries.len(), i);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    ",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map2.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    assert_eq!(map2.entries.len(), i);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    ",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map2.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    assert!(map1.len() < IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    ",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map2.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    assert!(map2.len() < IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "}"
          ],
          [
            "{",
            "    let mut map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let mut map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    ",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map1.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "        map2.entries.push(Bucket { hash: HashValue::from(i), key: i, value: \"value\" });",
            "    }",
            "    map1.append_unchecked(&mut map2);",
            "    let map1 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    let map2 = IndexMapCore::with_capacity(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY);",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    for i in 0..(IndexMapCore::<usize, &str>::MAX_ENTRIES_CAPACITY) {",
            "    }",
            "    assert!(std::panic::catch_unwind(|| { map1.append_unchecked(&mut map2); }).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]