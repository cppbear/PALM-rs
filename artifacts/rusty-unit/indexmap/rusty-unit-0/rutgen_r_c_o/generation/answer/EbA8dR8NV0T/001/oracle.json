[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
          "    map.insert(3, 30);",
          "    map.insert(1, 10);",
          "    map.insert(2, 20);",
          "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
          "        k1.cmp(k2).reverse()",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    let result = map.sorted_unstable_by(|k1, v1, k2, v2| { k1.cmp(k2).reverse() });",
            "    assert_eq!(result.as_slice(), &[(3, 30), (2, 20), (1, 10)]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        k1.cmp(k2).reverse()",
            "    });",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(3, 30);",
            "    map.insert(1, 10);",
            "    map.insert(2, 20);",
            "    let result = map.sorted_unstable_by(|k1, v1, k2, v2| { k1.cmp(k2).reverse() });",
            "    assert_eq!(result.as_slice(), &[(3, 30), (2, 20), (1, 10)]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
          "    let _ = map.sorted_unstable_by(|_, _, _, _| Ordering::Equal);",
          "}"
        ],
        "oracles": [
          [
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let entries = map.into_entries();",
            "    assert!(entries.is_empty());"
          ],
          [
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let entries = map.into_entries();",
            "    assert_eq!(map.first(), None);"
          ],
          [
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let entries = map.into_entries();",
            "    assert_eq!(map.last(), None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let _ = map.sorted_unstable_by(|_, _, _, _| Ordering::Equal);",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let entries = map.into_entries();",
            "    assert!(entries.is_empty());",
            "}"
          ],
          [
            "{",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let _ = map.sorted_unstable_by(|_, _, _, _| Ordering::Equal);",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let entries = map.into_entries();",
            "    assert_eq!(map.first(), None);",
            "}"
          ],
          [
            "{",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let _ = map.sorted_unstable_by(|_, _, _, _| Ordering::Equal);",
            "    let map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    let entries = map.into_entries();",
            "    assert_eq!(map.last(), None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
          "    map.insert(2, 20);",
          "    map.insert(2, 30);",
          "    map.insert(2, 10);",
          "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
          "        v1.cmp(v2)",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice().len(), 3);"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice()[0], Bucket { hash: _, key: 2, value: 30 });"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice()[1], Bucket { hash: _, key: 2, value: 20 });"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice()[2], Bucket { hash: _, key: 2, value: 10 });"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice().len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice()[0], Bucket { hash: _, key: 2, value: 30 });",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice()[1], Bucket { hash: _, key: 2, value: 20 });",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(2, 20);",
            "    map.insert(2, 30);",
            "    map.insert(2, 10);",
            "    let iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    assert_eq!(iter.as_slice()[2], Bucket { hash: _, key: 2, value: 10 });",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
          "    map.insert(5, 50);",
          "    map.insert(4, 40);",
          "    map.insert(3, 30);",
          "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
          "        v1.cmp(v2)",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(5, 50);",
            "    map.insert(4, 40);",
            "    map.insert(3, 30);",
            "    let iter = map.sorted_unstable_by(|_, v1, _, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = iter.as_slice().iter().map(|bucket| (bucket.key.clone(), bucket.value.clone())).collect();",
            "    assert_eq!(sorted_entries, vec![(3, 30), (4, 40), (5, 50)]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(5, 50);",
            "    map.insert(4, 40);",
            "    map.insert(3, 30);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(5, 50);",
            "    map.insert(4, 40);",
            "    map.insert(3, 30);",
            "    let iter = map.sorted_unstable_by(|_, v1, _, v2| {",
            "    v1.cmp(v2)",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = iter.as_slice().iter().map(|bucket| (bucket.key.clone(), bucket.value.clone())).collect();",
            "    assert_eq!(sorted_entries, vec![(3, 30), (4, 40), (5, 50)]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
          "    for i in 1..=1000 {",
          "        map.insert(i, i * 10);",
          "    }",
          "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
          "        v1.cmp(v2).then(k1.cmp(k2))",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "    map.insert(i, i * 10);",
            "    }",
            "    let sorted_iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = sorted_iter.as_slice().iter().map(|bucket| (bucket.key, bucket.value)).collect();",
            "    for (i, entry) in sorted_entries.iter().enumerate() {",
            "    assert_eq!(entry.1, (entry.0 * 10));"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "    map.insert(i, i * 10);",
            "    }",
            "    let sorted_iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = sorted_iter.as_slice().iter().map(|bucket| (bucket.key, bucket.value)).collect();",
            "    for (i, entry) in sorted_entries.iter().enumerate() {",
            "    }",
            "    assert!(sorted_entries.windows(2).all(|w| {"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "    map.insert(i, i * 10);",
            "    }",
            "    let sorted_iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = sorted_iter.as_slice().iter().map(|bucket| (bucket.key, bucket.value)).collect();",
            "    for (i, entry) in sorted_entries.iter().enumerate() {",
            "    }",
            "    w[0].1 <= w[1].1 || (w[0].1 == w[1].1 && w[0].0 < w[1].0)",
            "    }));",
            "    assert_eq!(sorted_entries.len(), 1000);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "        map.insert(i, i * 10);",
            "    }",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "    map.insert(i, i * 10);",
            "    }",
            "    let sorted_iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = sorted_iter.as_slice().iter().map(|bucket| (bucket.key, bucket.value)).collect();",
            "    for (i, entry) in sorted_entries.iter().enumerate() {",
            "    assert_eq!(entry.1, (entry.0 * 10));",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "        map.insert(i, i * 10);",
            "    }",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "    map.insert(i, i * 10);",
            "    }",
            "    let sorted_iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = sorted_iter.as_slice().iter().map(|bucket| (bucket.key, bucket.value)).collect();",
            "    for (i, entry) in sorted_entries.iter().enumerate() {",
            "    }",
            "    assert!(sorted_entries.windows(2).all(|w| {",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "        map.insert(i, i * 10);",
            "    }",
            "    let _ = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "        v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    for i in 1..=1000 {",
            "    map.insert(i, i * 10);",
            "    }",
            "    let sorted_iter = map.sorted_unstable_by(|k1, v1, k2, v2| {",
            "    v1.cmp(v2).then(k1.cmp(k2))",
            "    });",
            "    let sorted_entries: Vec<(i32, i32)> = sorted_iter.as_slice().iter().map(|bucket| (bucket.key, bucket.value)).collect();",
            "    for (i, entry) in sorted_entries.iter().enumerate() {",
            "    }",
            "    w[0].1 <= w[1].1 || (w[0].1 == w[1].1 && w[0].0 < w[1].0)",
            "    }));",
            "    assert_eq!(sorted_entries.len(), 1000);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
          "    map.insert(1, 20);",
          "    map.insert(2, 20);",
          "    map.insert(3, 10);",
          "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
          "        v1.cmp(v2)",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries.len(), 3);"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries[0], Bucket { hash: _, key: 3, value: 10 });"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries[1], Bucket { hash: _, key: 1, value: 20 });"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries[2], Bucket { hash: _, key: 2, value: 20 });"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[0].key < entries[1].key || entries[0].key < entries[2].key);"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[1].key == entries[2].key || entries[1].key < entries[0].key);"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[1].value == entries[2].value);"
          ],
          [
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[0].value < entries[1].value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries[0], Bucket { hash: _, key: 3, value: 10 });",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries[1], Bucket { hash: _, key: 1, value: 20 });",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert_eq!(entries[2], Bucket { hash: _, key: 2, value: 20 });",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[0].key < entries[1].key || entries[0].key < entries[2].key);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[1].key == entries[2].key || entries[1].key < entries[0].key);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[1].value == entries[2].value);",
            "}"
          ],
          [
            "{",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let _ = map.sorted_unstable_by(|_, v1, _, v2| {",
            "        v1.cmp(v2)",
            "    });",
            "    let mut map: IndexMap<i32, i32, RandomState> = IndexMap::new();",
            "    map.insert(1, 20);",
            "    map.insert(2, 20);",
            "    map.insert(3, 10);",
            "    let entries = map.into_entries();",
            "    assert!(entries[0].value < entries[1].value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]