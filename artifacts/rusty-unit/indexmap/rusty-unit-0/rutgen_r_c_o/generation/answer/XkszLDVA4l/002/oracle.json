[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMapCore::<usize, String>::new();",
          "    let index = 1; // at is greater than len (len is 0)",
          "    map.split_off(index);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 1;",
            "    let result = std::panic::catch_unwind(|| {",
            "    map.split_off(index);",
            "    });",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 1;",
            "    let result = std::panic::catch_unwind(|| {",
            "    map.split_off(index);",
            "    });",
            "    assert_eq!(result.err().unwrap().downcast_ref::<&str>(), Some(&\"index out of bounds: the len is 0 but the index is 1. Expected index <= len\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 1; // at is greater than len (len is 0)",
            "    map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 1;",
            "    let result = std::panic::catch_unwind(|| {",
            "    map.split_off(index);",
            "    });",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 1; // at is greater than len (len is 0)",
            "    map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 1;",
            "    let result = std::panic::catch_unwind(|| {",
            "    map.split_off(index);",
            "    });",
            "    assert_eq!(result.err().unwrap().downcast_ref::<&str>(), Some(&\"index out of bounds: the len is 0 but the index is 1. Expected index <= len\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
          "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1; // at exceeds the MAX_ENTRIES_CAPACITY",
          "    map.split_off(index);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1;",
            "    assert_panics!(map.split_off(index));"
          ],
          [
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1;",
            "    assert_eq!(map.len(), 0);"
          ],
          [
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1;",
            "    assert_eq!(map.capacity(), IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1; // at exceeds the MAX_ENTRIES_CAPACITY",
            "    map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1;",
            "    assert_panics!(map.split_off(index));",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1; // at exceeds the MAX_ENTRIES_CAPACITY",
            "    map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1;",
            "    assert_eq!(map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1; // at exceeds the MAX_ENTRIES_CAPACITY",
            "    map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::with_capacity(IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "    let index = IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY + 1;",
            "    assert_eq!(map.capacity(), IndexMapCore::<usize, String>::MAX_ENTRIES_CAPACITY);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMapCore::<usize, String>::new();",
          "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
          "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
          "",
          "    let index = 1; // splitting at a valid index",
          "    let result = map.split_off(index);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
            "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
            "    let index = 3; // splitting at an invalid index",
            "    let result = catch_panic(|| map.split_off(index));",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
            "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
            "    let index = 3; // splitting at an invalid index",
            "    let result = catch_panic(|| map.split_off(index));",
            "    assert_eq!(result.unwrap_err().to_string(), \"index out of bounds: the len is 2 but the index is 3. Expected index <= len\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
            "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
            "",
            "    let index = 1; // splitting at a valid index",
            "    let result = map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
            "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
            "    let index = 3; // splitting at an invalid index",
            "    let result = catch_panic(|| map.split_off(index));",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
            "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
            "",
            "    let index = 1; // splitting at a valid index",
            "    let result = map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    map.entries.push(Bucket { hash: HashValue::from(0), key: 1, value: \"one\".to_string() });",
            "    map.entries.push(Bucket { hash: HashValue::from(1), key: 2, value: \"two\".to_string() });",
            "    let index = 3; // splitting at an invalid index",
            "    let result = catch_panic(|| map.split_off(index));",
            "    assert_eq!(result.unwrap_err().to_string(), \"index out of bounds: the len is 2 but the index is 3. Expected index <= len\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = IndexMapCore::<usize, String>::new();",
          "    let index = 0; // splitting at zero should also be valid",
          "    let result = map.split_off(index);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 0;",
            "    let len = map.len();",
            "    assert!(index <= len, \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 0; // splitting at zero should also be valid",
            "    let result = map.split_off(index);",
            "    let mut map = IndexMapCore::<usize, String>::new();",
            "    let index = 0;",
            "    let len = map.len();",
            "    assert!(index <= len, \"index out of bounds: the len is {len} but the index is {index}. Expected index <= len\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]