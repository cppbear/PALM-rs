{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map/core.rs\n// crate name is indexmap\ntype Indices = hash_table::HashTable<usize>;\ntype Entries<K, V> = Vec<Bucket<K, V>>;\nuse hashbrown::hash_table;\nuse crate::vec::{self, Vec};\nuse crate::TryReserveError;\nuse core::mem;\nuse core::ops::RangeBounds;\nuse crate::util::simplify_range;\nuse crate::{Bucket, Equivalent, HashValue};\npub use entry::{Entry, IndexedEntry, OccupiedEntry, VacantEntry};\ntrait Entries {\n    type Entry;\n    fn into_entries(self) -> Vec<Self::Entry>;\n    fn as_entries(&self) -> &[Self::Entry];\n    fn as_entries_mut(&mut self) -> &mut [Self::Entry];\n    fn with_entries<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut [Self::Entry]);\n}\nstruct RefMut<'a, K, V> {\n    indices: &'a mut Indices,\n    entries: &'a mut Entries<K, V>,\n}\n#[derive(Copy, Debug)]\nstruct Bucket<K, V> {\n    hash: HashValue,\n    key: K,\n    value: V,\n}\n#[derive(Clone, Copy, Debug, PartialEq)]\nstruct HashValue(usize);\nimpl<'a, K, V> RefMut<'a, K, V> {\n    #[inline]\n    fn new(indices: &'a mut Indices, entries: &'a mut Entries<K, V>) -> Self {\n        Self { indices, entries }\n    }\n    #[inline]\n    fn reserve_entries(&mut self, additional: usize) {}\n    fn insert_unique(\n        self,\n        hash: HashValue,\n        key: K,\n        value: V,\n    ) -> OccupiedEntry<'a, K, V> {}\n    fn shift_insert_unique(&mut self, index: usize, hash: HashValue, key: K, value: V) {}\n    fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {}\n    fn shift_remove_finish(&mut self, index: usize) -> (K, V) {}\n    fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)> {}\n    fn swap_remove_finish(&mut self, index: usize) -> (K, V) {\n        let entry = self.entries.swap_remove(index);\n        if let Some(entry) = self.entries.get(index) {\n            let last = self.entries.len();\n            update_index(self.indices, entry.hash, last, index);\n        }\n        (entry.key, entry.value)\n    }\n    fn decrement_indices(&mut self, start: usize, end: usize) {}\n    fn increment_indices(&mut self, start: usize, end: usize) {}\n    #[track_caller]\n    fn move_index(&mut self, from: usize, to: usize) {}\n    #[track_caller]\n    fn swap_indices(&mut self, a: usize, b: usize) {}\n}\n#[inline]\nfn update_index(table: &mut Indices, hash: HashValue, old: usize, new: usize) {\n    let index = table.find_mut(hash.get(), move |&i| i == old).expect(\"index not found\");\n    *index = new;\n}\n\nThe function to be tested is presented as follows:\n/// Finish removing an entry by swapping it with the last\n///\n/// The index should already be removed from `self.indices`.\nfn swap_remove_finish(&mut self, index: usize) -> (K, V) {\n    // use swap_remove, but then we need to update the index that points\n    // to the other entry that has to move\n    let entry = self.entries.swap_remove(index);\n\n    // correct index that points to the entry that had to swap places\n    if let Some(entry) = self.entries.get(index) {\n        // was not last element\n        // examine new element in `index` and find it in indices\n        let last = self.entries.len();\n        update_index(self.indices, entry.hash, last, index);\n    }\n\n    (entry.key, entry.value)\n}\n",
  "depend_pt": ""
}