{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/map/core/entry.rs\n// crate name is indexmap\nuse super::{equivalent, Entries, IndexMapCore, RefMut};\nuse crate::HashValue;\nuse core::{fmt, mem};\nuse hashbrown::hash_table;\npub struct VacantEntry<'a, K, V> {\n    map: RefMut<'a, K, V>,\n    hash: HashValue,\n    key: K,\n}\npub struct OccupiedEntry<'a, K, V> {\n    entries: &'a mut Entries<K, V>,\n    index: hash_table::OccupiedEntry<'a, usize>,\n}\npub enum Entry<'a, K, V> {\n    /// Existing slot with equivalent key.\n    Occupied(OccupiedEntry<'a, K, V>),\n    /// Vacant slot (no equivalent key in the map).\n    Vacant(VacantEntry<'a, K, V>),\n}\nimpl<'a, K, V> Entry<'a, K, V> {\n    pub fn index(&self) -> usize {}\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {}\n    pub fn or_insert(self, default: V) -> &'a mut V {}\n    pub fn or_insert_with<F>(self, call: F) -> &'a mut V\n    where\n        F: FnOnce() -> V,\n    {}\n    pub fn or_insert_with_key<F>(self, call: F) -> &'a mut V\n    where\n        F: FnOnce(&K) -> V,\n    {}\n    pub fn key(&self) -> &K {\n        match *self {\n            Entry::Occupied(ref entry) => entry.key(),\n            Entry::Vacant(ref entry) => entry.key(),\n        }\n    }\n    pub fn and_modify<F>(mut self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n        if let Entry::Occupied(entry) = &mut self {\n            f(entry.get_mut());\n        }\n        self\n    }\n    pub fn or_default(self) -> &'a mut V\n    where\n        V: Default,\n    {}\n}\nimpl<'a, K, V> VacantEntry<'a, K, V> {\n    pub fn index(&self) -> usize {}\n    pub fn key(&self) -> &K {\n        &self.key\n    }\n    pub(crate) fn key_mut(&mut self) -> &mut K {}\n    pub fn into_key(self) -> K {}\n    pub fn insert(self, value: V) -> &'a mut V {}\n    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {}\n    pub fn insert_sorted(self, value: V) -> (usize, &'a mut V)\n    where\n        K: Ord,\n    {}\n    pub fn shift_insert(mut self, index: usize, value: V) -> &'a mut V {}\n}\nimpl<'a, K, V> OccupiedEntry<'a, K, V> {\n    pub(crate) fn new(\n        entries: &'a mut Entries<K, V>,\n        index: hash_table::OccupiedEntry<'a, usize>,\n    ) -> Self {\n        Self { entries, index }\n    }\n    #[inline]\n    pub fn index(&self) -> usize {}\n    #[inline]\n    fn into_ref_mut(self) -> RefMut<'a, K, V> {}\n    pub fn key(&self) -> &K {\n        &self.entries[self.index()].key\n    }\n    pub(crate) fn key_mut(&mut self) -> &mut K {}\n    pub fn get(&self) -> &V {}\n    pub fn get_mut(&mut self) -> &mut V {}\n    pub fn into_mut(self) -> &'a mut V {}\n    pub(super) fn into_muts(self) -> (&'a mut K, &'a mut V) {}\n    pub fn insert(&mut self, value: V) -> V {}\n    #[deprecated(\n        note = \"`remove` disrupts the map order -- \\\n        use `swap_remove` or `shift_remove` for explicit behavior.\"\n    )]\n    pub fn remove(self) -> V {}\n    pub fn swap_remove(self) -> V {}\n    pub fn shift_remove(self) -> V {}\n    #[deprecated(\n        note = \"`remove_entry` disrupts the map order -- \\\n        use `swap_remove_entry` or `shift_remove_entry` for explicit behavior.\"\n    )]\n    pub fn remove_entry(self) -> (K, V) {}\n    pub fn swap_remove_entry(self) -> (K, V) {}\n    pub fn shift_remove_entry(self) -> (K, V) {}\n    #[track_caller]\n    pub fn move_index(self, to: usize) {}\n    pub fn swap_indices(self, other: usize) {}\n}\n\nThe function to be tested is presented as follows:\n/// Gets a reference to the entry's key, either within the map if occupied,\n/// or else the new key that was used to find the entry.\npub fn key(&self) -> &K {\n    match *self {\n        Entry::Occupied(ref entry) => entry.key(),\n        Entry::Vacant(ref entry) => entry.key(),\n    }\n}\n",
  "depend_pt": ""
}