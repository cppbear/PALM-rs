{
    "function_name": "indexmap::set::set::IndexSet<T, S>::is_subset",
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/set.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/indexmap",
    "tests": 14,
    "tests_lines": [
        18,
        9,
        9,
        14,
        22,
        17,
        27,
        33,
        33,
        24,
        23,
        33,
        33,
        33
    ],
    "oracles": 11,
    "oracles_compiled": 10,
    "oracles_compiled_rate": 90.9090909090909,
    "tests_compiled": 13,
    "tests_compiled_rate": 92.85714285714286,
    "oracles_run": 10,
    "oracles_passed": 10,
    "oracles_passed_rate": 100.0,
    "tests_run": 13,
    "tests_passed": 13,
    "tests_passed_rate": 100.0,
    "lines": 6,
    "lines_covered": 6,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1221,
        1222,
        1223,
        1224,
        1225,
        1226
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    assert!(set1.is_subset(&set2));",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "",
                "    set1.is_subset(&set2);",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    assert!(set1.len() <= set2.len());",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "",
                "    set1.is_subset(&set2);",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    assert!(set1.is_subset(&set2) == true);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "",
                "    set1.is_subset(&set2);",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    assert!(set1.is_subset(&set2) == true);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "",
                "    set1.insert(3);",
                "    set1.insert(2);",
                "    set1.insert(1);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "    set1.insert(3);",
                "    set1.insert(2);",
                "    set1.insert(1);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    assert!(set1.is_subset(&set2));",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "",
                "    for i in 0..1000 {",
                "        set1.insert(i);",
                "        set2.insert(i);",
                "    }",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "    for i in 0..1000 { set1.insert(i); }",
                "    for i in 0..1000 { set2.insert(i); }",
                "    let result = set1.is_subset(&set2);",
                "    assert!(result);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set1.insert(3);",
                "    ",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    set2.insert(4);",
                "    set2.insert(5);",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set1.insert(3);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    set2.insert(4);",
                "    set2.insert(5);",
                "    assert!(set1.is_subset(&set2));",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(10, hasher);",
                "    self_set.reserve(10);",
                "    // Adding more elements to `self` than `other`",
                "    for i in 1..=6 {",
                "        self_set.insert(i);",
                "    }",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(10, hasher);",
                "    self_set.reserve(10);",
                "    for i in 1..=6 {",
                "    self_set.insert(i);",
                "    }",
                "    assert!(!result);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding different elements to `other`",
                "    for i in 6..=10 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(5, hasher);",
                "    self_set.reserve(5);",
                "    // Adding equal length but different elements",
                "    for i in 1..=5 {",
                "        self_set.insert(i);",
                "    }",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 6..=10 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(5, hasher);",
                "    self_set.reserve(5);",
                "    for i in 1..=5 {",
                "    self_set.insert(i);",
                "    }",
                "    assert_eq!(self_set.is_subset(&other), false);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=3 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let self_set = IndexSet::with_capacity_and_hasher(0, hasher);",
                "    // `self_set` is empty, so should return true",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=3 {",
                "    other.insert(i);",
                "    }",
                "    let self_set = IndexSet::with_capacity_and_hasher(0, hasher);",
                "    assert!(self_set.is_subset(&other));",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    // Elements added to `self` that are all contained in `other`",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    assert_eq!(self_set.len(), 3);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    // Elements added to `self` that are all contained in `other`",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    assert_eq!(other.len(), 5);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    // Elements added to `self` that are all contained in `other`",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    assert!(self_set.is_subset(&other) == true);",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1225,
            "start_column": 9,
            "end_line": 1225,
            "end_column": 34,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    assert!(set1.is_subset(&set2));",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "",
                "    set1.is_subset(&set2);",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    assert!(set1.len() <= set2.len());",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "",
                "    set1.is_subset(&set2);",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let set2: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    assert!(set1.is_subset(&set2) == true);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "",
                "    set1.is_subset(&set2);",
                "    let set1: IndexSet<i32, RandomState> = IndexSet::with_capacity_and_hasher(0, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    assert!(set1.is_subset(&set2) == true);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "",
                "    set1.insert(3);",
                "    set1.insert(2);",
                "    set1.insert(1);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(3, RandomState::new());",
                "    set1.insert(3);",
                "    set1.insert(2);",
                "    set1.insert(1);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    assert!(set1.is_subset(&set2));",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "",
                "    for i in 0..1000 {",
                "        set1.insert(i);",
                "        set2.insert(i);",
                "    }",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(1000, RandomState::new());",
                "    for i in 0..1000 { set1.insert(i); }",
                "    for i in 0..1000 { set2.insert(i); }",
                "    let result = set1.is_subset(&set2);",
                "    assert!(result);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set1.insert(3);",
                "    ",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    set2.insert(4);",
                "    set2.insert(5);",
                "",
                "    set1.is_subset(&set2);",
                "    let mut set1 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    let mut set2 = IndexSet::with_capacity_and_hasher(5, RandomState::new());",
                "    set1.insert(1);",
                "    set1.insert(2);",
                "    set1.insert(3);",
                "    set2.insert(1);",
                "    set2.insert(2);",
                "    set2.insert(3);",
                "    set2.insert(4);",
                "    set2.insert(5);",
                "    assert!(set1.is_subset(&set2));",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(10, hasher);",
                "    self_set.reserve(10);",
                "    // Adding more elements to `self` than `other`",
                "    for i in 1..=6 {",
                "        self_set.insert(i);",
                "    }",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(10, hasher);",
                "    self_set.reserve(10);",
                "    for i in 1..=6 {",
                "    self_set.insert(i);",
                "    }",
                "    assert!(!result);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding different elements to `other`",
                "    for i in 6..=10 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(5, hasher);",
                "    self_set.reserve(5);",
                "    // Adding equal length but different elements",
                "    for i in 1..=5 {",
                "        self_set.insert(i);",
                "    }",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 6..=10 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(5, hasher);",
                "    self_set.reserve(5);",
                "    for i in 1..=5 {",
                "    self_set.insert(i);",
                "    }",
                "    assert_eq!(self_set.is_subset(&other), false);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=3 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let self_set = IndexSet::with_capacity_and_hasher(0, hasher);",
                "    // `self_set` is empty, so should return true",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=3 {",
                "    other.insert(i);",
                "    }",
                "    let self_set = IndexSet::with_capacity_and_hasher(0, hasher);",
                "    assert!(self_set.is_subset(&other));",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    // Elements added to `self` that are all contained in `other`",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    assert_eq!(self_set.len(), 3);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    // Elements added to `self` that are all contained in `other`",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    assert_eq!(other.len(), 5);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::collections::hash_map::RandomState;",
                "    use crate::IndexSet;",
                "",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    // Adding elements to `other`",
                "    for i in 1..=5 {",
                "        other.insert(i);",
                "    }",
                "",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    // Elements added to `self` that are all contained in `other`",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    ",
                "    let result = self_set.is_subset(&other);",
                "    let hasher = RandomState::new();",
                "    let mut other = IndexSet::with_capacity_and_hasher(5, hasher.clone());",
                "    other.reserve(5);",
                "    for i in 1..=5 {",
                "    other.insert(i);",
                "    }",
                "    let mut self_set = IndexSet::with_capacity_and_hasher(3, hasher);",
                "    self_set.reserve(3);",
                "    self_set.insert(1);",
                "    self_set.insert(2);",
                "    self_set.insert(3);",
                "    assert!(self_set.is_subset(&other) == true);",
                "}"
            ],
            [
                {
                    "start_line": 1225,
                    "start_column": 9,
                    "end_line": 1225,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ]
}