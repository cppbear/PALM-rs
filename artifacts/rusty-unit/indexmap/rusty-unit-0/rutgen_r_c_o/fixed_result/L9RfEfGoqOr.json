{
    "function_name": "indexmap::set::iter::set::iter::Union<'a, T, S>::new",
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/set/iter.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/indexmap",
    "tests": 15,
    "tests_lines": [
        9,
        9,
        9,
        15,
        15,
        15,
        15,
        15,
        15,
        12,
        15,
        15,
        7,
        7,
        7
    ],
    "oracles": 6,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 33.33333333333333,
    "tests_compiled": 2,
    "tests_compiled_rate": 13.333333333333334,
    "oracles_run": 2,
    "oracles_passed": 2,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 8,
    "lines_covered": 8,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        451,
        452,
        453,
        454,
        455,
        456,
        457,
        458
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    let mut set2: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    ",
                "    set1.extend(0..500);",
                "    set2.extend(500..1000);",
                "    ",
                "    let union = Union::new(&set1, &set2);",
                "    let mut set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    let mut set2: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    set1.extend(0..500);",
                "    set2.extend(500..1000);",
                "    let union = Union::new(&set1, &set2);",
                "    assert_eq!(union.iter.count(), 1000);",
                "}"
            ],
            [
                451,
                452,
                453,
                454,
                455,
                456,
                457,
                458
            ]
        ],
        [
            [
                "{",
                "  let set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(10, std::collections::hash_map::RandomState::new());",
                "  let empty_set: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::new();",
                "  let _union = Union::new(&set1, &empty_set);",
                "  let set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(10, std::collections::hash_map::RandomState::new());",
                "  assert!(std::panic::catch_unwind(|| Union::new(&set1, &empty_set)).is_err());",
                "}"
            ],
            [
                451,
                452,
                453,
                454,
                455,
                456,
                457,
                458
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    let mut set2: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    ",
                "    set1.extend(0..500);",
                "    set2.extend(500..1000);",
                "    ",
                "    let union = Union::new(&set1, &set2);",
                "    let mut set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    let mut set2: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(1000, std::collections::hash_map::RandomState::new());",
                "    set1.extend(0..500);",
                "    set2.extend(500..1000);",
                "    let union = Union::new(&set1, &set2);",
                "    assert_eq!(union.iter.count(), 1000);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "  let set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(10, std::collections::hash_map::RandomState::new());",
                "  let empty_set: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::new();",
                "  let _union = Union::new(&set1, &empty_set);",
                "  let set1: IndexSet<i32, std::collections::hash_map::RandomState> = IndexSet::with_capacity_and_hasher(10, std::collections::hash_map::RandomState::new());",
                "  assert!(std::panic::catch_unwind(|| Union::new(&set1, &empty_set)).is_err());",
                "}"
            ],
            []
        ]
    ]
}