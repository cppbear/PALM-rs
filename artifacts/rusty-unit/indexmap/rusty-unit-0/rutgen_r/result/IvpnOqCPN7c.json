{
    "function_name": "indexmap::map::core::map::core::RefMut<'a, K, V>::move_index",
    "tests": 19,
    "tests_lines": [
        67,
        30,
        30,
        27,
        7,
        7,
        10,
        10,
        7,
        8,
        6,
        4,
        4,
        4,
        6,
        9,
        9,
        9,
        16
    ],
    "oracles": 19,
    "oracles_compiled": 9,
    "oracles_compiled_rate": 47.368421052631575,
    "tests_compiled": 9,
    "tests_compiled_rate": 47.368421052631575,
    "oracles_run": 9,
    "oracles_passed": 4,
    "oracles_passed_rate": 44.44444444444444,
    "tests_run": 9,
    "tests_passed": 4,
    "tests_passed_rate": 44.44444444444444,
    "lines": 17,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 6,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        688,
        689,
        690,
        691,
        693,
        694,
        695,
        696,
        697,
        698,
        699,
        700,
        701,
        702,
        705,
        706,
        707
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![",
                "                    Entry { hash: 1, value: 10 },",
                "                    Entry { hash: 2, value: 20 },",
                "                    Entry { hash: 3, value: 30 },",
                "                    Entry { hash: 4, value: 40 },",
                "                ],",
                "                indices: vec![0, 1, 2, 3],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            let from_hash = self.entries[from].hash;",
                "            let _ = self.entries[to]; // explicit bounds check",
                "            if from != to {",
                "                update_index(&mut self.indices, from_hash, from, usize::MAX);",
                "",
                "                if from < to {",
                "                    self.decrement_indices(from + 1, to + 1);",
                "                    self.entries[from..=to].rotate_left(1);",
                "                } else if to < from {",
                "                    self.increment_indices(to, from);",
                "                    self.entries[to..=from].rotate_right(1);",
                "                }",
                "",
                "                update_index(&mut self.indices, from_hash, usize::MAX, to);",
                "            }",
                "        }",
                "",
                "        fn decrement_indices(&mut self, start: usize, end: usize) {",
                "            for i in start..end {",
                "                self.indices[i] -= 1;",
                "            }",
                "        }",
                "",
                "        fn increment_indices(&mut self, start: usize, end: usize) {",
                "            for i in start..end {",
                "                self.indices[i] += 1;",
                "            }",
                "        }",
                "    }",
                "",
                "    fn update_index(indices: &mut Vec<usize>, hash: usize, from: usize, to: usize) {",
                "        // Dummy implementation for the sake of the test",
                "        if to < indices.len() {",
                "            indices[to] = indices[from];",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(1, 3); // Moving index 1 (value 20) to index 3",
                "    assert_eq!(index_map.entries[3].value, 20);",
                "    assert_eq!(index_map.entries[1].value, 30);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![",
                "                    Entry { hash: 1, value: 10 },",
                "                    Entry { hash: 2, value: 20 },",
                "                ],",
                "                indices: vec![0, 1],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            // Implementation is omitted for brevity, same as above.",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(0, 0); // This should panic",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![",
                "                    Entry { hash: 1, value: 10 },",
                "                    Entry { hash: 2, value: 20 },",
                "                ],",
                "                indices: vec![0, 1],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            // Implementation is omitted for brevity, same as above.",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(0, 2); // This should panic due to index out of bounds",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![], // Empty entries vector",
                "                indices: vec![],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            // Implementation is omitted for brevity, same as above.",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(0, 0); // This should panic due to empty slice",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }, Entry { hash: 3 }], vec![0, 1, 2]);",
                "    map.move_index(1, 2);",
                "    assert_eq!(map.entries[1].hash, 3);",
                "    assert_eq!(map.entries[2].hash, 2);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }], vec![0, 1]);",
                "    map.move_index(2, 1); // 'from' index is out of bounds",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }], vec![0, 1]);",
                "    map.move_index(0, 2); // 'to' index is out of bounds",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }], vec![0, 1]);",
                "    map.move_index(1, 1); // 'from' and 'to' indices are the same",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }, Entry { hash: 3 }], vec![0, 1, 2]);",
                "    map.move_index(0, 1);",
                "    assert_eq!(map.entries[0].hash, 2);",
                "    assert_eq!(map.entries[1].hash, 1);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 691,
            "start_column": 12,
            "end_line": 691,
            "end_column": 22,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 696,
            "start_column": 16,
            "end_line": 696,
            "end_column": 25,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 699,
            "start_column": 23,
            "end_line": 699,
            "end_column": 32,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![",
                "                    Entry { hash: 1, value: 10 },",
                "                    Entry { hash: 2, value: 20 },",
                "                    Entry { hash: 3, value: 30 },",
                "                    Entry { hash: 4, value: 40 },",
                "                ],",
                "                indices: vec![0, 1, 2, 3],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            let from_hash = self.entries[from].hash;",
                "            let _ = self.entries[to]; // explicit bounds check",
                "            if from != to {",
                "                update_index(&mut self.indices, from_hash, from, usize::MAX);",
                "",
                "                if from < to {",
                "                    self.decrement_indices(from + 1, to + 1);",
                "                    self.entries[from..=to].rotate_left(1);",
                "                } else if to < from {",
                "                    self.increment_indices(to, from);",
                "                    self.entries[to..=from].rotate_right(1);",
                "                }",
                "",
                "                update_index(&mut self.indices, from_hash, usize::MAX, to);",
                "            }",
                "        }",
                "",
                "        fn decrement_indices(&mut self, start: usize, end: usize) {",
                "            for i in start..end {",
                "                self.indices[i] -= 1;",
                "            }",
                "        }",
                "",
                "        fn increment_indices(&mut self, start: usize, end: usize) {",
                "            for i in start..end {",
                "                self.indices[i] += 1;",
                "            }",
                "        }",
                "    }",
                "",
                "    fn update_index(indices: &mut Vec<usize>, hash: usize, from: usize, to: usize) {",
                "        // Dummy implementation for the sake of the test",
                "        if to < indices.len() {",
                "            indices[to] = indices[from];",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(1, 3); // Moving index 1 (value 20) to index 3",
                "    assert_eq!(index_map.entries[3].value, 20);",
                "    assert_eq!(index_map.entries[1].value, 30);",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![",
                "                    Entry { hash: 1, value: 10 },",
                "                    Entry { hash: 2, value: 20 },",
                "                ],",
                "                indices: vec![0, 1],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            // Implementation is omitted for brevity, same as above.",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(0, 0); // This should panic",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![",
                "                    Entry { hash: 1, value: 10 },",
                "                    Entry { hash: 2, value: 20 },",
                "                ],",
                "                indices: vec![0, 1],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            // Implementation is omitted for brevity, same as above.",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(0, 2); // This should panic due to index out of bounds",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct Entry {",
                "        hash: usize,",
                "        value: i32,",
                "    }",
                "",
                "    struct IndexMap {",
                "        entries: Vec<Entry>,",
                "        indices: Vec<usize>,",
                "    }",
                "",
                "    impl IndexMap {",
                "        fn new() -> Self {",
                "            IndexMap {",
                "                entries: vec![], // Empty entries vector",
                "                indices: vec![],",
                "            }",
                "        }",
                "",
                "        fn move_index(&mut self, from: usize, to: usize) {",
                "            // Implementation is omitted for brevity, same as above.",
                "        }",
                "    }",
                "",
                "    let mut index_map = IndexMap::new();",
                "    index_map.move_index(0, 0); // This should panic due to empty slice",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }, Entry { hash: 3 }], vec![0, 1, 2]);",
                "    map.move_index(1, 2);",
                "    assert_eq!(map.entries[1].hash, 3);",
                "    assert_eq!(map.entries[2].hash, 2);",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }], vec![0, 1]);",
                "    map.move_index(2, 1); // 'from' index is out of bounds",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }], vec![0, 1]);",
                "    map.move_index(0, 2); // 'to' index is out of bounds",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }], vec![0, 1]);",
                "    map.move_index(1, 1); // 'from' and 'to' indices are the same",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = TestMap::new(vec![Entry { hash: 1 }, Entry { hash: 2 }, Entry { hash: 3 }], vec![0, 1, 2]);",
                "    map.move_index(0, 1);",
                "    assert_eq!(map.entries[0].hash, 2);",
                "    assert_eq!(map.entries[1].hash, 1);",
                "}"
            ],
            [
                {
                    "start_line": 691,
                    "start_column": 12,
                    "end_line": 691,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 696,
                    "start_column": 16,
                    "end_line": 696,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 699,
                    "start_column": 23,
                    "end_line": 699,
                    "end_column": 32,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/map/core.rs"
}