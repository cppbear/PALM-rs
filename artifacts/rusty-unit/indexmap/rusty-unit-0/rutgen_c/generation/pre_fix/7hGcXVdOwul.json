{
  "name": "indexmap::set::slice::set::slice::Slice<T>::partition_point",
  "name_with_impl": "indexmap::set::slice::{impl#1}::partition_point",
  "mod_info": {
    "name": "set::slice",
    "loc": "src/set.rs:5:1:5:11"
  },
  "visible": true,
  "loc": "src/set/slice.rs:169:5:174:6",
  "fn_tests": [
    {
      "chain_id": 0,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[cfg(test)]",
            "fn test_partition_point() {",
            "    struct TestBucket {",
            "        key: usize,",
            "    }",
            "    ",
            "    let entries = vec![",
            "        Bucket { hash: 0, key: 1, value: TestBucket { key: 1 } },",
            "        Bucket { hash: 0, key: 3, value: TestBucket { key: 3 } },",
            "        Bucket { hash: 0, key: 5, value: TestBucket { key: 5 } },",
            "    ];",
            "    ",
            "    let slice = Slice { entries };",
            "",
            "    let predicate = |&key: &usize| key < 4;",
            "    ",
            "    assert_eq!(slice.partition_point(predicate), 2);",
            "}",
            "",
            "#[cfg(test)]",
            "fn test_partition_point_empty() {",
            "    let entries: Vec<Bucket<usize, usize>> = vec![];",
            "    let slice = Slice { entries };",
            "",
            "    let predicate = |&key: &usize| key < 1;",
            "",
            "    assert_eq!(slice.partition_point(predicate), 0);",
            "}",
            "",
            "#[cfg(test)]",
            "fn test_partition_point_all_true() {",
            "    struct TestBucket {",
            "        key: usize,",
            "    }",
            "",
            "    let entries = vec![",
            "        Bucket { hash: 0, key: 1, value: TestBucket { key: 1 } },",
            "        Bucket { hash: 0, key: 2, value: TestBucket { key: 2 } },",
            "        Bucket { hash: 0, key: 3, value: TestBucket { key: 3 } },",
            "    ];",
            "",
            "    let slice = Slice { entries };",
            "",
            "    let predicate = |&key: &usize| key < 4;",
            "",
            "    assert_eq!(slice.partition_point(predicate), 3);",
            "}",
            "",
            "#[cfg(test)]",
            "fn test_partition_point_all_false() {",
            "    struct TestBucket {",
            "        key: usize,",
            "    }",
            "",
            "    let entries = vec![",
            "        Bucket { hash: 0, key: 1, value: TestBucket { key: 1 } },",
            "        Bucket { hash: 0, key: 2, value: TestBucket { key: 2 } },",
            "        Bucket { hash: 0, key: 3, value: TestBucket { key: 3 } },",
            "    ];",
            "",
            "    let slice = Slice { entries };",
            "",
            "    let predicate = |&key: &usize| key > 3;",
            "",
            "    assert_eq!(slice.partition_point(predicate), 0);",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}