{
  "name": "indexmap::map::core::map::core::IndexMapCore<K, V>::drain",
  "name_with_impl": "indexmap::map::core::{impl#2}::drain",
  "mod_info": {
    "name": "map::core",
    "loc": "src/map.rs:4:1:4:10"
  },
  "visible": true,
  "loc": "src/map/core.rs:187:5:194:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// may panic: self.entries.drain(range) may panic in certain situations\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ",
                  "   // Manually populating the entries to ensure we have a scenario to drain  ",
                  "   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });  ",
                  "   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });  ",
                  "   index_map.entries.push(Bucket { hash: HashValue(2), key: 2, value: 2 });  ",
                  " ",
                  "   let drained: Vec<Bucket<usize, usize>> = index_map.drain(1..3).collect();  ",
                  " ",
                  "   assert_eq!(drained.len(), 2);  ",
                  "   assert_eq!(drained[0].key, 1);  ",
                  "   assert_eq!(drained[1].key, 2);  ",
                  "   assert_eq!(index_map.entries.len(), 1);  ",
                  "   assert_eq!(index_map.entries[0].key, 0);  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"range start index 3 out of range for slice of length 3\")]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                  "   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });",
                  "   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });",
                  "   ",
                  "   // This should panic as we're trying to access an index out of bounds",
                  "   index_map.drain(3..4);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"range end index 0 out of range for slice of length 3\")]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();  ",
                  "   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });  ",
                  "   index_map.entries.push(Bucket { hash: HashValue(1), key: 1, value: 1 });  ",
                  "   ",
                  "   // This should panic as we're trying to access an end index out of bounds  ",
                  "   index_map.drain(0..0);  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"range start index 1 should be <= range end index 0\")]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "   let mut index_map: IndexMapCore<usize, usize> = IndexMapCore::new();",
                  "   index_map.entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 });",
                  "",
                  "   // This should panic as the start is greater than the end",
                  "   index_map.drain(1..0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}