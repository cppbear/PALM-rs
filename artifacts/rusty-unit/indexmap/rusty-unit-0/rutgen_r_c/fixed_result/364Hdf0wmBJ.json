{
    "function_name": "indexmap::map::core::map::core::RefMut<'a, K, V>::insert_unique",
    "tests": 8,
    "tests_lines": [
        27,
        22,
        14,
        16,
        15,
        16,
        27,
        19
    ],
    "oracles": 8,
    "oracles_compiled": 4,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 4,
    "tests_compiled_rate": 50.0,
    "oracles_run": 4,
    "oracles_passed": 2,
    "oracles_passed_rate": 50.0,
    "tests_run": 4,
    "tests_passed": 2,
    "tests_passed_rate": 50.0,
    "lines": 15,
    "lines_covered": 15,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        551,
        552,
        553,
        554,
        555,
        556,
        557,
        558,
        559,
        560,
        561,
        562,
        563,
        564,
        565
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::new();",
                "    let mut entries: Vec<Bucket<usize, String>> = Vec::new();",
                "    let entries_capacity = 2; // Ensuring capacity constraint",
                "    entries.reserve(entries_capacity);",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    ",
                "    // Pre-fill entries to satisfy the maximum capacity condition",
                "    ref_mut.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: 1,",
                "        value: \"Value1\".to_string(),",
                "    });",
                "    ref_mut.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: 2,",
                "        value: \"Value2\".to_string(),",
                "    });",
                "    ",
                "    // This call should panic as we're inserting without capacity",
                "    ref_mut.insert_unique(HashValue(3), 3, \"Value3\".to_string());",
                "}"
            ],
            [
                551,
                552,
                553
            ]
        ],
        [
            [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(1);",
                "    let key = 1;",
                "    let value = 42;",
                "",
                "    let occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "",
                "    assert_eq!(occupied_entry.key(), &key);",
                "    assert_eq!(occupied_entry.get(), &value);",
                "}"
            ],
            [
                551,
                552,
                553,
                554,
                555,
                556,
                557,
                558,
                559,
                560,
                561,
                562,
                563,
                564,
                565
            ]
        ],
        [
            [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(2);",
                "    entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 }); // Pre-filling to avoid capacity check",
                "",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(1);",
                "    let key = 1;",
                "    let value = 42;",
                "",
                "    let occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "",
                "    assert_eq!(occupied_entry.key(), &key);",
                "    assert_eq!(occupied_entry.get(), &value);",
                "    assert_eq!(entries.len(), 2); // Ensure the entry was added",
                "}"
            ],
            [
                551,
                552,
                553
            ]
        ],
        [
            [
                "{",
                "   let mut indices: Indices = hash_table::HashTable::default();  ",
                "   let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(1);  ",
                "   {  ",
                "       let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                "       ",
                "       let hash_value = HashValue(1);  ",
                "       let key = 1;  ",
                "       let value = 42;  ",
                " ",
                "       ref_mut.insert_unique(hash_value, key, value); // This should not panic  ",
                "       assert_eq!(entries.len(), 1); // Ensure it was added first  ",
                "   }  ",
                "",
                "}"
            ],
            [
                551,
                552,
                553,
                554,
                555,
                556,
                557,
                562,
                563,
                564,
                565
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 557,
            "start_column": 12,
            "end_line": 557,
            "end_column": 57,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::new();",
                "    let mut entries: Vec<Bucket<usize, String>> = Vec::new();",
                "    let entries_capacity = 2; // Ensuring capacity constraint",
                "    entries.reserve(entries_capacity);",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    ",
                "    // Pre-fill entries to satisfy the maximum capacity condition",
                "    ref_mut.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: 1,",
                "        value: \"Value1\".to_string(),",
                "    });",
                "    ref_mut.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: 2,",
                "        value: \"Value2\".to_string(),",
                "    });",
                "    ",
                "    // This call should panic as we're inserting without capacity",
                "    ref_mut.insert_unique(HashValue(3), 3, \"Value3\".to_string());",
                "}"
            ],
            [
                {
                    "start_line": 557,
                    "start_column": 12,
                    "end_line": 557,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::new();",
                "",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(1);",
                "    let key = 1;",
                "    let value = 42;",
                "",
                "    let occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "",
                "    assert_eq!(occupied_entry.key(), &key);",
                "    assert_eq!(occupied_entry.get(), &value);",
                "}"
            ],
            [
                {
                    "start_line": 557,
                    "start_column": 12,
                    "end_line": 557,
                    "end_column": 57,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut indices: Indices = hash_table::HashTable::default();",
                "    let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(2);",
                "    entries.push(Bucket { hash: HashValue(0), key: 0, value: 0 }); // Pre-filling to avoid capacity check",
                "",
                "    let ref_mut = RefMut::new(&mut indices, &mut entries);",
                "    let hash_value = HashValue(1);",
                "    let key = 1;",
                "    let value = 42;",
                "",
                "    let occupied_entry = ref_mut.insert_unique(hash_value, key, value);",
                "",
                "    assert_eq!(occupied_entry.key(), &key);",
                "    assert_eq!(occupied_entry.get(), &value);",
                "    assert_eq!(entries.len(), 2); // Ensure the entry was added",
                "}"
            ],
            [
                {
                    "start_line": 557,
                    "start_column": 12,
                    "end_line": 557,
                    "end_column": 57,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut indices: Indices = hash_table::HashTable::default();  ",
                "   let mut entries: Vec<Bucket<usize, usize>> = Vec::with_capacity(1);  ",
                "   {  ",
                "       let ref_mut = RefMut::new(&mut indices, &mut entries);  ",
                "       ",
                "       let hash_value = HashValue(1);  ",
                "       let key = 1;  ",
                "       let value = 42;  ",
                " ",
                "       ref_mut.insert_unique(hash_value, key, value); // This should not panic  ",
                "       assert_eq!(entries.len(), 1); // Ensure it was added first  ",
                "   }  ",
                "",
                "}"
            ],
            [
                {
                    "start_line": 557,
                    "start_column": 12,
                    "end_line": 557,
                    "end_column": 57,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/map/core.rs"
}