{
    "function_name": "indexmap::map::core::map::core::IndexMapCore<K, V>::insert_full",
    "tests": 10,
    "tests_lines": [
        16,
        20,
        24,
        21,
        21,
        26,
        19,
        15,
        20,
        19
    ],
    "oracles": 10,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 60.0,
    "tests_compiled": 6,
    "tests_compiled_rate": 60.0,
    "oracles_run": 6,
    "oracles_passed": 6,
    "oracles_passed_rate": 100.0,
    "tests_run": 6,
    "tests_passed": 6,
    "tests_passed_rate": 100.0,
    "lines": 17,
    "lines_covered": 17,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        338,
        339,
        340,
        341,
        342,
        343,
        344,
        345,
        346,
        347,
        349,
        350,
        351,
        352,
        353,
        354,
        357
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "   #[derive(Eq, PartialEq)]",
                "   struct TestKey(usize);",
                "   struct TestValue(usize);",
                "   ",
                "    let mut index_map = IndexMapCore::<TestKey, TestValue>::new();",
                "    let hash_value1 = HashValue(1);",
                "    let key1 = TestKey(1);",
                "    let value1 = TestValue(10);",
                "    ",
                "    let hash_value2 = HashValue(2);",
                "    let key2 = TestKey(2);",
                "    let value2 = TestValue(20);",
                "",
                "    // Insert first entry",
                "    let (index1, existing_value1) = index_map.insert_full(hash_value1, key1, value1);",
                "    assert_eq!(index1, 0);",
                "    assert!(existing_value1.is_none());",
                "",
                "    // Insert second entry",
                "    let (index2, existing_value2) = index_map.insert_full(hash_value2, key2, value2);",
                "    assert_eq!(index2, 1); // Should be at index 1 now",
                "    assert!(existing_value2.is_none()); // No existing value to replace",
                "}"
            ],
            [
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                349,
                350,
                351,
                352,
                353,
                354,
                357
            ]
        ],
        [
            [
                "{",
                "    // Initialize the IndexMapCore with usize as K and String as V",
                "    let mut index_map: IndexMapCore<usize, String> = IndexMapCore::new();",
                "",
                "    // Create a HashValue for the test",
                "    let hash_value = HashValue(42);",
                "    let key = 1;",
                "    let value = String::from(\"value1\");",
                "",
                "    // Insert a key-value pair which should be a vacant entry",
                "    let (index, previous_value) = index_map.insert_full(hash_value, key, value.clone());",
                "",
                "    // Verify the index at which the item was inserted",
                "    assert_eq!(index, 0);",
                "    // Verify that previously there was no value at this index",
                "    assert_eq!(previous_value, None);",
                "    // Verify the item was actually inserted",
                "    assert_eq!(index_map.entries.len(), 1);",
                "    assert_eq!(index_map.entries[0].key, key);",
                "    assert_eq!(index_map.entries[0].value, value);",
                "}"
            ],
            [
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                349,
                350,
                351,
                352,
                353,
                354,
                357
            ]
        ],
        [
            [
                "{",
                "    // Initialize the IndexMapCore with usize as K and String as V",
                "    let mut index_map: IndexMapCore<usize, String> = IndexMapCore::new();",
                "",
                "    // Create a HashValue for two test entries",
                "    let hash_value_1 = HashValue(42);",
                "    let key_1 = 1;",
                "    let value_1 = String::from(\"value1\");",
                "",
                "    let hash_value_2 = HashValue(42);",
                "    let key_2 = 1;",
                "    let value_2 = String::from(\"value2\");",
                "",
                "    // Insert first key-value pair",
                "    index_map.insert_full(hash_value_1, key_1, value_1);",
                "",
                "    // Insert another key-value pair with the same key which should now be occupied",
                "    let (index, previous_value) = index_map.insert_full(hash_value_2, key_2, value_2.clone());",
                "",
                "    // Verify the index at which the item was updated",
                "    assert_eq!(index, 0);",
                "    // Verify that the previous value was returned",
                "    assert_eq!(previous_value, Some(String::from(\"value1\")));",
                "    // Verify that the value has been updated to the new value",
                "    assert_eq!(index_map.entries[0].value, value_2);",
                "}"
            ],
            [
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                349,
                350,
                351,
                352,
                353,
                354,
                357
            ]
        ],
        [
            [
                "{",
                "   #[derive(Eq, PartialEq, Clone)]",
                "   struct Key(usize);",
                "   ",
                "   let mut index_map = IndexMapCore::new();",
                "   let hash_value = HashValue(123);",
                "   let key = Key(1);",
                "   let value = 42;",
                "",
                "   // Insert an initial value to create an occupied entry.",
                "   index_map.insert_full(hash_value, key.clone(), value);",
                "",
                "   // Now insert with the same key and expect to get back the previous value.",
                "   let new_value = 43;",
                "   let (index, previous_value) = index_map.insert_full(hash_value, key.clone(), new_value);",
                "",
                "   assert_eq!(index, 0); // Should be at index 0",
                "   assert_eq!(previous_value, Some(value)); // Should return the old value",
                "}"
            ],
            [
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                349,
                350,
                351,
                352,
                353,
                354,
                357
            ]
        ],
        [
            [
                "{",
                "    #[derive(Eq, PartialEq)]",
                "    struct Key(usize);",
                "",
                "    let mut index_map = IndexMapCore::new();",
                "    let hash_value = HashValue(456);",
                "    let key = Key(2);",
                "    let value = 24;",
                "",
                "    // Insert for the first time, it should be a vacant entry.",
                "    let (index, previous_value) = index_map.insert_full(hash_value, key, value);",
                "",
                "    assert_eq!(index, 0); // The first insertion goes to index 0",
                "    assert_eq!(previous_value, None); // There was no previous value",
                "}"
            ],
            [
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                349,
                350,
                351,
                352,
                353,
                354,
                357
            ]
        ],
        [
            [
                "{",
                "    #[derive(Eq, PartialEq)]",
                "    struct Key(usize);",
                "",
                "    let mut index_map = IndexMapCore::new();",
                "    let hash_value = HashValue(789);",
                "    let key1 = Key(3);",
                "    let key2 = Key(4);",
                "    let value1 = 12;",
                "    let value2 = 34;",
                "",
                "    // Insert first key-value pair",
                "    index_map.insert_full(hash_value, key1, value1);",
                "",
                "    // Insert second key-value pair generating a collision with hash_value",
                "    let (index, previous_value) = index_map.insert_full(hash_value, key2, value2);",
                "",
                "    assert_eq!(index, 1); // Second entry at index 1",
                "    assert_eq!(previous_value, None); // No previous value for key2",
                "}"
            ],
            [
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                349,
                350,
                351,
                352,
                353,
                354,
                357
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "   #[derive(Eq, PartialEq)]",
                "   struct TestKey(usize);",
                "   struct TestValue(usize);",
                "   ",
                "    let mut index_map = IndexMapCore::<TestKey, TestValue>::new();",
                "    let hash_value1 = HashValue(1);",
                "    let key1 = TestKey(1);",
                "    let value1 = TestValue(10);",
                "    ",
                "    let hash_value2 = HashValue(2);",
                "    let key2 = TestKey(2);",
                "    let value2 = TestValue(20);",
                "",
                "    // Insert first entry",
                "    let (index1, existing_value1) = index_map.insert_full(hash_value1, key1, value1);",
                "    assert_eq!(index1, 0);",
                "    assert!(existing_value1.is_none());",
                "",
                "    // Insert second entry",
                "    let (index2, existing_value2) = index_map.insert_full(hash_value2, key2, value2);",
                "    assert_eq!(index2, 1); // Should be at index 1 now",
                "    assert!(existing_value2.is_none()); // No existing value to replace",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    // Initialize the IndexMapCore with usize as K and String as V",
                "    let mut index_map: IndexMapCore<usize, String> = IndexMapCore::new();",
                "",
                "    // Create a HashValue for the test",
                "    let hash_value = HashValue(42);",
                "    let key = 1;",
                "    let value = String::from(\"value1\");",
                "",
                "    // Insert a key-value pair which should be a vacant entry",
                "    let (index, previous_value) = index_map.insert_full(hash_value, key, value.clone());",
                "",
                "    // Verify the index at which the item was inserted",
                "    assert_eq!(index, 0);",
                "    // Verify that previously there was no value at this index",
                "    assert_eq!(previous_value, None);",
                "    // Verify the item was actually inserted",
                "    assert_eq!(index_map.entries.len(), 1);",
                "    assert_eq!(index_map.entries[0].key, key);",
                "    assert_eq!(index_map.entries[0].value, value);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    // Initialize the IndexMapCore with usize as K and String as V",
                "    let mut index_map: IndexMapCore<usize, String> = IndexMapCore::new();",
                "",
                "    // Create a HashValue for two test entries",
                "    let hash_value_1 = HashValue(42);",
                "    let key_1 = 1;",
                "    let value_1 = String::from(\"value1\");",
                "",
                "    let hash_value_2 = HashValue(42);",
                "    let key_2 = 1;",
                "    let value_2 = String::from(\"value2\");",
                "",
                "    // Insert first key-value pair",
                "    index_map.insert_full(hash_value_1, key_1, value_1);",
                "",
                "    // Insert another key-value pair with the same key which should now be occupied",
                "    let (index, previous_value) = index_map.insert_full(hash_value_2, key_2, value_2.clone());",
                "",
                "    // Verify the index at which the item was updated",
                "    assert_eq!(index, 0);",
                "    // Verify that the previous value was returned",
                "    assert_eq!(previous_value, Some(String::from(\"value1\")));",
                "    // Verify that the value has been updated to the new value",
                "    assert_eq!(index_map.entries[0].value, value_2);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   #[derive(Eq, PartialEq, Clone)]",
                "   struct Key(usize);",
                "   ",
                "   let mut index_map = IndexMapCore::new();",
                "   let hash_value = HashValue(123);",
                "   let key = Key(1);",
                "   let value = 42;",
                "",
                "   // Insert an initial value to create an occupied entry.",
                "   index_map.insert_full(hash_value, key.clone(), value);",
                "",
                "   // Now insert with the same key and expect to get back the previous value.",
                "   let new_value = 43;",
                "   let (index, previous_value) = index_map.insert_full(hash_value, key.clone(), new_value);",
                "",
                "   assert_eq!(index, 0); // Should be at index 0",
                "   assert_eq!(previous_value, Some(value)); // Should return the old value",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    #[derive(Eq, PartialEq)]",
                "    struct Key(usize);",
                "",
                "    let mut index_map = IndexMapCore::new();",
                "    let hash_value = HashValue(456);",
                "    let key = Key(2);",
                "    let value = 24;",
                "",
                "    // Insert for the first time, it should be a vacant entry.",
                "    let (index, previous_value) = index_map.insert_full(hash_value, key, value);",
                "",
                "    assert_eq!(index, 0); // The first insertion goes to index 0",
                "    assert_eq!(previous_value, None); // There was no previous value",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    #[derive(Eq, PartialEq)]",
                "    struct Key(usize);",
                "",
                "    let mut index_map = IndexMapCore::new();",
                "    let hash_value = HashValue(789);",
                "    let key1 = Key(3);",
                "    let key2 = Key(4);",
                "    let value1 = 12;",
                "    let value2 = 34;",
                "",
                "    // Insert first key-value pair",
                "    index_map.insert_full(hash_value, key1, value1);",
                "",
                "    // Insert second key-value pair generating a collision with hash_value",
                "    let (index, previous_value) = index_map.insert_full(hash_value, key2, value2);",
                "",
                "    assert_eq!(index, 1); // Second entry at index 1",
                "    assert_eq!(previous_value, None); // No previous value for key2",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/map/core.rs"
}