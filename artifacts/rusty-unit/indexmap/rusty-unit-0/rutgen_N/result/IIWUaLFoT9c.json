{
    "function_name": "indexmap::set::set::IndexSet<T, S>::get_range",
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/set.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/indexmap",
    "tests": 4,
    "tests_lines": [
        43,
        43,
        43,
        43
    ],
    "oracles": 4,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 50.0,
    "oracles_run": 2,
    "oracles_passed": 2,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 5,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        1003,
        1004,
        1005,
        1006,
        1007
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    use std::ops::Range;",
                "",
                "    struct MyIndexMap<T> {",
                "        entries: Vec<T>,",
                "    }",
                "",
                "    impl<T> MyIndexMap<T> {",
                "        pub fn new(entries: Vec<T>) -> Self {",
                "            MyIndexMap { entries }",
                "        }",
                "",
                "        pub fn get_range<R: std::ops::RangeBounds<usize>>(&self, range: R) -> Option<&[T]> {",
                "            let len = self.entries.len();",
                "            let range = try_simplify_range(range, len)?;",
                "            Some(&self.entries[range])",
                "        }",
                "    }",
                "",
                "    fn try_simplify_range<R: RangeBounds<usize>>(range: R, len: usize) -> Option<Range<usize>> {",
                "        let start = match range.start_bound() {",
                "            std::ops::Bound::Included(&s) => s,",
                "            std::ops::Bound::Excluded(&s) => s + 1,",
                "            std::ops::Bound::Unbounded => 0,",
                "        };",
                "",
                "        let end = match range.end_bound() {",
                "            std::ops::Bound::Included(&e) => e + 1,",
                "            std::ops::Bound::Excluded(&e) => e,",
                "            std::ops::Bound::Unbounded => len,",
                "        };",
                "",
                "        if start < end && end <= len {",
                "            Some(start..end)",
                "        } else {",
                "            None",
                "        }",
                "    }",
                "",
                "    let map: MyIndexMap<i32> = MyIndexMap::new(vec![]);",
                "    let result = map.get_range(0..1);",
                "    assert_eq!(result, None);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ops::Range;",
                "",
                "    struct MyIndexMap<T> {",
                "        entries: Vec<T>,",
                "    }",
                "",
                "    impl<T> MyIndexMap<T> {",
                "        pub fn new(entries: Vec<T>) -> Self {",
                "            MyIndexMap { entries }",
                "        }",
                "",
                "        pub fn get_range<R: std::ops::RangeBounds<usize>>(&self, range: R) -> Option<&[T]> {",
                "            let len = self.entries.len();",
                "            let range = try_simplify_range(range, len)?;",
                "            Some(&self.entries[range])",
                "        }",
                "    }",
                "",
                "    fn try_simplify_range<R: RangeBounds<usize>>(range: R, len: usize) -> Option<Range<usize>> {",
                "        let start = match range.start_bound() {",
                "            std::ops::Bound::Included(&s) => s,",
                "            std::ops::Bound::Excluded(&s) => s + 1,",
                "            std::ops::Bound::Unbounded => 0,",
                "        };",
                "",
                "        let end = match range.end_bound() {",
                "            std::ops::Bound::Included(&e) => e + 1,",
                "            std::ops::Bound::Excluded(&e) => e,",
                "            std::ops::Bound::Unbounded => len,",
                "        };",
                "",
                "        if start < end && end <= len {",
                "            Some(start..end)",
                "        } else {",
                "            None",
                "        }",
                "    }",
                "",
                "    let map = MyIndexMap::new(vec![1, 2, 3]);",
                "    let result = map.get_range(3..5);",
                "    assert_eq!(result, None);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    use std::ops::Range;",
                "",
                "    struct MyIndexMap<T> {",
                "        entries: Vec<T>,",
                "    }",
                "",
                "    impl<T> MyIndexMap<T> {",
                "        pub fn new(entries: Vec<T>) -> Self {",
                "            MyIndexMap { entries }",
                "        }",
                "",
                "        pub fn get_range<R: std::ops::RangeBounds<usize>>(&self, range: R) -> Option<&[T]> {",
                "            let len = self.entries.len();",
                "            let range = try_simplify_range(range, len)?;",
                "            Some(&self.entries[range])",
                "        }",
                "    }",
                "",
                "    fn try_simplify_range<R: RangeBounds<usize>>(range: R, len: usize) -> Option<Range<usize>> {",
                "        let start = match range.start_bound() {",
                "            std::ops::Bound::Included(&s) => s,",
                "            std::ops::Bound::Excluded(&s) => s + 1,",
                "            std::ops::Bound::Unbounded => 0,",
                "        };",
                "",
                "        let end = match range.end_bound() {",
                "            std::ops::Bound::Included(&e) => e + 1,",
                "            std::ops::Bound::Excluded(&e) => e,",
                "            std::ops::Bound::Unbounded => len,",
                "        };",
                "",
                "        if start < end && end <= len {",
                "            Some(start..end)",
                "        } else {",
                "            None",
                "        }",
                "    }",
                "",
                "    let map: MyIndexMap<i32> = MyIndexMap::new(vec![]);",
                "    let result = map.get_range(0..1);",
                "    assert_eq!(result, None);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ops::Range;",
                "",
                "    struct MyIndexMap<T> {",
                "        entries: Vec<T>,",
                "    }",
                "",
                "    impl<T> MyIndexMap<T> {",
                "        pub fn new(entries: Vec<T>) -> Self {",
                "            MyIndexMap { entries }",
                "        }",
                "",
                "        pub fn get_range<R: std::ops::RangeBounds<usize>>(&self, range: R) -> Option<&[T]> {",
                "            let len = self.entries.len();",
                "            let range = try_simplify_range(range, len)?;",
                "            Some(&self.entries[range])",
                "        }",
                "    }",
                "",
                "    fn try_simplify_range<R: RangeBounds<usize>>(range: R, len: usize) -> Option<Range<usize>> {",
                "        let start = match range.start_bound() {",
                "            std::ops::Bound::Included(&s) => s,",
                "            std::ops::Bound::Excluded(&s) => s + 1,",
                "            std::ops::Bound::Unbounded => 0,",
                "        };",
                "",
                "        let end = match range.end_bound() {",
                "            std::ops::Bound::Included(&e) => e + 1,",
                "            std::ops::Bound::Excluded(&e) => e,",
                "            std::ops::Bound::Unbounded => len,",
                "        };",
                "",
                "        if start < end && end <= len {",
                "            Some(start..end)",
                "        } else {",
                "            None",
                "        }",
                "    }",
                "",
                "    let map = MyIndexMap::new(vec![1, 2, 3]);",
                "    let result = map.get_range(3..5);",
                "    assert_eq!(result, None);",
                "}"
            ],
            []
        ]
    ]
}