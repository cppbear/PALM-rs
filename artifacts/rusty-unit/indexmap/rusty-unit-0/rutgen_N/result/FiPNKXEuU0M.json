{
    "function_name": "indexmap::set::set::IndexSet<T, S>::sort_by_cached_key",
    "file_path": "/home/abezbm/rusty-unit/evaluation/indexmap/rusty-unit-0/src/set.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/indexmap",
    "tests": 2,
    "tests_lines": [
        32,
        32
    ],
    "oracles": 2,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 100.0,
    "oracles_run": 2,
    "oracles_passed": 2,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 9,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        901,
        902,
        903,
        904,
        905,
        906,
        907,
        908,
        909
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct TestSet {",
                "        entries: Vec<(i32, char)>,",
                "    }",
                "",
                "    impl TestSet {",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut Vec<(i32, char)>),",
                "        {",
                "            f(&mut self.entries);",
                "        }",
                "",
                "        fn sort_by_cached_key<K, F>(&mut self, mut sort_key: F)",
                "        where",
                "            K: Ord,",
                "            F: FnMut(&(i32, char)) -> K,",
                "        {",
                "            self.with_entries(move |entries| {",
                "                entries.sort_by_cached_key(move |a| sort_key(&a));",
                "            });",
                "        }",
                "    }",
                "",
                "    let mut test_set = TestSet {",
                "        entries: vec![(3, 'c'), (1, 'a'), (2, 'b')],",
                "    };",
                "",
                "    test_set.sort_by_cached_key(|&(_, value)| value);",
                "",
                "    assert_eq!(test_set.entries, vec![(1, 'a'), (2, 'b'), (3, 'c')]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestSet {",
                "        entries: Vec<(i32, char)>,",
                "    }",
                "",
                "    impl TestSet {",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut Vec<(i32, char)>),",
                "        {",
                "            f(&mut self.entries);",
                "        }",
                "",
                "        fn sort_by_cached_key<K, F>(&mut self, mut sort_key: F)",
                "        where",
                "            K: Ord,",
                "            F: FnMut(&(i32, char)) -> K,",
                "        {",
                "            self.with_entries(move |entries| {",
                "                entries.sort_by_cached_key(move |a| sort_key(&a));",
                "            });",
                "        }",
                "    }",
                "",
                "    let mut test_set = TestSet {",
                "        entries: vec![(3, 'a'), (1, 'a'), (2, 'b')],",
                "    };",
                "",
                "    test_set.sort_by_cached_key(|&(_, value)| value);",
                "",
                "    assert_eq!(test_set.entries, vec![(3, 'a'), (1, 'a'), (2, 'b')]);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct TestSet {",
                "        entries: Vec<(i32, char)>,",
                "    }",
                "",
                "    impl TestSet {",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut Vec<(i32, char)>),",
                "        {",
                "            f(&mut self.entries);",
                "        }",
                "",
                "        fn sort_by_cached_key<K, F>(&mut self, mut sort_key: F)",
                "        where",
                "            K: Ord,",
                "            F: FnMut(&(i32, char)) -> K,",
                "        {",
                "            self.with_entries(move |entries| {",
                "                entries.sort_by_cached_key(move |a| sort_key(&a));",
                "            });",
                "        }",
                "    }",
                "",
                "    let mut test_set = TestSet {",
                "        entries: vec![(3, 'c'), (1, 'a'), (2, 'b')],",
                "    };",
                "",
                "    test_set.sort_by_cached_key(|&(_, value)| value);",
                "",
                "    assert_eq!(test_set.entries, vec![(1, 'a'), (2, 'b'), (3, 'c')]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestSet {",
                "        entries: Vec<(i32, char)>,",
                "    }",
                "",
                "    impl TestSet {",
                "        fn with_entries<F>(&mut self, f: F)",
                "        where",
                "            F: FnOnce(&mut Vec<(i32, char)>),",
                "        {",
                "            f(&mut self.entries);",
                "        }",
                "",
                "        fn sort_by_cached_key<K, F>(&mut self, mut sort_key: F)",
                "        where",
                "            K: Ord,",
                "            F: FnMut(&(i32, char)) -> K,",
                "        {",
                "            self.with_entries(move |entries| {",
                "                entries.sort_by_cached_key(move |a| sort_key(&a));",
                "            });",
                "        }",
                "    }",
                "",
                "    let mut test_set = TestSet {",
                "        entries: vec![(3, 'a'), (1, 'a'), (2, 'b')],",
                "    };",
                "",
                "    test_set.sort_by_cached_key(|&(_, value)| value);",
                "",
                "    assert_eq!(test_set.entries, vec![(3, 'a'), (1, 'a'), (2, 'b')]);",
                "}"
            ],
            []
        ]
    ]
}