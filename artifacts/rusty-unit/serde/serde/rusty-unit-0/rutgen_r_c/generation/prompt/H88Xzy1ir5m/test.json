{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/de/impls.rs\n// crate name is serde\nuse crate::lib::*;\nuse crate::de::{\n    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, Unexpected,\n    VariantAccess, Visitor,\n};\nuse crate::seed::InPlaceSeed;\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse crate::de::size_hint;\nmacro_rules! impl_deserialize_num {\n    (\n        $primitive:ident, $nonzero:ident, $deserialize:ident $($method:ident !\n        ($($val:ident : $visit:ident)*);)*\n    ) => {\n        impl_deserialize_num!($primitive, $deserialize $($method ! ($($val :\n        $visit)*);)*); impl <'de > Deserialize <'de > for num::$nonzero { fn deserialize\n        < D > (deserializer : D) -> Result < Self, D::Error > where D : Deserializer <'de\n        >, { struct NonZeroVisitor; impl <'de > Visitor <'de > for NonZeroVisitor { type\n        Value = num::$nonzero; fn expecting(& self, formatter : & mut fmt::Formatter) ->\n        fmt::Result { formatter.write_str(concat!(\"a nonzero \", stringify!($primitive)))\n        } $($($method ! (nonzero $primitive $val : $visit);)*)* } deserializer\n        .$deserialize (NonZeroVisitor) } } #[cfg(not(no_core_num_saturating))] impl <'de\n        > Deserialize <'de > for Saturating <$primitive > { fn deserialize < D >\n        (deserializer : D) -> Result < Self, D::Error > where D : Deserializer <'de >, {\n        struct SaturatingVisitor; impl <'de > Visitor <'de > for SaturatingVisitor { type\n        Value = Saturating <$primitive >; fn expecting(& self, formatter : & mut\n        fmt::Formatter) -> fmt::Result { formatter\n        .write_str(\"integer with support for saturating semantics\") } $($($method !\n        (saturating $primitive $val : $visit);)*)* } deserializer.$deserialize\n        (SaturatingVisitor) } }\n    };\n    (\n        $primitive:ident, $deserialize:ident $($method:ident ! ($($val:ident :\n        $visit:ident)*);)*\n    ) => {\n        impl <'de > Deserialize <'de > for $primitive { #[inline] fn deserialize < D >\n        (deserializer : D) -> Result < Self, D::Error > where D : Deserializer <'de >, {\n        struct PrimitiveVisitor; impl <'de > Visitor <'de > for PrimitiveVisitor { type\n        Value = $primitive; fn expecting(& self, formatter : & mut fmt::Formatter) ->\n        fmt::Result { formatter.write_str(stringify!($primitive)) } $($($method ! ($val :\n        $visit);)*)* } deserializer.$deserialize (PrimitiveVisitor) } }\n    };\n}\nmacro_rules! num_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline] fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E :\n        Error, { Ok(v) }\n    };\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if let Some(nonzero) = Self::Value::new(v) { Ok(nonzero) } else {\n        Err(Error::invalid_value(Unexpected::Unsigned(0), & self)) } }\n    };\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        Ok(Saturating(v)) }\n    };\n}\nmacro_rules! num_as_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline] fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E :\n        Error, { Ok(v as Self::Value) }\n    };\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if let Some(nonzero) = Self::Value::new(v as $primitive) { Ok(nonzero) } else {\n        Err(Error::invalid_value(Unexpected::Unsigned(0), & self)) } }\n    };\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        Ok(Saturating(v as $primitive)) }\n    };\n}\nmacro_rules! num_as_copysign_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline] fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E :\n        Error, { #[cfg(not(feature = \"std\"))] { Ok(v as Self::Value) } #[cfg(feature =\n        \"std\")] { let sign = if v.is_sign_positive() { 1.0 } else { - 1.0 }; Ok((v as\n        Self::Value).copysign(sign)) } }\n    };\n}\nmacro_rules! int_to_int {\n    ($ty:ident : $visit:ident) => {\n        #[inline] fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E :\n        Error, { Self::Value::try_from(v as i64).map_err(| _ |\n        Error::invalid_value(Unexpected::Signed(v as i64), & self)) }\n    };\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if let Ok(v) = $primitive ::try_from(v as i64) { if let Some(nonzero) =\n        Self::Value::new(v) { return Ok(nonzero); } }\n        Err(Error::invalid_value(Unexpected::Signed(v as i64), & self)) }\n    };\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if (v as i64) < $primitive ::MIN as i64 { Ok(Saturating($primitive ::MIN)) } else\n        if ($primitive ::MAX as i64) < v as i64 { Ok(Saturating($primitive ::MAX)) } else\n        { Ok(Saturating(v as $primitive)) } }\n    };\n}\nmacro_rules! int_to_uint {\n    ($ty:ident : $visit:ident) => {\n        #[inline] fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E :\n        Error, { if 0 <= v { #[allow(irrefutable_let_patterns)] if let Ok(v) =\n        Self::Value::try_from(v as u64) { return Ok(v as Self::Value); } }\n        Err(Error::invalid_value(Unexpected::Signed(v as i64), & self)) }\n    };\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if 0 < v { #[allow(irrefutable_let_patterns)] if let Ok(v) = $primitive\n        ::try_from(v as u64) { if let Some(nonzero) = Self::Value::new(v) { return\n        Ok(nonzero); } } } Err(Error::invalid_value(Unexpected::Signed(v as i64), &\n        self)) }\n    };\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if v < 0 { Ok(Saturating(0)) } else if ($primitive ::MAX as u64) < v as u64 {\n        Ok(Saturating($primitive ::MAX)) } else { Ok(Saturating(v as $primitive)) } }\n    };\n}\nmacro_rules! uint_to_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline] fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E :\n        Error, { Self::Value::try_from(v as u64).map_err(| _ |\n        Error::invalid_value(Unexpected::Unsigned(v as u64), & self)) }\n    };\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if let Ok(v) = $primitive ::try_from(v as u64) { if let Some(nonzero) =\n        Self::Value::new(v) { return Ok(nonzero); } }\n        Err(Error::invalid_value(Unexpected::Unsigned(v as u64), & self)) }\n    };\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if let Ok(v) = $primitive ::try_from(v as u64) { Ok(Saturating(v as $primitive))\n        } else { Ok(Saturating($primitive ::MAX)) } }\n    };\n}\nimpl_deserialize_num! {\n    i8, NonZeroI8, deserialize_i8 num_self!(i8 : visit_i8); int_to_int!(i16 : visit_i16\n    i32 : visit_i32 i64 : visit_i64); uint_to_self!(u8 : visit_u8 u16 : visit_u16 u32 :\n    visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    i16, NonZeroI16, deserialize_i16 num_self!(i16 : visit_i16); num_as_self!(i8 :\n    visit_i8); int_to_int!(i32 : visit_i32 i64 : visit_i64); uint_to_self!(u8 : visit_u8\n    u16 : visit_u16 u32 : visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    i32, NonZeroI32, deserialize_i32 num_self!(i32 : visit_i32); num_as_self!(i8 :\n    visit_i8 i16 : visit_i16); int_to_int!(i64 : visit_i64); uint_to_self!(u8 : visit_u8\n    u16 : visit_u16 u32 : visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    i64, NonZeroI64, deserialize_i64 num_self!(i64 : visit_i64); num_as_self!(i8 :\n    visit_i8 i16 : visit_i16 i32 : visit_i32); uint_to_self!(u8 : visit_u8 u16 :\n    visit_u16 u32 : visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    isize, NonZeroIsize, deserialize_i64 num_as_self!(i8 : visit_i8 i16 : visit_i16);\n    int_to_int!(i32 : visit_i32 i64 : visit_i64); uint_to_self!(u8 : visit_u8 u16 :\n    visit_u16 u32 : visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    u8, NonZeroU8, deserialize_u8 num_self!(u8 : visit_u8); int_to_uint!(i8 : visit_i8\n    i16 : visit_i16 i32 : visit_i32 i64 : visit_i64); uint_to_self!(u16 : visit_u16 u32 :\n    visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    u16, NonZeroU16, deserialize_u16 num_self!(u16 : visit_u16); num_as_self!(u8 :\n    visit_u8); int_to_uint!(i8 : visit_i8 i16 : visit_i16 i32 : visit_i32 i64 :\n    visit_i64); uint_to_self!(u32 : visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    u32, NonZeroU32, deserialize_u32 num_self!(u32 : visit_u32); num_as_self!(u8 :\n    visit_u8 u16 : visit_u16); int_to_uint!(i8 : visit_i8 i16 : visit_i16 i32 : visit_i32\n    i64 : visit_i64); uint_to_self!(u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    u64, NonZeroU64, deserialize_u64 num_self!(u64 : visit_u64); num_as_self!(u8 :\n    visit_u8 u16 : visit_u16 u32 : visit_u32); int_to_uint!(i8 : visit_i8 i16 : visit_i16\n    i32 : visit_i32 i64 : visit_i64);\n}\nimpl_deserialize_num! {\n    usize, NonZeroUsize, deserialize_u64 num_as_self!(u8 : visit_u8 u16 : visit_u16);\n    int_to_uint!(i8 : visit_i8 i16 : visit_i16 i32 : visit_i32 i64 : visit_i64);\n    uint_to_self!(u32 : visit_u32 u64 : visit_u64);\n}\nimpl_deserialize_num! {\n    f32, deserialize_f32 num_self!(f32 : visit_f32); num_as_copysign_self!(f64 :\n    visit_f64); num_as_self!(i8 : visit_i8 i16 : visit_i16 i32 : visit_i32 i64 :\n    visit_i64); num_as_self!(u8 : visit_u8 u16 : visit_u16 u32 : visit_u32 u64 :\n    visit_u64);\n}\nimpl_deserialize_num! {\n    f64, deserialize_f64 num_self!(f64 : visit_f64); num_as_copysign_self!(f32 :\n    visit_f32); num_as_self!(i8 : visit_i8 i16 : visit_i16 i32 : visit_i32 i64 :\n    visit_i64); num_as_self!(u8 : visit_u8 u16 : visit_u16 u32 : visit_u32 u64 :\n    visit_u64);\n}\nmacro_rules! num_128 {\n    ($ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if v as i128 >= Self::Value::MIN as i128 && v as u128 <= Self::Value::MAX as u128\n        { Ok(v as Self::Value) } else {\n        Err(Error::invalid_value(Unexpected::Other(stringify!($ty)), & self,)) } }\n    };\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if v as i128 >= $primitive ::MIN as i128 && v as u128 <= $primitive ::MAX as u128\n        { if let Some(nonzero) = Self::Value::new(v as $primitive) { Ok(nonzero) } else {\n        Err(Error::invalid_value(Unexpected::Unsigned(0), & self)) } } else {\n        Err(Error::invalid_value(Unexpected::Other(stringify!($ty)), & self,)) } }\n    };\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit < E > (self, v : $ty) -> Result < Self::Value, E > where E : Error, {\n        if (v as i128) < $primitive ::MIN as i128 { Ok(Saturating($primitive ::MIN)) }\n        else if ($primitive ::MAX as u128) < v as u128 { Ok(Saturating($primitive ::MAX))\n        } else { Ok(Saturating(v as $primitive)) } }\n    };\n}\nimpl_deserialize_num! {\n    i128, NonZeroI128, deserialize_i128 num_self!(i128 : visit_i128); num_as_self!(i8 :\n    visit_i8 i16 : visit_i16 i32 : visit_i32 i64 : visit_i64); num_as_self!(u8 : visit_u8\n    u16 : visit_u16 u32 : visit_u32 u64 : visit_u64); num_128!(u128 : visit_u128);\n}\nimpl_deserialize_num! {\n    u128, NonZeroU128, deserialize_u128 num_self!(u128 : visit_u128); num_as_self!(u8 :\n    visit_u8 u16 : visit_u16 u32 : visit_u32 u64 : visit_u64); int_to_uint!(i8 : visit_i8\n    i16 : visit_i16 i32 : visit_i32 i64 : visit_i64); num_128!(i128 : visit_i128);\n}\nmacro_rules! forwarded_impl {\n    ($(#[$attr:meta])* ($($id:ident),*), $ty:ty, $func:expr) => {\n        $(#[$attr])* impl <'de $(, $id : Deserialize <'de >,)*> Deserialize <'de > for\n        $ty { fn deserialize < D > (deserializer : D) -> Result < Self, D::Error > where\n        D : Deserializer <'de >, { Deserialize::deserialize(deserializer).map($func) } }\n    };\n}\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", all(not(no_core_cstr), feature = \"alloc\")))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] (), Box < CStr\n    >, CString::into_boxed_c_str\n}\nforwarded_impl! {\n    (T), Reverse < T >, Reverse\n}\nmacro_rules! seq_impl {\n    (\n        $(#[$attr:meta])* $ty:ident < T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(,\n        $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*>, $access:ident,\n        $clear:expr, $with_capacity:expr, $reserve:expr, $insert:expr\n    ) => {\n        $(#[$attr])* impl <'de, T $(, $typaram)*> Deserialize <'de > for $ty < T $(,\n        $typaram)*> where T : Deserialize <'de > $(+ $tbound1 $(+ $tbound2)*)*,\n        $($typaram : $bound1 $(+ $bound2)*,)* { fn deserialize < D > (deserializer : D)\n        -> Result < Self, D::Error > where D : Deserializer <'de >, { struct SeqVisitor <\n        T $(, $typaram)*> { marker : PhantomData <$ty < T $(, $typaram)*>>, } impl <'de,\n        T $(, $typaram)*> Visitor <'de > for SeqVisitor < T $(, $typaram)*> where T :\n        Deserialize <'de > $(+ $tbound1 $(+ $tbound2)*)*, $($typaram : $bound1 $(+\n        $bound2)*,)* { type Value = $ty < T $(, $typaram)*>; fn expecting(& self,\n        formatter : & mut fmt::Formatter) -> fmt::Result { formatter\n        .write_str(\"a sequence\") } #[inline] fn visit_seq < A > (self, mut $access : A)\n        -> Result < Self::Value, A::Error > where A : SeqAccess <'de >, { let mut values\n        = $with_capacity; while let Some(value) = tri!($access .next_element()) { $insert\n        (& mut values, value); } Ok(values) } } let visitor = SeqVisitor { marker :\n        PhantomData }; deserializer.deserialize_seq(visitor) } fn deserialize_in_place <\n        D > (deserializer : D, place : & mut Self) -> Result < (), D::Error > where D :\n        Deserializer <'de >, { struct SeqInPlaceVisitor <'a, T : 'a $(, $typaram : 'a)*>\n        (&'a mut $ty < T $(, $typaram)*>); impl <'a, 'de, T $(, $typaram)*> Visitor <'de\n        > for SeqInPlaceVisitor <'a, T $(, $typaram)*> where T : Deserialize <'de > $(+\n        $tbound1 $(+ $tbound2)*)*, $($typaram : $bound1 $(+ $bound2)*,)* { type Value =\n        (); fn expecting(& self, formatter : & mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a sequence\") } #[inline] fn visit_seq < A > (mut self, mut\n        $access : A) -> Result < Self::Value, A::Error > where A : SeqAccess <'de >, {\n        $clear (& mut self.0); $reserve (& mut self.0, size_hint::cautious::< T >\n        ($access .size_hint())); while let Some(value) = tri!($access .next_element()) {\n        $insert (& mut self.0, value); } Ok(()) } } deserializer\n        .deserialize_seq(SeqInPlaceVisitor(place)) } }\n    };\n}\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] BinaryHeap < T : Ord >, seq,\n    BinaryHeap::clear, BinaryHeap::with_capacity(size_hint::cautious::< T > (seq\n    .size_hint())), BinaryHeap::reserve, BinaryHeap::push\n);\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] BTreeSet < T : Eq + Ord >, seq,\n    BTreeSet::clear, BTreeSet::new(), nop_reserve, BTreeSet::insert\n);\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] LinkedList < T >, seq,\n    LinkedList::clear, LinkedList::new(), nop_reserve, LinkedList::push_back\n);\nseq_impl!(\n    #[cfg(feature = \"std\")] #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))] HashSet < T :\n    Eq + Hash, S : BuildHasher + Default >, seq, HashSet::clear,\n    HashSet::with_capacity_and_hasher(size_hint::cautious::< T > (seq.size_hint()),\n    S::default()), HashSet::reserve, HashSet::insert\n);\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] VecDeque < T >, seq,\n    VecDeque::clear, VecDeque::with_capacity(size_hint::cautious::< T > (seq\n    .size_hint())), VecDeque::reserve, VecDeque::push_back\n);\nmacro_rules! array_impls {\n    ($($len:expr => ($($n:tt)+))+) => {\n        $(impl <'de, T > Visitor <'de > for ArrayVisitor < [T; $len] > where T :\n        Deserialize <'de >, { type Value = [T; $len]; fn expecting(& self, formatter : &\n        mut fmt::Formatter) -> fmt::Result { formatter\n        .write_str(concat!(\"an array of length \", $len)) } #[inline] fn visit_seq < A >\n        (self, mut seq : A) -> Result < Self::Value, A::Error > where A : SeqAccess <'de\n        >, { Ok([$(match tri!(seq.next_element()) { Some(val) => val, None => return\n        Err(Error::invalid_length($n, & self)), }),+]) } } impl <'a, 'de, T > Visitor\n        <'de > for ArrayInPlaceVisitor <'a, [T; $len] > where T : Deserialize <'de >, {\n        type Value = (); fn expecting(& self, formatter : & mut fmt::Formatter) ->\n        fmt::Result { formatter.write_str(concat!(\"an array of length \", $len)) }\n        #[inline] fn visit_seq < A > (self, mut seq : A) -> Result < Self::Value,\n        A::Error > where A : SeqAccess <'de >, { let mut fail_idx = None; for (idx, dest)\n        in self.0[..].iter_mut().enumerate() { if tri!(seq\n        .next_element_seed(InPlaceSeed(dest))) .is_none() { fail_idx = Some(idx); break;\n        } } if let Some(idx) = fail_idx { return Err(Error::invalid_length(idx, & self));\n        } Ok(()) } } impl <'de, T > Deserialize <'de > for [T; $len] where T :\n        Deserialize <'de >, { fn deserialize < D > (deserializer : D) -> Result < Self,\n        D::Error > where D : Deserializer <'de >, { deserializer.deserialize_tuple($len,\n        ArrayVisitor::< [T; $len] >::new()) } fn deserialize_in_place < D > (deserializer\n        : D, place : & mut Self) -> Result < (), D::Error > where D : Deserializer <'de\n        >, { deserializer.deserialize_tuple($len, ArrayInPlaceVisitor(place)) } })+\n    };\n}\narray_impls! {\n    1 => (0) 2 => (0 1) 3 => (0 1 2) 4 => (0 1 2 3) 5 => (0 1 2 3 4) 6 => (0 1 2 3 4 5) 7\n    => (0 1 2 3 4 5 6) 8 => (0 1 2 3 4 5 6 7) 9 => (0 1 2 3 4 5 6 7 8) 10 => (0 1 2 3 4 5\n    6 7 8 9) 11 => (0 1 2 3 4 5 6 7 8 9 10) 12 => (0 1 2 3 4 5 6 7 8 9 10 11) 13 => (0 1\n    2 3 4 5 6 7 8 9 10 11 12) 14 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13) 15 => (0 1 2 3 4 5\n    6 7 8 9 10 11 12 13 14) 16 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) 17 => (0 1 2 3\n    4 5 6 7 8 9 10 11 12 13 14 15 16) 18 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)\n    19 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18) 20 => (0 1 2 3 4 5 6 7 8 9 10\n    11 12 13 14 15 16 17 18 19) 21 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n    20) 22 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21) 23 => (0 1 2 3 4\n    5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22) 24 => (0 1 2 3 4 5 6 7 8 9 10 11 12\n    13 14 15 16 17 18 19 20 21 22 23) 25 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17\n    18 19 20 21 22 23 24) 26 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\n    22 23 24 25) 27 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n    25 26) 28 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\n    27) 29 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27\n    28) 30 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27\n    28 29) 31 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\n    27 28 29 30) 32 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n    25 26 27 28 29 30 31)\n}\nmacro_rules! tuple_impls {\n    ($($len:tt => ($($n:tt $name:ident)+))+) => {\n        $(#[cfg_attr(docsrs, doc(hidden))] impl <'de, $($name),+> Deserialize <'de > for\n        ($($name,)+) where $($name : Deserialize <'de >,)+ { tuple_impl_body!($len =>\n        ($($n $name)+)); })+\n    };\n}\nmacro_rules! tuple_impl_body {\n    ($len:tt => ($($n:tt $name:ident)+)) => {\n        #[inline] fn deserialize < D > (deserializer : D) -> Result < Self, D::Error >\n        where D : Deserializer <'de >, { struct TupleVisitor <$($name,)+> { marker :\n        PhantomData < ($($name,)+) >, } impl <'de, $($name : Deserialize <'de >),+>\n        Visitor <'de > for TupleVisitor <$($name,)+> { type Value = ($($name,)+); fn\n        expecting(& self, formatter : & mut fmt::Formatter) -> fmt::Result { formatter\n        .write_str(concat!(\"a tuple of size \", $len)) } #[inline]\n        #[allow(non_snake_case)] fn visit_seq < A > (self, mut seq : A) -> Result <\n        Self::Value, A::Error > where A : SeqAccess <'de >, { $(let $name = match\n        tri!(seq.next_element()) { Some(value) => value, None => return\n        Err(Error::invalid_length($n, & self)), };)+ Ok(($($name,)+)) } } deserializer\n        .deserialize_tuple($len, TupleVisitor { marker : PhantomData }) } #[inline] fn\n        deserialize_in_place < D > (deserializer : D, place : & mut Self) -> Result < (),\n        D::Error > where D : Deserializer <'de >, { struct TupleInPlaceVisitor <'a,\n        $($name : 'a,)+> (&'a mut ($($name,)+)); impl <'a, 'de, $($name : Deserialize\n        <'de >),+> Visitor <'de > for TupleInPlaceVisitor <'a, $($name,)+> { type Value =\n        (); fn expecting(& self, formatter : & mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(concat!(\"a tuple of size \", $len)) } #[inline]\n        #[allow(non_snake_case)] fn visit_seq < A > (self, mut seq : A) -> Result <\n        Self::Value, A::Error > where A : SeqAccess <'de >, { $(if tri!(seq\n        .next_element_seed(InPlaceSeed(& mut (self.0).$n))) .is_none() { return\n        Err(Error::invalid_length($n, & self)); })+ Ok(()) } } deserializer\n        .deserialize_tuple($len, TupleInPlaceVisitor(place)) }\n    };\n}\ntuple_impls! {\n    2 => (0 T0 1 T1) 3 => (0 T0 1 T1 2 T2) 4 => (0 T0 1 T1 2 T2 3 T3) 5 => (0 T0 1 T1 2\n    T2 3 T3 4 T4) 6 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5) 7 => (0 T0 1 T1 2 T2 3 T3 4 T4 5\n    T5 6 T6) 8 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7) 9 => (0 T0 1 T1 2 T2 3 T3 4\n    T4 5 T5 6 T6 7 T7 8 T8) 10 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9) 11\n    => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10) 12 => (0 T0 1 T1 2 T2 3\n    T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11) 13 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5\n    6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12) 14 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7\n    T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13) 15 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7\n    T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14) 16 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5\n    6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\nmacro_rules! map_impl {\n    (\n        $(#[$attr:meta])* $ty:ident < K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(,\n        $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*>, $access:ident,\n        $with_capacity:expr,\n    ) => {\n        $(#[$attr])* impl <'de, K, V $(, $typaram)*> Deserialize <'de > for $ty < K, V\n        $(, $typaram)*> where K : Deserialize <'de > $(+ $kbound1 $(+ $kbound2)*)*, V :\n        Deserialize <'de >, $($typaram : $bound1 $(+ $bound2)*),* { fn deserialize < D >\n        (deserializer : D) -> Result < Self, D::Error > where D : Deserializer <'de >, {\n        struct MapVisitor < K, V $(, $typaram)*> { marker : PhantomData <$ty < K, V $(,\n        $typaram)*>>, } impl <'de, K, V $(, $typaram)*> Visitor <'de > for MapVisitor <\n        K, V $(, $typaram)*> where K : Deserialize <'de > $(+ $kbound1 $(+ $kbound2)*)*,\n        V : Deserialize <'de >, $($typaram : $bound1 $(+ $bound2)*),* { type Value = $ty\n        < K, V $(, $typaram)*>; fn expecting(& self, formatter : & mut fmt::Formatter) ->\n        fmt::Result { formatter.write_str(\"a map\") } #[inline] fn visit_map < A > (self,\n        mut $access : A) -> Result < Self::Value, A::Error > where A : MapAccess <'de >,\n        { let mut values = $with_capacity; while let Some((key, value)) = tri!($access\n        .next_entry()) { values.insert(key, value); } Ok(values) } } let visitor =\n        MapVisitor { marker : PhantomData }; deserializer.deserialize_map(visitor) } }\n    };\n}\nmap_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] BTreeMap < K : Ord, V >, map,\n    BTreeMap::new(),\n}\nmap_impl! {\n    #[cfg(feature = \"std\")] #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))] HashMap < K :\n    Eq + Hash, V, S : BuildHasher + Default >, map,\n    HashMap::with_capacity_and_hasher(size_hint::cautious::< (K, V) > (map.size_hint()),\n    S::default()),\n}\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! parse_ip_impl {\n    ($ty:ty, $expecting:expr, $size:tt) => {\n        impl <'de > Deserialize <'de > for $ty { fn deserialize < D > (deserializer : D)\n        -> Result < Self, D::Error > where D : Deserializer <'de >, { if deserializer\n        .is_human_readable() { deserializer\n        .deserialize_str(FromStrVisitor::new($expecting)) } else { < [u8; $size]\n        >::deserialize(deserializer).map(<$ty >::from) } } }\n    };\n}\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! variant_identifier {\n    (\n        $name_kind:ident ($($variant:ident; $bytes:expr; $index:expr),*)\n        $expecting_message:expr, $variants_name:ident\n    ) => {\n        enum $name_kind { $($variant),* } static $variants_name : & [& str] = &\n        [$(stringify!($variant)),*]; impl <'de > Deserialize <'de > for $name_kind { fn\n        deserialize < D > (deserializer : D) -> Result < Self, D::Error > where D :\n        Deserializer <'de >, { struct KindVisitor; impl <'de > Visitor <'de > for\n        KindVisitor { type Value = $name_kind; fn expecting(& self, formatter : & mut\n        fmt::Formatter) -> fmt::Result { formatter.write_str($expecting_message) } fn\n        visit_u64 < E > (self, value : u64) -> Result < Self::Value, E > where E : Error,\n        { match value { $($index => Ok($name_kind :: $variant),)* _ =>\n        Err(Error::invalid_value(Unexpected::Unsigned(value), & self),), } } fn visit_str\n        < E > (self, value : & str) -> Result < Self::Value, E > where E : Error, { match\n        value { $(stringify!($variant) => Ok($name_kind :: $variant),)* _ =>\n        Err(Error::unknown_variant(value, $variants_name)), } } fn visit_bytes < E >\n        (self, value : & [u8]) -> Result < Self::Value, E > where E : Error, { match\n        value { $($bytes => Ok($name_kind :: $variant),)* _ => { match\n        str::from_utf8(value) { Ok(value) => Err(Error::unknown_variant(value,\n        $variants_name)), Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &\n        self)), } } } } } deserializer.deserialize_identifier(KindVisitor) } }\n    };\n}\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! deserialize_enum {\n    (\n        $name:ident $name_kind:ident ($($variant:ident; $bytes:expr; $index:expr),*)\n        $expecting_message:expr, $deserializer:expr\n    ) => {\n        variant_identifier! { $name_kind ($($variant; $bytes; $index),*)\n        $expecting_message, VARIANTS } struct EnumVisitor; impl <'de > Visitor <'de > for\n        EnumVisitor { type Value = $name; fn expecting(& self, formatter : & mut\n        fmt::Formatter) -> fmt::Result { formatter.write_str(concat!(\"a \",\n        stringify!($name))) } fn visit_enum < A > (self, data : A) -> Result <\n        Self::Value, A::Error > where A : EnumAccess <'de >, { match tri!(data.variant())\n        { $(($name_kind :: $variant, v) => v.newtype_variant().map($name :: $variant),)*\n        } } } $deserializer .deserialize_enum(stringify!($name), VARIANTS, EnumVisitor)\n    };\n}\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_ip_impl!(net::Ipv4Addr, \"IPv4 address\", 4);\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_ip_impl!(net::Ipv6Addr, \"IPv6 address\", 16);\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! parse_socket_impl {\n    ($ty:ty, $expecting:tt, $new:expr,) => {\n        impl <'de > Deserialize <'de > for $ty { fn deserialize < D > (deserializer : D)\n        -> Result < Self, D::Error > where D : Deserializer <'de >, { if deserializer\n        .is_human_readable() { deserializer\n        .deserialize_str(FromStrVisitor::new($expecting)) } else { < (_, u16)\n        >::deserialize(deserializer).map($new) } } }\n    };\n}\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_socket_impl! {\n    net::SocketAddrV4, \"IPv4 socket address\", | (ip, port) | net::SocketAddrV4::new(ip,\n    port),\n}\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_socket_impl! {\n    net::SocketAddrV6, \"IPv6 socket address\", | (ip, port) | net::SocketAddrV6::new(ip,\n    port, 0, 0),\n}\nforwarded_impl! {\n    #[cfg(feature = \"std\")] #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))] (), Box < Path\n    >, PathBuf::into_boxed_path\n}\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nvariant_identifier! {\n    OsStringKind(Unix; b\"Unix\"; 0, Windows; b\"Windows\"; 1) \"`Unix` or `Windows`\",\n    OSSTR_VARIANTS\n}\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] (T), Box < T >, Box::new\n}\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] (T), Box < [T] >,\n    Vec::into_boxed_slice\n}\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))] #[cfg_attr(docsrs,\n    doc(cfg(any(feature = \"std\", feature = \"alloc\"))))] (), Box < str >,\n    String::into_boxed_str\n}\nforwarded_impl! {\n    #[cfg(all(feature = \"std\", any(unix, windows)))] #[cfg_attr(docsrs,\n    doc(cfg(all(feature = \"std\", any(unix, windows)))))] (), Box < OsStr >,\n    OsString::into_boxed_os_str\n}\nmacro_rules! box_forwarded_impl {\n    ($(#[$attr:meta])* $t:ident) => {\n        $(#[$attr])* impl <'de, T > Deserialize <'de > for $t < T > where T : ? Sized,\n        Box < T >: Deserialize <'de >, { fn deserialize < D > (deserializer : D) ->\n        Result < Self, D::Error > where D : Deserializer <'de >, {\n        Box::deserialize(deserializer).map(Into::into) } }\n    };\n}\nbox_forwarded_impl! {\n    #[doc = \" This impl requires the [`\\\"rc\\\"`] Cargo feature of Serde.\"] #[doc = \"\"]\n    #[doc = \" Deserializing a data structure containing `Rc` will not attempt to\"] #[doc\n    = \" deduplicate `Rc` references to the same data. Every deserialized `Rc`\"] #[doc =\n    \" will end up with a strong count of 1.\"] #[doc = \"\"] #[doc =\n    \" [`\\\"rc\\\"`]: https://serde.rs/feature-flags.html#-features-rc\"] #[cfg(all(feature =\n    \"rc\", any(feature = \"std\", feature = \"alloc\")))] #[cfg_attr(docsrs,\n    doc(cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))))] Rc\n}\nbox_forwarded_impl! {\n    #[doc = \" This impl requires the [`\\\"rc\\\"`] Cargo feature of Serde.\"] #[doc = \"\"]\n    #[doc = \" Deserializing a data structure containing `Arc` will not attempt to\"] #[doc\n    = \" deduplicate `Arc` references to the same data. Every deserialized `Arc`\"] #[doc =\n    \" will end up with a strong count of 1.\"] #[doc = \"\"] #[doc =\n    \" [`\\\"rc\\\"`]: https://serde.rs/feature-flags.html#-features-rc\"] #[cfg(all(feature =\n    \"rc\", any(feature = \"std\", feature = \"alloc\")))] #[cfg_attr(docsrs,\n    doc(cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))))] Arc\n}\nforwarded_impl! {\n    (T), RefCell < T >, RefCell::new\n}\nforwarded_impl! {\n    #[cfg(feature = \"std\")] #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))] (T), Mutex < T\n    >, Mutex::new\n}\nforwarded_impl! {\n    #[cfg(feature = \"std\")] #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))] (T), RwLock <\n    T >, RwLock::new\n}\n#[cfg(all(feature = \"std\", not(no_std_atomic)))]\nmacro_rules! atomic_impl {\n    ($($ty:ident $size:expr)*) => {\n        $(#[cfg(any(no_target_has_atomic, target_has_atomic = $size))] #[cfg_attr(docsrs,\n        doc(cfg(all(feature = \"std\", target_has_atomic = $size))))] impl <'de >\n        Deserialize <'de > for $ty { fn deserialize < D > (deserializer : D) -> Result <\n        Self, D::Error > where D : Deserializer <'de >, {\n        Deserialize::deserialize(deserializer).map(Self::new) } })*\n    };\n}\n#[cfg(all(feature = \"std\", not(no_std_atomic)))]\natomic_impl! {\n    AtomicBool \"8\" AtomicI8 \"8\" AtomicI16 \"16\" AtomicI32 \"32\" AtomicIsize \"ptr\" AtomicU8\n    \"8\" AtomicU16 \"16\" AtomicU32 \"32\" AtomicUsize \"ptr\"\n}\n#[cfg(all(feature = \"std\", not(no_std_atomic64)))]\natomic_impl! {\n    AtomicI64 \"64\" AtomicU64 \"64\"\n}\npub trait Visitor<'de>: Sized {\n    type Value;\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bool(v), &self))\n    }\n    fn visit_i8<E>(self, v: i8) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n    fn visit_i16<E>(self, v: i16) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n    fn visit_i32<E>(self, v: i32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n    fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Signed(v), &self))\n    }\n    fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let mut buf = [0u8; 58];\n        let mut writer = crate::format::Buf::new(&mut buf);\n        fmt::Write::write_fmt(&mut writer, format_args!(\"integer `{}` as i128\", v))\n            .unwrap();\n        Err(Error::invalid_type(Unexpected::Other(writer.as_str()), &self))\n    }\n    fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n    fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n    fn visit_u32<E>(self, v: u32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unsigned(v), &self))\n    }\n    fn visit_u128<E>(self, v: u128) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let mut buf = [0u8; 57];\n        let mut writer = crate::format::Buf::new(&mut buf);\n        fmt::Write::write_fmt(&mut writer, format_args!(\"integer `{}` as u128\", v))\n            .unwrap();\n        Err(Error::invalid_type(Unexpected::Other(writer.as_str()), &self))\n    }\n    fn visit_f32<E>(self, v: f32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_f64(v as f64)\n    }\n    fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Float(v), &self))\n    }\n    #[inline]\n    fn visit_char<E>(self, v: char) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(v.encode_utf8(&mut [0u8; 4]))\n    }\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Str(v), &self))\n    }\n    #[inline]\n    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(v)\n    }\n    #[inline]\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(&v)\n    }\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bytes(v), &self))\n    }\n    #[inline]\n    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_bytes(v)\n    }\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_bytes(&v)\n    }\n    fn visit_none<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Option, &self))\n    }\n    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::Option, &self))\n    }\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unit, &self))\n    }\n    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::NewtypeStruct, &self))\n    }\n    fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        let _ = seq;\n        Err(Error::invalid_type(Unexpected::Seq, &self))\n    }\n    fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>\n    where\n        A: MapAccess<'de>,\n    {\n        let _ = map;\n        Err(Error::invalid_type(Unexpected::Map, &self))\n    }\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        let _ = data;\n        Err(Error::invalid_type(Unexpected::Enum, &self))\n    }\n    fn __private_visit_untagged_option<D>(self, _: D) -> Result<Self::Value, ()>\n    where\n        D: Deserializer<'de>,\n    {\n        Err(())\n    }\n}\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nstruct OsStringVisitor;\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl<'de> Visitor<'de> for OsStringVisitor {\n    type Value = OsString;\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {}\n    #[cfg(windows)]\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        use std::os::windows::ffi::OsStringExt;\n        match tri!(data.variant()) {\n            (OsStringKind::Windows, v) => {\n                v.newtype_variant::<Vec<u16>>().map(|vec| OsString::from_wide(&vec))\n            }\n            (OsStringKind::Unix, _) => {\n                Err(Error::custom(\"cannot deserialize Unix OS string on Windows\"))\n            }\n        }\n    }\n    #[cfg(windows)]\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        use std::os::windows::ffi::OsStringExt;\n        match tri!(data.variant()) {\n            (OsStringKind::Windows, v) => {\n                v.newtype_variant::<Vec<u16>>().map(|vec| OsString::from_wide(&vec))\n            }\n            (OsStringKind::Unix, _) => {\n                Err(Error::custom(\"cannot deserialize Unix OS string on Windows\"))\n            }\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\nfn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\nwhere\n    A: EnumAccess<'de>,\n{\n    use std::os::unix::ffi::OsStringExt;\n\n    match tri!(data.variant()) {\n        (OsStringKind::Unix, v) => v.newtype_variant().map(OsString::from_vec),\n        (OsStringKind::Windows, _) => Err(Error::custom(\n            \"cannot deserialize Windows OS string on Unix\",\n        )),\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}