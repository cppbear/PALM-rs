[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSeq {",
          "        values: Vec<Content>,",
          "        index: usize,",
          "    }",
          "",
          "    impl SeqAccess<'_> for TestSeq {",
          "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
          "            if self.index < self.values.len() {",
          "                self.index += 1;",
          "                Ok(Some(self.values[self.index - 1].clone()))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "    }",
          "",
          "    let seq = TestSeq {",
          "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
          "        index: 0,",
          "    };",
          "",
          "    let visitor = TaggedContentVisitor {",
          "        tag_name: \"tag\",",
          "        expecting: \"a bool tag\",",
          "        value: PhantomData,",
          "    };",
          "",
          "    let _ = visitor.visit_seq(seq);",
          "}"
        ],
        "oracles": [
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::Bool(true));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::String(\"value\".to_string()));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    assert!(result.unwrap().is_some());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap_err().kind(), de::Error::missing_field(\"tag\"));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true), Content::String(\"value\".to_string())], index: 1 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true), Content::String(\"value\".to_string())], index: 1 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::Bool(true));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::Bool(true));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::String(\"value\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    assert!(result.unwrap().is_some());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap_err().kind(), de::Error::missing_field(\"tag\"));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true), Content::String(\"value\".to_string())], index: 1 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::Bool(true), Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a bool tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let mut seq_access = seq;",
            "    let result = seq_access.next_element::<Content>();",
            "    let seq = TestSeq { values: vec![Content::Bool(true)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::Bool(true), Content::String(\"value\".to_string())], index: 1 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a bool tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::Bool(true));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSeq {",
          "        values: Vec<Content>,",
          "        index: usize,",
          "    }",
          "",
          "    impl SeqAccess<'_> for TestSeq {",
          "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
          "            if self.index < self.values.len() {",
          "                self.index += 1;",
          "                Ok(Some(self.values[self.index - 1].clone()))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "    }",
          "",
          "    let seq = TestSeq {",
          "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
          "        index: 0,",
          "    };",
          "",
          "    let visitor = TaggedContentVisitor {",
          "        tag_name: \"tag\",",
          "        expecting: \"an u8 tag\",",
          "        value: PhantomData,",
          "    };",
          "",
          "    let _ = visitor.visit_seq(seq);",
          "}"
        ],
        "oracles": [
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    assert!(matches!(tag, Content::U8(255)));"
          ],
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    assert!(content_result.is_ok());"
          ],
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    assert!(content_result.unwrap().matches(Content::Map(_)));"
          ],
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    assert!(result_empty.is_err());"
          ],
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    assert!(result_empty.err().unwrap().to_string().contains(\"missing field\"));"
          ],
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    let seq_err = TestSeq { values: vec![Content::U8(255)], index: 0 };",
            "    let visitor_err = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a tag\", value: PhantomData };",
            "    let result_err = visitor_err.visit_seq(seq_err);",
            "    assert!(result_err.is_err());"
          ],
          [
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    let seq_err = TestSeq { values: vec![Content::U8(255)], index: 0 };",
            "    let visitor_err = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a tag\", value: PhantomData };",
            "    let result_err = visitor_err.visit_seq(seq_err);",
            "    assert!(result_err.err().unwrap().to_string().contains(\"missing field\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    assert!(matches!(tag, Content::U8(255)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    assert!(content_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    assert!(content_result.unwrap().matches(Content::Map(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    assert!(result_empty.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    assert!(result_empty.err().unwrap().to_string().contains(\"missing field\"));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    let seq_err = TestSeq { values: vec![Content::U8(255)], index: 0 };",
            "    let visitor_err = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a tag\", value: PhantomData };",
            "    let result_err = visitor_err.visit_seq(seq_err);",
            "    assert!(result_err.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::U8(255), Content::Bytes(vec![1, 2, 3])],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an u8 tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let tag = tri!(seq.next_element()).unwrap();",
            "    let rest = de::value::SeqAccessDeserializer::new(seq);",
            "    let content_result = Content::deserialize(rest);",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an u8 tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    let seq_err = TestSeq { values: vec![Content::U8(255)], index: 0 };",
            "    let visitor_err = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a tag\", value: PhantomData };",
            "    let result_err = visitor_err.visit_seq(seq_err);",
            "    assert!(result_err.err().unwrap().to_string().contains(\"missing field\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSeq {",
          "        values: Vec<Content>,",
          "        index: usize,",
          "    }",
          "",
          "    impl SeqAccess<'_> for TestSeq {",
          "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
          "            Ok(None)",
          "        }",
          "    }",
          "",
          "    let seq = TestSeq {",
          "        values: vec![],",
          "        index: 0,",
          "    };",
          "",
          "    let visitor = TaggedContentVisitor {",
          "        tag_name: \"tag\",",
          "        expecting: \"a missing tag\",",
          "        value: PhantomData,",
          "    };",
          "",
          "    let result = visitor.visit_seq(seq);",
          "}"
        ],
        "oracles": [
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap().1, tri!(Content::deserialize(rest)));"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap().1, tri!(Content::deserialize(rest)));"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap_err(), de::Error::missing_field(\"tag\"));"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap_err(), de::Error::missing_field(\"tag\"));"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::String(\"value\".into())],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::String(\"value\".into())],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap().1, tri!(Content::deserialize(rest)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap().1, tri!(Content::deserialize(rest)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap().1, tri!(Content::deserialize(rest)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap_err(), de::Error::missing_field(\"tag\"));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap_err(), de::Error::missing_field(\"tag\"));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::String(\"value\".into())],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a missing tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::Bool(true)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::U8(1)],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq {",
            "    values: vec![Content::String(\"value\".into())],",
            "    index: 0,",
            "    };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.unwrap().1, tri!(Content::deserialize(rest)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSeq {",
          "        values: Vec<Content>,",
          "        index: usize,",
          "    }",
          "",
          "    impl SeqAccess<'_> for TestSeq {",
          "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
          "            if self.index < self.values.len() {",
          "                self.index += 1;",
          "                Ok(Some(self.values[self.index - 1].clone()))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "    }",
          "",
          "    let seq = TestSeq {",
          "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
          "        index: 0,",
          "    };",
          "",
          "    let visitor = TaggedContentVisitor {",
          "        tag_name: \"tag\",",
          "        expecting: \"a string tag\",",
          "        value: PhantomData,",
          "    };",
          "",
          "    let _ = visitor.visit_seq(seq);",
          "}"
        ],
        "oracles": [
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::String(\"tag_value\".to_string()));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    assert!(result_empty.is_err());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    assert_eq!(err.to_string(), \"missing field `tag`\");"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    assert!(result_error.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    assert_eq!(tag_error, Content::String(\"tag_value\".to_string()));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    assert!(matches!(content_error, Content::Map(_)));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    let seq_duplicates = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::String(\"another_value\".to_string())], index: 0 };",
            "    let visitor_duplicates = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_duplicates = visitor_duplicates.visit_seq(seq_duplicates);",
            "    assert!(result_duplicates.is_err());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    let seq_duplicates = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::String(\"another_value\".to_string())], index: 0 };",
            "    let visitor_duplicates = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_duplicates = visitor_duplicates.visit_seq(seq_duplicates);",
            "    if let Err(err) = result_duplicates {",
            "    assert_eq!(err.to_string(), \"duplicate field `tag`\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert_eq!(tag, Content::String(\"tag_value\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    assert!(result_empty.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    assert_eq!(err.to_string(), \"missing field `tag`\");",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    assert!(result_error.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    assert_eq!(tag_error, Content::String(\"tag_value\".to_string()));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    assert!(matches!(content_error, Content::Map(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    let seq_duplicates = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::String(\"another_value\".to_string())], index: 0 };",
            "    let visitor_duplicates = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_duplicates = visitor_duplicates.visit_seq(seq_duplicates);",
            "    assert!(result_duplicates.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"a string tag\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let _ = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::F64(10.5)], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq_empty = TestSeq { values: vec![], index: 0 };",
            "    let visitor_empty = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_empty = visitor_empty.visit_seq(seq_empty);",
            "    if let Err(err) = result_empty {",
            "    }",
            "    let seq_error = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor_error = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_error = visitor_error.visit_seq(seq_error);",
            "    let (tag_error, content_error) = result_error.unwrap();",
            "    let seq_duplicates = TestSeq { values: vec![Content::String(\"tag_value\".to_string()), Content::String(\"another_value\".to_string())], index: 0 };",
            "    let visitor_duplicates = TaggedContentVisitor { tag_name: \"tag\", expecting: \"a string tag\", value: PhantomData };",
            "    let result_duplicates = visitor_duplicates.visit_seq(seq_duplicates);",
            "    if let Err(err) = result_duplicates {",
            "    assert_eq!(err.to_string(), \"duplicate field `tag`\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestSeq {",
          "        values: Vec<Content>,",
          "        index: usize,",
          "    }",
          "",
          "    impl SeqAccess<'_> for TestSeq {",
          "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
          "            if self.index < self.values.len() {",
          "                self.index += 1;",
          "                Ok(Some(self.values[self.index - 1].clone()))",
          "            } else {",
          "                Ok(None)",
          "            }",
          "        }",
          "    }",
          "",
          "    let seq = TestSeq {",
          "        values: vec![Content::None, Content::String(\"value\".to_string())],",
          "        index: 0,",
          "    };",
          "",
          "    let visitor = TaggedContentVisitor {",
          "        tag_name: \"tag\",",
          "        expecting: \"an invalid tag scenario\",",
          "        value: PhantomData,",
          "    };",
          "",
          "    let result = visitor.visit_seq(seq);",
          "}"
        ],
        "oracles": [
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::None));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.err().unwrap(), de::Error::missing_field(\"tag\"));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::String(\"value\".to_string())));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::None));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::String(\"tag_value\".to_string())));"
          ],
          [
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::None));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert_eq!(result.err().unwrap(), de::Error::missing_field(\"tag\"));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::String(\"value\".to_string())));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::None));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(tag, Content::String(\"tag_value\".to_string())));",
            "}"
          ],
          [
            "{",
            "    struct TestSeq {",
            "        values: Vec<Content>,",
            "        index: usize,",
            "    }",
            "",
            "    impl SeqAccess<'_> for TestSeq {",
            "        fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error> {",
            "            if self.index < self.values.len() {",
            "                self.index += 1;",
            "                Ok(Some(self.values[self.index - 1].clone()))",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "    }",
            "",
            "    let seq = TestSeq {",
            "        values: vec![Content::None, Content::String(\"value\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let visitor = TaggedContentVisitor {",
            "        tag_name: \"tag\",",
            "        expecting: \"an invalid tag scenario\",",
            "        value: PhantomData,",
            "    };",
            "",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::None, Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let seq = TestSeq { values: vec![Content::String(\"value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::None, Content::None], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    let seq = TestSeq { values: vec![Content::String(\"tag_value\".to_string())], index: 0 };",
            "    let visitor = TaggedContentVisitor { tag_name: \"tag\", expecting: \"an invalid tag scenario\", value: PhantomData };",
            "    let result = visitor.visit_seq(seq);",
            "    let (tag, content) = result.unwrap();",
            "    assert!(matches!(content, Content::Map(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]