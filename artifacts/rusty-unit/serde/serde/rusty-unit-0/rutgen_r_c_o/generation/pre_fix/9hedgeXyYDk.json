{
  "name": "serde::de::impls::range_from::<de::impls::range_from::RangeFromVisitor<Idx> as de::Visitor<'de>>::visit_map",
  "name_with_impl": "serde::de::impls::range_from::{impl#1}::visit_map",
  "mod_info": {
    "name": "de::impls::range_from",
    "loc": "serde/src/de/impls.rs:2622:1:2729:2"
  },
  "visible": true,
  "loc": "serde/src/de/impls.rs:2707:9:2727:10",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: map.next_key() matches Ok(val) is true\n",
        "// constraint: let Some(key) = tri!(map.next_key()) is true\n",
        "// constraint: start matches Some(start) is true\n",
        "// constraint: start matches Some(start) is true\n",
        "// expected return value/type: Ok(start)\n"
      ],
      "input_infer": "start: [1, 2, 3], map: Field::Start -> 1, map: Field::Start -> 2, map: Field::Start -> 3\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMapAccess {",
                "        keys: Vec<Field>,",
                "        values: Vec<i32>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMapAccess {",
                "        type Error = serde::de::Error;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.keys.len() {",
                "                let key = self.keys[self.index].clone();",
                "                self.index += 1;",
                "                Ok(Some(key))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                "        where",
                "            T: Deserialize<'de>,",
                "        {",
                "            if self.index <= self.values.len() {",
                "                let value = self.values[self.index - 1];",
                "                self.index += 1;",
                "                Ok(value as T)",
                "            } else {",
                "                Err(serde::de::Error::custom(\"No value available\"))",
                "            }",
                "        }",
                "    }",
                "",
                "    let keys = vec![Field::Start, Field::Start, Field::Start];",
                "    let values = vec![1, 2, 3];",
                "    let mut access = MockMapAccess { keys, values, index: 0 };",
                "    let visitor = RangeFromVisitor::<i32> {",
                "        expecting: \"a field that starts with an integer\",",
                "        phantom: std::marker::PhantomData,",
                "    };",
                "",
                "    let _ = visitor.visit_map(access);",
                "}"
              ],
              "oracles": [
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result, Ok(2));"
                ],
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![1];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result, Ok(1));"
                ],
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![1];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![1];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![];",
                  "    let values = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result, Ok(2));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![1];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result, Ok(1));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![1];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![1];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![];",
                  "    let values = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "    expecting: \"a field that starts with an integer\",",
                  "    phantom: std::marker::PhantomData,",
                  "    };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMapAccess {",
                "        keys: Vec<Field>,",
                "        values: Vec<i32>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMapAccess {",
                "        type Error = serde::de::Error;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.keys.len() {",
                "                let key = self.keys[self.index].clone();",
                "                self.index += 1;",
                "                Ok(Some(key))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                "        where",
                "            T: Deserialize<'de>,",
                "        {",
                "            if self.index <= self.values.len() {",
                "                let value = self.values[self.index - 1];",
                "                self.index += 1;",
                "                Ok(value as T)",
                "            } else {",
                "                Err(serde::de::Error::custom(\"No value available\"))",
                "            }",
                "        }",
                "    }",
                "",
                "    let keys = vec![Field::Start, Field::Start];",
                "    let values = vec![1, 2];",
                "    let mut access = MockMapAccess { keys, values, index: 0 };",
                "    let visitor = RangeFromVisitor::<i32> {",
                "        expecting: \"a field that starts with an integer\",",
                "        phantom: std::marker::PhantomData,",
                "    };",
                "",
                "    let result = visitor.visit_map(access);",
                "    let _ = result.unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result.unwrap_err().to_string(), \"duplicate field `start`\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result.unwrap_err().to_string(), \"duplicate field `start`\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMapAccess {",
                "        keys: Vec<Field>,",
                "        values: Vec<i32>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMapAccess {",
                "        type Error = serde::de::Error;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.keys.len() {",
                "                let key = self.keys[self.index].clone();",
                "                self.index += 1;",
                "                Ok(Some(key))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                "        where",
                "            T: Deserialize<'de>,",
                "        {",
                "            if self.index <= self.values.len() {",
                "                let value = self.values[self.index - 1];",
                "                self.index += 1;",
                "                Ok(value as T)",
                "            } else {",
                "                Err(serde::de::Error::custom(\"No value available\"))",
                "            }",
                "        }",
                "    }",
                "",
                "    let keys = vec![]; // No keys provided to simulate missing field case",
                "    let values: Vec<i32> = vec![];",
                "    let mut access = MockMapAccess { keys, values, index: 0 };",
                "    let visitor = RangeFromVisitor::<i32> {",
                "        expecting: \"a field that starts with an integer\",",
                "        phantom: std::marker::PhantomData,",
                "    };",
                "",
                "    let result = visitor.visit_map(access);",
                "    let _ = result.unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result.unwrap(), 42);"
                ],
                [
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start];",
                  "    let values: Vec<i32> = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![]; // No keys provided to simulate missing field case",
                  "    let values: Vec<i32> = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![]; // No keys provided to simulate missing field case",
                  "    let values: Vec<i32> = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    assert_eq!(result.unwrap(), 42);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![]; // No keys provided to simulate missing field case",
                  "    let values: Vec<i32> = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<T>(&mut self) -> Result<T, Self::Error>",
                  "        where",
                  "            T: Deserialize<'de>,",
                  "        {",
                  "            if self.index <= self.values.len() {",
                  "                let value = self.values[self.index - 1];",
                  "                self.index += 1;",
                  "                Ok(value as T)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No value available\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![]; // No keys provided to simulate missing field case",
                  "    let values: Vec<i32> = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> {",
                  "        expecting: \"a field that starts with an integer\",",
                  "        phantom: std::marker::PhantomData,",
                  "    };",
                  "",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start];",
                  "    let values = vec![42];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    let keys = vec![Field::Start];",
                  "    let values: Vec<i32> = vec![];",
                  "    let mut access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor::<i32> { expecting: \"a field that starts with an integer\", phantom: std::marker::PhantomData };",
                  "    let result = visitor.visit_map(access);",
                  "    let _ = result.unwrap_err();",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2765:21\n     |\n2765 |                 Err(serde::de::Error::custom(\"No value available\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2765 -                 Err(serde::de::Error::custom(\"No value available\"))\n2765 +                 Err(Error::custom(\"No value available\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0605]: non-primitive cast: `i32` as `T`\n    --> serde/src/de/impls.rs:2763:20\n     |\n2763 |                 Ok(value as T)\n     |                    ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599, E0605.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: map.next_key() matches Ok(val) is true\n",
        "// constraint: let Some(key) = tri!(map.next_key()) is true\n",
        "// constraint: start matches None is true\n",
        "// expected return value/type: Err(<A::Error as Error>::missing_field(\"start\"))\n"
      ],
      "input_infer": "0 to 0 for the length of keys in the map, and only one key that is not Field::Start.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        keys: Vec<Field>,",
                "        values: Vec<i32>,",
                "        current: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for TestMap {",
                "        type Error = serde::de::StdError;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.current < self.keys.len() {",
                "                let key = self.keys[self.current];",
                "                self.current += 1;",
                "                Ok(Some(key))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            Err(serde::de::Error::custom(\"Not applicable value\"))",
                "        }",
                "    }",
                "",
                "    let keys = vec![Field::Start]; // No keys provided",
                "    let values = vec![1, 2, 3]; // Example values",
                "",
                "    let map = TestMap {",
                "        keys,",
                "        values,",
                "        current: 0,",
                "    };",
                "",
                "    let visitor = RangeFromVisitor {",
                "        expecting: \"an integer\",",
                "        phantom: std::marker::PhantomData::<i32>,",
                "    };",
                "",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let keys = vec![];",
                  "    let values = vec![];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let keys = vec![];",
                  "    let values = vec![];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().kind(), serde::de::Error::missing_field(\"start\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestMap {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        current: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMap {",
                  "        type Error = serde::de::StdError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.current < self.keys.len() {",
                  "                let key = self.keys[self.current];",
                  "                self.current += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(serde::de::Error::custom(\"Not applicable value\"))",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start]; // No keys provided",
                  "    let values = vec![1, 2, 3]; // Example values",
                  "",
                  "    let map = TestMap {",
                  "        keys,",
                  "        values,",
                  "        current: 0,",
                  "    };",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"an integer\",",
                  "        phantom: std::marker::PhantomData::<i32>,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(map);",
                  "    let keys = vec![];",
                  "    let values = vec![];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMap {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        current: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMap {",
                  "        type Error = serde::de::StdError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.current < self.keys.len() {",
                  "                let key = self.keys[self.current];",
                  "                self.current += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(serde::de::Error::custom(\"Not applicable value\"))",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start]; // No keys provided",
                  "    let values = vec![1, 2, 3]; // Example values",
                  "",
                  "    let map = TestMap {",
                  "        keys,",
                  "        values,",
                  "        current: 0,",
                  "    };",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"an integer\",",
                  "        phantom: std::marker::PhantomData::<i32>,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(map);",
                  "    let keys = vec![];",
                  "    let values = vec![];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().kind(), serde::de::Error::missing_field(\"start\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::StdError;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing this module\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::StdError;\n2744 +         type Error = de::StdError;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2760:17\n     |\n2760 |             Err(serde::de::Error::custom(\"Not applicable value\"))\n     |                 ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2760 -             Err(serde::de::Error::custom(\"Not applicable value\"))\n2760 +             Err(Error::custom(\"Not applicable value\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for TestMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::StdError;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing this module\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::StdError;\n2744 +         type Error = de::StdError;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2760:17\n     |\n2760 |             Err(serde::de::Error::custom(\"Not applicable value\"))\n     |                 ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2760 -             Err(serde::de::Error::custom(\"Not applicable value\"))\n2760 +             Err(Error::custom(\"Not applicable value\"))\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2784:44\n     |\n2784 |     assert_eq!(result.unwrap_err().kind(), serde::de::Error::missing_field(\"start\"));\n     |                                            ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2784 -     assert_eq!(result.unwrap_err().kind(), serde::de::Error::missing_field(\"start\"));\n2784 +     assert_eq!(result.unwrap_err().kind(), Error::missing_field(\"start\"));\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for TestMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMap {",
                "        keys: Vec<Field>,",
                "        values: Vec<i32>,",
                "        current: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for TestMap {",
                "        type Error = serde::de::StdError;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.current < self.keys.len() {",
                "                let key = self.keys[self.current];",
                "                self.current += 1;",
                "                Ok(Some(key))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            Err(serde::de::Error::custom(\"Not applicable value\"))",
                "        }",
                "    }",
                "",
                "    let keys = vec![Field::Start, Field::Start]; // Duplicate Field::Start",
                "    let values = vec![1, 2, 3]; // Example values",
                "",
                "    let map = TestMap {",
                "        keys,",
                "        values,",
                "        current: 0,",
                "    };",
                "",
                "    let visitor = RangeFromVisitor {",
                "        expecting: \"an integer\",",
                "        phantom: std::marker::PhantomData::<i32>,",
                "    };",
                "",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.err().unwrap(), <TestMap::Error as Error>::duplicate_field(\"start\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestMap {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        current: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMap {",
                  "        type Error = serde::de::StdError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.current < self.keys.len() {",
                  "                let key = self.keys[self.current];",
                  "                self.current += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(serde::de::Error::custom(\"Not applicable value\"))",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start]; // Duplicate Field::Start",
                  "    let values = vec![1, 2, 3]; // Example values",
                  "",
                  "    let map = TestMap {",
                  "        keys,",
                  "        values,",
                  "        current: 0,",
                  "    };",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"an integer\",",
                  "        phantom: std::marker::PhantomData::<i32>,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(map);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMap {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        current: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMap {",
                  "        type Error = serde::de::StdError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.current < self.keys.len() {",
                  "                let key = self.keys[self.current];",
                  "                self.current += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(serde::de::Error::custom(\"Not applicable value\"))",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start]; // Duplicate Field::Start",
                  "    let values = vec![1, 2, 3]; // Example values",
                  "",
                  "    let map = TestMap {",
                  "        keys,",
                  "        values,",
                  "        current: 0,",
                  "    };",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"an integer\",",
                  "        phantom: std::marker::PhantomData::<i32>,",
                  "    };",
                  "",
                  "    let _ = visitor.visit_map(map);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 2, 3];",
                  "    let map = TestMap { keys, values, current: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"an integer\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.err().unwrap(), <TestMap::Error as Error>::duplicate_field(\"start\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::StdError;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing this module\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::StdError;\n2744 +         type Error = de::StdError;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2760:17\n     |\n2760 |             Err(serde::de::Error::custom(\"Not applicable value\"))\n     |                 ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2760 -             Err(serde::de::Error::custom(\"Not applicable value\"))\n2760 +             Err(Error::custom(\"Not applicable value\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for TestMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 5 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::StdError;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing this module\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::StdError;\n2744 +         type Error = de::StdError;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2760:17\n     |\n2760 |             Err(serde::de::Error::custom(\"Not applicable value\"))\n     |                 ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2760 -             Err(serde::de::Error::custom(\"Not applicable value\"))\n2760 +             Err(Error::custom(\"Not applicable value\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for TestMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0223]: ambiguous associated type\n    --> serde/src/de/impls.rs:2784:40\n     |\n2784 |     assert_eq!(result.err().unwrap(), <TestMap::Error as Error>::duplicate_field(\"start\"));\n     |                                        ^^^^^^^^^^^^^^\n     |\nhelp: use fully-qualified syntax\n     |\n2784 |     assert_eq!(result.err().unwrap(), <<TestMap as TryFrom>::Error as Error>::duplicate_field(\"start\"));\n     |                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2784 |     assert_eq!(result.err().unwrap(), <<TestMap as TryInto>::Error as Error>::duplicate_field(\"start\"));\n     |                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2784 |     assert_eq!(result.err().unwrap(), <<TestMap as de::MapAccess>::Error as Error>::duplicate_field(\"start\"));\n     |                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0046, E0049, E0223, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: map.next_key() matches Ok(val) is true\n",
        "// constraint: let Some(key) = tri!(map.next_key()) is true\n",
        "// constraint: start.is_some() is true\n",
        "// expected return value/type: Err(<A::Error as Error>::duplicate_field(\"start\"))\n"
      ],
      "input_infer": "start: {1, 1}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMapAccess {",
                "        keys: Vec<Field>,",
                "        values: Vec<i32>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMapAccess {",
                "        type Error = serde::de::Error;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.keys.len() {",
                "                let key = self.keys[self.index].clone();",
                "                self.index += 1;",
                "                Ok(Some(key))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            if self.index - 1 < self.values.len() {",
                "                let value: V = bincode::deserialize(&self.values[self.index - 1].to_le_bytes()).unwrap();",
                "                Ok(value)",
                "            } else {",
                "                Err(serde::de::Error::custom(\"No more values\"))",
                "            }",
                "        }",
                "    }",
                "",
                "    let keys = vec![Field::Start, Field::Start];",
                "    let values = vec![1, 1];",
                "    let map_access = MockMapAccess { keys, values, index: 0 };",
                "    ",
                "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                "    ",
                "    let result = visitor.visit_map(map_access);",
                "}"
              ],
              "oracles": [
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 1];",
                  "    let map_access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map_access);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 1];",
                  "    let map_access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map_access);",
                  "    assert_eq!(result.unwrap_err(), <MockMapAccess::Error as Error>::duplicate_field(\"start\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            if self.index - 1 < self.values.len() {",
                  "                let value: V = bincode::deserialize(&self.values[self.index - 1].to_le_bytes()).unwrap();",
                  "                Ok(value)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No more values\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 1];",
                  "    let map_access = MockMapAccess { keys, values, index: 0 };",
                  "    ",
                  "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                  "    ",
                  "    let result = visitor.visit_map(map_access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 1];",
                  "    let map_access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map_access);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMapAccess {",
                  "        keys: Vec<Field>,",
                  "        values: Vec<i32>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMapAccess {",
                  "        type Error = serde::de::Error;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.keys.len() {",
                  "                let key = self.keys[self.index].clone();",
                  "                self.index += 1;",
                  "                Ok(Some(key))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            if self.index - 1 < self.values.len() {",
                  "                let value: V = bincode::deserialize(&self.values[self.index - 1].to_le_bytes()).unwrap();",
                  "                Ok(value)",
                  "            } else {",
                  "                Err(serde::de::Error::custom(\"No more values\"))",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 1];",
                  "    let map_access = MockMapAccess { keys, values, index: 0 };",
                  "    ",
                  "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                  "    ",
                  "    let result = visitor.visit_map(map_access);",
                  "    let keys = vec![Field::Start, Field::Start];",
                  "    let values = vec![1, 1];",
                  "    let map_access = MockMapAccess { keys, values, index: 0 };",
                  "    let visitor = RangeFromVisitor { expecting: \"Expecting range from visitor\", phantom: std::marker::PhantomData::<i32> };",
                  "    let result = visitor.visit_map(map_access);",
                  "    assert_eq!(result.unwrap_err(), <MockMapAccess::Error as Error>::duplicate_field(\"start\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2764:21\n     |\n2764 |                 Err(serde::de::Error::custom(\"No more values\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2764 -                 Err(serde::de::Error::custom(\"No more values\"))\n2764 +                 Err(Error::custom(\"No more values\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n    --> serde/src/de/impls.rs:2761:32\n     |\n2761 |                 let value: V = bincode::deserialize(&self.values[self.index - 1].to_le_bytes()).unwrap();\n     |                                ^^^^^^^ use of undeclared crate or module `bincode`\n\nSome errors have detailed explanations: E0046, E0049, E0433, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2744:22\n     |\n2744 |         type Error = serde::de::Error;\n     |                      ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these modules\n     |\n2732 +    use crate::__private::de;\n     |\n2732 +    use crate::de;\n     |\nhelp: if you import `de`, refer to it directly\n     |\n2744 -         type Error = serde::de::Error;\n2744 +         type Error = de::Error;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `serde`\n    --> serde/src/de/impls.rs:2764:21\n     |\n2764 |                 Err(serde::de::Error::custom(\"No more values\"))\n     |                     ^^^^^ use of undeclared crate or module `serde`\n     |\nhelp: consider importing one of these items\n     |\n2732 +    use crate::__private::doc::Error;\n     |\n2732 +    use crate::__private::fmt::Error;\n     |\n2732 +    use crate::de::Error;\n     |\n2732 +    use crate::de::error::Error;\n     |\n       and 7 other candidates\nhelp: if you import `Error`, refer to it directly\n     |\n2764 -                 Err(serde::de::Error::custom(\"No more values\"))\n2764 +                 Err(Error::custom(\"No more values\"))\n     |\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2746:20\n     |\n2746 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2743:5\n     |\n2743 |       impl<'de> MapAccess<'de> for MockMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0223]: ambiguous associated type\n    --> serde/src/de/impls.rs:2781:38\n     |\n2781 |     assert_eq!(result.unwrap_err(), <MockMapAccess::Error as Error>::duplicate_field(\"start\"));\n     |                                      ^^^^^^^^^^^^^^^^^^^^\n     |\nhelp: use fully-qualified syntax\n     |\n2781 |     assert_eq!(result.unwrap_err(), <<MockMapAccess as TryFrom>::Error as Error>::duplicate_field(\"start\"));\n     |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2781 |     assert_eq!(result.unwrap_err(), <<MockMapAccess as TryInto>::Error as Error>::duplicate_field(\"start\"));\n     |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2781 |     assert_eq!(result.unwrap_err(), <<MockMapAccess as de::MapAccess>::Error as Error>::duplicate_field(\"start\"));\n     |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `clone` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2748:49\n     |\n2633 |     enum Field {\n     |     ---------- method `clone` not found for this enum\n...\n2748 |                 let key = self.keys[self.index].clone();\n     |                                                 ^^^^^ method not found in `Field`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `clone`, perhaps you need to implement it:\n             candidate #1: `Clone`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n    --> serde/src/de/impls.rs:2761:32\n     |\n2761 |                 let value: V = bincode::deserialize(&self.values[self.index - 1].to_le_bytes()).unwrap();\n     |                                ^^^^^^^ use of undeclared crate or module `bincode`\n\nSome errors have detailed explanations: E0046, E0049, E0223, E0433, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 8 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: map.next_key() matches Ok(val) is true\n",
        "// constraint: let Some(key) = tri!(map.next_key()) is true\n",
        "// constraint: start.is_some() is false\n",
        "// constraint: map.next_value() matches Err(err) is true\n",
        "// expected return value/type: Err(err)\n"
      ],
      "input_infer": "start: [None], key: [Field::Start], num_fields: [0-1]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMapAccess {",
                "        called_next_key: bool,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for TestMapAccess {",
                "        type Error = Box<dyn Error>;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.called_next_key {",
                "                Ok(None)",
                "            } else {",
                "                self.called_next_key = true;",
                "                Ok(Some(Field::Start))",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            Err(Box::new(Error::duplicate_field(\"start\")))",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor {",
                "        expecting: \"test\",",
                "        phantom: PhantomData::<i32>,",
                "    };",
                "    let map = TestMapAccess { called_next_key: false };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"duplicate field `start`\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.called_next_key {",
                  "                Ok(None)",
                  "            } else {",
                  "                self.called_next_key = true;",
                  "                Ok(Some(Field::Start))",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.called_next_key {",
                  "                Ok(None)",
                  "            } else {",
                  "                self.called_next_key = true;",
                  "                Ok(Some(Field::Start))",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"duplicate field `start`\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:26\n     |\n2769 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:13\n     |\n2770 |     assert!(result.is_err());\n     |             ^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2746:17\n     |\n2746 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 16 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:26\n     |\n2769 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:16\n     |\n2770 |     assert_eq!(result.err().unwrap().to_string(), \"duplicate field `start`\");\n     |                ^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:16\n     |\n2770 |     assert_eq!(result.err().unwrap().to_string(), \"duplicate field `start`\");\n     |                ^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:16\n     |\n2770 |     assert_eq!(result.err().unwrap().to_string(), \"duplicate field `start`\");\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2746:17\n     |\n2746 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 18 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMapAccess {",
                "        called_next_key: bool,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for TestMapAccess {",
                "        type Error = Box<dyn Error>;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            Ok(None)",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            Err(Box::new(Error::duplicate_field(\"start\")))",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor {",
                "        expecting: \"test\",",
                "        phantom: PhantomData::<i32>,",
                "    };",
                "    let map = TestMapAccess { called_next_key: false };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().downcast_ref::<Error>(), Some(&Error::duplicate_field(\"start\")));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            Ok(None)",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            Ok(None)",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().downcast_ref::<Error>(), Some(&Error::duplicate_field(\"start\")));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2748:40\n     |\n2748 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2761:21\n     |\n2761 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2764:26\n     |\n2764 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2765:13\n     |\n2765 |     assert!(result.is_err());\n     |             ^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2745:13\n     |\n2745 |             Ok(None)\n     |             ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2752:13\n     |\n2752 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2752:13\n     |\n2752 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2752:17\n     |\n2752 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 15 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2748:40\n     |\n2748 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2761:21\n     |\n2761 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2764:26\n     |\n2764 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2765:16\n     |\n2765 |     assert_eq!(result.unwrap_err().downcast_ref::<Error>(), Some(&Error::duplicate_field(\"start\")));\n     |                ^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `downcast_ref` found for struct `std::boxed::Box<dyn de::Error>` in the current scope\n    --> serde/src/de/impls.rs:2765:36\n     |\n2765 |     assert_eq!(result.unwrap_err().downcast_ref::<Error>(), Some(&Error::duplicate_field(\"start\")));\n     |                                    ^^^^^^^^^^^^\n     |\nhelp: there is a method `as_ref` with a similar name\n     |\n2765 |     assert_eq!(result.unwrap_err().as_ref::<Error>(), Some(&Error::duplicate_field(\"start\")));\n     |                                    ~~~~~~\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2745:13\n     |\n2745 |             Ok(None)\n     |             ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2752:13\n     |\n2752 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2752:13\n     |\n2752 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2752:17\n     |\n2752 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277, E0599.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 16 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMapAccess {",
                "        called_next_key: bool,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for TestMapAccess {",
                "        type Error = Box<dyn Error>;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.called_next_key {",
                "                Ok(None)",
                "            } else {",
                "                self.called_next_key = true;",
                "                Ok(Some(Field::Start))",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            Err(Box::new(Error::missing_field(\"start\")))",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor {",
                "        expecting: \"test\",",
                "        phantom: PhantomData::<i32>,",
                "    };",
                "    let map = TestMapAccess { called_next_key: false };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut start: Option<Idx> = None;",
                  "    let key = tri!(map.next_key());",
                  "    start = Some(tri!(map.next_value()));",
                  "    assert!(matches!(_ ,Err(ref e) if e.to_string() == \"missing field `start`\"));"
                ],
                [
                  "    let mut start: Option<Idx> = None;",
                  "    let key = tri!(map.next_key());",
                  "    start = Some(tri!(map.next_value()));",
                  "    assert!(start.is_some());"
                ],
                [
                  "    let mut start: Option<Idx> = None;",
                  "    let key = tri!(map.next_key());",
                  "    start = Some(tri!(map.next_value()));",
                  "    assert!(matches!(map.next_value::<Idx>(), Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.called_next_key {",
                  "                Ok(None)",
                  "            } else {",
                  "                self.called_next_key = true;",
                  "                Ok(Some(Field::Start))",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::missing_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let mut start: Option<Idx> = None;",
                  "    let key = tri!(map.next_key());",
                  "    start = Some(tri!(map.next_value()));",
                  "    assert!(matches!(_ ,Err(ref e) if e.to_string() == \"missing field `start`\"));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.called_next_key {",
                  "                Ok(None)",
                  "            } else {",
                  "                self.called_next_key = true;",
                  "                Ok(Some(Field::Start))",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::missing_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let mut start: Option<Idx> = None;",
                  "    let key = tri!(map.next_key());",
                  "    start = Some(tri!(map.next_value()));",
                  "    assert!(start.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        called_next_key: bool,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.called_next_key {",
                  "                Ok(None)",
                  "            } else {",
                  "                self.called_next_key = true;",
                  "                Ok(Some(Field::Start))",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::missing_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { called_next_key: false };",
                  "    let _ = visitor.visit_map(map);",
                  "    let mut start: Option<Idx> = None;",
                  "    let key = tri!(map.next_key());",
                  "    start = Some(tri!(map.next_value()));",
                  "    assert!(matches!(map.next_value::<Idx>(), Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: no rules expected the token `_`\n    --> serde/src/de/impls.rs:2770:22\n     |\n2770 |     assert!(matches!(_ ,Err(ref e) if e.to_string() == \"missing field `start`\"));\n     |                      ^ no rules expected this token in macro call\n     |\nnote: while trying to match meta-variable `$expression:expr`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/macros/mod.rs:456:6\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2767:27\n     |\n2767 |     let mut start: Option<Idx> = None;\n     |                           ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2735 | fn test_visit_map_20<Idx>()\n     |                     +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2768:24\n     |\n2768 |     let key = tri!(map.next_key());\n     |                        ^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ expected `()`, found `Result<_, Box<dyn Error>>`\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\n     = note: expected unit type `()`\n                     found enum `Result<_, std::boxed::Box<dyn de::Error>>`\n     = note: this error originates in the macro `tri` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:27\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                           ^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2769:18\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                  ---------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2769:18\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                  ---------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: this function depends on never type fallback being `()`\n    --> serde/src/de/impls.rs:2735:1\n     |\n2735 | fn test_visit_map_20()\n     | ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n     = note: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\n     = help: specify the types explicitly\nnote: in edition 2024, the requirement `!: de::Deserialize<'_>` will fail\n    --> serde/src/de/impls.rs:2769:27\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                           ^^^^^^^^^^\n     = note: `#[warn(dependency_on_unit_never_type_fallback)]` on by default\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2746:17\n     |\n2746 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277, E0308, E0412.\nFor more information about an error, try `rustc --explain E0038`.\nwarning: `serde` (lib test) generated 1 warning\nerror: could not compile `serde` (lib test) due to 23 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2767:27\n     |\n2767 |     let mut start: Option<Idx> = None;\n     |                           ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2735 | fn test_visit_map_21<Idx>()\n     |                     +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2768:24\n     |\n2768 |     let key = tri!(map.next_key());\n     |                        ^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ expected `()`, found `Result<_, Box<dyn Error>>`\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\n     = note: expected unit type `()`\n                     found enum `Result<_, std::boxed::Box<dyn de::Error>>`\n     = note: this error originates in the macro `tri` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:27\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                           ^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2769:18\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                  ---------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2769:18\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                  ---------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: this function depends on never type fallback being `()`\n    --> serde/src/de/impls.rs:2735:1\n     |\n2735 | fn test_visit_map_21()\n     | ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n     = note: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\n     = help: specify the types explicitly\nnote: in edition 2024, the requirement `!: de::Deserialize<'_>` will fail\n    --> serde/src/de/impls.rs:2769:27\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                           ^^^^^^^^^^\n     = note: `#[warn(dependency_on_unit_never_type_fallback)]` on by default\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2746:17\n     |\n2746 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277, E0308, E0412.\nFor more information about an error, try `rustc --explain E0038`.\nwarning: `serde` (lib test) generated 1 warning\nerror: could not compile `serde` (lib test) due to 22 previous errors; 1 warning emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2767:27\n     |\n2767 |     let mut start: Option<Idx> = None;\n     |                           ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2735 | fn test_visit_map_22<Idx>()\n     |                     +++++\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2770:39\n     |\n2770 |     assert!(matches!(map.next_value::<Idx>(), Err(_)));\n     |                                       ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2735 | fn test_visit_map_22<Idx>()\n     |                     +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2768:24\n     |\n2768 |     let key = tri!(map.next_key());\n     |                        ^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ expected `()`, found `Result<_, Box<dyn Error>>`\n     |\n    ::: serde/src/de/impls.rs:2768:15\n     |\n2768 |     let key = tri!(map.next_key());\n     |               -------------------- in this macro invocation\n     |\n     = note: expected unit type `()`\n                     found enum `Result<_, std::boxed::Box<dyn de::Error>>`\n     = note: this error originates in the macro `tri` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:27\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                           ^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2769:18\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                  ---------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/lib.rs:298:32\n     |\n298  |             Err(err) => return Err(err),\n     |                                ^^^^^^^^ `de::Error` cannot be made into an object\n     |\n    ::: serde/src/de/impls.rs:2769:18\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                  ---------------------- in this macro invocation\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `tri` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:26\n     |\n2770 |     assert!(matches!(map.next_value::<Idx>(), Err(_)));\n     |                          ^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: this function depends on never type fallback being `()`\n    --> serde/src/de/impls.rs:2735:1\n     |\n2735 | fn test_visit_map_22()\n     | ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n     = note: for more information, see issue #123748 <https://github.com/rust-lang/rust/issues/123748>\n     = help: specify the types explicitly\nnote: in edition 2024, the requirement `!: de::Deserialize<'_>` will fail\n    --> serde/src/de/impls.rs:2769:27\n     |\n2769 |     start = Some(tri!(map.next_value()));\n     |                           ^^^^^^^^^^\n     = note: `#[warn(dependency_on_unit_never_type_fallback)]` on by default\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2746:17\n     |\n2746 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::missing_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277, E0308, E0412.\nFor more information about an error, try `rustc --explain E0038`.\nwarning: `serde` (lib test) generated 1 warning\nerror: could not compile `serde` (lib test) due to 24 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestMapAccess {",
                "        count: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for TestMapAccess {",
                "        type Error = Box<dyn Error>;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.count < 2 {",
                "                self.count += 1;",
                "                Ok(Some(Field::Start))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                "        where",
                "            V: Deserialize<'de>,",
                "        {",
                "            Err(Box::new(Error::duplicate_field(\"start\")))",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor {",
                "        expecting: \"test\",",
                "        phantom: PhantomData::<i32>,",
                "    };",
                "    let map = TestMapAccess { count: 0 };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(matches!(result, Err(_)));"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(format!(\"{}\", result.unwrap_err()), \"duplicate_field(\\\"start\\\")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        count: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.count < 2 {",
                  "                self.count += 1;",
                  "                Ok(Some(Field::Start))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        count: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.count < 2 {",
                  "                self.count += 1;",
                  "                Ok(Some(Field::Start))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestMapAccess {",
                  "        count: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for TestMapAccess {",
                  "        type Error = Box<dyn Error>;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.count < 2 {",
                  "                self.count += 1;",
                  "                Ok(Some(Field::Start))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<V, Self::Error>",
                  "        where",
                  "            V: Deserialize<'de>,",
                  "        {",
                  "            Err(Box::new(Error::duplicate_field(\"start\")))",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor {",
                  "        expecting: \"test\",",
                  "        phantom: PhantomData::<i32>,",
                  "    };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData::<i32> };",
                  "    let map = TestMapAccess { count: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(format!(\"{}\", result.unwrap_err()), \"duplicate_field(\\\"start\\\")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:26\n     |\n2769 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:13\n     |\n2770 |     assert!(result.is_err());\n     |             ^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2747:17\n     |\n2747 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 16 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:26\n     |\n2769 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2747:17\n     |\n2747 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 15 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `std::boxed::Box<(dyn de::Error + 'static)>: de::Error` is not satisfied\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `std::boxed::Box<(dyn de::Error + 'static)>`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/impls.rs:2742:22\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                      ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`, which is required by `<TestMapAccess as de::MapAccess<'de>>::Error: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\n     = note: required for `std::boxed::Box<(dyn de::Error + 'static)>` to implement `std::error::Error`\nnote: required for `<TestMapAccess as de::MapAccess<'de>>::Error` to implement `de::Error`\n    --> serde/src/de/mod.rs:161:19\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   ^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\nnote: required by a bound in `de::MapAccess::Error`\n    --> serde/src/de/mod.rs:1795:17\n     |\n1795 |     type Error: Error;\n     |                 ^^^^^ required by this bound in `MapAccess::Error`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2744:20\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2741:5\n     |\n2741 |       impl<'de> MapAccess<'de> for TestMapAccess {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2742:26\n     |\n2742 |         type Error = Box<dyn Error>;\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2744:35\n     |\n2744 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2753:40\n     |\n2753 |         fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2766:21\n     |\n2766 |     let _ = visitor.visit_map(map);\n     |                     ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2769:26\n     |\n2769 |     let result = visitor.visit_map(map);\n     |                          ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:30\n     |\n2770 |     assert_eq!(format!(\"{}\", result.unwrap_err()), \"duplicate_field(\\\"start\\\")\");\n     |                              ^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2770:25\n     |\n2770 |     assert_eq!(format!(\"{}\", result.unwrap_err()), \"duplicate_field(\\\"start\\\")\");\n     |                         ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2747:17\n     |\n2747 |                 Ok(Some(Field::Start))\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2749:17\n     |\n2749 |                 Ok(None)\n     |                 ^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:13\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/impls.rs:2757:17\n     |\n2757 |             Err(Box::new(Error::duplicate_field(\"start\")))\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: required for the cast from `std::boxed::Box<{type error}>` to `std::boxed::Box<dyn de::Error>`\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0277.\nFor more information about an error, try `rustc --explain E0038`.\nerror: could not compile `serde` (lib test) due to 17 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: map.next_key() matches Ok(val) is true\n",
        "// constraint: let Some(key) = tri!(map.next_key()) is true\n",
        "// constraint: start.is_some() is false\n",
        "// constraint: map.next_value() matches Ok(val) is true\n",
        "// constraint: map.next_key() matches Err(err) is true\n",
        "// expected return value/type: Err(err)\n"
      ],
      "input_infer": "test input ranges: {} (empty map), { \"start\": valid_value }, { \"start\": valid_value, \"start\": duplicate_value }, { \"key\": valid_value }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMap {",
                "        entries: Vec<(Field, Idx)>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMap {",
                "        type Error = MockError;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            Ok(None)",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                "            Err(MockError {})",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                "    let map = MockMap { entries: vec![], index: 0 };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().to_string(), \"expected error message\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            Ok(None)",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Err(MockError {})",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            Ok(None)",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Err(MockError {})",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().to_string(), \"expected error message\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2749:47\n     |\n2749 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror[E0422]: cannot find struct, variant or union type `MockError` in this scope\n    --> serde/src/de/impls.rs:2750:17\n     |\n2750 |             Err(MockError {})\n     |                 ^^^^^^^^^ not found in this scope\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0412, E0422.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2749:47\n     |\n2749 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror[E0422]: cannot find struct, variant or union type `MockError` in this scope\n    --> serde/src/de/impls.rs:2750:17\n     |\n2750 |             Err(MockError {})\n     |                 ^^^^^^^^^ not found in this scope\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0412, E0422.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMap {",
                "        entries: Vec<(Field, Idx)>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMap {",
                "        type Error = MockError;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.entries.len() {",
                "                let entry = &self.entries[self.index];",
                "                self.index += 1;",
                "                Ok(Some(entry.0))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                "            Ok(self.entries[self.index - 1].1)",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.err(), Some(MockError::duplicate_field(\"start\")));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.entries.len() {",
                  "                let entry = &self.entries[self.index];",
                  "                self.index += 1;",
                  "                Ok(Some(entry.0))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Ok(self.entries[self.index - 1].1)",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.entries.len() {",
                  "                let entry = &self.entries[self.index];",
                  "                self.index += 1;",
                  "                Ok(Some(entry.0))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Ok(self.entries[self.index - 1].1)",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.err(), Some(MockError::duplicate_field(\"start\")));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2755:47\n     |\n2755 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0412.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2755:47\n     |\n2755 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0433]: failed to resolve: use of undeclared type `MockError`\n    --> serde/src/de/impls.rs:2766:35\n     |\n2766 |     assert_eq!(result.err(), Some(MockError::duplicate_field(\"start\")));\n     |                                   ^^^^^^^^^ use of undeclared type `MockError`\n\nSome errors have detailed explanations: E0046, E0049, E0412, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMap {",
                "        entries: Vec<(Field, Idx)>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMap {",
                "        type Error = MockError;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.entries.len() {",
                "                let entry = &self.entries[self.index];",
                "                self.index += 1;",
                "                Ok(Some(entry.0))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                "            Ok(self.entries[self.index - 1].1)",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().kind(), MockErrorKind::DuplicateField(\"start\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.entries.len() {",
                  "                let entry = &self.entries[self.index];",
                  "                self.index += 1;",
                  "                Ok(Some(entry.0))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Ok(self.entries[self.index - 1].1)",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.entries.len() {",
                  "                let entry = &self.entries[self.index];",
                  "                self.index += 1;",
                  "                Ok(Some(entry.0))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Ok(self.entries[self.index - 1].1)",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 43)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert_eq!(result.unwrap_err().kind(), MockErrorKind::DuplicateField(\"start\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2755:47\n     |\n2755 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nSome errors have detailed explanations: E0046, E0049, E0412.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2755:47\n     |\n2755 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0433]: failed to resolve: use of undeclared type `MockErrorKind`\n    --> serde/src/de/impls.rs:2766:44\n     |\n2766 |     assert_eq!(result.unwrap_err().kind(), MockErrorKind::DuplicateField(\"start\"));\n     |                                            ^^^^^^^^^^^^^ use of undeclared type `MockErrorKind`\n\nSome errors have detailed explanations: E0046, E0049, E0412, E0433.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockMap {",
                "        entries: Vec<(Field, Idx)>,",
                "        index: usize,",
                "    }",
                "",
                "    impl<'de> MapAccess<'de> for MockMap {",
                "        type Error = MockError;",
                "",
                "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                "            if self.index < self.entries.len() {",
                "                let entry = &self.entries[self.index];",
                "                self.index += 1;",
                "                Ok(Some(entry.0))",
                "            } else {",
                "                Ok(None)",
                "            }",
                "        }",
                "",
                "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                "            Ok(self.entries[self.index - 1].1)",
                "        }",
                "    }",
                "",
                "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Other, 100)], index: 0 };",
                "    let _ = visitor.visit_map(map);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    let mut map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 100)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.entries.len() {",
                  "                let entry = &self.entries[self.index];",
                  "                self.index += 1;",
                  "                Ok(Some(entry.0))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Ok(self.entries[self.index - 1].1)",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Other, 100)], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let mut map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockMap {",
                  "        entries: Vec<(Field, Idx)>,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'de> MapAccess<'de> for MockMap {",
                  "        type Error = MockError;",
                  "",
                  "        fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {",
                  "            if self.index < self.entries.len() {",
                  "                let entry = &self.entries[self.index];",
                  "                self.index += 1;",
                  "                Ok(Some(entry.0))",
                  "            } else {",
                  "                Ok(None)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {",
                  "            Ok(self.entries[self.index - 1].1)",
                  "        }",
                  "    }",
                  "",
                  "    let visitor = RangeFromVisitor { expecting: \"test\", phantom: PhantomData };",
                  "    let map = MockMap { entries: vec![(Field::Start, 42), (Field::Other, 100)], index: 0 };",
                  "    let _ = visitor.visit_map(map);",
                  "    let mut map = MockMap { entries: vec![(Field::Start, 42)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    let mut map = MockMap { entries: vec![(Field::Start, 42), (Field::Start, 100)], index: 0 };",
                  "    let result = visitor.visit_map(map);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2755:47\n     |\n2755 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no variant or associated item named `Other` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2761:67\n     |\n2633 |     enum Field {\n     |     ---------- variant or associated item `Other` not found for this enum\n...\n2761 |     let map = MockMap { entries: vec![(Field::Start, 42), (Field::Other, 100)], index: 0 };\n     |                                                                   ^^^^^ variant or associated item not found in `Field`\n\nSome errors have detailed explanations: E0046, E0049, E0412, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2738:30\n     |\n2738 |         entries: Vec<(Field, Idx)>,\n     |                              ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2737 |     struct MockMap<Idx> {\n     |                   +++++\n\nerror[E0412]: cannot find type `MockError` in this scope\n    --> serde/src/de/impls.rs:2743:22\n     |\n2743 |         type Error = MockError;\n     |                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Idx` in this scope\n    --> serde/src/de/impls.rs:2755:47\n     |\n2755 |         fn next_value<V>(&mut self) -> Result<Idx, Self::Error> {\n     |                                               ^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2742 |     impl<'de, Idx> MapAccess<'de> for MockMap {\n     |             +++++\n\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/impls.rs:2733:8\n     |\n2733 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0049]: method `next_key` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/impls.rs:2745:20\n     |\n2745 |         fn next_key(&mut self) -> Result<Option<Field>, Self::Error> {\n     |                    ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1852:17\n     |\n1852 |     fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     |                 - expected 1 type parameter\n\nerror[E0046]: not all trait items implemented, missing: `next_key_seed`, `next_value_seed`\n    --> serde/src/de/impls.rs:2742:5\n     |\n2742 |       impl<'de> MapAccess<'de> for MockMap {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `next_key_seed`, `next_value_seed` in implementation\n     |\n    ::: serde/src/de/mod.rs:1802:5\n     |\n1802 | /     fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n1803 | |     where\n1804 | |         K: DeserializeSeed<'de>;\n     | |________________________________- `next_key_seed` from trait\n...\n1815 | /     fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n1816 | |     where\n1817 | |         V: DeserializeSeed<'de>;\n     | |________________________________- `next_value_seed` from trait\n\nerror[E0599]: no variant or associated item named `Other` found for enum `range_from::Field` in the current scope\n    --> serde/src/de/impls.rs:2761:67\n     |\n2633 |     enum Field {\n     |     ---------- variant or associated item `Other` not found for this enum\n...\n2761 |     let map = MockMap { entries: vec![(Field::Start, 42), (Field::Other, 100)], index: 0 };\n     |                                                                   ^^^^^ variant or associated item not found in `Field`\n\nSome errors have detailed explanations: E0046, E0049, E0412, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}