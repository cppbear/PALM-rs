{
  "name": "serde::__private::de::content::<__private::de::content::ContentRefDeserializer<'a, 'de, E> as de::Deserializer<'de>>::deserialize_any",
  "name_with_impl": "serde::__private::de::content::{impl#22}::deserialize_any",
  "mod_info": {
    "name": "__private::de::content",
    "loc": "serde/src/private/de.rs:198:1:2358:2"
  },
  "visible": true,
  "loc": "serde/src/private/de.rs:1741:9:1771:10",
  "fn_tests": [
    {
      "chain_id": 0,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[derive(Debug)]",
            "enum Content<'de> {",
            "    Bool(bool),",
            "    U8(u8),",
            "    U16(u16),",
            "    U32(u32),",
            "    U64(u64),",
            "    I8(i8),",
            "    I16(i16),",
            "    I32(i32),",
            "    I64(i64),",
            "    F32(f32),",
            "    F64(f64),",
            "    Char(char),",
            "    String(String),",
            "    Str(&'de str),",
            "    ByteBuf(Vec<u8>),",
            "    Bytes(&'de [u8]),",
            "    Unit,",
            "    None,",
            "    Some(Box<Content<'de>>),",
            "    Newtype(Box<Content<'de>>),",
            "    Seq(Vec<Content<'de>>),",
            "    Map(std::collections::HashMap<String, Content<'de>>),",
            "}",
            "",
            "struct ContentDeserializer<'de> {",
            "    content: &'de Content<'de>,",
            "}",
            "",
            "impl<'de> ContentDeserializer<'de> {",
            "    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, String>",
            "    where",
            "        V: Visitor<'de>,",
            "    {",
            "        match *self.content {",
            "            Content::Bool(v) => visitor.visit_bool(v),",
            "            Content::U8(v) => visitor.visit_u8(v),",
            "            Content::U16(v) => visitor.visit_u16(v),",
            "            Content::U32(v) => visitor.visit_u32(v),",
            "            Content::U64(v) => visitor.visit_u64(v),",
            "            Content::I8(v) => visitor.visit_i8(v),",
            "            Content::I16(v) => visitor.visit_i16(v),",
            "            Content::I32(v) => visitor.visit_i32(v),",
            "            Content::I64(v) => visitor.visit_i64(v),",
            "            Content::F32(v) => visitor.visit_f32(v),",
            "            Content::F64(v) => visitor.visit_f64(v),",
            "            Content::Char(v) => visitor.visit_char(v),",
            "            Content::String(ref v) => visitor.visit_str(v),",
            "            Content::Str(v) => visitor.visit_borrowed_str(v),",
            "            Content::ByteBuf(ref v) => visitor.visit_bytes(v),",
            "            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),",
            "            Content::Unit => visitor.visit_unit(),",
            "            Content::None => visitor.visit_none(),",
            "            Content::Some(ref v) => visitor.visit_some(ContentDeserializer { content: v }),",
            "            Content::Newtype(ref v) => {",
            "                visitor.visit_newtype_struct(ContentDeserializer { content: v })",
            "            }",
            "            Content::Seq(ref v) => visitor.visit_seq(ContentDeserializer { content: &v }),",
            "            Content::Map(ref v) => visitor.visit_map(ContentDeserializer { content: &v }),",
            "        }",
            "    }",
            "}",
            "",
            "trait Visitor<'de> {",
            "    type Value;",
            "",
            "    fn visit_bool(self, v: bool) -> Result<Self::Value, String>;",
            "    fn visit_u8(self, v: u8) -> Result<Self::Value, String>;",
            "    fn visit_u16(self, v: u16) -> Result<Self::Value, String>;",
            "    fn visit_u32(self, v: u32) -> Result<Self::Value, String>;",
            "    fn visit_u64(self, v: u64) -> Result<Self::Value, String>;",
            "    fn visit_i8(self, v: i8) -> Result<Self::Value, String>;",
            "    fn visit_i16(self, v: i16) -> Result<Self::Value, String>;",
            "    fn visit_i32(self, v: i32) -> Result<Self::Value, String>;",
            "    fn visit_i64(self, v: i64) -> Result<Self::Value, String>;",
            "    fn visit_f32(self, v: f32) -> Result<Self::Value, String>;",
            "    fn visit_f64(self, v: f64) -> Result<Self::Value, String>;",
            "    fn visit_char(self, v: char) -> Result<Self::Value, String>;",
            "    fn visit_str(self, v: &str) -> Result<Self::Value, String>;",
            "    fn visit_borrowed_str(self, v: &'de str) -> Result<Self::Value, String>;",
            "    fn visit_bytes(self, v: &[u8]) -> Result<Self::Value, String>;",
            "    fn visit_borrowed_bytes(self, v: &'de [u8]) -> Result<Self::Value, String>;",
            "    fn visit_unit(self) -> Result<Self::Value, String>;",
            "    fn visit_none(self) -> Result<Self::Value, String>;",
            "    fn visit_some(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String>;",
            "    fn visit_newtype_struct(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String>;",
            "    fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String>;",
            "    fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String>;",
            "}",
            "",
            "struct TestVisitor {",
            "    value: Option<String>,",
            "}",
            "",
            "impl<'de> Visitor<'de> for TestVisitor {",
            "    type Value = String;",
            "",
            "    fn visit_bool(self, v: bool) -> Result<Self::Value, String> {",
            "        Ok(format!(\"Bool: {}\", v))",
            "    }",
            "",
            "    fn visit_u8(self, v: u8) -> Result<Self::Value, String> {",
            "        Ok(format!(\"U8: {}\", v))",
            "    }",
            "",
            "    fn visit_u16(self, v: u16) -> Result<Self::Value, String> {",
            "        Ok(format!(\"U16: {}\", v))",
            "    }",
            "",
            "    fn visit_u32(self, v: u32) -> Result<Self::Value, String> {",
            "        Ok(format!(\"U32: {}\", v))",
            "    }",
            "",
            "    fn visit_u64(self, v: u64) -> Result<Self::Value, String> {",
            "        Ok(format!(\"U64: {}\", v))",
            "    }",
            "",
            "    fn visit_i8(self, v: i8) -> Result<Self::Value, String> {",
            "        Ok(format!(\"I8: {}\", v))",
            "    }",
            "",
            "    fn visit_i16(self, v: i16) -> Result<Self::Value, String> {",
            "        Ok(format!(\"I16: {}\", v))",
            "    }",
            "",
            "    fn visit_i32(self, v: i32) -> Result<Self::Value, String> {",
            "        Ok(format!(\"I32: {}\", v))",
            "    }",
            "",
            "    fn visit_i64(self, v: i64) -> Result<Self::Value, String> {",
            "        Ok(format!(\"I64: {}\", v))",
            "    }",
            "",
            "    fn visit_f32(self, v: f32) -> Result<Self::Value, String> {",
            "        Ok(format!(\"F32: {}\", v))",
            "    }",
            "",
            "    fn visit_f64(self, v: f64) -> Result<Self::Value, String> {",
            "        Ok(format!(\"F64: {}\", v))",
            "    }",
            "",
            "    fn visit_char(self, v: char) -> Result<Self::Value, String> {",
            "        Ok(format!(\"Char: {}\", v))",
            "    }",
            "",
            "    fn visit_str(self, v: &str) -> Result<Self::Value, String> {",
            "        Ok(format!(\"String: {}\", v))",
            "    }",
            "",
            "    fn visit_borrowed_str(self, v: &'de str) -> Result<Self::Value, String> {",
            "        Ok(format!(\"Borrowed Str: {}\", v))",
            "    }",
            "",
            "    fn visit_bytes(self, v: &[u8]) -> Result<Self::Value, String> {",
            "        Ok(format!(\"ByteBuf: {:?}\", v))",
            "    }",
            "",
            "    fn visit_borrowed_bytes(self, v: &'de [u8]) -> Result<Self::Value, String> {",
            "        Ok(format!(\"Borrowed Bytes: {:?}\", v))",
            "    }",
            "",
            "    fn visit_unit(self) -> Result<Self::Value, String> {",
            "        Ok(\"Unit\".to_string())",
            "    }",
            "",
            "    fn visit_none(self) -> Result<Self::Value, String> {",
            "        Ok(\"None\".to_string())",
            "    }",
            "",
            "    fn visit_some(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {",
            "        v.deserialize_any(self)",
            "    }",
            "",
            "    fn visit_newtype_struct(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {",
            "        v.deserialize_any(self)",
            "    }",
            "",
            "    fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {",
            "        Ok(\"Seq\".to_string())",
            "    }",
            "",
            "    fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {",
            "        Ok(\"Map\".to_string())",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let content = Content::Bool(true);",
                  "    let deserializer = ContentDeserializer { content: &content };",
                  "    let visitor = TestVisitor { value: None };",
                  "    assert_eq!(deserializer.deserialize_any(visitor).unwrap(), \"Bool: true\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nwarning: unused import: `ntest::timeout`\n    --> serde/src/private/de.rs:2362:8\n     |\n2362 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2421:85\n     |\n2421 |             Content::Seq(ref v) => visitor.visit_seq(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&Vec<Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::vec::Vec<llmtests::Content<'_>>`\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2422:85\n     |\n2422 |             Content::Map(ref v) => visitor.visit_map(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&HashMap<String, Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::collections::HashMap<std::string::String, llmtests::Content<'_>>`\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2541:24\n     |\n2541 |     fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2545:24\n     |\n2545 |     fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde` (lib test) generated 3 warnings\nerror: could not compile `serde` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let content = Content::U8(255);",
                  "    let deserializer = ContentDeserializer { content: &content };",
                  "    let visitor = TestVisitor { value: None };",
                  "    assert_eq!(deserializer.deserialize_any(visitor).unwrap(), \"U8: 255\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nwarning: unused import: `ntest::timeout`\n    --> serde/src/private/de.rs:2362:8\n     |\n2362 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2421:85\n     |\n2421 |             Content::Seq(ref v) => visitor.visit_seq(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&Vec<Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::vec::Vec<llmtests::Content<'_>>`\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2422:85\n     |\n2422 |             Content::Map(ref v) => visitor.visit_map(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&HashMap<String, Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::collections::HashMap<std::string::String, llmtests::Content<'_>>`\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2541:24\n     |\n2541 |     fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2545:24\n     |\n2545 |     fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde` (lib test) generated 3 warnings\nerror: could not compile `serde` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let content = Content::String(\"hello\".to_string());",
                  "    let deserializer = ContentDeserializer { content: &content };",
                  "    let visitor = TestVisitor { value: None };",
                  "    assert_eq!(deserializer.deserialize_any(visitor).unwrap(), \"String: hello\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nwarning: unused import: `ntest::timeout`\n    --> serde/src/private/de.rs:2362:8\n     |\n2362 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2421:85\n     |\n2421 |             Content::Seq(ref v) => visitor.visit_seq(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&Vec<Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::vec::Vec<llmtests::Content<'_>>`\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2422:85\n     |\n2422 |             Content::Map(ref v) => visitor.visit_map(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&HashMap<String, Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::collections::HashMap<std::string::String, llmtests::Content<'_>>`\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2541:24\n     |\n2541 |     fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2545:24\n     |\n2545 |     fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde` (lib test) generated 3 warnings\nerror: could not compile `serde` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let content = Content::Unit;",
                  "    let deserializer = ContentDeserializer { content: &content };",
                  "    let visitor = TestVisitor { value: None };",
                  "    assert_eq!(deserializer.deserialize_any(visitor).unwrap(), \"Unit\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nwarning: unused import: `ntest::timeout`\n    --> serde/src/private/de.rs:2362:8\n     |\n2362 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2421:85\n     |\n2421 |             Content::Seq(ref v) => visitor.visit_seq(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&Vec<Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::vec::Vec<llmtests::Content<'_>>`\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2422:85\n     |\n2422 |             Content::Map(ref v) => visitor.visit_map(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&HashMap<String, Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::collections::HashMap<std::string::String, llmtests::Content<'_>>`\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2541:24\n     |\n2541 |     fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2545:24\n     |\n2545 |     fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde` (lib test) generated 3 warnings\nerror: could not compile `serde` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let content = Content::None;",
                  "    let deserializer = ContentDeserializer { content: &content };",
                  "    let visitor = TestVisitor { value: None };",
                  "    assert_eq!(deserializer.deserialize_any(visitor).unwrap(), \"None\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nwarning: unused import: `ntest::timeout`\n    --> serde/src/private/de.rs:2362:8\n     |\n2362 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2421:85\n     |\n2421 |             Content::Seq(ref v) => visitor.visit_seq(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&Vec<Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::vec::Vec<llmtests::Content<'_>>`\n\nerror[E0308]: mismatched types\n    --> serde/src/private/de.rs:2422:85\n     |\n2422 |             Content::Map(ref v) => visitor.visit_map(ContentDeserializer { content: &v }),\n     |                                                                                     ^^ expected `&Content<'_>`, found `&&HashMap<String, Content<'_>>`\n     |\n     = note: expected reference `&llmtests::Content<'_>`\n                found reference `&&std::collections::HashMap<std::string::String, llmtests::Content<'_>>`\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2541:24\n     |\n2541 |     fn visit_seq(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `v`\n    --> serde/src/private/de.rs:2545:24\n     |\n2545 |     fn visit_map(self, v: ContentDeserializer<'de>) -> Result<Self::Value, String> {\n     |                        ^ help: if this is intentional, prefix it with an underscore: `_v`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `serde` (lib test) generated 3 warnings\nerror: could not compile `serde` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}