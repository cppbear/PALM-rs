{
  "name": "serde::de::<&mut A as de::SeqAccess<'de>>::next_element_seed",
  "name_with_impl": "serde::de::{impl#6}::next_element_seed",
  "mod_info": {
    "name": "de",
    "loc": "serde/src/lib.rs:311:1:311:12"
  },
  "visible": true,
  "loc": "serde/src/de/mod.rs:1751:5:1756:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::marker::PhantomData;",
            "use serde::de::DeserializeSeed;",
            "use serde::de::Visitor;",
            "use serde::de::MapAccess;",
            "use serde::Deserialize;"
          ],
          "has_test_mod": false,
          "common": [
            "fn next_element_seed_test() {",
            "",
            "    struct TestDeserializer<'de> {",
            "        elements: &'de [&'de str],",
            "        index: usize,",
            "    }",
            "",
            "    impl<'de> TestDeserializer<'de> {",
            "        fn new(elements: &'de [&'de str]) -> Self {",
            "            Self { elements, index: 0 }",
            "        }",
            "    }",
            "",
            "    impl<'de> Iterator for TestDeserializer<'de> {",
            "        type Item = Result<Option<&'de str>, serde::de::Error>;",
            "",
            "        fn next(&mut self) -> Option<Self::Item> {",
            "            if self.index < self.elements.len() {",
            "                let element = self.elements[self.index];",
            "                self.index += 1;",
            "                Some(Ok(Some(element)))",
            "            } else {",
            "                None",
            "            }",
            "        }",
            "    }",
            "",
            "    struct Seed;",
            "",
            "    impl<'de> DeserializeSeed<'de> for Seed {",
            "        type Value = String;",
            "",
            "        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>",
            "        where",
            "            D: serde::Deserializer<'de>,",
            "        {",
            "            let value: &'de str = deserializer.deserialize_str(StringVisitor)?;",
            "            Ok(value.to_string())",
            "        }",
            "    }",
            "",
            "    struct StringVisitor;",
            "",
            "    impl<'de> Visitor<'de> for StringVisitor {",
            "        type Value = &'de str;",
            "",
            "        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {",
            "            formatter.write_str(\"a string\")",
            "        }",
            "",
            "        fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>",
            "        where",
            "            E: serde::de::Error,",
            "        {",
            "            Ok(value)",
            "        }",
            "    }",
            "",
            "    impl<'de> serde::de::MapAccess<'de> for TestDeserializer<'de> {",
            "        type Error = serde::de::Error;",
            "",
            "        fn next_key<V>(&mut self, visitor: V) -> Result<Option<V::Value>, Self::Error>",
            "        where",
            "            V: Visitor<'de>,",
            "        {",
            "            if self.index < self.elements.len() {",
            "                let key = self.elements[self.index];",
            "                self.index += 1;",
            "                visitor.visit_str(key)",
            "            } else {",
            "                Ok(None)",
            "            }",
            "        }",
            "",
            "        fn next_value<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>",
            "        where",
            "            V: Visitor<'de>,",
            "        {",
            "            if self.index > 0 {",
            "                let value = self.elements[self.index - 1];",
            "                visitor.visit_str(value)",
            "            } else {",
            "                Err(serde::de::Error::custom(\"Value not found\"))",
            "            }",
            "        }",
            "    }",
            "",
            "    let elements = [\"first\", \"second\", \"third\"];",
            "    let mut deserializer = TestDeserializer::new(&elements);",
            "    let seed = Seed;",
            "",
            "    assert_eq!(deserializer.next_element_seed(seed).unwrap(), Some(\"first\".to_string()));",
            "    assert_eq!(deserializer.next_element_seed(seed).unwrap(), Some(\"second\".to_string()));",
            "    assert_eq!(deserializer.next_element_seed(seed).unwrap(), Some(\"third\".to_string()));",
            "    assert_eq!(deserializer.next_element_seed(seed).unwrap(), None);",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}