{
  "name": "serde::de::ignored_any::<de::ignored_any::IgnoredAny as de::Visitor<'de>>::visit_seq",
  "name_with_impl": "serde::de::ignored_any::{impl#0}::visit_seq",
  "mod_info": {
    "name": "de::ignored_any",
    "loc": "serde/src/de/mod.rs:121:1:121:17"
  },
  "visible": true,
  "loc": "serde/src/de/ignored_any.rs:192:5:200:6",
  "fn_tests": [
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: seq.next_element() matches Ok(val) is true\n",
        "// constraint: let Some(IgnoredAny) = tri!(seq.next_element()) is true\n",
        "// constraint: seq.next_element() matches Err(err) is true\n",
        "// expected return value/type: Err(err)\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use serde::de::SeqAccess;",
            "use serde::de::DeserializeSeed;",
            "use serde::de::IgnoredAny;"
          ],
          "has_test_mod": false,
          "common": [
            "fn test_visit_seq_ok() -> Result<(), Box<dyn std::error::Error>> {",
            "",
            "    struct TestSeqAccess {",
            "        elements: Vec<Result<IgnoredAny, String>>,",
            "        index: usize,",
            "    }",
            "",
            "    impl<'de> SeqAccess<'de> for TestSeqAccess {",
            "        type Error = String;",
            "",
            "        fn next_element_seed<T>(&mut self, _seed: T) -> Result<Option<IgnoredAny>, Self::Error>",
            "        where",
            "            T: DeserializeSeed<'de>,",
            "        {",
            "            if self.index < self.elements.len() {",
            "                let val = self.elements[self.index].clone();",
            "                self.index += 1;",
            "                return Ok(Some(val?));",
            "            }",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeqAccess {",
            "        elements: vec![Ok(IgnoredAny), Ok(IgnoredAny), Ok(IgnoredAny)],",
            "        index: 0,",
            "    };",
            "",
            "    let result: Result<IgnoredAny, String> = visit_seq(seq);",
            "    assert!(result.is_ok());",
            "    Ok(())",
            "}",
            "",
            "fn test_visit_seq_err() -> Result<(), Box<dyn std::error::Error>> {",
            "",
            "    struct TestSeqAccess {",
            "        elements: Vec<Result<IgnoredAny, String>>,",
            "        index: usize,",
            "    }",
            "",
            "    impl<'de> SeqAccess<'de> for TestSeqAccess {",
            "        type Error = String;",
            "",
            "        fn next_element_seed<T>(&mut self, _seed: T) -> Result<Option<IgnoredAny>, Self::Error>",
            "        where",
            "            T: DeserializeSeed<'de>,",
            "        {",
            "            if self.index < self.elements.len() {",
            "                let val = self.elements[self.index].clone();",
            "                self.index += 1;",
            "                return Ok(Some(val?));",
            "            }",
            "            Ok(None)",
            "        }",
            "    }",
            "",
            "    let seq = TestSeqAccess {",
            "        elements: vec![Ok(IgnoredAny), Err(\"Error occurred\".to_string())],",
            "        index: 0,",
            "    };",
            "",
            "    let result: Result<IgnoredAny, String> = visit_seq(seq);",
            "    assert!(result.is_err());",
            "    Ok(())",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}