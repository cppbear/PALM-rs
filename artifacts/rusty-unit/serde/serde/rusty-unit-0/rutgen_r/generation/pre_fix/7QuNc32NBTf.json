{
  "name": "serde::de::value::private::<de::value::private::UnitOnly<E> as de::VariantAccess<'de>>::tuple_variant",
  "name_with_impl": "serde::de::value::private::{impl#0}::tuple_variant",
  "mod_info": {
    "name": "de::value::private",
    "loc": "serde/src/de/value.rs:1730:1:1894:2"
  },
  "visible": true,
  "loc": "serde/src/de/value.rs:1770:9:1778:10",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            ))\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "",
                  "    impl<'de> de::Visitor<'de> for DummyVisitor {",
                  "        type Value = ();",
                  "        ",
                  "        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            formatter.write_str(\"a tuple variant\")",
                  "        }",
                  "        ",
                  "        fn visit_unit_variant<E>(self) -> Result<Self::Value, E> where E: de::Error {",
                  "            Err(de::Error::custom(\"Unit variant not expected\"))",
                  "        }",
                  "    }",
                  "",
                  "    struct DummyDeserializer;",
                  "",
                  "    impl de::Deserializer<'_> for DummyDeserializer {",
                  "        type Error = de::Error;",
                  "",
                  "        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>",
                  "        where",
                  "            V: de::Visitor<'de>,",
                  "        {",
                  "            // Simulates invocation of the tuple_variant method",
                  "            let len = 0; // edge case for unit variant",
                  "            self.tuple_variant(len, visitor)",
                  "        }",
                  "",
                  "        fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>",
                  "        where",
                  "            V: de::Visitor<'de>,",
                  "        {",
                  "            Err(de::Error::invalid_type(",
                  "                Unexpected::UnitVariant,",
                  "                &\"tuple variant\",",
                  "            ))",
                  "        }",
                  "",
                  "        // Other required methods would go here...",
                  "        fn deserialize_bool(self) -> Result<bool, Self::Error> { unimplemented!() }",
                  "        fn deserialize_i8(self) -> Result<i8, Self::Error> { unimplemented!() }",
                  "        fn deserialize_i16(self) -> Result<i16, Self::Error> { unimplemented!() }",
                  "        fn deserialize_i32(self) -> Result<i32, Self::Error> { unimplemented!() }",
                  "        fn deserialize_i64(self) -> Result<i64, Self::Error> { unimplemented!() }",
                  "        fn deserialize_u8(self) -> Result<u8, Self::Error> { unimplemented!() }",
                  "        fn deserialize_u16(self) -> Result<u16, Self::Error> { unimplemented!() }",
                  "        fn deserialize_u32(self) -> Result<u32, Self::Error> { unimplemented!() }",
                  "        fn deserialize_u64(self) -> Result<u64, Self::Error> { unimplemented!() }",
                  "        fn deserialize_f32(self) -> Result<f32, Self::Error> { unimplemented!() }",
                  "        fn deserialize_f64(self) -> Result<f64, Self::Error> { unimplemented!() }",
                  "        fn deserialize_char(self) -> Result<char, Self::Error> { unimplemented!() }",
                  "        fn deserialize_string(self) -> Result<String, Self::Error> { unimplemented!() }",
                  "        fn deserialize_bytes(self) -> Result<&'de [u8], Self::Error> { unimplemented!() }",
                  "        fn deserialize_option<V>(self, _visitor: V) -> Result<Option<V::Value>, Self::Error> ",
                  "        where V: de::Visitor<'de> { unimplemented!() }",
                  "        fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value, Self::Error> ",
                  "        where V: de::Visitor<'de> { unimplemented!() }",
                  "        fn deserialize_map<V>(self, _visitor: V) -> Result<V::Value, Self::Error> ",
                  "        where V: de::Visitor<'de> { unimplemented!() }",
                  "        fn deserialize_struct<V>(self, _name: &'static str, _visitor: V) -> Result<V::Value, Self::Error> ",
                  "        where V: de::Visitor<'de> { unimplemented!() }",
                  "        fn deserialize_enum<V>(",
                  "            self,",
                  "            _name: &'static str,",
                  "            _variants: &'static [&'static str],",
                  "            _visitor: V,",
                  "        ) -> Result<V::Value, Self::Error>",
                  "        where V: de::Visitor<'de> { unimplemented!() }",
                  "    }",
                  "",
                  "    let deserializer = DummyDeserializer;",
                  "",
                  "    let result: Result<(), de::Error> = deserializer.deserialize_any(DummyVisitor);",
                  "    assert!(result.is_err());",
                  "    assert_eq!(result.unwrap_err(), de::Error::invalid_type(Unexpected::UnitVariant, &\"tuple variant\"));  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/abezbm/rust-utgen-test-crates-new/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/abezbm/rust-utgen-test-crates-new/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror[E0407]: method `visit_unit_variant` is not a member of trait `de::Visitor`\n    --> serde/src/de/value.rs:1911:9\n     |\n1911 | /         fn visit_unit_variant<E>(self) -> Result<Self::Value, E> where E: de::Error {\n1912 | |             Err(de::Error::custom(\"Unit variant not expected\"))\n1913 | |         }\n     | |_________^ not a member of trait `de::Visitor`\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1923:28\n     |\n1923 |             V: de::Visitor<'de>,\n     |                            ^^^ undeclared lifetime\n     |\n     = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1923 |             V: for<'de> de::Visitor<'de>,\n     |                ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1923 |             for<'de> V: de::Visitor<'de>,\n     |             ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1921 |         fn deserialize_any<'de, V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                            ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0407]: method `tuple_variant` is not a member of trait `de::Deserializer`\n    --> serde/src/de/value.rs:1930:9\n     |\n1930 | /         fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n1931 | |         where\n1932 | |             V: de::Visitor<'de>,\n1933 | |         {\n...    |\n1937 | |             ))\n1938 | |         }\n     | |_________^ not a member of trait `de::Deserializer`\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1932:28\n     |\n1932 |             V: de::Visitor<'de>,\n     |                            ^^^ undeclared lifetime\n     |\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1932 |             V: for<'de> de::Visitor<'de>,\n     |                ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1932 |             for<'de> V: de::Visitor<'de>,\n     |             ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1930 |         fn tuple_variant<'de, V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n     |                          ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1954:47\n     |\n1954 |         fn deserialize_bytes(self) -> Result<&'de [u8], Self::Error> { unimplemented!() }\n     |                                               ^^^ undeclared lifetime\n     |\nhelp: consider introducing lifetime `'de` here\n     |\n1954 |         fn deserialize_bytes<'de>(self) -> Result<&'de [u8], Self::Error> { unimplemented!() }\n     |                             +++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1956:30\n     |\n1956 |         where V: de::Visitor<'de> { unimplemented!() }\n     |                              ^^^ undeclared lifetime\n     |\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1956 |         where V: for<'de> de::Visitor<'de> { unimplemented!() }\n     |                  ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1956 |         where for<'de> V: de::Visitor<'de> { unimplemented!() }\n     |               ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1955 |         fn deserialize_option<'de, V>(self, _visitor: V) -> Result<Option<V::Value>, Self::Error> \n     |                               ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1958:30\n     |\n1958 |         where V: de::Visitor<'de> { unimplemented!() }\n     |                              ^^^ undeclared lifetime\n     |\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1958 |         where V: for<'de> de::Visitor<'de> { unimplemented!() }\n     |                  ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1958 |         where for<'de> V: de::Visitor<'de> { unimplemented!() }\n     |               ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1957 |         fn deserialize_seq<'de, V>(self, _visitor: V) -> Result<V::Value, Self::Error> \n     |                            ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1960:30\n     |\n1960 |         where V: de::Visitor<'de> { unimplemented!() }\n     |                              ^^^ undeclared lifetime\n     |\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1960 |         where V: for<'de> de::Visitor<'de> { unimplemented!() }\n     |                  ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1960 |         where for<'de> V: de::Visitor<'de> { unimplemented!() }\n     |               ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1959 |         fn deserialize_map<'de, V>(self, _visitor: V) -> Result<V::Value, Self::Error> \n     |                            ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1962:30\n     |\n1962 |         where V: de::Visitor<'de> { unimplemented!() }\n     |                              ^^^ undeclared lifetime\n     |\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1962 |         where V: for<'de> de::Visitor<'de> { unimplemented!() }\n     |                  ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1962 |         where for<'de> V: de::Visitor<'de> { unimplemented!() }\n     |               ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1961 |         fn deserialize_struct<'de, V>(self, _name: &'static str, _visitor: V) -> Result<V::Value, Self::Error> \n     |                               ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nerror[E0261]: use of undeclared lifetime name `'de`\n    --> serde/src/de/value.rs:1969:30\n     |\n1969 |         where V: de::Visitor<'de> { unimplemented!() }\n     |                              ^^^ undeclared lifetime\n     |\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1969 |         where V: for<'de> de::Visitor<'de> { unimplemented!() }\n     |                  ++++++++\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\n     |\n1969 |         where for<'de> V: de::Visitor<'de> { unimplemented!() }\n     |               ++++++++\nhelp: consider introducing lifetime `'de` here\n     |\n1963 |         fn deserialize_enum<'de, V>(\n     |                             ++++\nhelp: consider introducing lifetime `'de` here\n     |\n1918 |     impl<'de> de::Deserializer<'_> for DummyDeserializer {\n     |         +++++\n\nwarning: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1919:22\n     |\n1919 |         type Error = de::Error;\n     |                      ^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by a bound in `de::Deserializer::Error`\n    --> serde/src/de/mod.rs:917:5\n     |\n917  |     type Error: Error;\n     |     ^^^^^^^^^^^^^^^^^^ required by this bound in `Deserializer::Error`\nhelp: consider relaxing the implicit `Sized` restriction\n    -->  serde/src/de/mod.rs:917:22\n     |\n917  |     type Error: Error + ?Sized;\n     |                       ++++++++\n\nerror[E0049]: method `deserialize_bool` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1941:28\n     |\n1941 |         fn deserialize_bool(self) -> Result<bool, Self::Error> { unimplemented!() }\n     |                            ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:933:25\n     |\n933  |     fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                         - expected 1 type parameter\n\nerror[E0049]: method `deserialize_i8` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1942:26\n     |\n1942 |         fn deserialize_i8(self) -> Result<i8, Self::Error> { unimplemented!() }\n     |                          ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:938:23\n     |\n938  |     fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                       - expected 1 type parameter\n\nerror[E0049]: method `deserialize_i16` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1943:27\n     |\n1943 |         fn deserialize_i16(self) -> Result<i16, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:943:24\n     |\n943  |     fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_i32` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1944:27\n     |\n1944 |         fn deserialize_i32(self) -> Result<i32, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:948:24\n     |\n948  |     fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_i64` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1945:27\n     |\n1945 |         fn deserialize_i64(self) -> Result<i64, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:953:24\n     |\n953  |     fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_u8` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1946:26\n     |\n1946 |         fn deserialize_u8(self) -> Result<u8, Self::Error> { unimplemented!() }\n     |                          ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:969:23\n     |\n969  |     fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                       - expected 1 type parameter\n\nerror[E0049]: method `deserialize_u16` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1947:27\n     |\n1947 |         fn deserialize_u16(self) -> Result<u16, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:974:24\n     |\n974  |     fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_u32` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1948:27\n     |\n1948 |         fn deserialize_u32(self) -> Result<u32, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:979:24\n     |\n979  |     fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_u64` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1949:27\n     |\n1949 |         fn deserialize_u64(self) -> Result<u64, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:984:24\n     |\n984  |     fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_f32` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1950:27\n     |\n1950 |         fn deserialize_f32(self) -> Result<f32, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1000:24\n     |\n1000 |     fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_f64` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1951:27\n     |\n1951 |         fn deserialize_f64(self) -> Result<f64, Self::Error> { unimplemented!() }\n     |                           ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1005:24\n     |\n1005 |     fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                        - expected 1 type parameter\n\nerror[E0049]: method `deserialize_char` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1952:28\n     |\n1952 |         fn deserialize_char(self) -> Result<char, Self::Error> { unimplemented!() }\n     |                            ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1010:25\n     |\n1010 |     fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                         - expected 1 type parameter\n\nerror[E0049]: method `deserialize_string` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1953:30\n     |\n1953 |         fn deserialize_string(self) -> Result<String, Self::Error> { unimplemented!() }\n     |                              ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1032:27\n     |\n1032 |     fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                           - expected 1 type parameter\n\nerror[E0049]: method `deserialize_bytes` has 0 type parameters but its trait declaration has 1 type parameter\n    --> serde/src/de/value.rs:1954:29\n     |\n1954 |         fn deserialize_bytes(self) -> Result<&'de [u8], Self::Error> { unimplemented!() }\n     |                             ^ found 0 type parameters\n     |\n    ::: serde/src/de/mod.rs:1043:26\n     |\n1043 |     fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                          - expected 1 type parameter\n\nerror[E0050]: method `deserialize_struct` has 3 parameters but the declaration in trait `de::Deserializer::deserialize_struct` has 4\n    --> serde/src/de/value.rs:1961:34\n     |\n1961 |           fn deserialize_struct<V>(self, _name: &'static str, _visitor: V) -> Result<V::Value, Self::Error> \n     |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 4 parameters, found 3\n     |\n    ::: serde/src/de/mod.rs:1122:9\n     |\n1122 | /         self,\n1123 | |         name: &'static str,\n1124 | |         fields: &'static [&'static str],\n1125 | |         visitor: V,\n     | |__________________- trait requires 4 parameters\n\nerror[E0046]: not all trait items implemented, missing: `deserialize_str`, `deserialize_byte_buf`, `deserialize_unit`, `deserialize_unit_struct`, `deserialize_newtype_struct`, `deserialize_tuple`, `deserialize_tuple_struct`, `deserialize_identifier`, `deserialize_ignored_any`\n    --> serde/src/de/value.rs:1918:5\n     |\n1918 |       impl de::Deserializer<'_> for DummyDeserializer {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `deserialize_str`, `deserialize_byte_buf`, `deserialize_unit`, `deserialize_unit_struct`, `deserialize_newtype_struct`, `deserialize_tuple`, `deserialize_tuple_struct`, `deserialize_identifier`, `deserialize_ignored_any` in implementation\n     |\n    ::: serde/src/de/mod.rs:1021:5\n     |\n1021 | /     fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n1022 | |     where\n1023 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_str` from trait\n...\n1054 | /     fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n1055 | |     where\n1056 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_byte_buf` from trait\n...\n1068 | /     fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n1069 | |     where\n1070 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_unit` from trait\n...\n1074 | /     fn deserialize_unit_struct<V>(\n1075 | |         self,\n1076 | |         name: &'static str,\n1077 | |         visitor: V,\n1078 | |     ) -> Result<V::Value, Self::Error>\n1079 | |     where\n1080 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_unit_struct` from trait\n...\n1084 | /     fn deserialize_newtype_struct<V>(\n1085 | |         self,\n1086 | |         name: &'static str,\n1087 | |         visitor: V,\n1088 | |     ) -> Result<V::Value, Self::Error>\n1089 | |     where\n1090 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_newtype_struct` from trait\n...\n1099 | /     fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n1100 | |     where\n1101 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_tuple` from trait\n...\n1105 | /     fn deserialize_tuple_struct<V>(\n1106 | |         self,\n1107 | |         name: &'static str,\n1108 | |         len: usize,\n...    |\n1111 | |     where\n1112 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_tuple_struct` from trait\n...\n1143 | /     fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n1144 | |     where\n1145 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_identifier` from trait\n...\n1151 | /     fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n1152 | |     where\n1153 | |         V: Visitor<'de>;\n     | |________________________- `deserialize_ignored_any` from trait\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1919:22\n     |\n1919 |         type Error = de::Error;\n     |                      ^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1921:52\n     |\n1921 |         fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1930:64\n     |\n1930 |         fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n     |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1941:38\n     |\n1941 |         fn deserialize_bool(self) -> Result<bool, Self::Error> { unimplemented!() }\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1941:38\n     |\n1941 |         fn deserialize_bool(self) -> Result<bool, Self::Error> { unimplemented!() }\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1942:36\n     |\n1942 |         fn deserialize_i8(self) -> Result<i8, Self::Error> { unimplemented!() }\n     |                                    ^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1942:36\n     |\n1942 |         fn deserialize_i8(self) -> Result<i8, Self::Error> { unimplemented!() }\n     |                                    ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1943:37\n     |\n1943 |         fn deserialize_i16(self) -> Result<i16, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1943:37\n     |\n1943 |         fn deserialize_i16(self) -> Result<i16, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1944:37\n     |\n1944 |         fn deserialize_i32(self) -> Result<i32, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1944:37\n     |\n1944 |         fn deserialize_i32(self) -> Result<i32, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1945:37\n     |\n1945 |         fn deserialize_i64(self) -> Result<i64, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1945:37\n     |\n1945 |         fn deserialize_i64(self) -> Result<i64, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1946:36\n     |\n1946 |         fn deserialize_u8(self) -> Result<u8, Self::Error> { unimplemented!() }\n     |                                    ^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1946:36\n     |\n1946 |         fn deserialize_u8(self) -> Result<u8, Self::Error> { unimplemented!() }\n     |                                    ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1947:37\n     |\n1947 |         fn deserialize_u16(self) -> Result<u16, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1947:37\n     |\n1947 |         fn deserialize_u16(self) -> Result<u16, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1948:37\n     |\n1948 |         fn deserialize_u32(self) -> Result<u32, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1948:37\n     |\n1948 |         fn deserialize_u32(self) -> Result<u32, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1949:37\n     |\n1949 |         fn deserialize_u64(self) -> Result<u64, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1949:37\n     |\n1949 |         fn deserialize_u64(self) -> Result<u64, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1950:37\n     |\n1950 |         fn deserialize_f32(self) -> Result<f32, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1950:37\n     |\n1950 |         fn deserialize_f32(self) -> Result<f32, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1951:37\n     |\n1951 |         fn deserialize_f64(self) -> Result<f64, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1951:37\n     |\n1951 |         fn deserialize_f64(self) -> Result<f64, Self::Error> { unimplemented!() }\n     |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1952:38\n     |\n1952 |         fn deserialize_char(self) -> Result<char, Self::Error> { unimplemented!() }\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1952:38\n     |\n1952 |         fn deserialize_char(self) -> Result<char, Self::Error> { unimplemented!() }\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1953:40\n     |\n1953 |         fn deserialize_string(self) -> Result<String, Self::Error> { unimplemented!() }\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1953:40\n     |\n1953 |         fn deserialize_string(self) -> Result<String, Self::Error> { unimplemented!() }\n     |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1954:39\n     |\n1954 |         fn deserialize_bytes(self) -> Result<&'de [u8], Self::Error> { unimplemented!() }\n     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1954:39\n     |\n1954 |         fn deserialize_bytes(self) -> Result<&'de [u8], Self::Error> { unimplemented!() }\n     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1955:56\n     |\n1955 |         fn deserialize_option<V>(self, _visitor: V) -> Result<Option<V::Value>, Self::Error> \n     |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1955:56\n     |\n1955 |         fn deserialize_option<V>(self, _visitor: V) -> Result<Option<V::Value>, Self::Error> \n     |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1957:53\n     |\n1957 |         fn deserialize_seq<V>(self, _visitor: V) -> Result<V::Value, Self::Error> \n     |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1959:53\n     |\n1959 |         fn deserialize_map<V>(self, _visitor: V) -> Result<V::Value, Self::Error> \n     |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1961:77\n     |\n1961 |         fn deserialize_struct<V>(self, _name: &'static str, _visitor: V) -> Result<V::Value, Self::Error> \n     |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1968:14\n     |\n1968 |         ) -> Result<V::Value, Self::Error>\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1974:17\n     |\n1974 |     let result: Result<(), de::Error> = deserializer.deserialize_any(DummyVisitor);\n     |                 ^^^^^^^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `dyn de::Error` cannot be known at compilation time\n    --> serde/src/de/value.rs:1974:17\n     |\n1974 |     let result: Result<(), de::Error> = deserializer.deserialize_any(DummyVisitor);\n     |                 ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `dyn de::Error`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0038]: the trait `de::Error` cannot be made into an object\n    --> serde/src/de/value.rs:1974:54\n     |\n1974 |     let result: Result<(), de::Error> = deserializer.deserialize_any(DummyVisitor);\n     |                                                      ^^^^^^^^^^^^^^^ `de::Error` cannot be made into an object\n     |\nnote: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n    --> serde/src/de/mod.rs:161:26\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                   -----  ^^^^^ ...because it requires `Self: Sized`\n     |                   |\n     |                   this trait cannot be made into an object...\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = help: only type `de::value::Error` is seen to implement the trait in this crate, consider using it directly instead\n     = note: `de::Error` can be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the size for values of type `(dyn de::Error + 'static)` cannot be known at compilation time\n    --> serde/src/de/value.rs:1974:54\n     |\n1974 |     let result: Result<(), de::Error> = deserializer.deserialize_any(DummyVisitor);\n     |                                                      ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n     |\n     = help: the trait `Sized` is not implemented for `(dyn de::Error + 'static)`\nnote: required by an implicit `Sized` bound in `Result`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:527:20\n     |\n527  | pub enum Result<T, E> {\n     |                    ^ required by the implicit `Sized` requirement on this type parameter in `Result`\n\nerror[E0599]: the method `is_err` exists for enum `Result<(), dyn Error>`, but its trait bounds were not satisfied\n    --> serde/src/de/value.rs:1975:20\n     |\n1975 |     assert!(result.is_err());\n     |                    ^^^^^^ method cannot be called on `Result<(), dyn Error>` due to unsatisfied trait bounds\n     |\n    ::: serde/src/de/mod.rs:161:9\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |         ---------------------------------------- doesn't satisfy `dyn de::Error: Sized`\n     |\n     = note: the following trait bounds were not satisfied:\n             `dyn de::Error: Sized`\n\nerror[E0599]: the method `unwrap_err` exists for enum `Result<(), dyn Error>`, but its trait bounds were not satisfied\n    --> serde/src/de/value.rs:1976:23\n     |\n1976 |     assert_eq!(result.unwrap_err(), de::Error::invalid_type(Unexpected::UnitVariant, &\"tuple variant\"));  \n     |                       ^^^^^^^^^^ method cannot be called on `Result<(), dyn Error>` due to unsatisfied trait bounds\n     |\n    ::: serde/src/de/mod.rs:161:9\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |         ---------------------------------------- doesn't satisfy `dyn de::Error: Sized`\n     |\n     = note: the following trait bounds were not satisfied:\n             `dyn de::Error: Sized`\n\nerror[E0599]: no method named `tuple_variant` found for struct `DummyDeserializer` in the current scope\n    --> serde/src/de/value.rs:1927:18\n     |\n1916 |     struct DummyDeserializer;\n     |     ------------------------ method `tuple_variant` not found for this struct\n...\n1927 |             self.tuple_variant(len, visitor)\n     |                  ^^^^^^^^^^^^^ method not found in `DummyDeserializer`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `de::VariantAccess` defines an item `tuple_variant`, perhaps you need to implement it\n    --> serde/src/de/mod.rs:2031:1\n     |\n2031 | pub trait VariantAccess<'de>: Sized {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0782]: trait objects must include the `dyn` keyword\n    --> serde/src/de/value.rs:1919:22\n     |\n1919 |         type Error = de::Error;\n     |                      ^^^^^^^^^\n     |\nhelp: add `dyn` keyword before this trait\n     |\n1919 |         type Error = dyn de::Error;\n     |                      +++\n\nerror[E0782]: trait objects must include the `dyn` keyword\n    --> serde/src/de/value.rs:1974:28\n     |\n1974 |     let result: Result<(), de::Error> = deserializer.deserialize_any(DummyVisitor);\n     |                            ^^^^^^^^^\n     |\nhelp: add `dyn` keyword before this trait\n     |\n1974 |     let result: Result<(), dyn de::Error> = deserializer.deserialize_any(DummyVisitor);\n     |                            +++\n\nSome errors have detailed explanations: E0038, E0046, E0049, E0050, E0261, E0277, E0407, E0599, E0782.\nFor more information about an error, try `rustc --explain E0038`.\nwarning: `serde` (lib test) generated 1 warning\nerror: could not compile `serde` (lib test) due to 73 previous errors; 1 warning emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}