[
  {
    "uses": [
      "use std::sync::Arc;",
      "use std::sync::Mutex;",
      "use std::thread;"
    ],
    "has_test_mod": false,
    "common": [
      "#[cfg(test)]",
      "fn test_get_or_init_valid() {",
      "    struct TestData {",
      "        value: i32,",
      "    }",
      "    ",
      "    let once_ref: OnceRef<TestData> = OnceRef::new();",
      "    ",
      "    let result = once_ref.get_or_init(|| {",
      "        let data = TestData { value: 42 };",
      "        &data",
      "    });",
      "}",
      "",
      "#[cfg(test)]",
      "fn test_get_or_init_non_null() {",
      "    struct TestData {",
      "        value: i32,",
      "    }",
      "",
      "    let once_ref: OnceRef<TestData> = OnceRef::new();",
      "    ",
      "    let result = once_ref.get_or_init(|| {",
      "        static DATA: TestData = TestData { value: 99 };",
      "        &DATA",
      "    });",
      "}",
      "",
      "#[cfg(test)]",
      "fn test_get_or_init_multiple_threads() {",
      "",
      "    struct TestData {",
      "        value: i32,",
      "    }",
      "",
      "    let once_ref: Arc<OnceRef<TestData>> = Arc::new(OnceRef::new());",
      "    let results = Arc::new(Mutex::new(Vec::new()));",
      "",
      "    let mut handles = vec![];",
      "",
      "    for _ in 0..10 {",
      "        let once_ref_clone = Arc::clone(&once_ref);",
      "        let results_clone = Arc::clone(&results);",
      "        let handle = thread::spawn(move || {",
      "            let result = once_ref_clone.get_or_init(|| {",
      "                let data = TestData { value: 1 };",
      "                &data",
      "            });",
      "            results_clone.lock().unwrap().push(result.value);",
      "        });",
      "        handles.push(handle);",
      "    }",
      "",
      "    for handle in handles {",
      "        handle.join().unwrap();",
      "    }",
      "}",
      "",
      "#[cfg(test)]",
      "fn test_get_or_init_memory_safety() {",
      "    struct TestData {",
      "        value: i32,",
      "    }",
      "",
      "    let once_ref: OnceRef<TestData> = OnceRef::new();",
      "    ",
      "    let result = once_ref.get_or_init(|| {",
      "        let data = Box::new(TestData { value: 72 });",
      "        &*data // Box is valid and won't cause allocation failure in this context",
      "    });",
      "}",
      "",
      "#[cfg(test)]",
      "fn test_get_or_init_void_return() {",
      "    struct TestData {",
      "        value: i32,",
      "    }",
      "",
      "    let once_ref: OnceRef<TestData> = OnceRef::new();",
      "    ",
      "    let result = once_ref.get_or_init(|| {",
      "        panic!(\"This should not panic, as it is valid input for get_or_init.\")",
      "    });",
      "}"
    ],
    "chain_tests": []
  }
]