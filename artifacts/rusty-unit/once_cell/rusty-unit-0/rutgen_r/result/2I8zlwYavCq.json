{
    "function_name": "once_cell::race::race::OnceRef<'a, T>::compare_exchange",
    "file_path": "/home/abezbm/rusty-unit/evaluation/once_cell/rusty-unit-0/src/race.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/once_cell",
    "tests": 3,
    "tests_lines": [
        35,
        36,
        34
    ],
    "oracles": 3,
    "oracles_compiled": 3,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 3,
    "tests_compiled_rate": 100.0,
    "oracles_run": 3,
    "oracles_passed": 2,
    "oracles_passed_rate": 66.66666666666666,
    "tests_run": 3,
    "tests_passed": 2,
    "tests_passed_rate": 66.66666666666666,
    "lines": 11,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        320,
        321,
        322,
        323,
        324,
        325,
        326,
        327,
        328,
        329,
        330
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    use std::sync::{Arc, Mutex};",
                "    use std::ptr;",
                "    use std::sync::atomic::{AtomicPtr, Ordering};",
                "",
                "    struct Inner {",
                "        inner: AtomicPtr<i32>,",
                "    }",
                "",
                "    impl Inner {",
                "        fn new() -> Self {",
                "            Inner {",
                "                inner: AtomicPtr::new(ptr::null_mut()),",
                "            }",
                "        }",
                "",
                "        fn compare_exchange(&self, value: *const i32) -> Result<(), *const i32> {",
                "            self.inner",
                "                .compare_exchange(",
                "                    ptr::null_mut(),",
                "                    value as *mut i32,",
                "                    Ordering::Release,",
                "                    Ordering::Acquire,",
                "                )",
                "                .map(|_: *mut i32| ())",
                "                .map_err(|err| err as *const i32)",
                "        }",
                "    }",
                "",
                "    let inner = Inner::new();",
                "    let value: i32 = 42;",
                "    let value_ptr: *const i32 = &value;",
                "",
                "    assert!(inner.compare_exchange(value_ptr).is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ptr;",
                "    use std::sync::atomic::{AtomicPtr, Ordering};",
                "",
                "    struct Inner {",
                "        inner: AtomicPtr<i32>,",
                "    }",
                "",
                "    impl Inner {",
                "        fn new() -> Self {",
                "            Inner {",
                "                inner: AtomicPtr::new(ptr::null_mut()),",
                "            }",
                "        }",
                "",
                "        fn compare_exchange(&self, value: *const i32) -> Result<(), *const i32> {",
                "            self.inner",
                "                .compare_exchange(",
                "                    ptr::null_mut(),",
                "                    value as *mut i32,",
                "                    Ordering::Release,",
                "                    Ordering::Acquire,",
                "                )",
                "                .map(|_: *mut i32| ())",
                "                .map_err(|err| err as *const i32)",
                "        }",
                "    }",
                "",
                "    let inner = Inner::new();",
                "    let value: i32 = 42;",
                "    let value_ptr: *const i32 = &value;",
                "",
                "    inner.compare_exchange(value_ptr).unwrap();",
                "",
                "    assert_eq!(inner.compare_exchange(value_ptr).is_err(), true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ptr;",
                "    use std::sync::atomic::{AtomicPtr, Ordering};",
                "",
                "    struct Inner {",
                "        inner: AtomicPtr<i32>,",
                "    }",
                "",
                "    impl Inner {",
                "        fn new() -> Self {",
                "            Inner {",
                "                inner: AtomicPtr::new(ptr::null_mut()),",
                "            }",
                "        }",
                "",
                "        fn compare_exchange(&self, value: *const i32) -> Result<(), *const i32> {",
                "            self.inner",
                "                .compare_exchange(",
                "                    ptr::null_mut(),",
                "                    value as *mut i32,",
                "                    Ordering::Release,",
                "                    Ordering::Acquire,",
                "                )",
                "                .map(|_: *mut i32| ())",
                "                .map_err(|err| err as *const i32)",
                "        }",
                "    }",
                "",
                "    let inner = Inner::new();",
                "",
                "    // This should cause a panic because we're passing a dangling pointer",
                "    let value_ptr: *const i32 = ptr::null();",
                "    inner.compare_exchange(value_ptr).unwrap();",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    use std::sync::{Arc, Mutex};",
                "    use std::ptr;",
                "    use std::sync::atomic::{AtomicPtr, Ordering};",
                "",
                "    struct Inner {",
                "        inner: AtomicPtr<i32>,",
                "    }",
                "",
                "    impl Inner {",
                "        fn new() -> Self {",
                "            Inner {",
                "                inner: AtomicPtr::new(ptr::null_mut()),",
                "            }",
                "        }",
                "",
                "        fn compare_exchange(&self, value: *const i32) -> Result<(), *const i32> {",
                "            self.inner",
                "                .compare_exchange(",
                "                    ptr::null_mut(),",
                "                    value as *mut i32,",
                "                    Ordering::Release,",
                "                    Ordering::Acquire,",
                "                )",
                "                .map(|_: *mut i32| ())",
                "                .map_err(|err| err as *const i32)",
                "        }",
                "    }",
                "",
                "    let inner = Inner::new();",
                "    let value: i32 = 42;",
                "    let value_ptr: *const i32 = &value;",
                "",
                "    assert!(inner.compare_exchange(value_ptr).is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ptr;",
                "    use std::sync::atomic::{AtomicPtr, Ordering};",
                "",
                "    struct Inner {",
                "        inner: AtomicPtr<i32>,",
                "    }",
                "",
                "    impl Inner {",
                "        fn new() -> Self {",
                "            Inner {",
                "                inner: AtomicPtr::new(ptr::null_mut()),",
                "            }",
                "        }",
                "",
                "        fn compare_exchange(&self, value: *const i32) -> Result<(), *const i32> {",
                "            self.inner",
                "                .compare_exchange(",
                "                    ptr::null_mut(),",
                "                    value as *mut i32,",
                "                    Ordering::Release,",
                "                    Ordering::Acquire,",
                "                )",
                "                .map(|_: *mut i32| ())",
                "                .map_err(|err| err as *const i32)",
                "        }",
                "    }",
                "",
                "    let inner = Inner::new();",
                "    let value: i32 = 42;",
                "    let value_ptr: *const i32 = &value;",
                "",
                "    inner.compare_exchange(value_ptr).unwrap();",
                "",
                "    assert_eq!(inner.compare_exchange(value_ptr).is_err(), true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::ptr;",
                "    use std::sync::atomic::{AtomicPtr, Ordering};",
                "",
                "    struct Inner {",
                "        inner: AtomicPtr<i32>,",
                "    }",
                "",
                "    impl Inner {",
                "        fn new() -> Self {",
                "            Inner {",
                "                inner: AtomicPtr::new(ptr::null_mut()),",
                "            }",
                "        }",
                "",
                "        fn compare_exchange(&self, value: *const i32) -> Result<(), *const i32> {",
                "            self.inner",
                "                .compare_exchange(",
                "                    ptr::null_mut(),",
                "                    value as *mut i32,",
                "                    Ordering::Release,",
                "                    Ordering::Acquire,",
                "                )",
                "                .map(|_: *mut i32| ())",
                "                .map_err(|err| err as *const i32)",
                "        }",
                "    }",
                "",
                "    let inner = Inner::new();",
                "",
                "    // This should cause a panic because we're passing a dangling pointer",
                "    let value_ptr: *const i32 = ptr::null();",
                "    inner.compare_exchange(value_ptr).unwrap();",
                "}"
            ],
            []
        ]
    ]
}