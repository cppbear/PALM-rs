{
    "function_name": "hashbrown::raw::raw::RawTable<T, A>::remove_entry",
    "tests": 2,
    "tests_lines": [
        47,
        46
    ],
    "oracles": 2,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 100.0,
    "oracles_run": 2,
    "oracles_passed": 2,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 6,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        894,
        895,
        896,
        897,
        898,
        900
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct Dummy {",
                "        value: i32,",
                "    }",
                "",
                "    struct DummyTable {",
                "        entries: Vec<Dummy>,",
                "    }",
                "",
                "    impl DummyTable {",
                "        fn new() -> Self {",
                "            DummyTable { entries: Vec::new() }",
                "        }",
                "",
                "        fn insert(&mut self, hash: u64, value: i32) {",
                "            self.entries.push(Dummy { value });",
                "        }",
                "",
                "        fn find<F>(&self, hash: u64, mut eq: F) -> Option<usize>",
                "        where",
                "            F: FnMut(&Dummy) -> bool,",
                "        {",
                "            self.entries.iter().position(|entry| eq(entry))",
                "        }",
                "",
                "        unsafe fn remove(&mut self, index: usize) -> (Dummy, usize) {",
                "            let entry = self.entries.remove(index);",
                "            (entry, index)",
                "        }",
                "",
                "        pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&Dummy) -> bool) -> Option<Dummy> {",
                "            match self.find(hash, eq) {",
                "                Some(bucket) => Some(unsafe { self.remove(bucket).0 }),",
                "                None => None,",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut table = DummyTable::new();",
                "    table.insert(1, 42);",
                "    table.insert(2, 100);",
                "    ",
                "    let removed_entry = table.remove_entry(1, |e| e.value == 42);",
                "    ",
                "    assert!(removed_entry.is_some());",
                "    assert_eq!(removed_entry.unwrap().value, 42);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Dummy {",
                "        value: i32,",
                "    }",
                "",
                "    struct DummyTable {",
                "        entries: Vec<Dummy>,",
                "    }",
                "",
                "    impl DummyTable {",
                "        fn new() -> Self {",
                "            DummyTable { entries: Vec::new() }",
                "        }",
                "",
                "        fn insert(&mut self, hash: u64, value: i32) {",
                "            self.entries.push(Dummy { value });",
                "        }",
                "",
                "        fn find<F>(&self, hash: u64, mut eq: F) -> Option<usize>",
                "        where",
                "            F: FnMut(&Dummy) -> bool,",
                "        {",
                "            self.entries.iter().position(|entry| eq(entry))",
                "        }",
                "",
                "        unsafe fn remove(&mut self, index: usize) -> (Dummy, usize) {",
                "            let entry = self.entries.remove(index);",
                "            (entry, index)",
                "        }",
                "",
                "        pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&Dummy) -> bool) -> Option<Dummy> {",
                "            match self.find(hash, eq) {",
                "                Some(bucket) => Some(unsafe { self.remove(bucket).0 }),",
                "                None => None,",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut table = DummyTable::new();",
                "    table.insert(1, 42);",
                "    table.insert(2, 100);",
                "    ",
                "    let removed_entry = table.remove_entry(3, |e| e.value == 200);",
                "    ",
                "    assert!(removed_entry.is_none());",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct Dummy {",
                "        value: i32,",
                "    }",
                "",
                "    struct DummyTable {",
                "        entries: Vec<Dummy>,",
                "    }",
                "",
                "    impl DummyTable {",
                "        fn new() -> Self {",
                "            DummyTable { entries: Vec::new() }",
                "        }",
                "",
                "        fn insert(&mut self, hash: u64, value: i32) {",
                "            self.entries.push(Dummy { value });",
                "        }",
                "",
                "        fn find<F>(&self, hash: u64, mut eq: F) -> Option<usize>",
                "        where",
                "            F: FnMut(&Dummy) -> bool,",
                "        {",
                "            self.entries.iter().position(|entry| eq(entry))",
                "        }",
                "",
                "        unsafe fn remove(&mut self, index: usize) -> (Dummy, usize) {",
                "            let entry = self.entries.remove(index);",
                "            (entry, index)",
                "        }",
                "",
                "        pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&Dummy) -> bool) -> Option<Dummy> {",
                "            match self.find(hash, eq) {",
                "                Some(bucket) => Some(unsafe { self.remove(bucket).0 }),",
                "                None => None,",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut table = DummyTable::new();",
                "    table.insert(1, 42);",
                "    table.insert(2, 100);",
                "    ",
                "    let removed_entry = table.remove_entry(1, |e| e.value == 42);",
                "    ",
                "    assert!(removed_entry.is_some());",
                "    assert_eq!(removed_entry.unwrap().value, 42);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Dummy {",
                "        value: i32,",
                "    }",
                "",
                "    struct DummyTable {",
                "        entries: Vec<Dummy>,",
                "    }",
                "",
                "    impl DummyTable {",
                "        fn new() -> Self {",
                "            DummyTable { entries: Vec::new() }",
                "        }",
                "",
                "        fn insert(&mut self, hash: u64, value: i32) {",
                "            self.entries.push(Dummy { value });",
                "        }",
                "",
                "        fn find<F>(&self, hash: u64, mut eq: F) -> Option<usize>",
                "        where",
                "            F: FnMut(&Dummy) -> bool,",
                "        {",
                "            self.entries.iter().position(|entry| eq(entry))",
                "        }",
                "",
                "        unsafe fn remove(&mut self, index: usize) -> (Dummy, usize) {",
                "            let entry = self.entries.remove(index);",
                "            (entry, index)",
                "        }",
                "",
                "        pub fn remove_entry(&mut self, hash: u64, eq: impl FnMut(&Dummy) -> bool) -> Option<Dummy> {",
                "            match self.find(hash, eq) {",
                "                Some(bucket) => Some(unsafe { self.remove(bucket).0 }),",
                "                None => None,",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut table = DummyTable::new();",
                "    table.insert(1, 42);",
                "    table.insert(2, 100);",
                "    ",
                "    let removed_entry = table.remove_entry(3, |e| e.value == 200);",
                "    ",
                "    assert!(removed_entry.is_none());",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/hashbrown/rusty-unit-0/src/raw/mod.rs"
}