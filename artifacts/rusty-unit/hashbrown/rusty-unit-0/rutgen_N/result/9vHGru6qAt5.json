{
    "function_name": "hashbrown::raw::raw::RawTableInner::clear_no_drop",
    "tests": 2,
    "tests_lines": [
        49,
        47
    ],
    "oracles": 2,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 100.0,
    "oracles_run": 2,
    "oracles_passed": 1,
    "oracles_passed_rate": 50.0,
    "tests_run": 2,
    "tests_passed": 1,
    "tests_passed_rate": 50.0,
    "lines": 10,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 2,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        3112,
        3113,
        3114,
        3115,
        3116,
        3117,
        3118,
        3119,
        3120,
        3121
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct TestTable {",
                "        items: usize,",
                "        growth_left: usize,",
                "        bucket_mask: usize,",
                "    }",
                "",
                "    impl TestTable {",
                "        fn is_empty_singleton(&self) -> bool {",
                "            self.items == 0 && self.growth_left == 0",
                "        }",
                "",
                "        unsafe fn ctrl(&self, _index: usize) -> *mut u8 {",
                "            // Returning a dummy pointer for illustration.",
                "            std::ptr::null_mut()",
                "        }",
                "",
                "        fn num_ctrl_bytes(&self) -> usize {",
                "            // Returning a fixed size for illustration.",
                "            4",
                "        }",
                "",
                "        fn clear_no_drop(&mut self) {",
                "            if !self.is_empty_singleton() {",
                "                unsafe {",
                "                    self.ctrl(0)",
                "                        .write_bytes(0, self.num_ctrl_bytes());",
                "                }",
                "            }",
                "            self.items = 0;",
                "            self.growth_left = bucket_mask_to_capacity(self.bucket_mask);",
                "        }",
                "    }",
                "",
                "    fn bucket_mask_to_capacity(mask: usize) -> usize {",
                "        mask.count_ones() as usize",
                "    }",
                "",
                "    let mut table = TestTable {",
                "        items: 5,",
                "        growth_left: 3,",
                "        bucket_mask: 0b111,",
                "    };",
                "",
                "    table.clear_no_drop();",
                "",
                "    assert_eq!(table.items, 0);",
                "    assert_eq!(table.growth_left, bucket_mask_to_capacity(table.bucket_mask));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestTable {",
                "        items: usize,",
                "        growth_left: usize,",
                "        bucket_mask: usize,",
                "    }",
                "",
                "    impl TestTable {",
                "        fn is_empty_singleton(&self) -> bool {",
                "            self.items == 0 && self.growth_left == 0",
                "        }",
                "",
                "        unsafe fn ctrl(&self, _index: usize) -> *mut u8 {",
                "            std::ptr::null_mut()",
                "        }",
                "",
                "        fn num_ctrl_bytes(&self) -> usize {",
                "            4",
                "        }",
                "",
                "        fn clear_no_drop(&mut self) {",
                "            if !self.is_empty_singleton() {",
                "                unsafe {",
                "                    self.ctrl(0)",
                "                        .write_bytes(0, self.num_ctrl_bytes());",
                "                }",
                "            }",
                "            self.items = 0;",
                "            self.growth_left = bucket_mask_to_capacity(self.bucket_mask);",
                "        }",
                "    }",
                "",
                "    fn bucket_mask_to_capacity(mask: usize) -> usize {",
                "        mask.count_ones() as usize",
                "    }",
                "",
                "    let mut table = TestTable {",
                "        items: 0,",
                "        growth_left: 0,",
                "        bucket_mask: 0b111,",
                "    };",
                "",
                "    table.clear_no_drop();",
                "",
                "    assert_eq!(table.items, 0);",
                "    assert_eq!(table.growth_left, bucket_mask_to_capacity(table.bucket_mask));",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 3113,
            "start_column": 12,
            "end_line": 3113,
            "end_column": 38,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct TestTable {",
                "        items: usize,",
                "        growth_left: usize,",
                "        bucket_mask: usize,",
                "    }",
                "",
                "    impl TestTable {",
                "        fn is_empty_singleton(&self) -> bool {",
                "            self.items == 0 && self.growth_left == 0",
                "        }",
                "",
                "        unsafe fn ctrl(&self, _index: usize) -> *mut u8 {",
                "            // Returning a dummy pointer for illustration.",
                "            std::ptr::null_mut()",
                "        }",
                "",
                "        fn num_ctrl_bytes(&self) -> usize {",
                "            // Returning a fixed size for illustration.",
                "            4",
                "        }",
                "",
                "        fn clear_no_drop(&mut self) {",
                "            if !self.is_empty_singleton() {",
                "                unsafe {",
                "                    self.ctrl(0)",
                "                        .write_bytes(0, self.num_ctrl_bytes());",
                "                }",
                "            }",
                "            self.items = 0;",
                "            self.growth_left = bucket_mask_to_capacity(self.bucket_mask);",
                "        }",
                "    }",
                "",
                "    fn bucket_mask_to_capacity(mask: usize) -> usize {",
                "        mask.count_ones() as usize",
                "    }",
                "",
                "    let mut table = TestTable {",
                "        items: 5,",
                "        growth_left: 3,",
                "        bucket_mask: 0b111,",
                "    };",
                "",
                "    table.clear_no_drop();",
                "",
                "    assert_eq!(table.items, 0);",
                "    assert_eq!(table.growth_left, bucket_mask_to_capacity(table.bucket_mask));",
                "}"
            ],
            [
                {
                    "start_line": 3113,
                    "start_column": 12,
                    "end_line": 3113,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestTable {",
                "        items: usize,",
                "        growth_left: usize,",
                "        bucket_mask: usize,",
                "    }",
                "",
                "    impl TestTable {",
                "        fn is_empty_singleton(&self) -> bool {",
                "            self.items == 0 && self.growth_left == 0",
                "        }",
                "",
                "        unsafe fn ctrl(&self, _index: usize) -> *mut u8 {",
                "            std::ptr::null_mut()",
                "        }",
                "",
                "        fn num_ctrl_bytes(&self) -> usize {",
                "            4",
                "        }",
                "",
                "        fn clear_no_drop(&mut self) {",
                "            if !self.is_empty_singleton() {",
                "                unsafe {",
                "                    self.ctrl(0)",
                "                        .write_bytes(0, self.num_ctrl_bytes());",
                "                }",
                "            }",
                "            self.items = 0;",
                "            self.growth_left = bucket_mask_to_capacity(self.bucket_mask);",
                "        }",
                "    }",
                "",
                "    fn bucket_mask_to_capacity(mask: usize) -> usize {",
                "        mask.count_ones() as usize",
                "    }",
                "",
                "    let mut table = TestTable {",
                "        items: 0,",
                "        growth_left: 0,",
                "        bucket_mask: 0b111,",
                "    };",
                "",
                "    table.clear_no_drop();",
                "",
                "    assert_eq!(table.items, 0);",
                "    assert_eq!(table.growth_left, bucket_mask_to_capacity(table.bucket_mask));",
                "}"
            ],
            [
                {
                    "start_line": 3113,
                    "start_column": 12,
                    "end_line": 3113,
                    "end_column": 38,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/hashbrown/rusty-unit-0/src/raw/mod.rs"
}