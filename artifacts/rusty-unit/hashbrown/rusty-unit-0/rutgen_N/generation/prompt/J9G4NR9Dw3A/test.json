{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/raw/mod.rs\n// crate name is hashbrown\nThe function to be tested is presented as follows:\n/// Attempts to allocate a new hash table with at least enough capacity\n/// for inserting the given number of elements without reallocating,\n/// and return it inside `ScopeGuard` to protect against panic in the hash\n/// function.\n///\n/// # Note\n///\n/// It is recommended (but not required):\n///\n/// * That the new table's `capacity` be greater than or equal to `self.items`.\n///\n/// * The `alloc` is the same [`Allocator`] as the `Allocator` used\n///   to allocate this table.\n///\n/// * The `table_layout` is the same [`TableLayout`] as the `TableLayout` used\n///   to allocate this table.\n///\n/// If `table_layout` does not match the `TableLayout` that was used to allocate\n/// this table, then using `mem::swap` with the `self` and the new table returned\n/// by this function results in [`undefined behavior`].\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\nfn prepare_resize<'a, A>(\n    &self,\n    alloc: &'a A,\n    table_layout: TableLayout,\n    capacity: usize,\n    fallibility: Fallibility,\n) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self) + 'a>, TryReserveError>\nwhere\n    A: Allocator,\n{\n    debug_assert!(self.items <= capacity);\n\n    // Allocate and initialize the new table.\n    let new_table =\n        RawTableInner::fallible_with_capacity(alloc, table_layout, capacity, fallibility)?;\n\n    // The hash function may panic, in which case we simply free the new\n    // table without dropping any elements that may have been copied into\n    // it.\n    //\n    // This guard is also used to free the old table on success, see\n    // the comment at the bottom of this function.\n    Ok(guard(new_table, move |self_| {\n        if !self_.is_empty_singleton() {\n            // SAFETY:\n            // 1. We have checked that our table is allocated.\n            // 2. We know for sure that the `alloc` and `table_layout` matches the\n            //    [`Allocator`] and [`TableLayout`] used to allocate this table.\n            unsafe { self_.free_buckets(alloc, table_layout) };\n        }\n    }))\n}\n",
  "depend_pt": ""
}