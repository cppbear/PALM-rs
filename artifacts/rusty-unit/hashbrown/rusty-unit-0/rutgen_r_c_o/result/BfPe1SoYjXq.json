{
    "function_name": "hashbrown::raw::raw::RawIterRange<T>::new",
    "tests": 40,
    "tests_lines": [
        14,
        14,
        14,
        16,
        16,
        16,
        14,
        14,
        12,
        13,
        13,
        13,
        13,
        13,
        13,
        14,
        14,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        17,
        17,
        17,
        17,
        21,
        21,
        22,
        25,
        26,
        26,
        26,
        28,
        28,
        22,
        27,
        24
    ],
    "oracles": 16,
    "oracles_compiled": 3,
    "oracles_compiled_rate": 18.75,
    "tests_compiled": 12,
    "tests_compiled_rate": 30.0,
    "oracles_run": 3,
    "oracles_passed": 2,
    "oracles_passed_rate": 66.66666666666666,
    "tests_run": 12,
    "tests_passed": 9,
    "tests_passed_rate": 75.0,
    "lines": 17,
    "lines_covered": 17,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        3492,
        3493,
        3494,
        3496,
        3497,
        3498,
        3499,
        3500,
        3501,
        3502,
        3503,
        3504,
        3505,
        3506,
        3507,
        3508,
        3509
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let len = 4; // A power of two",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 4;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(ctrl as usize % Group::WIDTH == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 4; // A power of two",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 4;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(len > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 4; // A power of two",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 4;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(std::ptr::eq(bucket.ptr.as_ptr(), ctrl));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 0; // Zero length",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 0;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert_eq!(len, 0);",
                "}"
            ],
            [
                3492,
                3493
            ]
        ],
        [
            [
                "{",
                "    let len = 0; // Zero length",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 0;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(ctrl as usize % Group::WIDTH == 0);",
                "}"
            ],
            [
                3492,
                3493
            ]
        ],
        [
            [
                "{",
                "    let len = 0; // Zero length",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 0;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(bucket.ptr.as_ptr() != ptr::null_mut());",
                "}"
            ],
            [
                3492,
                3493
            ]
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    assert!(layout.size() == 64);",
                "}"
            ],
            [
                3492,
                3493,
                3494,
                3496,
                3497,
                3498,
                3499,
                3500,
                3501,
                3502,
                3503,
                3504,
                3505,
                3506,
                3507,
                3508,
                3509
            ]
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    assert!(layout.align() == 8);",
                "}"
            ],
            [
                3492,
                3493,
                3494,
                3496,
                3497,
                3498,
                3499,
                3500,
                3501,
                3502,
                3503,
                3504,
                3505,
                3506,
                3507,
                3508,
                3509
            ]
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    assert!(!ctrl_ptr.is_null());",
                "}"
            ],
            [
                3492,
                3493,
                3494,
                3496,
                3497,
                3498,
                3499,
                3500,
                3501,
                3502,
                3503,
                3504,
                3505,
                3506,
                3507,
                3508,
                3509
            ]
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    let bucket = Bucket {",
                "    ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "    assert_eq!(bucket.ptr.as_ptr(), ctrl_ptr);",
                "}"
            ],
            [
                3492,
                3493,
                3494,
                3496,
                3497,
                3498,
                3499,
                3500,
                3501,
                3502,
                3503,
                3504,
                3505,
                3506,
                3507,
                3508,
                3509
            ]
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    let bucket = Bucket {",
                "    ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "    let len = 4;",
                "    assert!(len > 0);",
                "}"
            ],
            [
                3492,
                3493,
                3494,
                3496,
                3497,
                3498,
                3499,
                3500,
                3501,
                3502,
                3503,
                3504,
                3505,
                3506,
                3507,
                3508,
                3509
            ]
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    let bucket = Bucket {",
                "    ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "    let len = 4;",
                "    assert!(len <= 64 / 8); // number of table buckets, assuming 8 bytes per bucket",
                "}"
            ],
            [
                3492,
                3493,
                3494,
                3496,
                3497,
                3498,
                3499,
                3500,
                3501,
                3502,
                3503,
                3504,
                3505,
                3506,
                3507,
                3508,
                3509
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let len = 4; // A power of two",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 4;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(ctrl as usize % Group::WIDTH == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 4; // A power of two",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 4;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(len > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 4; // A power of two",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 4;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(std::ptr::eq(bucket.ptr.as_ptr(), ctrl));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 0; // Zero length",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 0;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert_eq!(len, 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 0; // Zero length",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 0;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(ctrl as usize % Group::WIDTH == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let len = 0; // Zero length",
                "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
                "",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
                "    }",
                "    let len = 0;",
                "    let ctrl: *const u8 = 0x1000 as *const u8;",
                "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
                "    assert!(bucket.ptr.as_ptr() != ptr::null_mut());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    assert!(layout.size() == 64);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    assert!(layout.align() == 8);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    assert!(!ctrl_ptr.is_null());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    let bucket = Bucket {",
                "    ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "    assert_eq!(bucket.ptr.as_ptr(), ctrl_ptr);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    let bucket = Bucket {",
                "    ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "    let len = 4;",
                "    assert!(len > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::alloc::{alloc, dealloc, Layout};",
                "",
                "    let layout = Layout::from_size_align(64, 8).unwrap(); // Allocate 64 bytes aligned for control bytes",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "",
                "    let bucket = Bucket {",
                "        ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "",
                "    let len = 4; // Power of two, valid length",
                "    unsafe {",
                "        let iter_range = RawIterRange::new(ctrl_ptr, bucket, len);",
                "    }",
                "",
                "    unsafe {",
                "        dealloc(ctrl_ptr, layout);",
                "    }",
                "    let layout = Layout::from_size_align(64, 8).unwrap();",
                "    let ctrl_ptr = unsafe { alloc(layout) };",
                "    let bucket = Bucket {",
                "    ptr: NonNull::new(ctrl_ptr as *mut u8).unwrap(),",
                "    };",
                "    let len = 4;",
                "    assert!(len <= 64 / 8); // number of table buckets, assuming 8 bytes per bucket",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/hashbrown/rusty-unit-0/src/raw/mod.rs"
}