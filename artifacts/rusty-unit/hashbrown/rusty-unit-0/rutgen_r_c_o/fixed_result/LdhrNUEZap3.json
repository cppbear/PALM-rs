{
    "function_name": "hashbrown::raw::raw::RawIterRange<T>::fold_impl",
    "file_path": "/home/abezbm/rusty-unit/evaluation/hashbrown/rusty-unit-0/src/raw/mod.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/hashbrown",
    "tests": 51,
    "tests_lines": [
        27,
        27,
        27,
        26,
        26,
        25,
        25,
        25,
        25,
        30,
        30,
        30,
        30,
        26,
        10,
        12,
        12,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        12,
        34,
        34,
        34,
        34,
        34,
        32,
        32,
        32,
        32,
        35,
        34,
        22,
        22,
        22,
        22,
        23,
        23,
        23,
        21,
        21,
        22,
        22,
        22,
        22,
        22,
        25
    ],
    "oracles": 17,
    "oracles_compiled": 5,
    "oracles_compiled_rate": 29.411764705882355,
    "tests_compiled": 6,
    "tests_compiled_rate": 11.76470588235294,
    "oracles_run": 5,
    "oracles_passed": 0,
    "oracles_passed_rate": 0.0,
    "tests_run": 6,
    "tests_passed": 0,
    "tests_passed_rate": 0.0,
    "lines": 47,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 4,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        3609,
        3610,
        3611,
        3612,
        3614,
        3617,
        3618,
        3619,
        3620,
        3623,
        3624,
        3625,
        3626,
        3627,
        3628,
        3629,
        3630,
        3631,
        3632,
        3633,
        3634,
        3635,
        3636,
        3637,
        3638,
        3639,
        3640,
        3641,
        3642,
        3643,
        3644,
        3645,
        3646,
        3647,
        3648,
        3649,
        3650,
        3651,
        3652,
        3653,
        3654,
        3655,
        3656,
        3657,
        3658,
        3659,
        3661
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let bucket = Bucket::<i32> { ptr: NonNull::dangling() };",
                "    let ctrl: *const u8 = std::ptr::null();",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 0) };",
                "    let result = unsafe { iter_range.fold_impl(0, 0, |acc, _| acc + 1) };",
                "    let bucket = Bucket::<i32> { ptr: NonNull::dangling() };",
                "    let ctrl: *const u8 = std::ptr::null();",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 0) };",
                "    assert_eq!(result, 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    let result = unsafe { iter_range.fold_impl(1, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    assert_eq!(iter_range.current_group.next().is_some(), true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    let result = unsafe { iter_range.fold_impl(1, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    let result = unsafe { iter_range.fold_impl(1, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    assert_eq!(result, 42);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let values = [1, 2, 3, 4, 5];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 5) };",
                "    let result = unsafe { iter_range.fold_impl(5, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let values = [1, 2, 3, 4, 5];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 5) };",
                "    let result = unsafe { iter_range.fold_impl(5, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    assert_eq!(result, 15);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let values = [1, 2, 3, 4]; // Assuming `Group::WIDTH` is 4 for this test",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 4) };",
                "    let result = unsafe { iter_range.fold_impl(4, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let values = [1, 2, 3, 4];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 4) };",
                "    let result = unsafe { iter_range.fold_impl(4, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    assert_eq!(result, 10);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let values = [1, 2, 3]; // n is set to 4 but we only have 3 elements",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 3) };",
                "    let result = unsafe { iter_range.fold_impl(4, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let values = [1, 2, 3];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 3) };",
                "    assert_eq!(result, 6);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 3614,
            "start_column": 23,
            "end_line": 3614,
            "end_column": 34,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 3623,
            "start_column": 16,
            "end_line": 3623,
            "end_column": 22,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let bucket = Bucket::<i32> { ptr: NonNull::dangling() };",
                "    let ctrl: *const u8 = std::ptr::null();",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 0) };",
                "    let result = unsafe { iter_range.fold_impl(0, 0, |acc, _| acc + 1) };",
                "    let bucket = Bucket::<i32> { ptr: NonNull::dangling() };",
                "    let ctrl: *const u8 = std::ptr::null();",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 0) };",
                "    assert_eq!(result, 0);",
                "}"
            ],
            [
                {
                    "start_line": 3614,
                    "start_column": 23,
                    "end_line": 3614,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 3623,
                    "start_column": 16,
                    "end_line": 3623,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    let result = unsafe { iter_range.fold_impl(1, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    assert_eq!(iter_range.current_group.next().is_some(), true);",
                "}"
            ],
            [
                {
                    "start_line": 3614,
                    "start_column": 23,
                    "end_line": 3614,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 3623,
                    "start_column": 16,
                    "end_line": 3623,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    let result = unsafe { iter_range.fold_impl(1, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let value = 42;",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(&value as *const _ as *mut _).unwrap() };",
                "    let ctrl: *const u8 = &value as *const _ as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 1) };",
                "    let result = unsafe { iter_range.fold_impl(1, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    assert_eq!(result, 42);",
                "}"
            ],
            [
                {
                    "start_line": 3614,
                    "start_column": 23,
                    "end_line": 3614,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 3623,
                    "start_column": 16,
                    "end_line": 3623,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let values = [1, 2, 3, 4, 5];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 5) };",
                "    let result = unsafe { iter_range.fold_impl(5, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let values = [1, 2, 3, 4, 5];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 5) };",
                "    let result = unsafe { iter_range.fold_impl(5, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    assert_eq!(result, 15);",
                "}"
            ],
            [
                {
                    "start_line": 3614,
                    "start_column": 23,
                    "end_line": 3614,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 3623,
                    "start_column": 16,
                    "end_line": 3623,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let values = [1, 2, 3, 4]; // Assuming `Group::WIDTH` is 4 for this test",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 4) };",
                "    let result = unsafe { iter_range.fold_impl(4, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let values = [1, 2, 3, 4];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 4) };",
                "    let result = unsafe { iter_range.fold_impl(4, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    assert_eq!(result, 10);",
                "}"
            ],
            [
                {
                    "start_line": 3614,
                    "start_column": 23,
                    "end_line": 3614,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 3623,
                    "start_column": 16,
                    "end_line": 3623,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let values = [1, 2, 3]; // n is set to 4 but we only have 3 elements",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 3) };",
                "    let result = unsafe { iter_range.fold_impl(4, 0, |acc, bucket| acc + *bucket.as_ref()) };",
                "    let values = [1, 2, 3];",
                "    let bucket = Bucket::<i32> { ptr: NonNull::new(values.as_ptr() as *mut _).unwrap() };",
                "    let ctrl: *const u8 = values.as_ptr() as *const u8;",
                "    let mut iter_range = unsafe { RawIterRange::new(ctrl, bucket, 3) };",
                "    assert_eq!(result, 6);",
                "}"
            ],
            [
                {
                    "start_line": 3614,
                    "start_column": 23,
                    "end_line": 3614,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 3623,
                    "start_column": 16,
                    "end_line": 3623,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}