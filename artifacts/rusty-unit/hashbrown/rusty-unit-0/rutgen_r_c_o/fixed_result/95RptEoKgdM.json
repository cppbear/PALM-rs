{
    "function_name": "hashbrown::map::equivalent_key",
    "file_path": "/home/abezbm/rusty-unit/evaluation/hashbrown/rusty-unit-0/src/map.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/hashbrown",
    "tests": 21,
    "tests_lines": [
        39,
        39,
        39,
        43,
        43,
        35,
        36,
        37,
        38,
        41,
        42,
        43,
        44,
        35,
        36,
        39,
        40,
        37,
        37,
        36,
        37
    ],
    "oracles": 5,
    "oracles_compiled": 5,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 21,
    "tests_compiled_rate": 100.0,
    "oracles_run": 5,
    "oracles_passed": 5,
    "oracles_passed_rate": 100.0,
    "tests_run": 21,
    "tests_passed": 20,
    "tests_passed_rate": 95.23809523809523,
    "lines": 6,
    "lines_covered": 6,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        220,
        221,
        222,
        223,
        224,
        225
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    assert!(result1);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    assert!(!result2);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    assert!(result3);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result4 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Valid String Value\"));",
                "    let result5 = string_key_fn(&(MyStringKey(\"This is a very long string\".to_string()), \"Invalid String Value\"));",
                "    assert!(result4);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result4 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Valid String Value\"));",
                "    let result5 = string_key_fn(&(MyStringKey(\"This is a very long string\".to_string()), \"Invalid String Value\"));",
                "    assert!(!result5);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    assert!(result1);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    assert!(result2);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    assert!(!result3);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    assert!(!result4);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    assert!(result5);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    let result6 = string_key_fn(&(MyStringKey(String::from(\"\")), \"Empty String\"));",
                "    assert!(!result6);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    let result6 = string_key_fn(&(MyStringKey(String::from(\"\")), \"Empty String\"));",
                "    let result7 = string_key_fn(&(MyStringKey(String::from(\"This is longer than twenty characters\")), \"Long String\"));",
                "    assert!(!result7);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    let result6 = string_key_fn(&(MyStringKey(String::from(\"\")), \"Empty String\"));",
                "    let result7 = string_key_fn(&(MyStringKey(String::from(\"This is longer than twenty characters\")), \"Long String\"));",
                "    let result8 = string_key_fn(&(MyStringKey(String::from(\"Short\")), \"Short String\"));",
                "    assert!(result8);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    assert_eq!(result, false);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let result = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    assert_eq!(result, true);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let result = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let equivalent_str = MyStringEquivalent;",
                "    let key_fn_str = equivalent_key(&equivalent_str);",
                "    let result_str = key_fn_str(&(MyStringKey(\"Hello\".to_string()), \"Valid String\"));",
                "    assert_eq!(result_str, true);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let result = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let equivalent_str = MyStringEquivalent;",
                "    let key_fn_str = equivalent_key(&equivalent_str);",
                "    let result_str = key_fn_str(&(MyStringKey(\"Hello\".to_string()), \"Valid String\"));",
                "    let result_str = key_fn_str(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    assert_eq!(result_str, false);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    assert_eq!(result1, true);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    assert_eq!(result2, false);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is sure to be a bit longer.\".to_string()), \"Long String\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    assert_eq!(result1, false);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is sure to be a bit longer.\".to_string()), \"Long String\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is sure to be a bit longer.\".to_string()), \"Long String\"));",
                "    assert_eq!(result2, false);",
                "}"
            ],
            [
                220,
                221,
                222,
                223,
                224,
                225
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    assert!(result1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    assert!(!result2);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    assert!(result3);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result4 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Valid String Value\"));",
                "    let result5 = string_key_fn(&(MyStringKey(\"This is a very long string\".to_string()), \"Invalid String Value\"));",
                "    assert!(result4);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let result2 = key_fn(&(MyKey(101), \"Invalid Value\"));",
                "    let result3 = key_fn(&(MyKey(0), \"Edge Case Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result4 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Valid String Value\"));",
                "    let result5 = string_key_fn(&(MyStringKey(\"This is a very long string\".to_string()), \"Invalid String Value\"));",
                "    assert!(!result5);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    assert!(result1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    assert!(result2);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    assert!(!result3);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    assert!(!result4);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    assert!(result5);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    let result6 = string_key_fn(&(MyStringKey(String::from(\"\")), \"Empty String\"));",
                "    assert!(!result6);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    let result6 = string_key_fn(&(MyStringKey(String::from(\"\")), \"Empty String\"));",
                "    let result7 = string_key_fn(&(MyStringKey(String::from(\"This is longer than twenty characters\")), \"Long String\"));",
                "    assert!(!result7);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result1 = key_fn(&(MyKey(0), \"Zero Value\"));",
                "    let result2 = key_fn(&(MyKey(50), \"Fifty Value\"));",
                "    let result3 = key_fn(&(MyKey(101), \"Over Value\"));",
                "    let result4 = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result5 = string_key_fn(&(MyStringKey(String::from(\"Hello\")), \"Greeting\"));",
                "    let result6 = string_key_fn(&(MyStringKey(String::from(\"\")), \"Empty String\"));",
                "    let result7 = string_key_fn(&(MyStringKey(String::from(\"This is longer than twenty characters\")), \"Long String\"));",
                "    let result8 = string_key_fn(&(MyStringKey(String::from(\"Short\")), \"Short String\"));",
                "    assert!(result8);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    assert_eq!(result, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let result = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    assert_eq!(result, true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let result = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let equivalent_str = MyStringEquivalent;",
                "    let key_fn_str = equivalent_key(&equivalent_str);",
                "    let result_str = key_fn_str(&(MyStringKey(\"Hello\".to_string()), \"Valid String\"));",
                "    assert_eq!(result_str, true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let equivalent = MyEquivalent;",
                "    let key_fn = equivalent_key(&equivalent);",
                "    let result = key_fn(&(MyKey(-1), \"Negative Value\"));",
                "    let result = key_fn(&(MyKey(50), \"Valid Value\"));",
                "    let equivalent_str = MyStringEquivalent;",
                "    let key_fn_str = equivalent_key(&equivalent_str);",
                "    let result_str = key_fn_str(&(MyStringKey(\"Hello\".to_string()), \"Valid String\"));",
                "    let result_str = key_fn_str(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    assert_eq!(result_str, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    assert_eq!(result1, true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"Hello\".to_string()), \"Value\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is a test\".to_string()), \"Another Value\"));",
                "    assert_eq!(result2, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is sure to be a bit longer.\".to_string()), \"Long String\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    assert_eq!(result1, false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyKey(i32);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyEquivalent;",
                "",
                "impl Equivalent<MyKey> for MyEquivalent {",
                "    fn equivalent(&self, other: &MyKey) -> bool {",
                "        other.0 >= 0 && other.0 <= 100",
                "    }",
                "}",
                "",
                "",
                "",
                "",
                "#[derive(Debug, Clone, PartialEq)]",
                "struct MyStringKey(String);",
                "",
                "#[derive(Debug, Clone)]",
                "struct MyStringEquivalent;",
                "",
                "impl Equivalent<MyStringKey> for MyStringEquivalent {",
                "    fn equivalent(&self, other: &MyStringKey) -> bool {",
                "        other.0.len() > 0 && other.0.len() <= 20",
                "    }",
                "}",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is sure to be a bit longer.\".to_string()), \"Long String\"));",
                "    let string_equivalent = MyStringEquivalent;",
                "    let string_key_fn = equivalent_key(&string_equivalent);",
                "    let result1 = string_key_fn(&(MyStringKey(\"\".to_string()), \"Empty String\"));",
                "    let result2 = string_key_fn(&(MyStringKey(\"This is sure to be a bit longer.\".to_string()), \"Long String\"));",
                "    assert_eq!(result2, false);",
                "}"
            ],
            []
        ]
    ]
}