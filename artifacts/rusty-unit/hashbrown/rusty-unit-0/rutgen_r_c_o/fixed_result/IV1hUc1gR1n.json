{
    "function_name": "hashbrown::raw::raw::RawTableInner::reserve_rehash_inner",
    "file_path": "/home/abezbm/rusty-unit/evaluation/hashbrown/rusty-unit-0/src/raw/mod.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/hashbrown",
    "tests": 22,
    "tests_lines": [
        25,
        25,
        24,
        24,
        24,
        15,
        15,
        15,
        17,
        18,
        20,
        20,
        19,
        19,
        19,
        19,
        19,
        20,
        20,
        22,
        21,
        30
    ],
    "oracles": 9,
    "oracles_compiled": 4,
    "oracles_compiled_rate": 44.44444444444444,
    "tests_compiled": 13,
    "tests_compiled_rate": 59.09090909090909,
    "oracles_run": 4,
    "oracles_passed": 1,
    "oracles_passed_rate": 25.0,
    "tests_run": 13,
    "tests_passed": 4,
    "tests_passed_rate": 30.76923076923077,
    "lines": 27,
    "lines_covered": 26,
    "lines_coveraged_rate": 96.29629629629629,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        2686,
        2687,
        2688,
        2689,
        2690,
        2691,
        2692,
        2693,
        2694,
        2695,
        2696,
        2697,
        2699,
        2700,
        2701,
        2703,
        2704,
        2717,
        2718,
        2729,
        2730,
        2731,
        2732,
        2733,
        2734,
        2735,
        2737
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    assert_eq!(table.items, 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    assert_eq!(table.bucket_mask, usize::MAX - 1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    assert!(table.growth_left > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    unsafe {",
                "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    assert_eq!(table.items, 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2729,
                2730,
                2731,
                2732,
                2733,
                2734,
                2735,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2729,
                2730,
                2731,
                2732,
                2733,
                2734,
                2735,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(table.items == 12);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(table.bucket_mask == 31);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(table.growth_left == bucket_mask_to_capacity(table.bucket_mask));",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(unsafe { table.num_ctrl_bytes() } >= 0);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(unsafe { table.is_empty_singleton() } == false);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16; // exactly half of capacity",
                "    let additional = 3;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16;",
                "    let additional = 3;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert_eq!(result.is_err(), true);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16; // exactly half of capacity",
                "    let additional = 3;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16;",
                "    let additional = 3;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                "}"
            ],
            [
                2686,
                2687,
                2688,
                2689,
                2690,
                2691,
                2692,
                2693,
                2694,
                2695,
                2696,
                2697,
                2699,
                2700,
                2703,
                2704,
                2717,
                2718,
                2737
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 2704,
            "start_column": 12,
            "end_line": 2704,
            "end_column": 42,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    assert_eq!(table.items, 0);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    assert_eq!(table.bucket_mask, usize::MAX - 1);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    assert!(table.growth_left > 0);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    ",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
                "    let additional = 1;",
                "    unsafe {",
                "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    assert_eq!(table.items, 0);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 16;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = capacity - 1;",
                "    let additional = 2;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(table.items == 12);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(table.bucket_mask == 31);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(table.growth_left == bucket_mask_to_capacity(table.bucket_mask));",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(unsafe { table.num_ctrl_bytes() } >= 0);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12; // less than half of capacity",
                "    let additional = 2;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 12;",
                "    let additional = 2;",
                "    assert!(unsafe { table.is_empty_singleton() } == false);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16; // exactly half of capacity",
                "    let additional = 3;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16;",
                "    let additional = 3;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert_eq!(result.is_err(), true);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16; // exactly half of capacity",
                "    let additional = 3;",
                "",
                "    unsafe {",
                "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
                "    }",
                "    let alloc = &Global;",
                "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
                "    let capacity = 32;",
                "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
                "    table.items = 16;",
                "    let additional = 3;",
                "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
                "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                "}"
            ],
            [
                {
                    "start_line": 2704,
                    "start_column": 12,
                    "end_line": 2704,
                    "end_column": 42,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ]
}