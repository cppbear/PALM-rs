[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
          "    let result = raw_table.clone().into_allocation();",
          "}"
        ],
        "oracles": [
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    assert!(result.is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr.as_ptr() != std::ptr::null_mut());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size(), expected_size);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.align(), expected_align);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(alloc, Global);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(!raw_table.table.is_empty_singleton());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr.as_ptr() != std::ptr::null_mut());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size(), expected_size);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.align(), expected_align);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(alloc, Global);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(!raw_table.table.is_empty_singleton());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(16, Global);",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
          "    let result = raw_table.clone().into_allocation();",
          "}"
        ],
        "oracles": [
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    assert!(!raw_table.table.is_empty_singleton());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    assert!(layout_buckets_result.is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(!ptr.as_ptr().is_null());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size() > 0, true);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(alloc, raw_table.allocator());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    assert!(!raw_table.table.is_empty_singleton());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    assert!(layout_buckets_result.is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(!ptr.as_ptr().is_null());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size() > 0, true);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(1000, Global);",
            "    let layout_buckets_result = Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets());",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(alloc, raw_table.allocator());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
          "    let result = raw_table.clone().into_allocation();",
          "}"
        ],
        "oracles": [
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(!ptr.as_ptr().is_null());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size() % layout.align(), 0);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.align(), std::mem::align_of::<u8>());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(raw_table.capacity(), usize::MAX - 1);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr == unsafe { NonNull::new_unchecked(raw_table.table.ctrl.as_ptr()) });"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(alloc, Global);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(!ptr.as_ptr().is_null());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size() % layout.align(), 0);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.align(), std::mem::align_of::<u8>());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(raw_table.capacity(), usize::MAX - 1);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr == unsafe { NonNull::new_unchecked(raw_table.table.ctrl.as_ptr()) });",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(usize::MAX - 1, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(alloc, Global);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
          "    let result = raw_table.clone().into_allocation();",
          "}"
        ],
        "oracles": [
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    assert!(raw_table.table.is_empty_singleton() == false);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr.is_non_null());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size(), mem::size_of::<u8>() * 3);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr == unsafe { NonNull::new_unchecked(raw_table.table.ctrl.as_ptr().sub(layout.align())) });"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(unsafe { ptr::read(&raw_table.alloc) } == alloc);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    assert!(raw_table.table.is_empty_singleton() == false);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr.is_non_null());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size(), mem::size_of::<u8>() * 3);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr == unsafe { NonNull::new_unchecked(raw_table.table.ctrl.as_ptr().sub(layout.align())) });",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(3, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(unsafe { ptr::read(&raw_table.alloc) } == alloc);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let raw_table = RawTable::<u8>::new_in(Global);",
          "    let result = raw_table.into_allocation();",
          "}"
        ],
        "oracles": [
          [
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    assert!(raw_table.table.is_empty_singleton() == false);"
          ],
          [
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    let result = raw_table.into_allocation();",
            "    assert!(result.is_some());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    let result = raw_table.into_allocation();",
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    assert!(raw_table.table.is_empty_singleton() == false);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    let result = raw_table.into_allocation();",
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    let result = raw_table.into_allocation();",
            "    let raw_table = RawTable::<u8>::new_in(Global);",
            "    let result = raw_table.into_allocation();",
            "    assert!(result.is_some());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
          "    let result = raw_table.clone().into_allocation();",
          "}"
        ],
        "oracles": [
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    assert!(raw_table.table.is_empty_singleton() == false);"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr.cast::<u8>().as_ptr() != std::ptr::null());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size(), raw_table.capacity());"
          ],
          [
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.align(), std::mem::align_of::<u8>());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    assert!(raw_table.table.is_empty_singleton() == false);",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    assert!(Self::TABLE_LAYOUT.calculate_layout_for(raw_table.table.buckets()).is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert!(ptr.cast::<u8>().as_ptr() != std::ptr::null());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.size(), raw_table.capacity());",
            "}"
          ],
          [
            "{",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let raw_table = RawTable::<u8>::with_capacity_in(8, Global);",
            "    let result = raw_table.clone().into_allocation();",
            "    let (ptr, layout, alloc) = result.unwrap();",
            "    assert_eq!(layout.align(), std::mem::align_of::<u8>());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]