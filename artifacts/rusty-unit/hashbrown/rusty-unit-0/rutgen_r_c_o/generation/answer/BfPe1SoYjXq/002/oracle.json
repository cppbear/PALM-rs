[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let len = 4; // A power of two",
          "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
          "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
          "",
          "    unsafe {",
          "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl as usize % Group::WIDTH == 0);"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(len > 0);"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(len.count_ones() == 1);"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl.add(len).is_null() == false);"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl.add(len - 1).is_null() == false);"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(std::ptr::eq(bucket.ptr.as_ptr(), ctrl));"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    assert!(iter_range.end == ctrl.add(len));"
          ],
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    assert!(iter_range.next_ctrl == ctrl.add(Group::WIDTH));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl as usize % Group::WIDTH == 0);",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(len > 0);",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(len.count_ones() == 1);",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl.add(len).is_null() == false);",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl.add(len - 1).is_null() == false);",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(std::ptr::eq(bucket.ptr.as_ptr(), ctrl));",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    assert!(iter_range.end == ctrl.add(len));",
            "}"
          ],
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    assert!(iter_range.next_ctrl == ctrl.add(Group::WIDTH));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let len = 4; // A power of two",
          "    let ctrl: *const u8 = 0x1001 as *const u8; // Misaligned",
          "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
          "",
          "    unsafe {",
          "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1001 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(std::panic::catch_unwind(|| {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0x1001 as *const u8; // Misaligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0x1001 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(std::panic::catch_unwind(|| {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let len = 0; // Zero length",
          "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
          "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
          "",
          "    unsafe {",
          "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert_eq!(len, 0);"
          ],
          [
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl as usize % Group::WIDTH == 0);"
          ],
          [
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(bucket.ptr.as_ptr() != ptr::null_mut());"
          ],
          [
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(raw_iter_range_variable.is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let len = 0; // Zero length",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert_eq!(len, 0);",
            "}"
          ],
          [
            "{",
            "    let len = 0; // Zero length",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(ctrl as usize % Group::WIDTH == 0);",
            "}"
          ],
          [
            "{",
            "    let len = 0; // Zero length",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(bucket.ptr.as_ptr() != ptr::null_mut());",
            "}"
          ],
          [
            "{",
            "    let len = 0; // Zero length",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 0;",
            "    let ctrl: *const u8 = 0x1000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(raw_iter_range_variable.is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let len = 3; // Not a power of two",
          "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
          "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
          "",
          "    unsafe {",
          "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let len = 3; // len is not a power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // ctrl is properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // bucket is valid",
            "    assert_panics!({ RawIterRange::new(ctrl, bucket, len) });"
          ]
        ],
        "codes": [
          [
            "{",
            "    let len = 3; // Not a power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 3; // len is not a power of two",
            "    let ctrl: *const u8 = 0x1000 as *const u8; // ctrl is properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // bucket is valid",
            "    assert_panics!({ RawIterRange::new(ctrl, bucket, len) });",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let len = 4; // A power of two",
          "    let ctrl: *const u8 = 0xFFFFFFFF as *const u8; // Out of bounds",
          "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
          "",
          "    unsafe {",
          "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let len = 4;",
            "    let ctrl: *const u8 = 0xFFFFFFFF as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(std::panic::catch_unwind(|| {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let len = 4; // A power of two",
            "    let ctrl: *const u8 = 0xFFFFFFFF as *const u8; // Out of bounds",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 4;",
            "    let ctrl: *const u8 = 0xFFFFFFFF as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x2000 as *mut u8).unwrap() };",
            "    assert!(std::panic::catch_unwind(|| {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let len = 8; // A power of two",
          "    let ctrl: *const u8 = 0x2000 as *const u8; // Properly aligned",
          "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() }; // Valid bucket",
          "",
          "    unsafe {",
          "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).next_ctrl }, expected_next_ctrl);"
          ],
          [
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).end }, expected_end);"
          ],
          [
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).current_group }, expected_current_group);"
          ],
          [
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).data.ptr }, bucket.ptr);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let len = 8; // A power of two",
            "    let ctrl: *const u8 = 0x2000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).next_ctrl }, expected_next_ctrl);",
            "}"
          ],
          [
            "{",
            "    let len = 8; // A power of two",
            "    let ctrl: *const u8 = 0x2000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).end }, expected_end);",
            "}"
          ],
          [
            "{",
            "    let len = 8; // A power of two",
            "    let ctrl: *const u8 = 0x2000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).current_group }, expected_current_group);",
            "}"
          ],
          [
            "{",
            "    let len = 8; // A power of two",
            "    let ctrl: *const u8 = 0x2000 as *const u8; // Properly aligned",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() }; // Valid bucket",
            "",
            "    unsafe {",
            "        let iter_range = RawIterRange::new(ctrl, bucket, len);",
            "    }",
            "    let len = 8;",
            "    let ctrl: *const u8 = 0x2000 as *const u8;",
            "    let bucket = Bucket { ptr: NonNull::new(0x3000 as *mut u8).unwrap() };",
            "    let expected_next_ctrl = ctrl.add(Group::WIDTH);",
            "    let expected_end = ctrl.add(len);",
            "    let current_group = Group::load_aligned(ctrl.cast()).match_full();",
            "    let expected_current_group = current_group.into_iter();",
            "    assert_eq!(unsafe { RawIterRange::new(ctrl, bucket, len).data.ptr }, bucket.ptr);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]