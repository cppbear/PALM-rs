[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut source_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 16,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 10,",
          "            items: 5,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "    let mut target_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 16,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 5,",
          "            items: 2,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "",
          "    unsafe {",
          "        target_table.clone_from_spec(&source_table);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    assert_eq!(target_items, source_items);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    assert_eq!(target_growth_left, source_table.table.growth_left);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 10,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 2,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    assert_eq!(target_items, source_items);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 10,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 2,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    assert_eq!(target_growth_left, source_table.table.growth_left);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut source_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 8,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 0,",
          "            items: 0,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "    let mut target_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 8,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 5,",
          "            items: 3,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "",
          "    unsafe {",
          "        target_table.clone_from_spec(&source_table);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    let source_table_items = source_table.table.items;",
            "    assert_eq!(target_table_items, source_table_items);"
          ],
          [
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    let source_table_items = source_table.table.items;",
            "    assert_eq!(target_table_growth_left, source_table_growth_left);"
          ],
          [
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    let source_table_items = source_table.table.items;",
            "    assert_eq!(target_table.table.ctrl.as_ptr(), source_table.table.ctrl.as_ptr());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 8,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 0,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 8,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 3,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    let source_table_items = source_table.table.items;",
            "    assert_eq!(target_table_items, source_table_items);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 8,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 0,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 8,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 3,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    let source_table_items = source_table.table.items;",
            "    assert_eq!(target_table_growth_left, source_table_growth_left);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 8,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 0,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 8,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 3,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    let source_table_items = source_table.table.items;",
            "    assert_eq!(target_table.table.ctrl.as_ptr(), source_table.table.ctrl.as_ptr());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut source_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 32,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 0,",
          "            items: 16,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "    let mut target_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 32,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 10,",
          "            items: 5,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "",
          "    unsafe {",
          "        target_table.clone_from_spec(&source_table);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let source_items = source_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(target_items, source_items);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(target_growth_left, source_table.table.growth_left);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 32,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 0,",
            "            items: 16,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 32,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 10,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(target_items, source_items);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 32,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 0,",
            "            items: 16,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 32,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 10,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_growth_left = target_table.table.growth_left;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(target_growth_left, source_table.table.growth_left);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut source_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 1 << 30,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 1 << 30,",
          "            items: 1 << 30,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "    let mut target_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 1 << 30,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 1 << 30,",
          "            items: 0,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "",
          "    unsafe {",
          "        target_table.clone_from_spec(&source_table);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(target_items, 0);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(source_items, 1 << 30);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert!(target_table.table.growth_left > 0);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert!(target_table.table.bucket_mask > 0);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert!(target_table.table.ctrl != source_table.table.ctrl);"
          ],
          [
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert_ne!(target_table.table.ctrl.as_ptr(), source_table.table.ctrl.as_ptr());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(target_items, 0);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert_eq!(source_items, 1 << 30);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert!(target_table.table.growth_left > 0);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert!(target_table.table.bucket_mask > 0);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert!(target_table.table.ctrl != source_table.table.ctrl);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 1 << 30,",
            "            items: 0,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_items = source_table.table.items;",
            "    let target_items = target_table.table.items;",
            "    assert_ne!(target_table.table.ctrl.as_ptr(), source_table.table.ctrl.as_ptr());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut source_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 1 << 30,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 2 << 30, // exceeding allowed limits",
          "            items: 1 << 30,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "    let mut target_table = RawTable {",
          "        table: RawTableInner {",
          "            bucket_mask: 16,",
          "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
          "            growth_left: 5,",
          "            items: 5,",
          "        },",
          "        alloc: Global,",
          "        marker: PhantomData::<u32>,",
          "    };",
          "",
          "    unsafe {",
          "        target_table.clone_from_spec(&source_table);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let source_table_growth_left = source_table.table.growth_left;",
            "    let source_table_items = source_table.table.items;",
            "    let target_table_bucket_mask = target_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    assert!(source_table_items > target_table_growth_left);"
          ],
          [
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let source_table_growth_left = source_table.table.growth_left;",
            "    let source_table_items = source_table.table.items;",
            "    let target_table_bucket_mask = target_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    assert!(source_table_growth_left > target_table_growth_left);"
          ],
          [
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let source_table_growth_left = source_table.table.growth_left;",
            "    let source_table_items = source_table.table.items;",
            "    let target_table_bucket_mask = target_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    assert!(source_table_bucket_mask > target_table_bucket_mask);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 2 << 30, // exceeding allowed limits",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let source_table_growth_left = source_table.table.growth_left;",
            "    let source_table_items = source_table.table.items;",
            "    let target_table_bucket_mask = target_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    assert!(source_table_items > target_table_growth_left);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 2 << 30, // exceeding allowed limits",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let source_table_growth_left = source_table.table.growth_left;",
            "    let source_table_items = source_table.table.items;",
            "    let target_table_bucket_mask = target_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    assert!(source_table_growth_left > target_table_growth_left);",
            "}"
          ],
          [
            "{",
            "    let mut source_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 1 << 30,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 2 << 30, // exceeding allowed limits",
            "            items: 1 << 30,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "    let mut target_table = RawTable {",
            "        table: RawTableInner {",
            "            bucket_mask: 16,",
            "            ctrl: NonNull::new(unsafe { std::mem::transmute(0_usize) }).unwrap(),",
            "            growth_left: 5,",
            "            items: 5,",
            "        },",
            "        alloc: Global,",
            "        marker: PhantomData::<u32>,",
            "    };",
            "",
            "    unsafe {",
            "        target_table.clone_from_spec(&source_table);",
            "    }",
            "    let source_table_bucket_mask = source_table.table.bucket_mask;",
            "    let source_table_growth_left = source_table.table.growth_left;",
            "    let source_table_items = source_table.table.items;",
            "    let target_table_bucket_mask = target_table.table.bucket_mask;",
            "    let target_table_growth_left = target_table.table.growth_left;",
            "    let target_table_items = target_table.table.items;",
            "    assert!(source_table_bucket_mask > target_table_bucket_mask);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]