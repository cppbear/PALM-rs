[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
          "    let allocator = Global; // Using Global allocator for our tests",
          "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
          "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
          "    ",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
          "    ",
          "    // Fill the control bytes to ensure the bucket at index 1 is full",
          "    for index in 0..capacity {",
          "        unsafe {",
          "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
          "        }",
          "    }",
          "    ",
          "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
          "    let index_to_erase = 1; // Arbitrary choice within valid limits",
          "    unsafe {",
          "        raw_table.erase(index_to_erase);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    assert_eq!(raw_table.items, capacity);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    assert!(unsafe { raw_table.is_bucket_full(1) });"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    assert!(unsafe { Group::load(raw_table.ctrl(1)).match_empty() == false });"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert!(unsafe { Group::load(raw_table.ctrl(1)).match_empty() });"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert_eq!(raw_table.items, capacity - 1);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert!(raw_table.growth_left > 0);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert!(unsafe { Group::load(raw_table.ctrl(0)).match_empty() });"
          ]
        ],
        "codes": [
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    assert_eq!(raw_table.items, capacity);",
            "}"
          ],
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    assert!(unsafe { raw_table.is_bucket_full(1) });",
            "}"
          ],
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    assert!(unsafe { Group::load(raw_table.ctrl(1)).match_empty() == false });",
            "}"
          ],
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert!(unsafe { Group::load(raw_table.ctrl(1)).match_empty() });",
            "}"
          ],
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert_eq!(raw_table.items, capacity - 1);",
            "}"
          ],
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert!(raw_table.growth_left > 0);",
            "}"
          ],
          [
            "{",
            "    // Assume A is some suitable allocator and TableLayout is properly defined/initialized",
            "    let allocator = Global; // Using Global allocator for our tests",
            "    let table_layout = TableLayout::default(); // Assuming default values for the layout",
            "    let capacity = 16; // Let's define a capacity ensuring we have enough buckets",
            "    ",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    ",
            "    // Fill the control bytes to ensure the bucket at index 1 is full",
            "    for index in 0..capacity {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Mark each one as full",
            "        }",
            "    }",
            "    ",
            "    // Now we will prepare some empty slots - but ensure no room for Tag::EMPTY",
            "    let index_to_erase = 1; // Arbitrary choice within valid limits",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let capacity = 16;",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, capacity);",
            "    for index in 0..capacity {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    unsafe { raw_table.erase(1); }",
            "    assert!(unsafe { Group::load(raw_table.ctrl(0)).match_empty() });",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default(); ",
          "",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
          "    ",
          "    // Ensuring that no items exist to call erase on",
          "    let index_to_erase = 0; // Invalid since the bucket is empty",
          "    unsafe {",
          "        raw_table.erase(index_to_erase);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.items == 0);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.is_empty_singleton() == true);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.buckets() == 4);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.is_bucket_full(0) == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    ",
            "    // Ensuring that no items exist to call erase on",
            "    let index_to_erase = 0; // Invalid since the bucket is empty",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.items == 0);",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    ",
            "    // Ensuring that no items exist to call erase on",
            "    let index_to_erase = 0; // Invalid since the bucket is empty",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.is_empty_singleton() == true);",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    ",
            "    // Ensuring that no items exist to call erase on",
            "    let index_to_erase = 0; // Invalid since the bucket is empty",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.buckets() == 4);",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    ",
            "    // Ensuring that no items exist to call erase on",
            "    let index_to_erase = 0; // Invalid since the bucket is empty",
            "    unsafe {",
            "        raw_table.erase(index_to_erase);",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 4);",
            "    assert!(raw_table.is_bucket_full(0) == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let allocator = Global;",
          "    let table_layout = TableLayout::default(); ",
          "",
          "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
          "    ",
          "    // Filling some buckets while leaving one as empty",
          "    for index in 0..7 {",
          "        unsafe {",
          "            raw_table.set_ctrl(index, Tag(1)); // Fill first 7",
          "        }",
          "    }",
          "    ",
          "    let index_to_erase = 1; // Choose an index to erase",
          "    unsafe {",
          "        raw_table.erase(index_to_erase); // Expected to work",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert_eq!(raw_table.ctrl(index_to_erase).read(), Tag::EMPTY);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert_eq!(raw_table.items, 7);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert!(raw_table.growth_left <= 8);"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert!(raw_table.is_bucket_full(2));"
          ],
          [
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert!(!raw_table.is_bucket_full(index_to_erase));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    ",
            "    // Filling some buckets while leaving one as empty",
            "    for index in 0..7 {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Fill first 7",
            "        }",
            "    }",
            "    ",
            "    let index_to_erase = 1; // Choose an index to erase",
            "    unsafe {",
            "        raw_table.erase(index_to_erase); // Expected to work",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert_eq!(raw_table.ctrl(index_to_erase).read(), Tag::EMPTY);",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    ",
            "    // Filling some buckets while leaving one as empty",
            "    for index in 0..7 {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Fill first 7",
            "        }",
            "    }",
            "    ",
            "    let index_to_erase = 1; // Choose an index to erase",
            "    unsafe {",
            "        raw_table.erase(index_to_erase); // Expected to work",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert_eq!(raw_table.items, 7);",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    ",
            "    // Filling some buckets while leaving one as empty",
            "    for index in 0..7 {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Fill first 7",
            "        }",
            "    }",
            "    ",
            "    let index_to_erase = 1; // Choose an index to erase",
            "    unsafe {",
            "        raw_table.erase(index_to_erase); // Expected to work",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert!(raw_table.growth_left <= 8);",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    ",
            "    // Filling some buckets while leaving one as empty",
            "    for index in 0..7 {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Fill first 7",
            "        }",
            "    }",
            "    ",
            "    let index_to_erase = 1; // Choose an index to erase",
            "    unsafe {",
            "        raw_table.erase(index_to_erase); // Expected to work",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert!(raw_table.is_bucket_full(2));",
            "}"
          ],
          [
            "{",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default(); ",
            "",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    ",
            "    // Filling some buckets while leaving one as empty",
            "    for index in 0..7 {",
            "        unsafe {",
            "            raw_table.set_ctrl(index, Tag(1)); // Fill first 7",
            "        }",
            "    }",
            "    ",
            "    let index_to_erase = 1; // Choose an index to erase",
            "    unsafe {",
            "        raw_table.erase(index_to_erase); // Expected to work",
            "    }",
            "    let allocator = Global;",
            "    let table_layout = TableLayout::default();",
            "    let mut raw_table = RawTableInner::with_capacity(&allocator, table_layout, 8);",
            "    for index in 0..7 {",
            "    unsafe { raw_table.set_ctrl(index, Tag(1)); }",
            "    }",
            "    let index_to_erase = 1;",
            "    unsafe { raw_table.erase(index_to_erase); }",
            "    assert!(!raw_table.is_bucket_full(index_to_erase));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]