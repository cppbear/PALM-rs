{
    "function_name": "http::header::map::header::map::OccupiedEntry<'a, T>::remove_entry_mult",
    "tests": 2,
    "tests_lines": [
        66,
        33
    ],
    "oracles": 2,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 1,
    "tests_compiled_rate": 50.0,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 1,
    "tests_passed": 1,
    "tests_passed_rate": 100.0,
    "lines": 17,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        3325,
        3326,
        3327,
        3328,
        3329,
        3330,
        3331,
        3332,
        3333,
        3334,
        3335,
        3336,
        3337,
        3338,
        3339,
        3340,
        3341
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct MockMap {",
                "        entries: Vec<Entry>,",
                "        probe: usize,",
                "    }",
                "",
                "    struct Entry {",
                "        key: HeaderName,",
                "        value: Value,",
                "    }",
                "",
                "    struct HeaderName(String);",
                "    struct Value(i32);",
                "",
                "    impl MockMap {",
                "        fn remove_found(&mut self, probe: usize, index: usize) -> Entry {",
                "            self.entries.remove(index)",
                "        }",
                "    }",
                "",
                "    let mut mock_map = MockMap {",
                "        entries: vec![",
                "            Entry {",
                "                key: HeaderName(\"Key1\".to_string()),",
                "                value: Value(1),",
                "            },",
                "        ],",
                "        probe: 0,",
                "    };",
                "",
                "    // This will trigger panic due to accessing invalid index",
                "    let _ = mock_map.remove_found(0, 1);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct MockMap {",
                "        entries: Vec<Entry>,",
                "        probe: usize,",
                "    }",
                "",
                "    struct Entry {",
                "        key: HeaderName,",
                "        value: Value,",
                "    }",
                "",
                "    struct HeaderName(String);",
                "    struct Value(i32);",
                "",
                "    impl MockMap {",
                "        fn remove_found(&mut self, probe: usize, index: usize) -> Entry {",
                "            self.entries.remove(index)",
                "        }",
                "    }",
                "",
                "    let mut mock_map = MockMap {",
                "        entries: vec![",
                "            Entry {",
                "                key: HeaderName(\"Key1\".to_string()),",
                "                value: Value(1),",
                "            },",
                "        ],",
                "        probe: 0,",
                "    };",
                "",
                "    // This will trigger panic due to accessing invalid index",
                "    let _ = mock_map.remove_found(0, 1);",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs"
}