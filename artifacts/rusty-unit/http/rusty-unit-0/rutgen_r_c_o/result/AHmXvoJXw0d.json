{
    "function_name": "http::header::map::header::map::HeaderMap<T>::try_grow",
    "tests": 42,
    "tests_lines": [
        7,
        7,
        7,
        7,
        7,
        23,
        23,
        23,
        23,
        20,
        21,
        21,
        21,
        24,
        24,
        24,
        24,
        35,
        35,
        35,
        35,
        24,
        24,
        24,
        24,
        32,
        32,
        32,
        32,
        9,
        9,
        9,
        9,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11,
        11
    ],
    "oracles": 13,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 53.84615384615385,
    "tests_compiled": 21,
    "tests_compiled_rate": 50.0,
    "oracles_run": 7,
    "oracles_passed": 7,
    "oracles_passed_rate": 100.0,
    "tests_run": 21,
    "tests_passed": 21,
    "tests_passed_rate": 100.0,
    "lines": 29,
    "lines_covered": 25,
    "lines_coveraged_rate": 86.20689655172413,
    "branches": 6,
    "branches_covered": 4,
    "branches_coverage_rate": 66.66666666666666,
    "codes_lines": [
        1735,
        1736,
        1737,
        1738,
        1739,
        1740,
        1741,
        1743,
        1744,
        1745,
        1746,
        1747,
        1748,
        1749,
        1754,
        1755,
        1756,
        1757,
        1758,
        1760,
        1761,
        1762,
        1764,
        1765,
        1766,
        1769,
        1770,
        1771,
        1772
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(100);",
                "    let result = header_map.try_grow(32769); // Exceeds MAX_SIZE",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(100);",
                "    let result = header_map.try_grow(32769);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1735,
                1736,
                1737,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(150);",
                "    let result = header_map.try_grow(40000); // Exceeds MAX_SIZE",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(150);",
                "    let result = header_map.try_grow(40000);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1735,
                1736,
                1737,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Indices with some vacant spaces",
                "    header_map.indices = Box::from([",
                "        Pos::new(2, HashValue(0)), // probe will not match",
                "        Pos::new(1, HashValue(3)), // an arbitrary position",
                "        Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    ",
                "    let _ = header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    header_map.indices = Box::from([",
                "    Pos::new(2, HashValue(0)), // probe will not match",
                "    Pos::new(1, HashValue(3)), // an arbitrary position",
                "    Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Indices with some vacant spaces",
                "    header_map.indices = Box::from([",
                "        Pos::new(2, HashValue(0)), // probe will not match",
                "        Pos::new(1, HashValue(3)), // an arbitrary position",
                "        Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    ",
                "    let _ = header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    header_map.indices = Box::from([",
                "    Pos::new(2, HashValue(0)), // probe will not match",
                "    Pos::new(1, HashValue(3)), // an arbitrary position",
                "    Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Indices with some vacant spaces",
                "    header_map.indices = Box::from([",
                "        Pos::new(2, HashValue(0)), // probe will not match",
                "        Pos::new(1, HashValue(3)), // an arbitrary position",
                "        Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    ",
                "    let _ = header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    header_map.indices = Box::from([",
                "    Pos::new(2, HashValue(0)), // probe will not match",
                "    Pos::new(1, HashValue(3)), // an arbitrary position",
                "    Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1744,
                1745,
                1746,
                1747,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1761,
                1762,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768; // Assuming this is the value of MAX_SIZE.",
                "    let result = header_map.try_grow(max_size);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768;",
                "    let result = header_map.try_grow(max_size);",
                "    assert_eq!(header_map.indices.len(), max_size);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768; // Assuming this is the value of MAX_SIZE.",
                "    let result = header_map.try_grow(max_size);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768;",
                "    let result = header_map.try_grow(max_size);",
                "    assert_eq!(header_map.mask, max_size.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768; // Assuming this is the value of MAX_SIZE.",
                "    let result = header_map.try_grow(max_size);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768;",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(header_map.entries.capacity() >= 0);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(header_map.entries.capacity() >= 0);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(header_map.entries.capacity() >= header_map.entries.len());",
                "}"
            ],
            [
                1735,
                1736,
                1738,
                1739,
                1740,
                1741,
                1743,
                1754,
                1755,
                1756,
                1757,
                1758,
                1760,
                1764,
                1769,
                1770,
                1771,
                1772
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1736,
            "start_column": 12,
            "end_line": 1736,
            "end_column": 34,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 1744,
            "start_column": 20,
            "end_line": 1744,
            "end_column": 41,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1745,
            "start_column": 20,
            "end_line": 1745,
            "end_column": 65,
            "positive": true,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(100);",
                "    let result = header_map.try_grow(32769); // Exceeds MAX_SIZE",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(100);",
                "    let result = header_map.try_grow(32769);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(150);",
                "    let result = header_map.try_grow(40000); // Exceeds MAX_SIZE",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(150);",
                "    let result = header_map.try_grow(40000);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Simulate some entries with specific conditions",
                "    header_map.indices = Box::from([",
                "        Pos::new(1, HashValue(0)), // position 1",
                "        Pos::new(2, HashValue(1)), // position 2",
                "        Pos::new(3, HashValue(2)), // position 3",
                "    ]);",
                "",
                "    // Trigger the function with conditions where probe_distance returns a non-zero for each",
                "    // First ideal should be greater than 0, hence we can assume 2 as first ideal",
                "    header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(128);",
                "    let new_raw_cap = 32768;",
                "    header_map.indices = Box::from([",
                "    Pos::new(1, HashValue(0)),",
                "    Pos::new(2, HashValue(1)),",
                "    Pos::new(3, HashValue(2)),",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Indices with some vacant spaces",
                "    header_map.indices = Box::from([",
                "        Pos::new(2, HashValue(0)), // probe will not match",
                "        Pos::new(1, HashValue(3)), // an arbitrary position",
                "        Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    ",
                "    let _ = header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    header_map.indices = Box::from([",
                "    Pos::new(2, HashValue(0)), // probe will not match",
                "    Pos::new(1, HashValue(3)), // an arbitrary position",
                "    Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Indices with some vacant spaces",
                "    header_map.indices = Box::from([",
                "        Pos::new(2, HashValue(0)), // probe will not match",
                "        Pos::new(1, HashValue(3)), // an arbitrary position",
                "        Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    ",
                "    let _ = header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    header_map.indices = Box::from([",
                "    Pos::new(2, HashValue(0)), // probe will not match",
                "    Pos::new(1, HashValue(3)), // an arbitrary position",
                "    Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    // Indices with some vacant spaces",
                "    header_map.indices = Box::from([",
                "        Pos::new(2, HashValue(0)), // probe will not match",
                "        Pos::new(1, HashValue(3)), // an arbitrary position",
                "        Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    ",
                "    let _ = header_map.try_grow(new_raw_cap).unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(64);",
                "    let new_raw_cap = 32768; // equal to MAX_SIZE, should not panic",
                "    header_map.indices = Box::from([",
                "    Pos::new(2, HashValue(0)), // probe will not match",
                "    Pos::new(1, HashValue(3)), // an arbitrary position",
                "    Pos::new(2, HashValue(5)), // position 2",
                "    ]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768; // Assuming this is the value of MAX_SIZE.",
                "    let result = header_map.try_grow(max_size);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768;",
                "    let result = header_map.try_grow(max_size);",
                "    assert_eq!(header_map.indices.len(), max_size);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768; // Assuming this is the value of MAX_SIZE.",
                "    let result = header_map.try_grow(max_size);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768;",
                "    let result = header_map.try_grow(max_size);",
                "    assert_eq!(header_map.mask, max_size.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768; // Assuming this is the value of MAX_SIZE.",
                "    let result = header_map.try_grow(max_size);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let max_size = 32768;",
                "    let result = header_map.try_grow(max_size);",
                "    assert!(header_map.entries.capacity() >= 0);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = Box::new([]); // Explicitly set indices to empty.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = Box::new([]);",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(header_map.entries.capacity() >= 0);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.indices.len(), new_raw_cap);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert_eq!(header_map.mask, new_raw_cap.wrapping_sub(1) as Size);",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384; // A valid size within the constraints.",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice(); // Explicitly set to zero-length.",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(0);",
                "    let new_raw_cap = 16384;",
                "    header_map.indices = vec![Pos::none(); 0].into_boxed_slice();",
                "    let result = header_map.try_grow(new_raw_cap);",
                "    assert!(header_map.entries.capacity() >= header_map.entries.len());",
                "}"
            ],
            [
                {
                    "start_line": 1736,
                    "start_column": 12,
                    "end_line": 1736,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1744,
                    "start_column": 20,
                    "end_line": 1744,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1745,
                    "start_column": 20,
                    "end_line": 1745,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs"
}