{
    "function_name": "http::header::name::header::name::HeaderName::from_bytes",
    "tests": 118,
    "tests_lines": [
        5,
        5,
        5,
        6,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        8,
        9,
        9,
        7,
        8,
        8,
        8,
        8,
        8,
        7,
        7,
        7,
        7,
        8,
        8,
        8,
        7,
        9,
        10,
        11,
        7,
        8,
        10,
        12,
        14,
        7,
        7,
        7,
        7,
        6,
        8,
        10,
        12,
        14,
        16,
        18,
        20,
        22,
        7,
        8,
        8,
        10,
        7,
        8,
        9,
        9,
        9,
        9,
        9,
        7,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        7,
        7,
        7,
        8,
        7,
        7,
        7,
        8,
        8,
        6,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        6,
        6,
        7,
        7,
        7,
        8,
        7,
        8,
        13,
        7,
        8,
        7,
        8,
        7,
        8
    ],
    "oracles": 39,
    "oracles_compiled": 26,
    "oracles_compiled_rate": 66.66666666666666,
    "tests_compiled": 54,
    "tests_compiled_rate": 45.76271186440678,
    "oracles_run": 26,
    "oracles_passed": 22,
    "oracles_passed_rate": 84.61538461538461,
    "tests_run": 54,
    "tests_passed": 40,
    "tests_passed_rate": 74.07407407407408,
    "lines": 24,
    "lines_covered": 24,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1115,
        1116,
        1117,
        1118,
        1119,
        1120,
        1121,
        1122,
        1123,
        1124,
        1126,
        1128,
        1130,
        1132,
        1133,
        1134,
        1135,
        1136,
        1137,
        1138,
        1144,
        1145,
        1146,
        1149
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(parse_result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"x-custom-header\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\xFF\"; // Invalid character",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(parse_result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    let repr = hdr_name.inner;",
                "    assert!(matches!(repr, Repr::Custom(MaybeLower { lower: true, .. })));",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    let repr = hdr_name.inner;",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    let repr = hdr_name.inner;",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"X-HEADER\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"valid-header-name-with-63-chars-in-length-valid-h\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
                "    let result_invalid = HeaderName::from_bytes(invalid_input);",
                "    assert!(result_invalid.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
                "    let result_invalid = HeaderName::from_bytes(invalid_input);",
                "    let empty_input: &[u8] = b\"\";",
                "    let result_empty = HeaderName::from_bytes(empty_input);",
                "    assert!(result_empty.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
                "    let result_invalid = HeaderName::from_bytes(invalid_input);",
                "    let empty_input: &[u8] = b\"\";",
                "    let result_empty = HeaderName::from_bytes(empty_input);",
                "    let too_long_input = b\"this-header-name-is-way-too-long-to-be-valid-and-exceeds-the-maximum-length-which-is-63-characters\";",
                "    let result_too_long = HeaderName::from_bytes(too_long_input);",
                "    assert!(result_too_long.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1136,
                1137,
                1138,
                1144,
                1145,
                1146,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert_eq!(result.err().unwrap().to_string(), \"Invalid header name\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', 1, 2, 3, 4]; // Array with mixed characters",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1135,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(parse_result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"custom-header\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"custom-header\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"custom-header\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = b\"\";",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src: &[u8] = b\"\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"\\xFF\"; // Invalid character",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"\\xFF\";",
                "    assert_eq!(HeaderName::from_bytes(src).is_err(), true);",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"123456\"; // Valid characters",
                "    let _ = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"123456\"; // Valid characters",
                "    let _ = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    let header_name = HeaderName::from_bytes(src).unwrap();",
                "    assert_eq!(header_name.as_str(), \"123456\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"valid\\x00header\"; // Contains null byte",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"valid\\x00header\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"accept\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.into_bytes().len(), input.len());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let expected_result = HeaderName::from_bytes(b\"custom-header\").unwrap();",
                "    assert!(matches!(expected_result.inner, Repr::Custom(_)));",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let expected_result = HeaderName::from_bytes(b\"custom-header\").unwrap();",
                "    assert_eq!(expected_result.as_str(), \"custom-header\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert_eq!(result.err().unwrap()._priv, ());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\xFF\"; // Invalid character that should trigger an error",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"\\xFF\"; // Invalid character that should trigger an error",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ValidHeader\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ValidHeader\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ValidHeader\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ValidHeader\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(matches!(result, Ok(_)));",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ValidHeader\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ValidHeader\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.unwrap().as_str() == \"ValidHeader\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"Invalid\\x00Header\"; // Contains null byte",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"Invalid\\x00Header\";",
                "    assert!(HeaderName::from_bytes(input).is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ThisHeaderIsWayTooLongToBeValid\"; // Length exceeds max limit",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ThisHeaderIsWayTooLongToBeValid\";",
                "    assert!(HeaderName::from_bytes(input).is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\x00\"; // Edge case with zero in the buffer",
                "    let _ = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"accept\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"a\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"a\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    let inner = result.unwrap().inner;",
                "    assert!(matches!(inner, Repr::Standard(_)));",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1120,
                1121,
                1122,
                1123,
                1124,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1136,
                1137,
                1138,
                1144,
                1145,
                1146,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxya\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let map_result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    assert!(map_result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1126,
                1128,
                1130,
                1132,
                1133,
                1134,
                1136,
                1137,
                1138,
                1144,
                1145,
                1146,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"accept-charset\");",
                "}"
            ],
            [
                1115,
                1116,
                1117,
                1118,
                1119,
                1149
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1134,
            "start_column": 24,
            "end_line": 1134,
            "end_column": 30,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(parse_result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"x-custom-header\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"x-custom-header\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\xFF\"; // Invalid character",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(parse_result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    let repr = hdr_name.inner;",
                "    assert!(matches!(repr, Repr::Custom(MaybeLower { lower: true, .. })));",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    let repr = hdr_name.inner;",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"X-HEADER\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    let repr = hdr_name.inner;",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"X-HEADER\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"valid-header-name-with-63-chars-in-length-valid-h\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
                "    let result_invalid = HeaderName::from_bytes(invalid_input);",
                "    assert!(result_invalid.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
                "    let result_invalid = HeaderName::from_bytes(invalid_input);",
                "    let empty_input: &[u8] = b\"\";",
                "    let result_empty = HeaderName::from_bytes(empty_input);",
                "    assert!(result_empty.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
                "    let result_invalid = HeaderName::from_bytes(invalid_input);",
                "    let empty_input: &[u8] = b\"\";",
                "    let result_empty = HeaderName::from_bytes(empty_input);",
                "    let too_long_input = b\"this-header-name-is-way-too-long-to-be-valid-and-exceeds-the-maximum-length-which-is-63-characters\";",
                "    let result_too_long = HeaderName::from_bytes(too_long_input);",
                "    assert!(result_too_long.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert_eq!(result.err().unwrap().to_string(), \"Invalid header name\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
                "    let result = HeaderName::from_bytes(input);",
                "    let buf = uninit_u8_array();",
                "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
                "    let result = HeaderName::from_bytes(input);",
                "    let input = &[b'a', b'b', b'c', 1, 2, 3, 4]; // Array with mixed characters",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(parse_result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
                "    let result = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    let hdr_name = parse_result.unwrap();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"custom-header\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"custom-header\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"custom-header\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = b\"\";",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src: &[u8] = b\"\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"\\xFF\"; // Invalid character",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"\\xFF\";",
                "    assert_eq!(HeaderName::from_bytes(src).is_err(), true);",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"123456\"; // Valid characters",
                "    let _ = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"123456\"; // Valid characters",
                "    let _ = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    let header_name = HeaderName::from_bytes(src).unwrap();",
                "    assert_eq!(header_name.as_str(), \"123456\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"valid\\x00header\"; // Contains null byte",
                "    let _ = HeaderName::from_bytes(src);",
                "    let src = b\"valid\\x00header\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"accept\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"accept\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"accept\";",
                "    let result = HeaderName::from_bytes(input);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.into_bytes().len(), input.len());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let expected_result = HeaderName::from_bytes(b\"custom-header\").unwrap();",
                "    assert!(matches!(expected_result.inner, Repr::Custom(_)));",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"custom-header\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let expected_result = HeaderName::from_bytes(b\"custom-header\").unwrap();",
                "    assert_eq!(expected_result.as_str(), \"custom-header\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert_eq!(result.err().unwrap()._priv, ());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\xFF\"; // Invalid character that should trigger an error",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"\\xFF\"; // Invalid character that should trigger an error",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ValidHeader\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ValidHeader\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ValidHeader\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ValidHeader\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(matches!(result, Ok(_)));",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ValidHeader\";",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ValidHeader\";",
                "    let result = HeaderName::from_bytes(input);",
                "    assert!(result.unwrap().as_str() == \"ValidHeader\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"Invalid\\x00Header\"; // Contains null byte",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"Invalid\\x00Header\";",
                "    assert!(HeaderName::from_bytes(input).is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"ThisHeaderIsWayTooLongToBeValid\"; // Length exceeds max limit",
                "    let _ = HeaderName::from_bytes(input);",
                "    let input = b\"ThisHeaderIsWayTooLongToBeValid\";",
                "    assert!(HeaderName::from_bytes(input).is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input = b\"\\x00\"; // Edge case with zero in the buffer",
                "    let _ = HeaderName::from_bytes(input);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"accept\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"a\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"a\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    let inner = result.unwrap().inner;",
                "    assert!(matches!(inner, Repr::Standard(_)));",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxya\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let mut buf = uninit_u8_array();",
                "    let map_result = parse_hdr(src, &mut buf, &HEADER_CHARS);",
                "    assert!(map_result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let src = b\"accept-charset\";",
                "    let result = HeaderName::from_bytes(src);",
                "    let header_name = result.unwrap();",
                "    assert_eq!(header_name.as_str(), \"accept-charset\");",
                "}"
            ],
            [
                {
                    "start_line": 1134,
                    "start_column": 24,
                    "end_line": 1134,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/name.rs"
}