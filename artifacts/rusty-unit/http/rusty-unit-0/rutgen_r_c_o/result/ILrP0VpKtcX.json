{
    "function_name": "http::header::map::header::map::HeaderMap<T>::remove_found",
    "tests": 135,
    "tests_lines": [
        25,
        25,
        25,
        25,
        26,
        26,
        26,
        26,
        26,
        39,
        39,
        39,
        39,
        39,
        20,
        20,
        20,
        20,
        39,
        39,
        39,
        39,
        28,
        34,
        34,
        34,
        34,
        34,
        34,
        35,
        35,
        35,
        35,
        35,
        35,
        35,
        35,
        35,
        35,
        36,
        36,
        36,
        36,
        36,
        32,
        32,
        32,
        49,
        49,
        49,
        50,
        50,
        50,
        50,
        31,
        31,
        31,
        31,
        31,
        31,
        32,
        32,
        32,
        32,
        18,
        18,
        21,
        21,
        23,
        27,
        27,
        27,
        27,
        25,
        26,
        27,
        30,
        30,
        31,
        31,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        22,
        22,
        22,
        22,
        27,
        27,
        27,
        27,
        24,
        24,
        30,
        30,
        30,
        30,
        36,
        36,
        36,
        36,
        36,
        36,
        36,
        16,
        16,
        19,
        19,
        19,
        19,
        11,
        11,
        11,
        20,
        20,
        23,
        23,
        23,
        23,
        23,
        16,
        16,
        16,
        16,
        19,
        19,
        19,
        19
    ],
    "oracles": 17,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 41.17647058823529,
    "tests_compiled": 40,
    "tests_compiled_rate": 29.629629629629626,
    "oracles_run": 7,
    "oracles_passed": 3,
    "oracles_passed_rate": 42.857142857142854,
    "tests_run": 40,
    "tests_passed": 18,
    "tests_passed_rate": 45.0,
    "lines": 37,
    "lines_covered": 20,
    "lines_coveraged_rate": 54.054054054054056,
    "branches": 14,
    "branches_covered": 5,
    "branches_coverage_rate": 35.714285714285715,
    "codes_lines": [
        1552,
        1553,
        1554,
        1555,
        1556,
        1557,
        1560,
        1563,
        1564,
        1565,
        1566,
        1567,
        1569,
        1570,
        1571,
        1572,
        1576,
        1577,
        1578,
        1579,
        1580,
        1584,
        1585,
        1586,
        1587,
        1588,
        1589,
        1590,
        1591,
        1592,
        1593,
        1594,
        1597,
        1600,
        1602,
        1604,
        1605
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.entries.len() == 2);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.indices[probe].is_some());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.is_empty() == false);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(entry.key == key1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.entries.len() == 1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.contains_key(key2));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(!header_map.contains_key(key1));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(entry.key, HeaderName::from_static(\"Key1\"));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(entry.value, HeaderValue::from_static(\"Value1\"));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.extra_values.is_empty());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(entry.key == key);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(entry.value == HeaderValue::from_static(\"Value1\"));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(entry.key, key2);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(header_map.entries.len(), 1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(header_map.extra_values.len(), 1);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.entries.is_empty());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert_eq!(header_map.keys_len(), 0);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.is_empty());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.capacity() >= 10);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    assert_eq!(map.len(), 1);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    assert!(!map.is_empty());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert_eq!(entry.key, key);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert_eq!(entry.value, value);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert_eq!(map.len(), 0);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert!(map.is_empty());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    assert_eq!(map.len(), 1);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    assert!(!map.is_empty());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    assert_eq!(map.keys_len(), 1);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    let probe = 0;",
                "    let found = 0;",
                "    let _entry = map.remove_found(probe, found);",
                "    assert_eq!(map.len(), 0);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    let probe = 0;",
                "    let found = 0;",
                "    let _entry = map.remove_found(probe, found);",
                "    assert!(map.is_empty());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    let probe = 0;",
                "    let found = 0;",
                "    let _entry = map.remove_found(probe, found);",
                "    assert_eq!(map.keys_len(), 0);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1580,
                1584,
                1602,
                1604,
                1605
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1560,
            "start_column": 16,
            "end_line": 1560,
            "end_column": 27,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 1566,
            "start_column": 24,
            "end_line": 1566,
            "end_column": 36,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1567,
            "start_column": 24,
            "end_line": 1567,
            "end_column": 47,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1576,
            "start_column": 20,
            "end_line": 1576,
            "end_column": 31,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1584,
            "start_column": 12,
            "end_line": 1584,
            "end_column": 36,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1589,
            "start_column": 24,
            "end_line": 1589,
            "end_column": 45,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1590,
            "start_column": 24,
            "end_line": 1590,
            "end_column": 72,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.entries.len() == 2);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.indices[probe].is_some());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    assert!(header_map.is_empty() == false);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(entry.key == key1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.entries.len() == 1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.contains_key(key2));",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(!header_map.contains_key(key1));",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(entry.key, HeaderName::from_static(\"Key1\"));",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(entry.value, HeaderValue::from_static(\"Value1\"));",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.extra_values.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let links = Links { next: 0, tail: 0 };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                "    prev: Link::Entry(0),",
                "    next: Link::Entry(0),",
                "    });",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(entry.key == key);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"Key1\");",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "    let found = 0;",
                "    let probe = 0;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(entry.value == HeaderValue::from_static(\"Value1\"));",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(entry.key, key2);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert!(header_map.indices[probe].is_none());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(header_map.entries.len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "    let links = Links { next: 0, tail: 1 };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                "    let found = 1;",
                "    let probe = 1;",
                "    let entry = header_map.remove_found(probe, found);",
                "    assert_eq!(header_map.extra_values.len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.entries.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert_eq!(header_map.keys_len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    assert!(header_map.capacity() >= 10);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    assert_eq!(map.len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    assert!(!map.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert_eq!(entry.key, key);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert_eq!(entry.value, value);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert_eq!(map.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    let probe = 0;",
                "    let found = 0;",
                "    let entry = map.remove_found(probe, found);",
                "    assert!(map.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    assert_eq!(map.len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    assert!(!map.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    assert_eq!(map.keys_len(), 1);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    let probe = 0;",
                "    let found = 0;",
                "    let _entry = map.remove_found(probe, found);",
                "    assert_eq!(map.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    let probe = 0;",
                "    let found = 0;",
                "    let _entry = map.remove_found(probe, found);",
                "    assert!(map.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    let probe = 0;",
                "    let found = 0;",
                "    let _entry = map.remove_found(probe, found);",
                "    assert_eq!(map.keys_len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs"
}