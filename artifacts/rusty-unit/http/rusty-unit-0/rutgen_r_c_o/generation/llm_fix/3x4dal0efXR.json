{
  "name": "http::header::map::header::map::HeaderMap<T>::try_reserve_one",
  "name_with_impl": "http::header::map::{impl#1}::try_reserve_one",
  "mod_info": {
    "name": "header::map",
    "loc": "src/header/mod.rs:73:1:73:9"
  },
  "visible": false,
  "loc": "src/header/map.rs:1694:5:1732:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is true\n",
        "// constraint: load_factor >= LOAD_FACTOR_THRESHOLD is true, with bound load_factor == LOAD_FACTOR_THRESHOLD\n",
        "// constraint: self.try_grow(new_cap)? is Err/None\n"
      ],
      "input_infer": "0 < len < 128, 8 <= capacity <= 16384, load_factor == 0.2, new_cap > MAX_SIZE\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.danger.is_red(), true);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.indices.iter().all(|pos| pos.is_none()), true);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.entries.len(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    // Simulating a load factor of exactly 0.2",
                  "    for _ in 0..2 { ",
                  "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    // Insert enough items to reach load factor threshold",
                  "    assert_eq!(header_map.len(), 2);",
                  "    ",
                  "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    // Simulating a load factor of exactly 0.2",
                  "    for _ in 0..2 { ",
                  "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    // Insert enough items to reach load factor threshold",
                  "    assert_eq!(header_map.len(), 2);",
                  "    ",
                  "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    // Simulating a load factor of exactly 0.2",
                  "    for _ in 0..2 { ",
                  "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    // Insert enough items to reach load factor threshold",
                  "    assert_eq!(header_map.len(), 2);",
                  "    ",
                  "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.danger.is_red(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    // Simulating a load factor of exactly 0.2",
                  "    for _ in 0..2 { ",
                  "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    // Insert enough items to reach load factor threshold",
                  "    assert_eq!(header_map.len(), 2);",
                  "    ",
                  "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.indices.iter().all(|pos| pos.is_none()), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    // Simulating a load factor of exactly 0.2",
                  "    for _ in 0..2 { ",
                  "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    // Insert enough items to reach load factor threshold",
                  "    assert_eq!(header_map.len(), 2);",
                  "    ",
                  "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8);",
                  "    for _ in 0..2 {",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.entries.len(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    // Insert enough items to exceed the load factor threshold",
                "    for _ in 0..4 { ",
                "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                "    assert_eq!(header_map.len(), 4);",
                "    ",
                "    // This should not trigger any error, but should attempt to grow",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    for _ in 0..4 {",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.len(), 4);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    for _ in 0..4 {",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.try_reserve_one().is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    // Insert enough items to exceed the load factor threshold",
                  "    for _ in 0..4 { ",
                  "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    }",
                  "",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    ",
                  "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                  "    assert_eq!(header_map.len(), 4);",
                  "    ",
                  "    // This should not trigger any error, but should attempt to grow",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    for _ in 0..4 {",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    // Insert enough items to exceed the load factor threshold",
                  "    for _ in 0..4 { ",
                  "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    }",
                  "",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    ",
                  "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                  "    assert_eq!(header_map.len(), 4);",
                  "    ",
                  "    // This should not trigger any error, but should attempt to grow",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    for _ in 0..4 {",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    }",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.try_reserve_one().is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(0);",
                "    ",
                "    // Simulate empty state",
                "    assert_eq!(header_map.len(), 0);",
                "    ",
                "    // This should initialize the capacity to 8",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    assert_eq!(header_map.capacity(), 0);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_red(), true);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.indices[0].is_none(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(0);",
                  "    ",
                  "    // Simulate empty state",
                  "    assert_eq!(header_map.len(), 0);",
                  "    ",
                  "    // This should initialize the capacity to 8",
                  "    let result = header_map.try_reserve_one();",
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(0);",
                  "    ",
                  "    // Simulate empty state",
                  "    assert_eq!(header_map.len(), 0);",
                  "    ",
                  "    // This should initialize the capacity to 8",
                  "    let result = header_map.try_reserve_one();",
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    assert_eq!(header_map.capacity(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(0);",
                  "    ",
                  "    // Simulate empty state",
                  "    assert_eq!(header_map.len(), 0);",
                  "    ",
                  "    // This should initialize the capacity to 8",
                  "    let result = header_map.try_reserve_one();",
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(0);",
                  "    ",
                  "    // Simulate empty state",
                  "    assert_eq!(header_map.len(), 0);",
                  "    ",
                  "    // This should initialize the capacity to 8",
                  "    let result = header_map.try_reserve_one();",
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_red(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(0);",
                  "    ",
                  "    // Simulate empty state",
                  "    assert_eq!(header_map.len(), 0);",
                  "    ",
                  "    // This should initialize the capacity to 8",
                  "    let result = header_map.try_reserve_one();",
                  "    let header_map = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.push(HeaderValue::new());",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.indices[0].is_none(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3914:9\n     |\n3914 |     let mut header_map = HeaderMap::with_capacity(0);\n     |         ^^^^^^^^^^^^^^   --------------------------- type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3914 |     let mut header_map: map::HeaderMap<T> = HeaderMap::with_capacity(0);\n     |                       +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3923:42\n     |\n3923 |     header_map.entries.push(HeaderValue::new());\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3923:42\n     |\n3923 |     header_map.entries.push(HeaderValue::new());\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3923:42\n     |\n3923 |     header_map.entries.push(HeaderValue::new());\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3923:42\n     |\n3923 |     header_map.entries.push(HeaderValue::new());\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(128);",
                "    ",
                "    // Fill to the max defined capacity",
                "    for i in 0..128 {",
                "        header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                "    }",
                "    ",
                "    // Now it should reach the maximum capacity",
                "    assert_eq!(header_map.len(), 128);",
                "    ",
                "    // Try to reserve beyond this should ultimately trigger a try_grow of size > MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..128 {",
                  "    header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    assert_eq!(header_map.len(), 128);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..128 {",
                  "    header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..128 {",
                  "    header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(matches!(result, Err(MaxSizeReached { .. })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(128);",
                  "   ",
                  "   // Fill to the max defined capacity",
                  "   for i in 0..128 {",
                  "       header_map.insert(format!(\"key{}\", i).as_str(), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    ",
                  "    // Now it should reach the maximum capacity",
                  "    assert_eq!(header_map.len(), 128);",
                  "    ",
                  "    // Try to reserve beyond this should ultimately trigger a try_grow of size > MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..128 {",
                  "    header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    assert_eq!(header_map.len(), 128);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    ",
                  "    // Fill to the max defined capacity",
                  "   for i in 0..128 {",
                  "       header_map.insert(format!(\"key{}\", i).as_str(), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    ",
                  "    // Now it should reach the maximum capacity",
                  "    assert_eq!(header_map.len(), 128);",
                  "    ",
                  "    // Try to reserve beyond this should ultimately trigger a try_grow of size > MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..128 {",
                  "    header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    ",
                  "    // Fill to the max defined capacity",
                  "   for i in 0..128 {",
                  "       header_map.insert(format!(\"key{}\", i).as_str(), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    ",
                  "    // Now it should reach the maximum capacity",
                  "    assert_eq!(header_map.len(), 128);",
                  "    ",
                  "    // Try to reserve beyond this should ultimately trigger a try_grow of size > MAX_SIZE",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..128 {",
                  "    header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));",
                  "    }",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(matches!(result, Err(MaxSizeReached { .. })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `String: IntoHeaderName` is not satisfied\n    --> src/header/map.rs:3928:23\n     |\n3928 |     header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));\n     |                ------ ^^^^^^^^^^^^^^^^^^^ the trait `IntoHeaderName` is not implemented for `String`\n     |                |\n     |                required by a bound introduced by this call\n     |\n     = help: the trait `IntoHeaderName` is implemented for `&'static str`\nnote: required by a bound in `map::HeaderMap::<T>::insert`\n    --> src/header/map.rs:1230:12\n     |\n1228 |     pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n     |            ------ required by a bound in this associated function\n1229 |     where\n1230 |         K: IntoHeaderName,\n     |            ^^^^^^^^^^^^^^ required by this bound in `HeaderMap::<T>::insert`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `String: IntoHeaderName` is not satisfied\n    --> src/header/map.rs:3928:23\n     |\n3928 |     header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));\n     |                ------ ^^^^^^^^^^^^^^^^^^^ the trait `IntoHeaderName` is not implemented for `String`\n     |                |\n     |                required by a bound introduced by this call\n     |\n     = help: the trait `IntoHeaderName` is implemented for `&'static str`\nnote: required by a bound in `map::HeaderMap::<T>::insert`\n    --> src/header/map.rs:1230:12\n     |\n1228 |     pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n     |            ------ required by a bound in this associated function\n1229 |     where\n1230 |         K: IntoHeaderName,\n     |            ^^^^^^^^^^^^^^ required by this bound in `HeaderMap::<T>::insert`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `String: IntoHeaderName` is not satisfied\n    --> src/header/map.rs:3928:23\n     |\n3928 |     header_map.insert(format!(\"key{}\", i), HeaderValue::from_static(\"value\"));\n     |                ------ ^^^^^^^^^^^^^^^^^^^ the trait `IntoHeaderName` is not implemented for `String`\n     |                |\n     |                required by a bound introduced by this call\n     |\n     = help: the trait `IntoHeaderName` is implemented for `&'static str`\nnote: required by a bound in `map::HeaderMap::<T>::insert`\n    --> src/header/map.rs:1230:12\n     |\n1228 |     pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n     |            ------ required by a bound in this associated function\n1229 |     where\n1230 |         K: IntoHeaderName,\n     |            ^^^^^^^^^^^^^^ required by this bound in `HeaderMap::<T>::insert`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    header_map.danger.set_yellow();",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    assert_eq!(header_map.len(), 3);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    header_map.danger.set_yellow();",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                  "    header_map.danger.set_red();",
                  "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    header_map.danger.set_yellow();",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                  "    header_map.danger.set_red();",
                  "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_red(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    ",
                  "    // Simulating conditions that should lead to rebuilding",
                  "    for _ in 0..3 {",
                  "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    ",
                  "    // Set entries to ensure rebuilding occurs",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    assert_eq!(header_map.len(), 3);",
                  "    ",
                  "    // Trigger a reserve which should lead to rebuilding",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    header_map.danger.set_yellow();",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    assert_eq!(header_map.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    ",
                  "    // Simulating conditions that should lead to rebuilding",
                  "    for _ in 0..3 {",
                  "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    ",
                  "    // Set entries to ensure rebuilding occurs",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    assert_eq!(header_map.len(), 3);",
                  "    ",
                  "    // Trigger a reserve which should lead to rebuilding",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    header_map.danger.set_yellow();",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                  "    header_map.danger.set_red();",
                  "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    ",
                  "    // Simulating conditions that should lead to rebuilding",
                  "    for _ in 0..3 {",
                  "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    }",
                  "    ",
                  "    // Simulate yellow danger state",
                  "    header_map.danger.set_yellow();",
                  "    ",
                  "    // Set entries to ensure rebuilding occurs",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    assert_eq!(header_map.len(), 3);",
                  "    ",
                  "    // Trigger a reserve which should lead to rebuilding",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                  "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                  "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                  "    header_map.danger.set_yellow();",
                  "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                  "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                  "    header_map.danger.set_red();",
                  "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_red(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is true\n",
        "// constraint: load_factor >= LOAD_FACTOR_THRESHOLD is true, with bound load_factor == LOAD_FACTOR_THRESHOLD\n",
        "// constraint: self.try_grow(new_cap)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < len <= 16384, len / indices.len() == 0.2, indices.len() <= 8192, entries.len() = 3276\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8192);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"test-key-1\").unwrap(),",
                "        value: HeaderValue::from(\"test-value-1\".to_string()),",
                "        links: None,",
                "    }; 3276];",
                "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
                "    ",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 8192);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.danger.is_green());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"test-key-1\"),",
                  "        value: HeaderValue::from(\"test-value-1\".to_string()),",
                  "        links: None,",
                  "    }; 3276];",
                  "   let i = 0; // Initialize `i` to a valid index",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
                  "   ",
                  "   let result = header_map.try_reserve_one();",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"test-key-1\"),",
                  "       value: HeaderValue::from(\"test-value-1\".to_string()),",
                  "       links: None,",
                  "   }; 3276];",
                  "  header_map.indices = (0..4096).map(|i| Pos::new(i, HashValue(1))).collect::<Vec<_>>().into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
                  "  ",
                  "  let result = header_map.try_reserve_one();",
                  "  let mut header_map = HeaderMap::with_capacity(8192);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test-key-1\"), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
                  "  header_map.indices = (0..4096).map(|i| Pos::new(i, HashValue(1))).collect::<Vec<_>>().into_boxed_slice();",
                  "   let result = header_map.try_reserve_one();",
                  "   assert_eq!(header_map.capacity(), 8192);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"test-key-1\").unwrap(),",
                  "       value: HeaderValue::from(\"test-value-1\".to_string()),",
                  "       links: None,",
                  "   }; 3276];",
                  "   let i = 0; // Define i",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:16\n     |\n3919 |         value: HeaderValue::from(\"test-value-1\".to_string()),\n     |                ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:64\n     |\n3928 | ...t { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: Non...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3928:95\n     |\n3928 |    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-va...\n     |                                                                                               ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3928:112\n     |\n3928 | ...t-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];\n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3930:5\n     |\n3930 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:15\n     |\n3919 |        value: HeaderValue::from(\"test-value-1\".to_string()),\n     |               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3927:109\n     |\n3927 | ...atic(\"test-key-1\"), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];\n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:13\n     |\n3918 |        key: HeaderName::from(\"test-key-1\").unwrap(),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:44\n     |\n3918 |        key: HeaderName::from(\"test-key-1\").unwrap(),\n     |                                            ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:15\n     |\n3919 |        value: HeaderValue::from(\"test-value-1\".to_string()),\n     |               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:65\n     |\n3928 | ...t { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: Non...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3928:96\n     |\n3928 |     header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-v...\n     |                                                                                                ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3928:113\n     |\n3928 | ...t-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];\n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3931:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3931 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3931 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 7 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8192);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"test-key-2\").unwrap(),",
                "        value: HeaderValue::from(\"test-value-2\".to_string()),",
                "        links: None,",
                "    }; 3276];",
                "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
                "    ",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert_eq!(header_map.danger.is_yellow(), true);"
                ],
                [
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert_eq!(header_map.entries.len(), 3276);"
                ],
                [
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert_eq!(header_map.indices.len(), 4096);"
                ],
                [
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert!(header_map.try_reserve_one().is_ok());"
                ],
                [
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert_eq!(header_map.danger.is_green(), true);"
                ],
                [
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert!(header_map.capacity() > 4096);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "       key: HeaderName::from_bytes(b\"test-key-2\").unwrap(),",
                  "       value: HeaderValue::from_str(\"test-value-2\").unwrap(),",
                  "       links: None,",
                  "    }; 3276];",
                  "   header_map.indices = vec![Pos::new(0, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
                  "   ",
                  "   let result = header_map.try_reserve_one();",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from_bytes(b\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "   header_map.indices = vec![Pos::new(0, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert_eq!(header_map.danger.is_yellow(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "   key: HeaderName::try_from(\"test-key-2\").unwrap(),",
                  "   value: HeaderValue::from(\"test-value-2\".to_string()),",
                  "   links: None,",
                  "}; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::try_from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];  ",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "    assert_eq!(header_map.entries.len(), 3276);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "  key: HeaderName::from_static(\"test-key-2\"),",
                  "  value: HeaderValue::from_static(\"test-value-2\"),",
                  "      links: None,",
                  "   }; 3276];",
                  "  header_map.indices = (0..4096).map(|i| Pos::new(i, HashValue(1))).collect::<Vec<_>>().into_boxed_slice(); // 4096 to maintain load factor",
                  "  ",
                  "  let result = header_map.try_reserve_one();",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test-key-2\"), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "   header_map.indices = (0..4096).map(|i| Pos::new(i, HashValue(1))).collect::<Vec<_>>().into_boxed_slice();",
                  "    assert_eq!(header_map.indices.len(), 4096);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "       key: HeaderName::try_from(\"test-key-2\").unwrap(),  ",
                  "        value: HeaderValue::from(\"test-value-2\".to_string()),",
                  "        links: None,",
                  "    }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow();",
                  "   header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::try_from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None });  ",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();  ",
                  "    assert!(header_map.try_reserve_one().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "  key: HeaderName::try_from(\"test-key-2\").unwrap(),",
                  "      value: HeaderValue::from(\"test-value-2\".to_string()),",
                  "      links: None,",
                  "  }; 3276];",
                  "  let i = 0; // Define `i` before its use",
                  "  header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
                  "  ",
                  "  let result = header_map.try_reserve_one();",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::try_from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
                  "  header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"test-key-2\"),",
                  "      value: HeaderValue::from_static(\"test-value-2\"),",
                  "      links: None,",
                  "    }; 3276];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test-key-2\"), value: HeaderValue::from_static(\"test-value-2\"), links: None }; 3276];",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
                  "   assert!(header_map.capacity() > 4096);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3926:119\n     |\n3926 | ...t-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];\n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3927:40\n     |\n3927 |     header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();\n     |                                        ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:11\n     |\n3919 |    value: HeaderValue::from(\"test-value-2\".to_string()),\n     |           ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3926:116\n     |\n3926 | ...t-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];  \n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3926:109\n     |\n3926 | ...atic(\"test-key-2\"), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];\n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3927:39\n     |\n3927 |    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();  \n     |                                       ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:16\n     |\n3919 |         value: HeaderValue::from(\"test-value-2\".to_string()),\n     |                ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3926:114\n     |\n3926 | ...t-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None });  \n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:14\n     |\n3919 |       value: HeaderValue::from(\"test-value-2\".to_string()),\n     |              ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3927:115\n     |\n3927 | ...t-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];\n     |                               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3927:39\n     |\n3927 |    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();\n     |                                       ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8192);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = Vec::new();",
                "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert!(header_map.danger.is_yellow());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_yellow(), false);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_green(), true);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.indices.len() > 8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert!(header_map.danger.is_yellow());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_yellow(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_green(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = Vec::new();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.len();",
                  "    header_map.indices.len();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.indices.len() > 8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3914:9\n     |\n3914 |     let mut header_map = HeaderMap::with_capacity(8192);\n     |         ^^^^^^^^^^^^^^   ------------------------------ type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3914 |     let mut header_map: map::HeaderMap<T> = HeaderMap::with_capacity(8192);\n     |                       +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3914:9\n     |\n3914 |     let mut header_map = HeaderMap::with_capacity(8192);\n     |         ^^^^^^^^^^^^^^   ------------------------------ type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3914 |     let mut header_map: map::HeaderMap<T> = HeaderMap::with_capacity(8192);\n     |                       +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3914:9\n     |\n3914 |     let mut header_map = HeaderMap::with_capacity(8192);\n     |         ^^^^^^^^^^^^^^   ------------------------------ type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3914 |     let mut header_map: map::HeaderMap<T> = HeaderMap::with_capacity(8192);\n     |                       +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3914:9\n     |\n3914 |     let mut header_map = HeaderMap::with_capacity(8192);\n     |         ^^^^^^^^^^^^^^   ------------------------------ type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3914 |     let mut header_map: map::HeaderMap<T> = HeaderMap::with_capacity(8192);\n     |                       +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3928:34\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3928 |     assert_eq!(header_map.danger.is_green(), true);\n     |                                  ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3928 |     assert_eq!(header_map.danger.is_red(), true);\n     |                                  ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3914:9\n     |\n3914 |     let mut header_map = HeaderMap::with_capacity(8192);\n     |         ^^^^^^^^^^^^^^   ------------------------------ type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3914 |     let mut header_map: map::HeaderMap<T> = HeaderMap::with_capacity(8192);\n     |                       +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8192);",
                "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
                "    header_map.entries = vec![Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"test-key-3\").unwrap(),",
                "        value: HeaderValue::from(\"test-value-3\".to_string()),",
                "        links: None,",
                "    }; 8192]; // fill it to maximum capacity",
                "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                "    ",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let len = header_map.entries.len();",
                  "    assert_eq!(len, 8192);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    assert!(header_map.danger.is_yellow());"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert!(header_map.try_grow(16384).is_ok());"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert!(header_map.danger.is_green());"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert!(header_map.capacity() > 8192);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"test-key-3\"),",
                  "       value: HeaderValue::from(\"test-value-3\".to_string()),",
                  "       links: None,",
                  "    }; 8192]; // fill it to maximum capacity",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    let len = header_map.entries.len();",
                  "    assert_eq!(len, 8192);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_green(); // starts green, will simulate a full capacity",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::try_from(\"test-key-3\").unwrap(),",
                  "       value: HeaderValue::from(\"test-value-3\".to_string()),",
                  "       links: None,",
                  "   }; 8192]; // fill it to maximum capacity",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                  "   ",
                  "   let result = header_map.try_reserve_one();",
                  "   let len = header_map.entries.len();",
                  "   assert!(header_map.danger.is_yellow());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_green(); // starts green, will simulate a full capacity",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"test-key-3\").unwrap(),",
                  "       value: HeaderValue::from_static(\"test-value-3\"),",
                  "       links: None,",
                  "   }; 8192]; // fill it to maximum capacity",
                  "   let i = 0; // Declare `i` for the scope",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                  "   ",
                  "   let result = header_map.try_reserve_one();",
                  "   let len = header_map.entries.len();",
                  "   let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_green(); // starts green, will simulate a full capacity",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::try_from(\"test-key-3\").expect(\"Failed to create HeaderName\"),",
                  "      value: HeaderValue::from_static(\"test-value-3\"),",
                  "       links: None,",
                  "   }; 8192]; // fill it to maximum capacity",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                  "   ",
                  "   let result = header_map.try_reserve_one();",
                  "   let len = header_map.entries.len();",
                  "   let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "   assert!(header_map.try_grow(16384).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(8192);",
                  "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
                  "    header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_bytes(b\"test-key-3\").unwrap(), // Use from_bytes instead",
                  "       value: HeaderValue::from(\"test-value-3\".to_string()),",
                  "       links: None,",
                  "   }; 8192]; // fill it to maximum capacity",
                  "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);  ",
                  "   header_map.danger.set_green(); // starts green, will simulate a full capacity  ",
                  "   header_map.entries = vec![Bucket {  ",
                  "       hash: HashValue(1),  ",
                  "  key: HeaderName::from_str(\"test-key-3\").unwrap(),  ",
                  "  value: HeaderValue::from(\"test-value-3\".to_string()),  ",
                  "  links: None,  ",
                  "   }; 8192]; // fill it to maximum capacity  ",
                  "   let i = 0;  ",
                  "    ",
                  "    let result = header_map.try_reserve_one();",
                  "    let len = header_map.entries.len();",
                  "    let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(8192);",
                  "   header_map.danger.set_green(); // starts green, will simulate a full capacity",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::try_from(\"test-key-3\").expect(\"valid header name\"),",
                  "      value: HeaderValue::from_static(\"test-value-3\"),",
                  "      links: None,",
                  "   }; 8192]; // fill it to maximum capacity",
                  "   header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
                  "   ",
                  "   let result = header_map.try_reserve_one();",
                  "   let len = header_map.entries.len();",
                  "   let load_factor = len as f32 / header_map.indices.len() as f32;",
                  "   assert!(header_map.capacity() > 8192);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length\n     |                                        ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:15\n     |\n3919 |        value: HeaderValue::from(\"test-value-3\".to_string()),\n     |               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:39\n     |\n3922 |    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length\n     |                                       ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:15\n     |\n3919 |        value: HeaderValue::from(\"test-value-3\".to_string()),\n     |               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:13\n     |\n3918 |        key: HeaderName::from(\"test-key-3\").unwrap(),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:44\n     |\n3918 |        key: HeaderName::from(\"test-key-3\").unwrap(),\n     |                                            ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:39\n     |\n3922 |    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length\n     |                                       ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length\n     |                                        ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:15\n     |\n3919 |        value: HeaderValue::from(\"test-value-3\".to_string()),\n     |               ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3927:5\n     |\n3927 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0277, E0369, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:20\n     |\n3918 |   key: HeaderName::from_str(\"test-key-3\").unwrap(),  \n     |                    ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n3906 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n3918 |   key: HeaderName::from(\"test-key-3\").unwrap(),  \n     |                    ~~~~\n\nerror[E0277]: the trait bound `value::HeaderValue: From<String>` is not satisfied\n    --> src/header/map.rs:3919:10\n     |\n3919 |   value: HeaderValue::from(\"test-value-3\".to_string()),  \n     |          ^^^^^^^^^^^ the trait `From<String>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3927:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3927 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3927 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:39\n     |\n3922 |    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length\n     |                                       ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is true\n",
        "// constraint: load_factor >= LOAD_FACTOR_THRESHOLD is false\n",
        "// constraint: index in self.indices.iter_mut() is true\n",
        "// constraint: index in self.indices.iter_mut() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < entries.len() < (indices.len() * LOAD_FACTOR_THRESHOLD), indices.len() == 128, entries.len() == 25, danger.is_yellow() == true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
                "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    load_factor < LOAD_FACTOR_THRESHOLD;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    header_map.rebuild();",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::from_static(\"default-header\"), value: HeaderValue::new(), links: None }; 25];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    load_factor < LOAD_FACTOR_THRESHOLD;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    header_map.rebuild();",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3916:127\n     |\n3916 | ...default-header\"), value: HeaderValue::new(), links: None }; 25];\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3925:5\n     |\n3925 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
                "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert!(load_factor < LOAD_FACTOR_THRESHOLD);"
                ],
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    let capacity_before_rebuild = header_map.capacity();",
                  "    header_map.rebuild();",
                  "    assert!(header_map.capacity() > capacity_before_rebuild);"
                ],
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    let capacity_before_rebuild = header_map.capacity();",
                  "    header_map.rebuild();",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    let capacity_before_rebuild = header_map.capacity();",
                  "    header_map.rebuild();",
                  "    assert!(header_map.danger.is_red());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"default_value\"), links: None }; 28];",
                  "   header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "   let result = header_map.try_reserve_one();",
                  "   let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "   assert!(load_factor < LOAD_FACTOR_THRESHOLD);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"default_value\"), links: None }; 28];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    let capacity_before_rebuild = header_map.capacity();",
                  "    header_map.rebuild();",
                  "    assert!(header_map.capacity() > capacity_before_rebuild);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    let capacity_before_rebuild = header_map.capacity();",
                  "    header_map.rebuild();",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::from_static(\"default-header\"), value: HeaderValue::new(), links: None }; 28];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
                  "    let capacity_before_rebuild = header_map.capacity();",
                  "    header_map.rebuild();",
                  "    assert!(header_map.danger.is_red());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:76\n     |\n3916 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"default_value\"), links...\n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:76\n     |\n3916 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"default_value\"), links...\n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:77\n     |\n3916 |     header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];\n     |                                                                             ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3916:104\n     |\n3916 |     header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];\n     |                                                                                                        ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3925:5\n     |\n3925 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3916:127\n     |\n3916 | ...default-header\"), value: HeaderValue::new(), links: None }; 28];\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries.clear();",
                "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(())); // expected return value/type: Ok(())"
                ],
                [
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    assert!(header_map.danger.is_yellow()); // check danger level is yellow"
                ],
                [
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    assert!(header_map.indices.len() == 8); // ensure capacity of indices is correct"
                ],
                [
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert!(load_factor < LOAD_FACTOR_THRESHOLD); // check load_factor is as expected"
                ],
                [
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red(); // transition to red danger level",
                  "    assert!(header_map.danger.is_red()); // check danger level is red"
                ],
                [
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red(); // transition to red danger level",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none()); // resetting indices",
                  "    assert!(header_map.indices.iter().all(|index| index.is_none())); // ensure all indices are none"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(())); // expected return value/type: Ok(())",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    assert!(header_map.danger.is_yellow()); // check danger level is yellow",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    assert!(header_map.indices.len() == 8); // ensure capacity of indices is correct",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    assert!(load_factor < LOAD_FACTOR_THRESHOLD); // check load_factor is as expected",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red(); // transition to red danger level",
                  "    assert!(header_map.danger.is_red()); // check danger level is red",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries.clear();",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
                  "    let result = header_map.try_reserve_one();",
                  "    header_map.danger.set_yellow(); // ensuring danger is yellow",
                  "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red(); // transition to red danger level",
                  "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none()); // resetting indices",
                  "    assert!(header_map.indices.iter().all(|index| index.is_none())); // ensure all indices are none",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3924:42\n     |\n3924 |     header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3926:5\n     |\n3926 |     assert_eq!(result, Ok(())); // expected return value/type: Ok(())\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3924:42\n     |\n3924 |     header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3924:42\n     |\n3924 |     header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3924:42\n     |\n3924 |     header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3924:42\n     |\n3924 |     header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3924:42\n     |\n3924 |     header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD\n     |                                          ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 20];",
                "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    for index in header_map.indices.iter_mut() {",
                  "    *index = Pos::none();",
                  "    }",
                  "    header_map.rebuild();",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    for index in header_map.indices.iter_mut() {",
                  "    *index = Pos::none();",
                  "    }",
                  "    header_map.rebuild();",
                  "    assert!(header_map.danger.is_red());"
                ],
                [
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    for index in header_map.indices.iter_mut() {",
                  "    *index = Pos::none();",
                  "    }",
                  "    header_map.rebuild();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 20];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    for index in header_map.indices.iter_mut() {",
                  "    *index = Pos::none();",
                  "    }",
                  "    header_map.rebuild();",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 20];  ",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    for index in header_map.indices.iter_mut() {",
                  "    *index = Pos::none();",
                  "    }",
                  "    header_map.rebuild();",
                  "    assert!(header_map.danger.is_red());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 20];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
                  "    header_map.danger.set_red();",
                  "    for index in header_map.indices.iter_mut() {",
                  "    *index = Pos::none();",
                  "    }",
                  "    header_map.rebuild();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:76\n     |\n3916 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 20];\n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3926:5\n     |\n3926 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:76\n     |\n3916 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 20];  \n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:76\n     |\n3916 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 20];\n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
                "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                "",
                "    let result = header_map.try_reserve_one();",
                "    // header_map.capacity should now be 256",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 256);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    // header_map.capacity should now be 256",
                  "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
                  "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 25];  ",
                  "   header_map.indices = vec![Pos::none(); 128].into_boxed_slice();  ",
                  " ",
                  "   let result = header_map.try_reserve_one();  ",
                  "   // header_map.capacity should now be 256  ",
                  "   let header_map = HeaderMap::<HeaderValue>::with_capacity(128);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 25];  ",
                  "   header_map.indices = vec![Pos::none(); 128].into_boxed_slice();  ",
                  "   let result = header_map.try_reserve_one();  ",
                  "   assert_eq!(header_map.capacity(), 256);  ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:77\n     |\n3916 |     header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];\n     |                                                                             ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3916:104\n     |\n3916 |     header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];\n     |                                                                                                        ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3923:77\n     |\n3923 |     header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];\n     |                                                                             ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3923:104\n     |\n3923 |     header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];\n     |                                                                                                        ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3926:5\n     |\n3926 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3916:76\n     |\n3916 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 25];  \n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3923:76\n     |\n3923 |    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::from_static(\"\"), links: None }; 25];  \n     |                                                                            ^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is true\n",
        "// constraint: load_factor >= LOAD_FACTOR_THRESHOLD is false\n",
        "// constraint: index in self.indices.iter_mut() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < self.entries.len() < 128, self.indices.len() > 128, self.danger.is_yellow() == true\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(256);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"key1\").unwrap(),",
                "        value: HeaderValue::from(\"value1\"),",
                "        links: None,",
                "    }; 127]; // 0 < self.entries.len() < 128",
                "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.danger.is_yellow(), true);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.entries.len() < 128);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.indices.len() > 128);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.danger.is_green(), true);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.capacity() > 256);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.entries.len(), 127);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "    value: HeaderValue::from(\"value1\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.indices.len() % 2, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "let mut header_map = HeaderMap::with_capacity(256);  ",
                  "header_map.danger.set_yellow();  ",
                  "header_map.entries = vec![Bucket {  ",
                  "    hash: HashValue(1),  ",
                  "    key: HeaderName::from_static(\"key1\"),  ",
                  "    value: HeaderValue::from_static(\"value1\"),  ",
                  "    links: None,  ",
                  "}; 127];  ",
                  " header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u16))).collect();  ",
                  " ",
                  "   let result = header_map.try_reserve_one();  ",
                  " let mut header_map = HeaderMap::with_capacity(256);  ",
                  " header_map.danger.set_yellow();  ",
                  " header_map.entries = vec![Bucket {  ",
                  " hash: HashValue(1),  ",
                  " key: HeaderName::from_static(\"key1\"),  ",
                  " value: HeaderValue::from_static(\"value1\"),  ",
                  "  links: None,",
                  "  }; 127];",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();",
                  "   assert_eq!(header_map.danger.is_yellow(), true);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"key1\"),",
                  "       value: HeaderValue::from_static(\"value1\"),",
                  "       links: None,",
                  "    }; 127]; // 0 < self.entries.len() < 128",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"key1\"),",
                  "   value: HeaderValue::from_static(\"value1\"),",
                  "   links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.entries.len() < 128);",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "      hash: HashValue(1),",
                  "     key: HeaderName::from_bytes(b\"key1\").unwrap(),",
                  "      value: HeaderValue::from(\"value1\"),",
                  "       links: None,",
                  "   }; 127]; // 0 < self.entries.len() < 128",
                  "   header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into(); // self.indices.len() > 128",
                  "",
                  "   let result = header_map.try_reserve_one();",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "  hash: HashValue(1),",
                  " key: HeaderName::from_bytes(b\"key1\").unwrap(),",
                  "  value: HeaderValue::from(\"value1\"),",
                  "  links: None,",
                  "   }; 127];",
                  "   header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();",
                  "   assert!(header_map.indices.len() > 128);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"key1\"),",
                  "  value: HeaderValue::from_static(\"value1\"),",
                  "       links: None,",
                  "    }; 127]; // 0 < self.entries.len() < 128",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"key1\").unwrap(),",
                  "   value: HeaderValue::from_static(\"value1\"),",
                  "   links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  " let mut header_map = HeaderMap::with_capacity(256);",
                  " header_map.danger.set_yellow();",
                  " header_map.entries = vec![Bucket {",
                  "     hash: HashValue(1),",
                  "     key: HeaderName::from_bytes(\"key1\".as_bytes()).unwrap(),",
                  "     value: HeaderValue::from_static(\"value1\"),",
                  "     links: None,",
                  " }; 127]; // 0 < self.entries.len() < 128",
                  " header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128",
                  "",
                  " let result = header_map.try_reserve_one();",
                  " let mut header_map = HeaderMap::with_capacity(256);",
                  " header_map.danger.set_yellow();",
                  " header_map.entries = vec![Bucket {",
                  " hash: HashValue(1),",
                  " key: HeaderName::from_bytes(\"key1\".as_bytes()).unwrap(),",
                  " value: HeaderValue::from_static(\"value1\"),",
                  "  links: None,",
                  "  }; 127];",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();",
                  "  let result = header_map.try_reserve_one();",
                  " assert_eq!(header_map.danger.is_yellow(), true);",
                  "}"
                ],
                [
                  "{",
                  " let mut header_map = HeaderMap::with_capacity(256);",
                  " header_map.danger.set_yellow();",
                  " header_map.entries = vec![Bucket {",
                  "     hash: HashValue(1),",
                  "     key: HeaderName::from_static(\"key1\"), // Changed to from_static",
                  "     value: HeaderValue::from_static(\"value1\"), // Changed to from_static",
                  "     links: None,",
                  " }; 127]; // 0 < self.entries.len() < 128",
                  " header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fix for undefined variable `i`",
                  "",
                  " let result = header_map.try_reserve_one();",
                  " let mut header_map = HeaderMap::with_capacity(256);",
                  " header_map.danger.set_yellow();",
                  " header_map.entries = vec![Bucket {",
                  " hash: HashValue(1),",
                  " key: HeaderName::from_static(\"key1\"), // Changed to from_static",
                  " value: HeaderValue::from_static(\"value1\"), // Changed to from_static",
                  " links: None,",
                  "  }; 127];",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fix for undefined variable `i`",
                  "  let result = header_map.try_reserve_one();",
                  "  assert!(header_map.capacity() > 256);",
                  "   let result = header_map.try_reserve_one();",
                  "   assert!(header_map.capacity() > 256);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"key1\").unwrap(),",
                  "       value: HeaderValue::from_static(\"value1\"),",
                  "       links: None,",
                  "   }; 127]; // 0 < self.entries.len() < 128",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128",
                  "",
                  "  let result = header_map.try_reserve_one();",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "  hash: HashValue(1),",
                  "  key: HeaderName::from(\"key1\").unwrap(),",
                  "  value: HeaderValue::from_static(\"value1\"),",
                  "  links: None,",
                  "  }; 127];",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();",
                  "  let result = header_map.try_reserve_one();",
                  "  assert_eq!(header_map.entries.len(), 127);",
                  "}"
                ],
                [
                  "{  ",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  "  header_map.entries = vec![Bucket {  ",
                  "      hash: HashValue(1),  ",
                  "     key: HeaderName::from_static(\"key1\"),  ",
                  "     value: HeaderValue::from_static(\"value1\"),  ",
                  "      links: None,  ",
                  "  }; 127];  ",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  ",
                  "",
                  "  let result = header_map.try_reserve_one();  ",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  "  header_map.entries = vec![Bucket {  ",
                  "      hash: HashValue(1),  ",
                  "      key: HeaderName::from(\"key1\").unwrap(),  ",
                  "      value: HeaderValue::from_static(\"value1\"),  ",
                  "      links: None,  ",
                  "   }; 127];  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  ",
                  "   let result = header_map.try_reserve_one();  ",
                  "    assert_eq!(header_map.indices.len() % 2, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:63\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();\n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();\n     |                                                               +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:53\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |                                                     ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3933:40\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3933:53\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |                                                     ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:26\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |     ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into(); // self.indices.len() > 128\n     |                                                                     +++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:26\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |     ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();\n     |                                                                     +++++++\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:39\n     |\n3922 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into(); // self.indices.len() > 128\n     |                                       ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:52\n     |\n3922 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into(); // self.indices.len() > 128\n     |                                                    ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3933:39\n     |\n3933 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();\n     |                                       ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3933:52\n     |\n3933 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();\n     |                                                    ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3919:14\n     |\n3919 |       value: HeaderValue::from(\"value1\"),\n     |              ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:10\n     |\n3930 |   value: HeaderValue::from(\"value1\"),\n     |          ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:53\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |                                                     ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3933:40\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3933:53\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |                                                     ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:26\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |     ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into(); // self.indices.len() > 128\n     |                                                                     +++++++\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:10\n     |\n3929 |     key: HeaderName::from(\"key1\").unwrap(),\n     |          ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3929:35\n     |\n3929 |     key: HeaderName::from(\"key1\").unwrap(),\n     |                                   ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:26\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |     ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3933 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();\n     |                                                                     +++++++\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 8 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:62\n     |\n3922 |  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128\n     |                                                    --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                    |\n     |                                                    arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // self.indices.len() > 128\n     |                                                              +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:63\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();\n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();\n     |                                                               +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:62\n     |\n3922 |  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fix for undefined variable `i`\n     |                                                    --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                    |\n     |                                                    arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // Fix for undefined variable `i`\n     |                                                              +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:63\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fix for undefined variable `i`\n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // Fix for undefined variable `i`\n     |                                                               +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:13\n     |\n3918 |        key: HeaderName::from(\"key1\").unwrap(),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:38\n     |\n3918 |        key: HeaderName::from(\"key1\").unwrap(),\n     |                                      ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:63\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128\n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // self.indices.len() > 128\n     |                                                               +        +++++++++++++++++++++\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:8\n     |\n3929 |   key: HeaderName::from(\"key1\").unwrap(),\n     |        ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3929:33\n     |\n3929 |   key: HeaderName::from(\"key1\").unwrap(),\n     |                                 ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:63\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();\n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();\n     |                                                               +        +++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:63\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  \n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();  \n     |                                                               +        +++++++++++++++++++++\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:12\n     |\n3929 |       key: HeaderName::from(\"key1\").unwrap(),  \n     |            ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3929:37\n     |\n3929 |       key: HeaderName::from(\"key1\").unwrap(),  \n     |                                     ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:64\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  \n     |                                                      --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                      |\n     |                                                      arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();  \n     |                                                                +        +++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(256);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from(\"key2\").unwrap(),",
                "        value: HeaderValue::from(\"value2\"),",
                "        links: None,",
                "    }; 127]; // 0 < self.entries.len() < 128",
                "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.danger.is_green(), false);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.danger.is_red(), false);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.danger.is_yellow(), true);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.try_grow(512).is_err());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.entries.len(), 127);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.indices.len(), 256);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "    hash: HashValue(2),",
                  "    key: HeaderName::from(\"key2\").unwrap(),",
                  "    value: HeaderValue::from(\"value2\"),",
                  "    links: None,",
                  "    }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket {  ",
                  "       hash: HashValue(2),  ",
                  "      key: HeaderName::from(\"key2\").unwrap(),  ",
                  "      value: HeaderValue::from_static(\"value2\"),  ",
                  "      links: None,  ",
                  "   }; 127]; // 0 < self.entries.len() < 128  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  ",
                  " ",
                  "   let result = header_map.try_reserve_one();  ",
                  "   let mut header_map = HeaderMap::with_capacity(256);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket {  ",
                  "   hash: HashValue(2),  ",
                  "   key: HeaderName::from(\"key2\").unwrap(),  ",
                  "   value: HeaderValue::from(\"value2\"),  ",
                  "   links: None,  ",
                  "   }; 127];  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  ",
                  "   assert_eq!(header_map.danger.is_green(), false);  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket {  ",
                  "       hash: HashValue(2),  ",
                  "     key: HeaderName::from_static(\"key2\"),  ",
                  "     value: HeaderValue::from_static(\"value2\"),  ",
                  "      links: None,  ",
                  "   }; 127]; // 0 < self.entries.len() < 128  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  ",
                  " ",
                  "   let result = header_map.try_reserve_one();  ",
                  "   let mut header_map = HeaderMap::with_capacity(256);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket {  ",
                  "  hash: HashValue(2),  ",
                  "  key: HeaderName::from_static(\"key2\"),  ",
                  "  value: HeaderValue::from_static(\"value2\"),  ",
                  "   links: None,  ",
                  "   }; 127];  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  ",
                  "   assert_eq!(header_map.danger.is_red(), false);  ",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "      hash: HashValue(2),",
                  "      key: HeaderName::from_str(\"key2\").expect(\"Invalid HeaderName\"),",
                  "      value: HeaderValue::from_static(\"value2\"),",
                  "      links: None,",
                  "  }; 127]; // 0 < self.entries.len() < 128",
                  " let i = 0; // Initialize `i` to a valid index.  ",
                  " header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();  ",
                  "  let result = header_map.try_reserve_one();",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "      hash: HashValue(2),",
                  "      key: HeaderName::from_str(\"key2\").expect(\"Invalid HeaderName\"),",
                  "      value: HeaderValue::from_static(\"value2\"),",
                  "      links: None,",
                  "  }; 127];",
                  "  header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();",
                  "  assert_eq!(header_map.danger.is_yellow(), true);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);",
                  "   header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {  ",
                  "      hash: HashValue(2),  ",
                  "     key: HeaderName::from_bytes(b\"key2\").unwrap(),  ",
                  "      value: HeaderValue::from_static(\"value2\"),  ",
                  "      links: None,  ",
                  "  }; 127]; // 0 < self.entries.len() < 128  ",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  ",
                  "",
                  "  let result = header_map.try_reserve_one();  ",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  "  header_map.entries = vec![Bucket {  ",
                  "  hash: HashValue(2),  ",
                  " key: HeaderName::from_bytes(b\"key2\").unwrap(),  ",
                  "  value: HeaderValue::from_static(\"value2\"),  ",
                  "   links: None,  ",
                  "   }; 127];  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  ",
                  "   assert!(header_map.try_grow(512).is_err());  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket {",
                  "       hash: HashValue(2),",
                  "      key: HeaderName::from_str(\"key2\").expect(\"Failed to convert to HeaderName\"),",
                  "      value: HeaderValue::from(\"value2\"),",
                  "      links: None,",
                  "  }; 127]; // 0 < self.entries.len() < 128",
                  "  let i = 0; // Assuming a default value for i",
                  "",
                  "   let result = header_map.try_reserve_one();",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "  hash: HashValue(2),",
                  "  key: HeaderName::from_str(\"key2\").expect(\"Failed to convert to HeaderName\"),",
                  "   value: HeaderValue::from(\"value2\"),",
                  "   links: None,",
                  "   }; 127];",
                  "   let i = 0; // Assuming a default value for i",
                  "    assert_eq!(header_map.entries.len(), 127);",
                  "}"
                ],
                [
                  "  fn test_try_reserve_one_32()",
                  "  {",
                  "      let mut header_map = HeaderMap::with_capacity(256);  ",
                  "      header_map.danger.set_yellow();  ",
                  "      header_map.entries = vec![Bucket {  ",
                  "          key: HeaderName::from_bytes(b\"key2\").unwrap(),  // Changed from from_str to from_bytes",
                  "          value: HeaderValue::from(\"value2\"),  ",
                  "          links: None,  ",
                  "      }; 127]; // 0 < self.entries.len() < 128  ",
                  "      header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  ",
                  "  ",
                  "      let result = header_map.try_reserve_one();  ",
                  "      let mut header_map = HeaderMap::with_capacity(256);  ",
                  "      header_map.danger.set_yellow();  ",
                  "      header_map.entries = vec![Bucket {  ",
                  "          hash: HashValue(2),  ",
                  "          key: HeaderName::from_bytes(b\"key2\").unwrap(),  // Changed from from_str to from_bytes",
                  "   value: HeaderValue::from(\"value2\"),  ",
                  "   links: None,  ",
                  "   }; 127];  ",
                  "   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  ",
                  "   assert_eq!(header_map.indices.len(), 256);  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);  ",
                  "    header_map.danger.set_yellow();  ",
                  "    header_map.entries = vec![Bucket {  ",
                  "        hash: HashValue(2),  ",
                  "        key: HeaderName::from_static(\"key2\"),  ",
                  "        value: HeaderValue::from_static(\"value2\"),  ",
                  "        links: None,  ",
                  " }; 127]; // 0 < self.entries.len() < 128  ",
                  " let i = 0; // Declare variable `i` to use for indices  ",
                  " ",
                  "  let result = header_map.try_reserve_one();",
                  "  let mut header_map = HeaderMap::with_capacity(256);",
                  "  header_map.danger.set_yellow();",
                  "  header_map.entries = vec![Bucket {",
                  "  hash: HashValue(2),",
                  "  key: HeaderName::from_static(\"key2\"),",
                  "  value: HeaderValue::from(\"value2\"),",
                  "   links: None,",
                  "   }; 127];",
                  "   header_map.indices = vec![Pos::new(i, HashValue(i as u16)); 256];",
                  "   assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:12\n     |\n3918 |       key: HeaderName::from(\"key2\").unwrap(),  \n     |            ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:37\n     |\n3918 |       key: HeaderName::from(\"key2\").unwrap(),  \n     |                                     ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:64\n     |\n3922 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  \n     |                                                      --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                      |\n     |                                                      arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // self.indices.len() > 128  \n     |                                                                +        +++++++++++++++++++++\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:9\n     |\n3929 |    key: HeaderName::from(\"key2\").unwrap(),  \n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3929:34\n     |\n3929 |    key: HeaderName::from(\"key2\").unwrap(),  \n     |                                  ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:11\n     |\n3930 |    value: HeaderValue::from(\"value2\"),  \n     |           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:64\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  \n     |                                                      --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                      |\n     |                                                      arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();  \n     |                                                                +        +++++++++++++++++++++\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3934:33\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3934 |    assert_eq!(header_map.danger.is_green(), false);  \n     |                                 ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3934 |    assert_eq!(header_map.danger.is_red(), false);  \n     |                                 ~~~~~~\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 8 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:64\n     |\n3922 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  \n     |                                                      --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                      |\n     |                                                      arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // self.indices.len() > 128  \n     |                                                                +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:64\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  \n     |                                                      --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                      |\n     |                                                      arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();  \n     |                                                                +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:24\n     |\n3918 |       key: HeaderName::from_str(\"key2\").expect(\"Invalid HeaderName\"),\n     |                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n3906 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n3918 |       key: HeaderName::from(\"key2\").expect(\"Invalid HeaderName\"),\n     |                        ~~~~\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3923:50\n     |\n3923 |  header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();  \n     |                                        --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                        |\n     |                                        arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3923 |  header_map.indices = vec![Pos::new(i, HashValue((i as u64).try_into().unwrap())); 256].into();  \n     |                                                  +        +++++++++++++++++++++\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3929:24\n     |\n3929 |       key: HeaderName::from_str(\"key2\").expect(\"Invalid HeaderName\"),\n     |                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n3906 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n3929 |       key: HeaderName::from(\"key2\").expect(\"Invalid HeaderName\"),\n     |                        ~~~~\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:51\n     |\n3933 |   header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();\n     |                                         --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                         |\n     |                                         arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |   header_map.indices = vec![Pos::new(i, HashValue((i as u64).try_into().unwrap())); 256].into();\n     |                                                   +        +++++++++++++++++++++\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:63\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // self.indices.len() > 128  \n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // self.indices.len() > 128  \n     |                                                               +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:64\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();  \n     |                                                      --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                      |\n     |                                                      arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3933 |    header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();  \n     |                                                                +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:24\n     |\n3918 |       key: HeaderName::from_str(\"key2\").expect(\"Failed to convert to HeaderName\"),\n     |                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n3906 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n3918 |       key: HeaderName::from(\"key2\").expect(\"Failed to convert to HeaderName\"),\n     |                        ~~~~\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3919:14\n     |\n3919 |       value: HeaderValue::from(\"value2\"),\n     |              ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3929:20\n     |\n3929 |   key: HeaderName::from_str(\"key2\").expect(\"Failed to convert to HeaderName\"),\n     |                    ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n3906 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n3929 |   key: HeaderName::from(\"key2\").expect(\"Failed to convert to HeaderName\"),\n     |                    ~~~~\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:11\n     |\n3930 |    value: HeaderValue::from(\"value2\"),\n     |           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: expected one of `->`, `where`, or `{`, found keyword `fn`\n    --> src/header/map.rs:3913:3\n     |\n3912 | fn test_try_reserve_one_32()\n     |                             - expected one of `->`, `where`, or `{`\n3913 |   fn test_try_reserve_one_32()\n     |   ^^ unexpected token\n\nerror[E0432]: unresolved import `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `HeaderMap` in `header::map`\n\nerror[E0432]: unresolved imports `self::map::AsHeaderName`, `self::map::Drain`, `self::map::Entry`, `self::map::GetAll`, `self::map::HeaderMap`, `self::map::IntoHeaderName`, `self::map::IntoIter`, `self::map::Iter`, `self::map::IterMut`, `self::map::Keys`, `self::map::MaxSizeReached`, `self::map::OccupiedEntry`, `self::map::VacantEntry`, `self::map::ValueDrain`, `self::map::ValueIter`, `self::map::ValueIterMut`, `self::map::Values`, `self::map::ValuesMut`\n  --> src/header/mod.rs:78:5\n   |\n78 |     AsHeaderName, Drain, Entry, GetAll, HeaderMap, IntoHeaderName, IntoIter, Iter, IterMut, Keys,\n   |     ^^^^^^^^^^^^  ^^^^^  ^^^^^  ^^^^^^  ^^^^^^^^^  ^^^^^^^^^^^^^^  ^^^^^^^^  ^^^^  ^^^^^^^  ^^^^ no `Keys` in `header::map`\n   |     |             |      |      |       |          |               |         |     |\n   |     |             |      |      |       |          |               |         |     no `IterMut` in `header::map`\n   |     |             |      |      |       |          |               |         no `Iter` in `header::map`\n   |     |             |      |      |       |          |               no `IntoIter` in `header::map`\n   |     |             |      |      |       |          no `IntoHeaderName` in `header::map`\n   |     |             |      |      |       no `HeaderMap` in `header::map`\n   |     |             |      |      no `GetAll` in `header::map`\n   |     |             |      no `Entry` in `header::map`\n   |     |             no `Drain` in `header::map`\n   |     no `AsHeaderName` in `header::map`\n79 |     MaxSizeReached, OccupiedEntry, VacantEntry, ValueDrain, ValueIter, ValueIterMut, Values,\n   |     ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^\n80 |     ValuesMut,\n   |     ^^^^^^^^^\n   |\n   = help: consider importing one of these structs instead:\n           std::collections::binary_heap::Drain\n           std::collections::hash_map::Drain\n           std::collections::hash_set::Drain\n           std::collections::vec_deque::Drain\n           std::string::Drain\n           std::vec::Drain\n   = help: consider importing one of these enums instead:\n           std::collections::btree_map::Entry\n           std::collections::hash_map::Entry\n           serde_json::map::Entry\n   = help: consider importing one of these structs instead:\n           std::array::IntoIter\n           std::collections::binary_heap::IntoIter\n           std::collections::btree_map::IntoIter\n           std::collections::btree_set::IntoIter\n           std::collections::hash_map::IntoIter\n           std::collections::hash_set::IntoIter\n           std::collections::linked_list::IntoIter\n           std::collections::vec_deque::IntoIter\n           std::option::IntoIter\n           std::result::IntoIter\n           std::sync::mpsc::IntoIter\n           std::vec::IntoIter\n           core::array::IntoIter\n           core::option::IntoIter\n           core::result::IntoIter\n           bytes::buf::IntoIter\n           serde_json::map::IntoIter\n   = help: consider importing one of these structs instead:\n           std::collections::binary_heap::Iter\n           std::collections::btree_map::Iter\n           std::collections::btree_set::Iter\n           std::collections::hash_map::Iter\n           std::collections::hash_set::Iter\n           std::collections::linked_list::Iter\n           std::collections::vec_deque::Iter\n           std::option::Iter\n           std::path::Iter\n           std::result::Iter\n           std::slice::Iter\n           std::sync::mpsc::Iter\n           core::option::Iter\n           core::result::Iter\n           core::slice::Iter\n           serde_json::map::Iter\n   = help: consider importing one of these structs instead:\n           std::collections::btree_map::IterMut\n           std::collections::hash_map::IterMut\n           std::collections::linked_list::IterMut\n           std::collections::vec_deque::IterMut\n           std::option::IterMut\n           std::result::IterMut\n           std::slice::IterMut\n           core::option::IterMut\n           core::result::IterMut\n           core::slice::IterMut\n           serde_json::map::IterMut\n   = help: consider importing one of these structs instead:\n           std::collections::btree_map::Keys\n           std::collections::hash_map::Keys\n           serde_json::map::Keys\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `http` (lib test) generated 13 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 13 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:10\n     |\n3930 |   value: HeaderValue::from(\"value2\"),\n     |          ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3933:25\n     |\n3933 |    header_map.indices = vec![Pos::new(i, HashValue(i as u16)); 256];\n     |    ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |    |\n     |    expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3933 |    header_map.indices = vec![Pos::new(i, HashValue(i as u16)); 256].into();\n     |                                                                    +++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(256);",
                "    header_map.danger.set_yellow();",
                "    header_map.entries = vec![Bucket {",
                "        hash: HashValue(3),",
                "        key: HeaderName::from(\"key3\").unwrap(),",
                "        value: HeaderValue::from(\"value3\"),",
                "        links: None,",
                "    }; 127]; // 0 < self.entries.len() < 128",
                "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
                "",
                "    let result = header_map.try_reserve_one();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert_eq!(header_map.try_reserve_one(), Ok(()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.danger.is_red());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.entries.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.indices.iter().all(|index| index.is_none()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  "  header_map.entries = vec![Bucket {  ",
                  "      hash: HashValue(3),  ",
                  "      key: HeaderName::from(\"key3\").expect(\"Failed to create HeaderName from string\"),  ",
                  "      value: HeaderValue::from(\"value3\"),  ",
                  "      links: None,  ",
                  "  }; 127]; // 0 < self.entries.len() < 128  ",
                  " header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u16))).collect(); // self.indices.len() > 128  ",
                  "",
                  "  let result = header_map.try_reserve_one();  ",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  "  header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").expect(\"Failed to create HeaderName from string\"), value: HeaderValue::from(\"value3\"), links: None, }; 127];  ",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();",
                  "    assert_eq!(header_map.try_reserve_one(), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(256);  ",
                  "   header_map.danger.set_yellow();  ",
                  "   header_map.entries = vec![Bucket {  ",
                  "       hash: HashValue(3),  ",
                  "       key: HeaderName::try_from(\"key3\").expect(\"Invalid header name\"),  ",
                  "       value: HeaderValue::from_static(\"value3\"),  ",
                  "       links: None,  ",
                  "   }; 127]; // 0 < self.entries.len() < 128  ",
                  "   let i = 0;  // Adding the `i` variable initialization before its first use.  ",
                  "",
                  "   let result = header_map.try_reserve_one();",
                  "   let mut header_map = HeaderMap::with_capacity(256);",
                  "   header_map.danger.set_yellow();",
                  "   header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::try_from(\"key3\").expect(\"Invalid header name\"), value: HeaderValue::from_static(\"value3\"), links: None, }; 127];  ",
                  "   header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];  ",
                  "    assert!(header_map.danger.is_red());",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  "  header_map.entries = vec![Bucket {  ",
                  "      hash: HashValue(3),  ",
                  " key: HeaderName::try_from(\"key3\").expect(\"Valid header name\"),  ",
                  " value: HeaderValue::from(\"value3\"),  ",
                  "      links: None,  ",
                  "  }; 127]; // 0 < self.entries.len() < 128  ",
                  "  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fixed initialization of indices  ",
                  " ",
                  "  let result = header_map.try_reserve_one();  ",
                  "  let mut header_map = HeaderMap::with_capacity(256);  ",
                  "  header_map.danger.set_yellow();  ",
                  " header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::try_from(\"key3\").expect(\"Valid header name\"), value: HeaderValue::from(\"value3\"), links: None, }; 127];  ",
                  " header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fixed initialization of indices  ",
                  " assert!(header_map.entries.is_empty());  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket {",
                  "        hash: HashValue(3),",
                  "        key: HeaderName::from(\"key3\").unwrap(),",
                  "        value: HeaderValue::from(\"value3\"),",
                  "        links: None,",
                  "    }; 127]; // 0 < self.entries.len() < 128",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
                  "",
                  "    let result = header_map.try_reserve_one();",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
                  "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
                  "    assert!(header_map.indices.iter().all(|index| index.is_none()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:12\n     |\n3918 |       key: HeaderName::from(\"key3\").expect(\"Failed to create HeaderName from string\"),  \n     |            ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `expect` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:37\n     |\n3918 |       key: HeaderName::from(\"key3\").expect(\"Failed to create HeaderName from string\"),  \n     |                                     ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `expect` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3919:14\n     |\n3919 |       value: HeaderValue::from(\"value3\"),  \n     |              ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3927:63\n     |\n3927 | ...t { hash: HashValue(3), key: HeaderName::from(\"key3\").expect(\"Failed to create HeaderName from string\"), value: HeaderValue::from(\"val...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `expect` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3927:88\n     |\n3927 |   header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").expect(\"Failed to create HeaderName from string\"),...\n     |                                                                                        ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `expect` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3927:146\n     |\n3927 | ...rName from string\"), value: HeaderValue::from(\"value3\"), links: None, }; 127];  \n     |                                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3928:63\n     |\n3928 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect();\n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3928 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect();\n     |                                                               +        +++++++++++++++++++++\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3929:5\n     |\n3929 |     assert_eq!(header_map.try_reserve_one(), Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 8 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3928:52\n     |\n3928 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];  \n     |                                          --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                          |\n     |                                          arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3928 |    header_map.indices = vec![Pos::new(i, HashValue((i as u64).try_into().unwrap())); 256];  \n     |                                                    +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3928:25\n     |\n3928 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];  \n     |    ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |    |\n     |    expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3928 |    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();  \n     |                                                                    +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3919:9\n     |\n3919 |  value: HeaderValue::from(\"value3\"),  \n     |         ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:63\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fixed initialization of indices  \n     |                                                     --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                     |\n     |                                                     arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3922 |   header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // Fixed initialization of indices  \n     |                                                               +        +++++++++++++++++++++\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3927:127\n     |\n3927 | ...Valid header name\"), value: HeaderValue::from(\"value3\"), links: None, }; 127];  \n     |                                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3928:62\n     |\n3928 |  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue(i as u64))).collect(); // Fixed initialization of indices  \n     |                                                    --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                                                    |\n     |                                                    arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3928 |  header_map.indices = (0..256).map(|i| Pos::new(i, HashValue((i as u64).try_into().unwrap()))).collect(); // Fixed initialization of indices  \n     |                                                              +        +++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:40\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3922:53\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |                                                     ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3928:40\n     |\n3928 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |                                        ^ not found in this scope\n\nerror[E0425]: cannot find value `i` in this scope\n    --> src/header/map.rs:3928:53\n     |\n3928 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |                                                     ^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:14\n     |\n3918 |         key: HeaderName::from(\"key3\").unwrap(),\n     |              ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3918:39\n     |\n3918 |         key: HeaderName::from(\"key3\").unwrap(),\n     |                                       ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3919:16\n     |\n3919 |         value: HeaderValue::from(\"value3\"),\n     |                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3922:26\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128\n     |     ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3922 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into(); // self.indices.len() > 128\n     |                                                                     +++++++\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3927:65\n     |\n3927 | ...t { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0599]: no method named `unwrap` found for struct `name::HeaderName` in the current scope\n    --> src/header/map.rs:3927:90\n     |\n3927 |     header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), li...\n     |                                                                                          ^^^^^^ method not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- method `unwrap` not found for this struct\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3927:107\n     |\n3927 | ...om(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];\n     |                                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3928:26\n     |\n3928 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];\n     |     ------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<[Pos]>`, found `Vec<Pos>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `Box<[map::Pos]>`\n                found struct `Vec<map::Pos>`\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: call `Into::into` on this expression to convert `Vec<map::Pos>` into `Box<[map::Pos]>`\n     |\n3928 |     header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256].into();\n     |                                                                     +++++++\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is false\n",
        "// constraint: len == self.capacity() is true\n",
        "// constraint: len == 0 is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "1 <= len <= MAX_SIZE, len == capacity, capacity > 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert_eq!(len, 1);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert_eq!(capacity, 16);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(!danger_state);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(header_map.entries.capacity() >= 16);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(header_map.indices.len() > 0);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(header_map.mask == 15);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert_eq!(len, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert_eq!(capacity, 16);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(!danger_state);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(header_map.entries.capacity() >= 16);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(header_map.indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let danger_state = header_map.danger.is_yellow();",
                  "    assert!(header_map.mask == 15);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.danger.is_yellow(), false);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.capacity(), 32);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.indices.len(), 32);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: HeaderName::from_static(\"test2\"),",
                  "        value: HeaderValue::from_static(\"value2\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.danger.is_yellow(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: HeaderName::from_static(\"test2\"),",
                  "        value: HeaderValue::from_static(\"value2\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: HeaderName::from_static(\"test2\"),",
                  "        value: HeaderValue::from_static(\"value2\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.capacity(), 32);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"test1\"),",
                  "        value: HeaderValue::from_static(\"value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: HeaderName::from_static(\"test2\"),",
                  "        value: HeaderValue::from_static(\"value2\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.indices.len(), 32);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(64);",
                "    for i in 0..8 {",
                "        header_map.entries.push(Bucket {",
                "            hash: HashValue(i as u64),",
                "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                "            links: None,",
                "        });",
                "    }",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert_eq!(len, 8);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert_eq!(capacity, 8);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert!(header_map.indices.len() == expected_indices_length);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert!(header_map.entries.capacity() == expected_entries_capacity);"
                ],
                [
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert!(header_map.danger.is_green());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..8 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert_eq!(len, 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..8 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert_eq!(capacity, 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..8 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert!(header_map.indices.len() == expected_indices_length);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..8 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert!(header_map.entries.capacity() == expected_entries_capacity);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..8 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let len = header_map.entries.len();",
                  "    let capacity = header_map.capacity();",
                  "    let expected_indices_length = 16;",
                  "    let expected_entries_capacity = 8;",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3928:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3928 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3928 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(128);",
                "    for i in 0..16 {",
                "        header_map.entries.push(Bucket {",
                "            hash: HashValue(i as u64),",
                "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                "            links: None,",
                "        });",
                "    }",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.danger.is_yellow() == false);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.len() == header_map.capacity());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.len() == 16);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert_eq!(header_map.try_reserve_one(), Ok(()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.capacity() > 16);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.danger.is_yellow() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.len() == header_map.capacity());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.len() == 16);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert_eq!(header_map.try_reserve_one(), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i as u64),",
                  "            key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..16 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i as u64),",
                  "    key: HeaderName::from_static(&format!(\"test{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    assert!(header_map.capacity() > 16);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3927:21\n     |\n3927 |     hash: HashValue(i as u64),\n     |           --------- ^^^^^^^^ expected `u16`, found `u64`\n     |           |\n     |           arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3927 |     hash: HashValue((i as u64).try_into().unwrap()),\n     |                     +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3927:21\n     |\n3927 |     hash: HashValue(i as u64),\n     |           --------- ^^^^^^^^ expected `u16`, found `u64`\n     |           |\n     |           arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3927 |     hash: HashValue((i as u64).try_into().unwrap()),\n     |                     +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3927:21\n     |\n3927 |     hash: HashValue(i as u64),\n     |           --------- ^^^^^^^^ expected `u16`, found `u64`\n     |           |\n     |           arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3927 |     hash: HashValue((i as u64).try_into().unwrap()),\n     |                     +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3927:21\n     |\n3927 |     hash: HashValue(i as u64),\n     |           --------- ^^^^^^^^ expected `u16`, found `u64`\n     |           |\n     |           arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3927 |     hash: HashValue((i as u64).try_into().unwrap()),\n     |                     +        +++++++++++++++++++++\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3933:5\n     |\n3933 |     assert_eq!(header_map.try_reserve_one(), Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:29\n     |\n3917 |             hash: HashValue(i as u64),\n     |                   --------- ^^^^^^^^ expected `u16`, found `u64`\n     |                   |\n     |                   arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3917 |             hash: HashValue((i as u64).try_into().unwrap()),\n     |                             +        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3927:21\n     |\n3927 |     hash: HashValue(i as u64),\n     |           --------- ^^^^^^^^ expected `u16`, found `u64`\n     |           |\n     |           arguments to this struct are incorrect\n     |\nnote: tuple struct defined here\n    --> src/header/map.rs:260:8\n     |\n260  | struct HashValue(u16);\n     |        ^^^^^^^^^\nhelp: you can convert a `u64` to a `u16` and panic if the converted value doesn't fit\n     |\n3927 |     hash: HashValue((i as u64).try_into().unwrap()),\n     |                     +        +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is false\n",
        "// constraint: len == self.capacity() is true\n",
        "// constraint: len == 0 is true\n",
        "// constraint: self.try_grow(raw_cap << 1)? is Err/None\n"
      ],
      "input_infer": "0 <= self.danger <= 1, len == 0, capacity == 0, raw_cap <= MAX_SIZE - 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.danger.is_green());"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.capacity(), 16);"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.entries.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.indices.len(), 16);"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.capacity(), 16);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.entries.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.indices.len(), 16);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3919:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3919 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3919 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert!(header_map.danger.is_red());"
                ],
                [
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert_eq!(header_map.entries.len(), 0);"
                ],
                [
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert_eq!(header_map.capacity(), 0);"
                ],
                [
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));"
                ],
                [
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert_eq!(header_map.mask, 0);"
                ],
                [
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert!(header_map.try_grow(0).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert!(header_map.danger.is_red());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert_eq!(header_map.entries.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert_eq!(header_map.capacity(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert_eq!(header_map.mask, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();",
                  "    assert!(header_map.try_grow(0).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:42\n     |\n3915 |     let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                         |\n     |                         expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:38\n     |\n3917 |     let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                     --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                     |\n     |                     expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:42\n     |\n3915 |     let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                         |\n     |                         expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:38\n     |\n3917 |     let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                     --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                     |\n     |                     expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:42\n     |\n3915 |     let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                         |\n     |                         expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:38\n     |\n3917 |     let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                     --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                     |\n     |                     expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:42\n     |\n3915 |     let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                         |\n     |                         expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:38\n     |\n3917 |     let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                     --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                     |\n     |                     expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:42\n     |\n3915 |     let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                         |\n     |                         expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:38\n     |\n3917 |     let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                     --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                     |\n     |                     expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:42\n     |\n3915 |     let mut header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                         --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                         |\n     |                         expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3917:38\n     |\n3917 |     let header_map: HeaderMap<u32> = HeaderMap::try_with_capacity(MAX_SIZE).unwrap_err();\n     |                     --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `HeaderMap<u32>`, found `MaxSizeReached`\n     |                     |\n     |                     expected due to this\n     |\n     = note: expected struct `map::HeaderMap<u32>`\n                found struct `map::MaxSizeReached`\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                "    header_map.danger.set_red();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.entries.len() == 1);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.danger.is_red());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.indices.len() == 1);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.capacity() == 1);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.entries.capacity() == usable_capacity(8));"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.mask == 7);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.indices[0].is_none());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.try_grow(2).is_err());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.try_grow(8).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.entries.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.danger.is_red());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.indices.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.capacity() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.entries.capacity() == usable_capacity(8));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.mask == 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.indices[0].is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.try_grow(2).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });",
                  "    header_map.danger.set_red();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(1);",
                  "    assert!(header_map.try_grow(8).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/header/map.rs:3915:44\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            ^ expected `HashValue`, found integer\n     |\nhelp: try wrapping the expression in `header::map::HashValue`\n     |\n3915 |     header_map.entries.push(Bucket { hash: header::map::HashValue(1), key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                            +++++++++++++++++++++++ +\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:52\n     |\n3915 |     header_map.entries.push(Bucket { hash: 1, key: HeaderName::from(\"Test\"), value: 5, links: None });\n     |                                                    ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.try_reserve_one().is_ok());"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.capacity() == 8);"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.danger.is_green());"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.entries.len() == 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.indices.len() == 8);"
                ],
                [
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.mask == 7);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.try_reserve_one().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.capacity() == 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.entries.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.indices.len() == 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                  "    header_map.len();",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.mask == 7);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3921:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3921 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3921 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                true,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is false\n",
        "// constraint: len == self.capacity() is true\n",
        "// constraint: len == 0 is true\n",
        "// constraint: self.try_grow(raw_cap << 1)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "len = 0, capacity = 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 8);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.danger.is_yellow());"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.entries.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.capacity(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.indices.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.try_reserve_one(), Ok(()));"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.danger.is_green());"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert_eq!(header_map.capacity(), 8);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.indices.len() > 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.entries.capacity() > 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.entries.len() == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert!(header_map.danger.is_yellow());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.entries.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.capacity(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.indices.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    assert_eq!(header_map.try_reserve_one(), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert_eq!(header_map.capacity(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.entries.capacity() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow(); // Set danger to yellow",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_yellow();",
                  "    header_map.danger.set_green();",
                  "    assert!(header_map.entries.len() == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3919:5\n     |\n3919 |     assert_eq!(header_map.try_reserve_one(), Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3920:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3920 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3920 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                true,
                true,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    assert_eq!(header_map.capacity(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert!(header_map.capacity() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    // Ensure the length and capacity are both zero",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    // Ensure the length and capacity are both zero",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    assert_eq!(header_map.capacity(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    // Ensure the length and capacity are both zero",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green(); // Set danger to green",
                  "    // Ensure the length and capacity are both zero",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert!(header_map.capacity() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: self.danger.is_yellow() is false\n",
        "// constraint: len == self.capacity() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 < len < MAX_SIZE, len < capacity() <= MAX_SIZE\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(0),",
                "        key: HeaderName::from_static(\"Key1\"),",
                "        value: HeaderValue::from_static(\"Value1\"),",
                "        links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(0),",
                  "    key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from_static(\"Value1\"),",
                  "    links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    let expected_entries_len = 1;",
                  "    let expected_capacity = usable_capacity(16);",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.entries.len(), expected_entries_len);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(0),",
                  "    key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from_static(\"Value1\"),",
                  "    links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    let expected_entries_len = 1;",
                  "    let expected_capacity = usable_capacity(16);",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.capacity(), expected_capacity);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(0),",
                  "    key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from_static(\"Value1\"),",
                  "    links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    let expected_entries_len = 1;",
                  "    let expected_capacity = usable_capacity(16);",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert!(header_map.danger.is_green());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(0),",
                  "        key: HeaderName::from_static(\"Key1\"),",
                  "        value: HeaderValue::from_static(\"Value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(0),",
                  "    key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from_static(\"Value1\"),",
                  "    links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    let expected_entries_len = 1;",
                  "    let expected_capacity = usable_capacity(16);",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.entries.len(), expected_entries_len);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(0),",
                  "        key: HeaderName::from_static(\"Key1\"),",
                  "        value: HeaderValue::from_static(\"Value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(0),",
                  "    key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from_static(\"Value1\"),",
                  "    links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    let expected_entries_len = 1;",
                  "    let expected_capacity = usable_capacity(16);",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert_eq!(header_map.capacity(), expected_capacity);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(0),",
                  "        key: HeaderName::from_static(\"Key1\"),",
                  "        value: HeaderValue::from_static(\"Value1\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let mut header_map = HeaderMap::with_capacity(16);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(0),",
                  "    key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from_static(\"Value1\"),",
                  "    links: None,",
                  "    });",
                  "    header_map.danger.set_green();",
                  "    let expected_entries_len = 1;",
                  "    let expected_capacity = usable_capacity(16);",
                  "    header_map.try_reserve_one().unwrap();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3934:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3934 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3934 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    for i in 0..15 {",
                "        header_map.entries.push(Bucket {",
                "            hash: HashValue(i),",
                "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                "            links: None,",
                "        });",
                "    }",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.entries.len(), initial_len);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), initial_capacity);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.danger.is_green());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    for i in 0..15 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    for i in 0..15 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.entries.len(), initial_len);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    for i in 0..15 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), initial_capacity);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(32);",
                  "    for i in 0..15 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(32);",
                  "    let initial_len = 15;",
                  "    let initial_capacity = 32;",
                  "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
                  "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<(), map::MaxSizeReached>`\n    --> src/header/map.rs:3945:5\n     |\n3945 |     assert_eq!(result, Ok(()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::result::Result<(), map::MaxSizeReached>\n     |     std::result::Result<(), map::MaxSizeReached>\n     |\nnote: an implementation of `PartialEq` might be missing for `map::MaxSizeReached`\n    --> src/header/map.rs:217:1\n     |\n217  | pub struct MaxSizeReached {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::MaxSizeReached` with `#[derive(PartialEq)]`\n     |\n217  + #[derive(PartialEq)]\n218  | pub struct MaxSizeReached {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `initial_capacity`\n    --> src/header/map.rs:3927:9\n     |\n3927 |     let initial_capacity = 32;\n     |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_capacity`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result`\n    --> src/header/map.rs:3944:9\n     |\n3944 |     let result = header_map.try_reserve_one();\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n\nerror[E0596]: cannot borrow `header_map.entries` as mutable, as `header_map` is not declared as mutable\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(32);\n     |         ^^^^^^^^^^ not mutable\n...\n3928 |     header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"),...\n     |     ------------------ cannot borrow as mutable\n3929 |     header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"),...\n     |     ------------------ cannot borrow as mutable\n3930 |     header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"),...\n     |     ------------------ cannot borrow as mutable\n3931 |     header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"),...\n     |     ------------------ cannot borrow as mutable\n3932 |     header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"),...\n     |     ------------------ cannot borrow as mutable\n3933 |     header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"),...\n     |     ------------------ cannot borrow as mutable\n3934 |     header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"),...\n     |     ------------------ cannot borrow as mutable\n3935 |     header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"),...\n     |     ------------------ cannot borrow as mutable\n3936 |     header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"),...\n     |     ------------------ cannot borrow as mutable\n     |\n     = note: ...and 7 other attempted mutable borrows\nhelp: consider changing this to be mutable\n     |\n3925 |     let mut header_map = HeaderMap::with_capacity(32);\n     |         +++\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0596, E0716.\nFor more information about an error, try `rustc --explain E0596`.\nwarning: `http` (lib test) generated 16 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 16 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `initial_len`\n    --> src/header/map.rs:3926:9\n     |\n3926 |     let initial_len = 15;\n     |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_len`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result`\n    --> src/header/map.rs:3944:9\n     |\n3944 |     let result = header_map.try_reserve_one();\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n\nerror[E0596]: cannot borrow `header_map.entries` as mutable, as `header_map` is not declared as mutable\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(32);\n     |         ^^^^^^^^^^ not mutable\n...\n3928 |     header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"),...\n     |     ------------------ cannot borrow as mutable\n3929 |     header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"),...\n     |     ------------------ cannot borrow as mutable\n3930 |     header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"),...\n     |     ------------------ cannot borrow as mutable\n3931 |     header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"),...\n     |     ------------------ cannot borrow as mutable\n3932 |     header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"),...\n     |     ------------------ cannot borrow as mutable\n3933 |     header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"),...\n     |     ------------------ cannot borrow as mutable\n3934 |     header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"),...\n     |     ------------------ cannot borrow as mutable\n3935 |     header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"),...\n     |     ------------------ cannot borrow as mutable\n3936 |     header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"),...\n     |     ------------------ cannot borrow as mutable\n     |\n     = note: ...and 7 other attempted mutable borrows\nhelp: consider changing this to be mutable\n     |\n3925 |     let mut header_map = HeaderMap::with_capacity(32);\n     |         +++\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0596, E0716.\nFor more information about an error, try `rustc --explain E0596`.\nwarning: `http` (lib test) generated 16 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 16 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3945:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3945 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3945 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(64);",
                "    for i in 0..31 {",
                "        header_map.entries.push(Bucket {",
                "            hash: HashValue(i),",
                "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                "            links: None,",
                "        });",
                "    }",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 128);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.len(), 31);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.danger.is_green());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 128);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.len(), 31);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(64);",
                  "    for i in 0..31 {",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(i),",
                  "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "    links: None,",
                  "    });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0596]: cannot borrow `header_map.danger` as mutable, as `header_map` is not declared as mutable\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(64);\n     |         ^^^^^^^^^^ not mutable\n3926 |     for i in 0..31 {\n3927 |     header_map.entries.push(Bucket {\n     |     ------------------ cannot borrow as mutable\n...\n3934 |     header_map.danger.set_green();\n     |     ----------------- cannot borrow as mutable\n3935 |     let result = header_map.try_reserve_one();\n     |                  ---------- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n3925 |     let mut header_map = HeaderMap::with_capacity(64);\n     |         +++\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3930:38\n     |\n3930 |     value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |            --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |            |                         |\n     |            |                         creates a temporary value which is freed while still in use\n     |            argument requires that borrow lasts for `'static`\n3931 |     links: None,\n3932 |     });\n     |       - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3929:35\n     |\n3929 |     key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |          -------------------------^^^^^^^^^^^^^^^^^^^-\n     |          |                        |\n     |          |                        creates a temporary value which is freed while still in use\n     |          argument requires that borrow lasts for `'static`\n...\n3932 |     });\n     |       - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0596, E0716.\nFor more information about an error, try `rustc --explain E0596`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `result`\n    --> src/header/map.rs:3935:9\n     |\n3935 |     let result = header_map.try_reserve_one();\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0596]: cannot borrow `header_map.danger` as mutable, as `header_map` is not declared as mutable\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(64);\n     |         ^^^^^^^^^^ not mutable\n3926 |     for i in 0..31 {\n3927 |     header_map.entries.push(Bucket {\n     |     ------------------ cannot borrow as mutable\n...\n3934 |     header_map.danger.set_green();\n     |     ----------------- cannot borrow as mutable\n3935 |     let result = header_map.try_reserve_one();\n     |                  ---------- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n3925 |     let mut header_map = HeaderMap::with_capacity(64);\n     |         +++\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3930:38\n     |\n3930 |     value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |            --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |            |                         |\n     |            |                         creates a temporary value which is freed while still in use\n     |            argument requires that borrow lasts for `'static`\n3931 |     links: None,\n3932 |     });\n     |       - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3929:35\n     |\n3929 |     key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |          -------------------------^^^^^^^^^^^^^^^^^^^-\n     |          |                        |\n     |          |                        creates a temporary value which is freed while still in use\n     |          argument requires that borrow lasts for `'static`\n...\n3932 |     });\n     |       - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0596, E0716.\nFor more information about an error, try `rustc --explain E0596`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `result`\n    --> src/header/map.rs:3935:9\n     |\n3935 |     let result = header_map.try_reserve_one();\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0596]: cannot borrow `header_map.danger` as mutable, as `header_map` is not declared as mutable\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(64);\n     |         ^^^^^^^^^^ not mutable\n3926 |     for i in 0..31 {\n3927 |     header_map.entries.push(Bucket {\n     |     ------------------ cannot borrow as mutable\n...\n3934 |     header_map.danger.set_green();\n     |     ----------------- cannot borrow as mutable\n3935 |     let result = header_map.try_reserve_one();\n     |                  ---------- cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n3925 |     let mut header_map = HeaderMap::with_capacity(64);\n     |         +++\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3930:38\n     |\n3930 |     value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |            --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |            |                         |\n     |            |                         creates a temporary value which is freed while still in use\n     |            argument requires that borrow lasts for `'static`\n3931 |     links: None,\n3932 |     });\n     |       - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3929:35\n     |\n3929 |     key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |          -------------------------^^^^^^^^^^^^^^^^^^^-\n     |          |                        |\n     |          |                        creates a temporary value which is freed while still in use\n     |          argument requires that borrow lasts for `'static`\n...\n3932 |     });\n     |       - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0596, E0716.\nFor more information about an error, try `rustc --explain E0596`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3936:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3936 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3936 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(128);",
                "    for i in 0..63 {",
                "        header_map.entries.push(Bucket {",
                "            hash: HashValue(i),",
                "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                "            links: None,",
                "        });",
                "    }",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.indices.len(), initial_capacity);"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.entries.len(), initial_length);"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.danger.is_yellow(), false);"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.danger.is_green(), true);"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert!(header_map.try_grow(new_capacity).is_ok());"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.indices.len(), new_capacity);"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.entries.len(), initial_length);"
                ],
                [
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.danger.is_green(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.indices.len(), initial_capacity);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.entries.len(), initial_length);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.danger.is_yellow(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.danger.is_green(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert!(header_map.try_grow(new_capacity).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.indices.len(), new_capacity);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.entries.len(), initial_length);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(128);",
                  "    for i in 0..63 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let initial_length = header_map.entries.len();",
                  "    let initial_capacity = header_map.capacity();",
                  "    let new_capacity = initial_capacity * 2;",
                  "    assert_eq!(header_map.danger.is_green(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `initial_length`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let initial_length = header_map.entries.len();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_length`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `new_capacity`\n    --> src/header/map.rs:3927:9\n     |\n3927 |     let new_capacity = initial_capacity * 2;\n     |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_capacity`\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 16 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 16 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `new_capacity`\n    --> src/header/map.rs:3927:9\n     |\n3927 |     let new_capacity = initial_capacity * 2;\n     |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_capacity`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `initial_length`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let initial_length = header_map.entries.len();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_length`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `new_capacity`\n    --> src/header/map.rs:3927:9\n     |\n3927 |     let new_capacity = initial_capacity * 2;\n     |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_capacity`\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 16 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 16 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3928:34\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3928 |     assert_eq!(header_map.danger.is_green(), true);\n     |                                  ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3928 |     assert_eq!(header_map.danger.is_red(), true);\n     |                                  ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `initial_length`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let initial_length = header_map.entries.len();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_length`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `initial_length`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let initial_length = header_map.entries.len();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_length`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `new_capacity`\n    --> src/header/map.rs:3927:9\n     |\n3927 |     let new_capacity = initial_capacity * 2;\n     |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_capacity`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3919:46\n     |\n3919 |             value: HeaderValue::from_static(&format!(\"Value{}\", i)),\n     |                    --------------------------^^^^^^^^^^^^^^^^^^^^^-\n     |                    |                         |\n     |                    |                         creates a temporary value which is freed while still in use\n     |                    argument requires that borrow lasts for `'static`\n3920 |             links: None,\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3918:43\n     |\n3918 |             key: HeaderName::from_static(&format!(\"Key{}\", i)),\n     |                  -------------------------^^^^^^^^^^^^^^^^^^^-\n     |                  |                        |\n     |                  |                        creates a temporary value which is freed while still in use\n     |                  argument requires that borrow lasts for `'static`\n...\n3921 |         });\n     |           - temporary value is freed at the end of this statement\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3928:34\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3928 |     assert_eq!(header_map.danger.is_green(), true);\n     |                                  ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3928 |     assert_eq!(header_map.danger.is_red(), true);\n     |                                  ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(256);",
                "    for i in 0..127 {",
                "        header_map.entries.push(Bucket {",
                "            hash: HashValue(i),",
                "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                "            links: None,",
                "        });",
                "    }",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    assert_eq!(header_map.entries.len(), 127);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    assert!(header_map.danger.is_green());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.entries.len(), 127);"
                ],
                [
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 256);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    for i in 0..127 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    assert_eq!(header_map.entries.len(), 127);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    for i in 0..127 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    assert!(header_map.danger.is_green());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    for i in 0..127 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    let result = header_map.try_reserve_one();",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    for i in 0..127 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.entries.len(), 127);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(256);",
                  "    for i in 0..127 {",
                  "        header_map.entries.push(Bucket {",
                  "            hash: HashValue(i),",
                  "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
                  "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
                  "            links: None,",
                  "        });",
                  "    }",
                  "    header_map.danger.set_green();",
                  "    header_map.try_reserve_one().unwrap();",
                  "    let header_map = HeaderMap::with_capacity(256);",
                  "    let result = header_map.try_reserve_one();",
                  "    assert_eq!(header_map.capacity(), 256);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(256);\n     |         ^^^^^^^^^^   ----------------------------- type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3925 |     let header_map: map::HeaderMap<T> = HeaderMap::with_capacity(256);\n     |                   +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_green` found for enum `Danger` in the current scope\n    --> src/header/map.rs:3926:31\n     |\n316  | enum Danger {\n     | ----------- method `is_green` not found for this enum\n...\n3926 |     assert!(header_map.danger.is_green());\n     |                               ^^^^^^^^\n     |\nhelp: there is a method `is_red` with a similar name\n     |\n3926 |     assert!(header_map.danger.is_red());\n     |                               ~~~~~~\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(256);\n     |         ^^^^^^^^^^   ----------------------------- type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3925 |     let header_map: map::HeaderMap<T> = HeaderMap::with_capacity(256);\n     |                   +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(256);\n     |         ^^^^^^^^^^   ----------------------------- type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3925 |     let header_map: map::HeaderMap<T> = HeaderMap::with_capacity(256);\n     |                   +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0282]: type annotations needed for `map::HeaderMap<_>`\n    --> src/header/map.rs:3925:9\n     |\n3925 |     let header_map = HeaderMap::with_capacity(256);\n     |         ^^^^^^^^^^   ----------------------------- type must be known at this point\n     |\nhelp: consider giving `header_map` an explicit type, where the type for type parameter `T` is specified\n     |\n3925 |     let header_map: map::HeaderMap<T> = HeaderMap::with_capacity(256);\n     |                   +++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}