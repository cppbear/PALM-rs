{
  "name": "http::header::map::header::map::HeaderMap<T>::remove_found",
  "name_with_impl": "http::header::map::{impl#1}::remove_found",
  "mod_info": {
    "name": "header::map",
    "loc": "src/header/mod.rs:73:1:73:9"
  },
  "visible": false,
  "loc": "src/header/map.rs:1552:5:1605:6",
  "fn_tests": [
    {
      "chain_id": 13,
      "prompt_conds": [
        "// constraint: self.entries.swap_remove(found) is \n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((i, _)) = self.indices[probe].resolve() is true\n",
        "// constraint: i >= self.entries.len() is true, with bound i == self.entries.len()\n",
        "// constraint: let Some(links) = entry.links is true\n",
        "// constraint: self.extra_values[links.next] is \n",
        "// constraint: self.extra_values[links.tail] is \n",
        "// constraint: self.entries.is_empty() is true\n",
        "// expected return value/type: entry\n"
      ],
      "input_infer": "0 < found < 32768, 0 < probe < entries.len(), entries.len() == capacity, indices.len() > 0, i == entries.len(), links.next >= 0, links.tail >= 0, extra_values.len() > 0, !entries.is_empty()\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    // Assuming HeaderValue can be instantiated directly",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Pre-fill entries, so that entries.len() == capacity",
                "    let found = 0; // assuming we're removing the first entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.entries.len() == 2);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.indices.len() > 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.indices[probe].is_some());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.is_empty() == false);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(entry.key == key1);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 1);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.contains_key(key2));"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(!header_map.contains_key(key1));"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.entries.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.indices[probe].is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(entry.key == key1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.contains_key(key2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(!header_map.contains_key(key1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    // Assuming HeaderValue can be instantiated directly",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Pre-fill entries, so that entries.len() == capacity",
                  "    let found = 0; // assuming we're removing the first entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    // Manually add extra values",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 0,",
                "    };",
                "    header_map.entries[0].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    let found = 0; // index of the entry to remove",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from_static(\"Key1\"));"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, HeaderValue::from_static(\"Value1\"));"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    // Manually add extra values",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 0,",
                  "    };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    let found = 0; // index of the entry to remove",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from_static(\"Key1\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    // Manually add extra values",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 0,",
                  "    };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    let found = 0; // index of the entry to remove",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, HeaderValue::from_static(\"Value1\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    // Manually add extra values",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 0,",
                  "    };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    let found = 0; // index of the entry to remove",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    // Manually add extra values",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 0,",
                  "    };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    let found = 0; // index of the entry to remove",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    // Manually add extra values",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 0,",
                  "    };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    let found = 0; // index of the entry to remove",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let links = Links { next: 0, tail: 0 };",
                  "    header_map.entries[0].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from_static(\"ExtraValue1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                "",
                "    let key = HeaderName::from_static(\"Key1\");",
                "",
                "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                "",
                "    let found = 0; // index of the last entry",
                "    let probe = 0; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(entry.key == key);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(entry.value == HeaderValue::from_static(\"Value1\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    let found = 0; // index of the last entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    let found = 0; // index of the last entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    let found = 0; // index of the last entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(entry.key == key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "",
                  "    let found = 0; // index of the last entry",
                  "    let probe = 0; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"Key1\");",
                  "    header_map.insert(key.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(entry.value == HeaderValue::from_static(\"Value1\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                "",
                "    let key1 = HeaderName::from_static(\"Key1\");",
                "    let key2 = HeaderName::from_static(\"Key2\");",
                "",
                "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                "",
                "    // Manually setting links on the second entry",
                "    let links = Links {",
                "        next: 0,",
                "        tail: 1,",
                "    };",
                "    header_map.entries[1].links = Some(links);",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from_static(\"ExtraValue\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(1),",
                "    });",
                "",
                "    let found = 1; // index of the entry to remove",
                "    let probe = 1; // valid probe position",
                "",
                "    // Call the function being tested",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key2);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.entries.len(), 1);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.extra_values.len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Manually setting links on the second entry",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 1,",
                  "    };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue\"),",
                  "        prev: Link::Entry(1),",
                  "        next: Link::Entry(1),",
                  "    });",
                  "",
                  "    let found = 1; // index of the entry to remove",
                  "    let probe = 1; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Manually setting links on the second entry",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 1,",
                  "    };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue\"),",
                  "        prev: Link::Entry(1),",
                  "        next: Link::Entry(1),",
                  "    });",
                  "",
                  "    let found = 1; // index of the entry to remove",
                  "    let probe = 1; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Manually setting links on the second entry",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 1,",
                  "    };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue\"),",
                  "        prev: Link::Entry(1),",
                  "        next: Link::Entry(1),",
                  "    });",
                  "",
                  "    let found = 1; // index of the entry to remove",
                  "    let probe = 1; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "",
                  "    // Manually setting links on the second entry",
                  "    let links = Links {",
                  "        next: 0,",
                  "        tail: 1,",
                  "    };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from_static(\"ExtraValue\"),",
                  "        prev: Link::Entry(1),",
                  "        next: Link::Entry(1),",
                  "    });",
                  "",
                  "    let found = 1; // index of the entry to remove",
                  "    let probe = 1; // valid probe position",
                  "",
                  "    // Call the function being tested",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(5);",
                  "    let key1 = HeaderName::from_static(\"Key1\");",
                  "    let key2 = HeaderName::from_static(\"Key2\");",
                  "    header_map.insert(key1.clone(), HeaderValue::from_static(\"Value1\"));",
                  "    header_map.insert(key2.clone(), HeaderValue::from_static(\"Value2\"));",
                  "    let links = Links { next: 0, tail: 1 };",
                  "    header_map.entries[1].links = Some(links);",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"ExtraValue\"), prev: Link::Entry(1), next: Link::Entry(1) });",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.extra_values.len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// constraint: self.entries.swap_remove(found) is \n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((i, _)) = self.indices[probe].resolve() is true\n",
        "// constraint: i >= self.entries.len() is true, with bound i == self.entries.len()\n",
        "// constraint: let Some(links) = entry.links is true\n",
        "// constraint: self.extra_values[links.next] is \n",
        "// constraint: self.extra_values[links.tail] is \n",
        "// constraint: self.entries.is_empty() is false\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((_, entry_hash)) = self.indices[probe].resolve() is true\n",
        "// constraint: probe_distance(self.mask, entry_hash, probe) > 0 is false, with bound probe_distance(self.mask, entry_hash, probe) == 0\n",
        "// expected return value/type: entry\n"
      ],
      "input_infer": "1 <= found < MAX_SIZE, 0 <= probe < MAX_SIZE, self.entries.len() > 0, i == self.entries.len(), self.extra_values.len() > 0, self.extra_values[links.next] is valid, self.extra_values[links.tail] is valid\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(10);",
                "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                "    ",
                "    // Simulate a valid situation where `found` is a valid index",
                "    let found = 0;",
                "    let probe = 0;",
                "",
                "    // Set up necessary structures to avoid panics",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"Test-Key\"),",
                "        value: HeaderValue::from(\"Test-Value\"),",
                "        links: Some(Links { next: 0, tail: 0 }),",
                "    });",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from(\"Extra-Value\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    // Call the focal function",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    assert_eq!(header_map.len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from(\"Test-Key\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.len() == 0);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Test-Key\", HeaderValue::from(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));",
                  "   ",
                  "   // Simulate a valid situation where `found` is a valid index",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   // Set up necessary structures to avoid panics",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Test-Key\"),",
                  "       value: HeaderValue::from_static(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));",
                  "   assert_eq!(header_map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from(\"Test-Value\"));",
                  "   ",
                  "   // Simulate a valid situation where `found` is a valid index",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   // Set up necessary structures to avoid panics",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Test-Key\"),",
                  "       value: HeaderValue::from(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from(\"Test-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "   header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert_eq!(entry.key, HeaderName::from_static(\"Test-Key\"));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from_static(\"Test-Value\"));",
                  "  ",
                  "  // Simulate a valid situation where `found` is a valid index",
                  "  let found = 0;",
                  "  let probe = 0;",
                  "",
                  "  // Set up necessary structures to avoid panics",
                  "  header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                  "  header_map.entries.push(Bucket {",
                  "      hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Test-Key\"),",
                  "      value: HeaderValue::from_static(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "   header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));",
                  "   ",
                  "   // Simulate a valid situation where `found` is a valid index",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   // Set up necessary structures to avoid panics",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Test-Key\"),",
                  "       value: HeaderValue::from_static(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "   header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert!(header_map.entries.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from_static(\"Test-Value\"));",
                  "  ",
                  "   // Simulate a valid situation where `found` is a valid index",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   // Set up necessary structures to avoid panics",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Test-Key\"),",
                  "      value: HeaderValue::from_static(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from_static(\"Test-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "  header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(10);  ",
                  "  header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));  ",
                  " ",
                  "  // Simulate a valid situation where `found` is a valid index  ",
                  "  let found = 0;  ",
                  "  let probe = 0;  ",
                  " ",
                  "  // Set up necessary structures to avoid panics  ",
                  "  header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);  ",
                  "  header_map.entries.push(Bucket {  ",
                  "      hash: HashValue(1),  ",
                  "      key: HeaderName::from_static(\"Test-Key\"),  ",
                  "       value: HeaderValue::from_static(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Test-Key\", HeaderValue::from_static(\"Test-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "   header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert!(header_map.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from_static(\"Test-Value\"));",
                  "   ",
                  "   // Simulate a valid situation where `found` is a valid index",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   // Set up necessary structures to avoid panics",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]); ",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Test-Key\"),",
                  "       value: HeaderValue::from_static(\"Test-Value\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from_static(\"Test-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)); 1]);",
                  "   header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Test-Key\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:59\n     |\n3915 |    header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from(\"Test-Value\"));\n     |                                                           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3926:15\n     |\n3926 |        value: HeaderValue::from(\"Test-Value\"),\n     |               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |        value: HeaderValue::from(\"Extra-Value\"),\n     |               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:59\n     |\n3938 |    header_map.insert(HeaderName::from_static(\"Test-Key\"), HeaderValue::from(\"Test-Value\"));\n     |                                                           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3942:106\n     |\n3942 | ..._static(\"Test-Key\"), value: HeaderValue::from(\"Test-Value\"), links: Some(Links { next: 0, tail: 0 }), });\n     |                                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3943:53\n     |\n3943 |    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });\n     |                                                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3942:62\n     |\n3942 | ...t { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0,...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Test-Key\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3942:62\n     |\n3942 | ...t { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0,...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3942:61\n     |\n3942 | ...t { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0,...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3942:62\n     |\n3942 | ...t { hash: HashValue(1), key: HeaderName::from(\"Test-Key\"), value: HeaderValue::from_static(\"Test-Value\"), links: Some(Links { next: 0,...\n     |                                 ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3943:54\n     |\n3943 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra-Value\"), prev: Link::Entry(0), next: Link::Entry(0), });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(10);",
                "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                "    ",
                "    // Set up valid configurations",
                "    let found = 0;",
                "    let probe = 0;",
                "",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"Key1\"),",
                "        value: HeaderValue::from(\"Value1\"),",
                "        links: Some(Links { next: 0, tail: 0 }),",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from(\"Key2\"),",
                "        value: HeaderValue::from(\"Value2\"),",
                "        links: None,",
                "    });",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from(\"Extra-Value1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    // Call the focal function",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.entries.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.indices.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert!(header_map.extra_values.is_empty() == false);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert!(header_map.indices[0].is_some());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert!(header_map.indices[1].is_some());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.indices[0], Pos::new(0, HashValue(1)));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.indices[1], Pos::new(1, HashValue(2)));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.entries[0].key, HeaderName::from(\"Key1\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.entries[1].key, HeaderName::from(\"Key2\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.extra_values[0].value, HeaderValue::from(\"Extra-Value1\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from(\"Key1\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.entries.len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.indices[0], Pos::new(0, HashValue(2)));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values[0].prev, Link::Entry(0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));  ",
                  "   ",
                  "   // Set up valid configurations  ",
                  "   let found = 0;  ",
                  "   let probe = 0;  ",
                  " ",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(1),  ",
                  "       key: HeaderName::from(\"Key1\"),  ",
                  "       value: HeaderValue::from_static(\"Value1\"),  ",
                  "       links: Some(Links { next: 0, tail: 0 }),  ",
                  "   });  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(2),  ",
                  "       key: HeaderName::from(\"Key2\"),  ",
                  "       value: HeaderValue::from_static(\"Value2\"),  ",
                  "       links: None,  ",
                  "   });  ",
                  "   header_map.extra_values.push(ExtraValue {  ",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),  ",
                  "       prev: Link::Entry(0),  ",
                  "       next: Link::Entry(0),  ",
                  "   });  ",
                  " ",
                  "   // Call the focal function  ",
                  "   let entry = header_map.remove_found(probe, found);  ",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));  ",
                  "   assert_eq!(header_map.entries.len(), 2);  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "      key: HeaderName::from_static(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   assert_eq!(header_map.indices.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from_static(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "        links: None,",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "        value: HeaderValue::from(\"Extra-Value1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    // Call the focal function",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert!(header_map.extra_values.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   assert!(header_map.indices[0].is_some());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));  ",
                  "   ",
                  "   // Set up valid configurations  ",
                  "   let found = 0;  ",
                  "   let probe = 0;  ",
                  " ",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(1),  ",
                  "       key: HeaderName::from(\"Key1\"),  ",
                  "       value: HeaderValue::from_static(\"Value1\"),  ",
                  "       links: Some(Links { next: 0, tail: 0 }),  ",
                  "   });  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(2),  ",
                  "       key: HeaderName::from(\"Key2\"),  ",
                  "       value: HeaderValue::from_static(\"Value2\"),  ",
                  "       links: None,  ",
                  "   });  ",
                  "   header_map.extra_values.push(ExtraValue {  ",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),  ",
                  "       prev: Link::Entry(0),  ",
                  "       next: Link::Entry(0),  ",
                  "   });  ",
                  " ",
                  "   // Call the focal function  ",
                  "   let entry = header_map.remove_found(probe, found);  ",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));  ",
                  "   assert!(header_map.indices[1].is_some());  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));  ",
                  "   ",
                  "   // Set up valid configurations  ",
                  "   let found = 0;  ",
                  "   let probe = 0;  ",
                  " ",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(1),  ",
                  "      key: HeaderName::from_static(\"Key1\"),  ",
                  "      value: HeaderValue::from_static(\"Value1\"),  ",
                  "       links: Some(Links { next: 0, tail: 0 }),  ",
                  "   });  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(2),  ",
                  "      key: HeaderName::from_static(\"Key2\"),  ",
                  "      value: HeaderValue::from_static(\"Value2\"),  ",
                  "       links: None,  ",
                  "   });  ",
                  "   header_map.extra_values.push(ExtraValue {  ",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),  ",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    // Call the focal function",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));",
                  "    assert_eq!(header_map.indices[0], Pos::new(0, HashValue(1)));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "      key: HeaderName::from_static(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   assert_eq!(header_map.indices[1], Pos::new(1, HashValue(2)));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   assert_eq!(header_map.entries[0].key, HeaderName::from(\"Key1\"));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Key1\"),",
                  "      value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "      key: HeaderName::from_static(\"Key2\"),",
                  "      value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   assert_eq!(header_map.entries[1].key, HeaderName::from(\"Key2\"));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::try_from(\"Value1\").unwrap());",
                  "   header_map.insert(\"Key2\", HeaderValue::try_from(\"Value2\").unwrap());",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Key1\"),  ",
                  "      value: HeaderValue::try_from(\"Value1\").unwrap(),  ",
                  "      links: Some(Links { next: 0, tail: 0 }),  ",
                  "  });  ",
                  "  header_map.entries.push(Bucket {  ",
                  "      hash: HashValue(2),  ",
                  "      key: HeaderName::from_static(\"Key2\"),  ",
                  "       value: HeaderValue::try_from(\"Value2\").unwrap(),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::try_from(\"Extra-Value1\").unwrap(),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::try_from(\"Value1\").unwrap());",
                  "   header_map.insert(\"Key2\", HeaderValue::try_from(\"Value2\").unwrap());",
                  "   assert_eq!(header_map.extra_values[0].value, HeaderValue::try_from(\"Extra-Value1\").unwrap());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "  // Set up valid configurations",
                  "  let found = 0;",
                  "  let probe = 0;",
                  "  ",
                  "  header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "  header_map.entries.push(Bucket {",
                  "      hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Key1\"),",
                  "      value: HeaderValue::from_static(\"Value1\"),",
                  "      links: Some(Links { next: 0, tail: 0 }),",
                  "  });",
                  "  header_map.entries.push(Bucket {",
                  "      hash: HashValue(2),",
                  "      key: HeaderName::from_static(\"Key2\"),",
                  "      value: HeaderValue::from_static(\"Value2\"),",
                  "      links: None,",
                  "  });",
                  "  header_map.extra_values.push(ExtraValue {",
                  "      value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from(\"Key1\"));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert_eq!(header_map.entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert_eq!(header_map.indices[0], Pos::new(0, HashValue(2)));",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(2),",
                  "       key: HeaderName::from(\"Key2\"),",
                  "       value: HeaderValue::from_static(\"Value2\"),",
                  "       links: None,",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.insert(\"Key2\", HeaderValue::from_static(\"Value2\"));",
                  "   let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values[0].prev, Link::Entry(0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),  \n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),  \n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:16\n     |\n3936 |         value: HeaderValue::from(\"Extra-Value1\"),\n     |                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:31\n     |\n3944 |     header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));\n     |                               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:31\n     |\n3945 |     header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));\n     |                               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),  \n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),  \n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:31\n     |\n3944 |     header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));\n     |                               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:31\n     |\n3945 |     header_map.insert(\"Key2\", HeaderValue::from(\"Value2\"));\n     |                               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0369]: binary operation `==` cannot be applied to type `map::Pos`\n    --> src/header/map.rs:3946:5\n     |\n3946 |     assert_eq!(header_map.indices[0], Pos::new(0, HashValue(1)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     map::Pos\n     |     map::Pos\n     |\nnote: an implementation of `PartialEq` might be missing for `map::Pos`\n    --> src/header/map.rs:248:1\n     |\n248  | struct Pos {\n     | ^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::Pos` with `#[derive(PartialEq)]`\n     |\n248  + #[derive(PartialEq)]\n249  | struct Pos {\n     |\n\nerror[E0277]: `map::Pos` doesn't implement `Debug`\n    --> src/header/map.rs:3946:5\n     |\n3946 |     assert_eq!(header_map.indices[0], Pos::new(0, HashValue(1)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `map::Pos` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `map::Pos`\n     = note: add `#[derive(Debug)]` to `map::Pos` or manually `impl Debug for map::Pos`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::Pos` with `#[derive(Debug)]`\n     |\n248  + #[derive(Debug)]\n249  | struct Pos {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `map::Pos`\n    --> src/header/map.rs:3946:4\n     |\n3946 |    assert_eq!(header_map.indices[1], Pos::new(1, HashValue(2)));\n     |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |    |\n     |    map::Pos\n     |    map::Pos\n     |\nnote: an implementation of `PartialEq` might be missing for `map::Pos`\n    --> src/header/map.rs:248:1\n     |\n248  | struct Pos {\n     | ^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::Pos` with `#[derive(PartialEq)]`\n     |\n248  + #[derive(PartialEq)]\n249  | struct Pos {\n     |\n\nerror[E0277]: `map::Pos` doesn't implement `Debug`\n    --> src/header/map.rs:3946:4\n     |\n3946 |    assert_eq!(header_map.indices[1], Pos::new(1, HashValue(2)));\n     |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `map::Pos` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `map::Pos`\n     = note: add `#[derive(Debug)]` to `map::Pos` or manually `impl Debug for map::Pos`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::Pos` with `#[derive(Debug)]`\n     |\n248  + #[derive(Debug)]\n249  | struct Pos {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3946:42\n     |\n3946 |    assert_eq!(header_map.entries[0].key, HeaderName::from(\"Key1\"));\n     |                                          ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3946:42\n     |\n3946 |    assert_eq!(header_map.entries[1].key, HeaderName::from(\"Key2\"));\n     |                                          ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3947:27\n     |\n3947 |     assert_eq!(entry.key, HeaderName::from(\"Key1\"));\n     |                           ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0369]: binary operation `==` cannot be applied to type `map::Pos`\n    --> src/header/map.rs:3947:4\n     |\n3947 |    assert_eq!(header_map.indices[0], Pos::new(0, HashValue(2)));\n     |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |    |\n     |    map::Pos\n     |    map::Pos\n     |\nnote: an implementation of `PartialEq` might be missing for `map::Pos`\n    --> src/header/map.rs:248:1\n     |\n248  | struct Pos {\n     | ^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::Pos` with `#[derive(PartialEq)]`\n     |\n248  + #[derive(PartialEq)]\n249  | struct Pos {\n     |\n\nerror[E0277]: `map::Pos` doesn't implement `Debug`\n    --> src/header/map.rs:3947:4\n     |\n3947 |    assert_eq!(header_map.indices[0], Pos::new(0, HashValue(2)));\n     |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `map::Pos` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `map::Pos`\n     = note: add `#[derive(Debug)]` to `map::Pos` or manually `impl Debug for map::Pos`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `map::Pos` with `#[derive(Debug)]`\n     |\n248  + #[derive(Debug)]\n249  | struct Pos {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:13\n     |\n3925 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:13\n     |\n3931 |        key: HeaderName::from(\"Key2\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0600]: cannot apply unary operator `!` to type `map::Link`\n    --> src/header/map.rs:3947:5\n     |\n3947 |     assert!(header_map.extra_values[0].prev, Link::Entry(0));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot apply unary operator `!`\n     |\nnote: an implementation of `Not` might be missing for `map::Link`\n    --> src/header/map.rs:302:1\n     |\n302  | enum Link {\n     | ^^^^^^^^^ must implement `Not`\nnote: the trait `Not` must be implemented\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/bit.rs:34:1\n     |\n34   | pub trait Not {\n     | ^^^^^^^^^^^^^\n     = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(10);",
                "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                "    ",
                "    // Set up valid configurations",
                "    let found = 0;",
                "    let probe = 0;",
                "",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"Key1\"),",
                "        value: HeaderValue::from(\"Value1\"),",
                "        links: Some(Links { next: 1, tail: 1 }),",
                "    });",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from(\"Extra-Value1\"),",
                "        prev: Link::Entry(0),",
                "        next: Link::Entry(1),",
                "    });",
                "    header_map.extra_values.push(ExtraValue {",
                "        value: HeaderValue::from(\"Extra-Value2\"),",
                "        prev: Link::Entry(1),",
                "        next: Link::Entry(0),",
                "    });",
                "",
                "    // Call the focal function",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    assert_eq!(header_map.len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    assert_eq!(header_map.keys_len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    assert!(!header_map.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    assert_eq!(header_map.extra_values.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    assert!(header_map.entries.get(0).is_some());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    assert!(header_map.indices[0].is_some());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from(\"Key1\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, HeaderValue::from(\"Value1\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   assert_eq!(header_map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   assert_eq!(header_map.keys_len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   ",
                  "   // Set up valid configurations  ",
                  "   let found = 0;  ",
                  "   let probe = 0;  ",
                  " ",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(1),  ",
                  "       key: HeaderName::from(\"Key1\"),  ",
                  "       value: HeaderValue::from_static(\"Value1\"),  ",
                  "       links: Some(Links { next: 1, tail: 1 }),  ",
                  "   });  ",
                  "   header_map.extra_values.push(ExtraValue {  ",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),  ",
                  "       prev: Link::Entry(0),  ",
                  "       next: Link::Entry(1),  ",
                  "   });  ",
                  "   header_map.extra_values.push(ExtraValue {  ",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),  ",
                  "       prev: Link::Entry(1),  ",
                  "       next: Link::Entry(0),  ",
                  "   });  ",
                  " ",
                  "   // Call the focal function  ",
                  "   let entry = header_map.remove_found(probe, found);  ",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));  ",
                  "   assert!(!header_map.is_empty());  ",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from(\"Key1\"),",
                  "   value: HeaderValue::from_static(\"Value1\"),",
                  "   links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "   prev: Link::Entry(0),",
                  "   next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "   prev: Link::Entry(1),",
                  "   next: Link::Entry(0),",
                  "    });",
                  "    assert_eq!(header_map.extra_values.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Key1\"),  ",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "   assert!(header_map.entries.get(0).is_some());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(HeaderName::from_static(\"Key1\"), HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Key1\"),",
                  "      value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(1),",
                  "    });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "        prev: Link::Entry(1),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    // Call the focal function",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(HeaderName::from_static(\"Key1\"), HeaderValue::from_static(\"Value1\"));",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"Key1\"),",
                  "   value: HeaderValue::from(\"Value1\"),",
                  "   links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "  value: HeaderValue::from_static(\"Extra-Value1\"),  ",
                  "  prev: Link::Entry(0),  ",
                  "  next: Link::Entry(1),  ",
                  "  });  ",
                  "   header_map.extra_values.push(ExtraValue {",
                  "      value: HeaderValue::from_static(\"Extra-Value2\"),  ",
                  "       prev: Link::Entry(1),  ",
                  "       next: Link::Entry(0),  ",
                  "   });  ",
                  "    assert!(header_map.indices[0].is_some());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(HeaderName::from_static(\"Key1\"), HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "        prev: Link::Entry(0),",
                  "        next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "        prev: Link::Entry(1),",
                  "        next: Link::Entry(0),",
                  "    });",
                  "",
                  "    // Call the focal function",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"Key1\"),",
                  "    value: HeaderValue::from(\"Value1\"),",
                  "    links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "    value: HeaderValue::from(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "   assert_eq!(entry.key, HeaderName::from_static(\"Key1\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Key1\"), HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(HeaderName::from_static(\"Key1\"), HeaderValue::from_static(\"Value1\"));",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"Key1\"),",
                  "   value: HeaderValue::from_static(\"Value1\"),",
                  "   links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "   prev: Link::Entry(0),",
                  "   next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, HeaderValue::from(\"Value1\"));",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "  ",
                  "  // Set up valid configurations",
                  "  let found = 0;",
                  "  let probe = 0;",
                  "",
                  "  header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "  header_map.entries.push(Bucket {",
                  "      hash: HashValue(1),",
                  "      key: HeaderName::from(\"Key1\"),",
                  "      value: HeaderValue::from_static(\"Value1\"),",
                  "      links: Some(Links { next: 1, tail: 1 }),",
                  "  });",
                  "  header_map.extra_values.push(ExtraValue {",
                  "      value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "      prev: Link::Entry(0),",
                  "      next: Link::Entry(1),",
                  "  });",
                  "  header_map.extra_values.push(ExtraValue {",
                  "      value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "      prev: Link::Entry(1),",
                  "      next: Link::Entry(0),",
                  "  });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from(\"Key1\"),",
                  "   value: HeaderValue::from_static(\"Value1\"),",
                  "   links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "   prev: Link::Entry(0),",
                  "   next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "   prev: Link::Entry(1),",
                  "   next: Link::Entry(0),",
                  "   });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert!(header_map.entries.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Key1\"),",
                  "       value: HeaderValue::from_static(\"Value1\"),",
                  "       links: Some(Links { next: 1, tail: 1 }),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "       prev: Link::Entry(0),",
                  "       next: Link::Entry(1),",
                  "   });",
                  "   header_map.extra_values.push(ExtraValue {",
                  "       value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "       prev: Link::Entry(1),",
                  "       next: Link::Entry(0),",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Key1\", HeaderValue::from_static(\"Value1\"));",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "   key: HeaderName::from(\"Key1\"),",
                  "   value: HeaderValue::from_static(\"Value1\"),",
                  "   links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value1\"),",
                  "    prev: Link::Entry(0),",
                  "    next: Link::Entry(1),",
                  "    });",
                  "    header_map.extra_values.push(ExtraValue {",
                  "   value: HeaderValue::from_static(\"Extra-Value2\"),",
                  "    prev: Link::Entry(1),",
                  "    next: Link::Entry(0),",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Key1\"),  \n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3946:9\n     |\n3946 |    key: HeaderName::from(\"Key1\"),\n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3947:11\n     |\n3947 |    value: HeaderValue::from(\"Value1\"),\n     |           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3942:31\n     |\n3942 |     header_map.insert(\"Key1\", HeaderValue::from(\"Value1\"));\n     |                               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3947:12\n     |\n3947 |     value: HeaderValue::from(\"Value1\"),\n     |            ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3951:12\n     |\n3951 |     value: HeaderValue::from(\"Extra-Value1\"),\n     |            ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3961:29\n     |\n3961 |     assert_eq!(entry.value, HeaderValue::from(\"Value1\"));\n     |                             ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:12\n     |\n3924 |       key: HeaderName::from(\"Key1\"),\n     |            ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3946:9\n     |\n3946 |    key: HeaderName::from(\"Key1\"),\n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Key1\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3946:9\n     |\n3946 |    key: HeaderName::from(\"Key1\"),\n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(10);",
                "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                "    ",
                "    // Set up valid configurations",
                "    let found = 0;",
                "    let probe = 0;",
                "",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from(\"Last-Key\"),",
                "        value: HeaderValue::from(\"Last-Value\"),",
                "        links: None,",
                "    });",
                "",
                "    // Call the focal function",
                "    let entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert_eq!(header_map.indices[probe].index, !0);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert_eq!(header_map.entries.len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert_eq!(header_map.indices.len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert!(header_map.entries.len() > 0);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert!(header_map.indices[probe].is_some());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert!(header_map.entries.get(found).is_some());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::from(\"Last-Key\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, HeaderValue::from(\"Last-Value\"));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(10);  ",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));  ",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Last-Key\"),",
                  "        value: HeaderValue::from(\"Last-Value\"),",
                  "        links: None,",
                  "    });",
                  "",
                  "    // Call the focal function",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));  ",
                  "   let found = 0;  ",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert_eq!(header_map.indices[probe].index, !0);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(HeaderName::from_static(\"Last-Key\"), HeaderValue::from_static(\"Last-Value\"));",
                  "  ",
                  "  // Set up valid configurations",
                  "  let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Last-Key\"),",
                  "      value: HeaderValue::from_static(\"Last-Value\"),",
                  "      links: None,",
                  "  });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from(\"Last-Key\"),",
                  "   value: HeaderValue::from_static(\"Last-Value\"),",
                  "   links: None,",
                  "   });",
                  "   assert_eq!(header_map.entries.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  " let mut header_map = HeaderMap::with_capacity(10);",
                  " header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  " ",
                  "  // Set up valid configurations",
                  "  let found = 0;",
                  "  let probe = 0;",
                  "",
                  "  header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "  header_map.entries.push(Bucket {",
                  "      hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Last-Key\"),  // Changed here",
                  "     value: HeaderValue::from_static(\"Last-Value\"),",
                  "       links: None,",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"Last-Key\"),  // Changed here",
                  "   value: HeaderValue::from(\"Last-Value\"),",
                  "   links: None,",
                  "   });",
                  "   assert_eq!(header_map.indices.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "  ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Last-Key\"),",
                  "       value: HeaderValue::from_static(\"Last-Value\"),",
                  "       links: None,",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from(\"Last-Key\"),",
                  "   value: HeaderValue::from_static(\"Last-Value\"),",
                  "   links: None,",
                  "   });",
                  "   assert!(header_map.entries.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Last-Key\"),",
                  "       value: HeaderValue::from_static(\"Last-Value\"),",
                  "       links: None,",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "    key: HeaderName::from(\"Last-Key\"),",
                  "    value: HeaderValue::from(\"Last-Value\"),",
                  "    links: None,",
                  "    });",
                  "    assert!(header_map.indices[probe].is_some());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));  ",
                  "   ",
                  "   // Set up valid configurations  ",
                  "   let found = 0;  ",
                  "   let probe = 0;  ",
                  " ",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);  ",
                  "   header_map.entries.push(Bucket {  ",
                  "       hash: HashValue(1),  ",
                  "       key: HeaderName::from_static(\"Last-Key\"),  ",
                  "      value: HeaderValue::from_static(\"Last-Value\"),  ",
                  "       links: None,  ",
                  "   });  ",
                  " ",
                  "   // Call the focal function  ",
                  "   let entry = header_map.remove_found(probe, found);  ",
                  "   let mut header_map = HeaderMap::with_capacity(10);  ",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));  ",
                  "   let found = 0;  ",
                  "   let probe = 0;  ",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);  ",
                  "   header_map.entries.push(Bucket {  ",
                  "   hash: HashValue(1),  ",
                  "   key: HeaderName::from_static(\"Last-Key\"),  ",
                  "   value: HeaderValue::from(\"Last-Value\"),  ",
                  "   links: None,  ",
                  "   });  ",
                  "   assert!(header_map.entries.get(found).is_some());  ",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "      key: HeaderName::from_static(\"Last-Key\"),",
                  "      value: HeaderValue::from_static(\"Last-Value\"),",
                  "      links: None,",
                  "  });",
                  "",
                  "  // Call the focal function",
                  "  let entry = header_map.remove_found(probe, found);",
                  "  let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"Last-Key\"),",
                  "   value: HeaderValue::from(\"Last-Value\"),",
                  "   links: None,",
                  "   });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert_eq!(entry.key, HeaderName::from_static(\"Last-Key\"));",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Last-Key\"),",
                  "       value: HeaderValue::from(\"Last-Value\"),",
                  "       links: None,",
                  "    });",
                  "",
                  "    // Call the focal function",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   let found = 0;",
                  "    let probe = 0;",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "    header_map.entries.push(Bucket {",
                  "    hash: HashValue(1),",
                  "   key: HeaderName::from_static(\"Last-Key\"),",
                  "   value: HeaderValue::from_static(\"Last-Value\"),",
                  "   links: None,",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "   assert_eq!(entry.value, HeaderValue::from_static(\"Last-Value\"));",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map = HeaderMap::with_capacity(10);",
                  "  header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from_static(\"Last-Key\"),",
                  "       value: HeaderValue::from(\"Last-Value\"),",
                  "       links: None,",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "  header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "  header_map.entries.push(Bucket {",
                  "  hash: HashValue(1),",
                  "  key: HeaderName::from_static(\"Last-Key\"),",
                  "  value: HeaderValue::from_static(\"Last-Value\"),",
                  "   links: None,",
                  "   });",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   ",
                  "   // Set up valid configurations",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key: HeaderName::from(\"Last-Key\"),",
                  "       value: HeaderValue::from_static(\"Last-Value\"),",
                  "       links: None,",
                  "   });",
                  "",
                  "   // Call the focal function",
                  "   let entry = header_map.remove_found(probe, found);",
                  "   let mut header_map = HeaderMap::with_capacity(10);",
                  "   header_map.insert(\"Last-Key\", HeaderValue::from_static(\"Last-Value\"));",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   header_map.entries.push(Bucket {",
                  "   hash: HashValue(1),",
                  "   key: HeaderName::from(\"Last-Key\"),",
                  "   value: HeaderValue::from_static(\"Last-Value\"),",
                  "   links: None,",
                  "    });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:16\n     |\n3925 |         value: HeaderValue::from(\"Last-Value\"),\n     |                ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:10\n     |\n3938 |     key: HeaderName::from(\"Last-Key\"),\n     |          ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3939:12\n     |\n3939 |     value: HeaderValue::from(\"Last-Value\"),\n     |            ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:9\n     |\n3938 |    key: HeaderName::from(\"Last-Key\"),\n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3932:34\n     |\n3932 |    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));\n     |                                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3939:11\n     |\n3939 |    value: HeaderValue::from(\"Last-Value\"),\n     |           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Last-Key\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:9\n     |\n3938 |    key: HeaderName::from(\"Last-Key\"),\n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Last-Key\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:10\n     |\n3938 |     key: HeaderName::from(\"Last-Key\"),\n     |          ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3939:12\n     |\n3939 |     value: HeaderValue::from(\"Last-Value\"),\n     |            ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 3 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3939:11\n     |\n3939 |    value: HeaderValue::from(\"Last-Value\"),  \n     |           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3939:11\n     |\n3939 |    value: HeaderValue::from(\"Last-Value\"),\n     |           ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:15\n     |\n3925 |        value: HeaderValue::from(\"Last-Value\"),\n     |               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:15\n     |\n3925 |        value: HeaderValue::from(\"Last-Value\"),\n     |               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3932:34\n     |\n3932 |    header_map.insert(\"Last-Key\", HeaderValue::from(\"Last-Value\"));\n     |                                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:13\n     |\n3924 |        key: HeaderName::from(\"Last-Key\"),\n     |             ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:9\n     |\n3938 |    key: HeaderName::from(\"Last-Key\"),\n     |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 30,
      "prompt_conds": [
        "// constraint: self.entries.swap_remove(found) is \n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is false, with bound $probe_var == self.indices.len()\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((i, _)) = self.indices[probe].resolve() is true\n",
        "// constraint: i >= self.entries.len() is true, with bound i == self.entries.len()\n",
        "// constraint: let Some(links) = entry.links is true\n",
        "// constraint: self.extra_values[links.next] is \n",
        "// constraint: self.extra_values[links.tail] is \n",
        "// constraint: self.entries.is_empty() is false\n",
        "// constraint: $len > 0 is false, with bound self.indices.len() == 0\n"
      ],
      "input_infer": "1 <= found <= MAX_SIZE - 1, 0 <= probe < MAX_SIZE, self.entries.len() > 0, self.indices.len() > 0, 0 <= links.next < self.extra_values.len(), 0 <= links.tail < self.extra_values.len()\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from(\"Key1\");",
                "    let value = HeaderValue::from(\"Value1\");",
                "    header_map.insert(key.clone(), value.clone());",
                "",
                "    let found = 0;",
                "    let probe = 0;",
                "",
                "    // Assuming functions to create linked entries and extra values exist",
                "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert_eq!(header_map.len(), 1);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(!header_map.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.entries.len() > found);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, value);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.len() == 2);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key = HeaderName::from(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key = HeaderName::from_static(\"Key1\");",
                  "  let value = HeaderValue::from(\"Value1\");",
                  "  header_map.insert(key.clone(), value.clone());",
                  "  ",
                  "  let found = 0;",
                  "  let probe = 0;",
                  "  ",
                  "  // Assuming functions to create linked entries and extra values exist",
                  "  header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   ",
                  "  let _entry = header_map.remove_found(probe, found);",
                  "  let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key = HeaderName::from_static(\"Key1\");",
                  "  let value = HeaderValue::from(\"Value1\");",
                  "  header_map.insert(key.clone(), value.clone());",
                  "  assert_eq!(header_map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key = HeaderName::from_static(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key = HeaderName::from_static(\"Key1\");",
                  "  let value = HeaderValue::from_static(\"Value1\");",
                  "   header_map.insert(key.clone(), value);",
                  "   assert!(!header_map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key = HeaderName::from_static(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    assert!(header_map.entries.len() > found);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key = HeaderName::from(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   ",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, value);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key = HeaderName::from_static(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    // Assuming functions to create linked entries and extra values exist",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "   header_map.insert(key.clone(), value.clone());",
                  "",
                  "   let found = 0;",
                  "   let probe = 0;",
                  "   ",
                  "   // Assuming functions to create linked entries and extra values exist",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key = HeaderName::from(\"Key1\");",
                  "   let value = HeaderValue::from_static(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:14\n     |\n3915 |    let key = HeaderName::from(\"Key1\");\n     |              ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:15\n     |\n3916 |   let value = HeaderValue::from(\"Value1\");\n     |               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |   let value = HeaderValue::from(\"Value1\");\n     |               ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3925:54\n     |\n3925 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:15\n     |\n3929 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:17\n     |\n3930 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:15\n     |\n3929 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:17\n     |\n3930 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:54\n     |\n3935 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:54\n     |\n3936 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:14\n     |\n3915 |    let key = HeaderName::from(\"Key1\");\n     |              ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:15\n     |\n3929 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:17\n     |\n3930 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:54\n     |\n3935 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:54\n     |\n3936 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:15\n     |\n3929 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:17\n     |\n3930 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:14\n     |\n3929 |    let key = HeaderName::from(\"Key1\");\n     |              ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:54\n     |\n3935 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:54\n     |\n3936 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from(\"Key1\");",
                "    let value1 = HeaderValue::from(\"Value1\");",
                "    let key2 = HeaderName::from(\"Key2\");",
                "    let value2 = HeaderValue::from(\"Value2\");",
                "    ",
                "    header_map.insert(key1.clone(), value1.clone());",
                "    header_map.insert(key2.clone(), value2.clone());",
                "",
                "    let found = 1;",
                "    let probe = 1;",
                "",
                "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    assert!(header_map.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    assert_eq!(header_map.len(), 1);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert_eq!(header_map.len(), 2);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    assert!(header_map.entries[found].links.is_some());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    assert!(header_map.extra_values.len() == 2);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from(\"Value2\");",
                  "   ",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "   let found = 1;",
                  "   let probe = 1;",
                  "",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    assert!(header_map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key1 = HeaderName::from_static(\"Key1\");",
                  "  let value1 = HeaderValue::from_static(\"Value1\");",
                  "  let key2 = HeaderName::from_static(\"Key2\");",
                  "  let value2 = HeaderValue::from_static(\"Value2\");",
                  "  ",
                  "  header_map.insert(key1.clone(), value1.clone());",
                  "  header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "  let found = 1;",
                  "  let probe = 1;",
                  " ",
                  "  header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from(\"Value2\");",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   assert_eq!(header_map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "  let key2 = HeaderName::from_static(\"Key2\");",
                  "  let value2 = HeaderValue::from_static(\"Value2\");",
                  "   ",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "   let found = 1;",
                  "   let probe = 1;",
                  "",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "   let key2 = HeaderName::from(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "   assert_eq!(header_map.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "   ",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "   let found = 1;",
                  "   let probe = 1;",
                  "",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    assert!(header_map.entries[found].links.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 1;",
                  "    let probe = 1;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   assert!(header_map.extra_values.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key1 = HeaderName::from_static(\"Key1\");",
                  "  let value1 = HeaderValue::from_static(\"Value1\");",
                  "  let key2 = HeaderName::from_static(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "   ",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "   let found = 1;",
                  "   let probe = 1;",
                  "",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "   let key2 = HeaderName::from(\"Key2\");",
                  "   let value2 = HeaderValue::from_static(\"Value2\");",
                  "   header_map.insert(key1.clone(), value1.clone());",
                  "   header_map.insert(key2.clone(), value2.clone());",
                  "   header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "  let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "  let key1 = HeaderName::from_static(\"Key1\");",
                  "  let value1 = HeaderValue::from_static(\"Value1\");",
                  "  let key2 = HeaderName::from_static(\"Key2\");",
                  "  let value2 = HeaderValue::from_static(\"Value2\");",
                  "  ",
                  "  header_map.insert(key1.clone(), value1.clone());",
                  "  header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "  let found = 1;",
                  "  let probe = 1;",
                  "  ",
                  "  header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "  header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "   let _entry = header_map.remove_found(probe, found);",
                  "   let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "   let key1 = HeaderName::from_static(\"Key1\");",
                  "   let value1 = HeaderValue::from_static(\"Value1\");",
                  "   let key2 = HeaderName::from_static(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "   header_map.extra_values.push(ExtraValue { value: HeaderValue::from_static(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |    let value1 = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:17\n     |\n3918 |    let value2 = HeaderValue::from(\"Value2\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3927:53\n     |\n3927 |    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:53\n     |\n3928 |    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3933:17\n     |\n3933 |    let value1 = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:18\n     |\n3935 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3933:17\n     |\n3933 |    let value1 = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:17\n     |\n3935 |    let value2 = HeaderValue::from(\"Value2\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3932:15\n     |\n3932 |    let key1 = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3934:15\n     |\n3934 |    let key2 = HeaderName::from(\"Key2\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3940:54\n     |\n3940 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3932:16\n     |\n3932 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3933:18\n     |\n3933 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3932:15\n     |\n3932 |    let key1 = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3934:15\n     |\n3934 |    let key2 = HeaderName::from(\"Key2\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:18\n     |\n3935 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    ",
                "    let found = 0; // No entries exist",
                "    let probe = 0; // No valid probe",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.entries.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.indices.len() > 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.keys_len(), 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.clear().is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.capacity() >= 10);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.try_append(0, HeaderValue::new()).is_err());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.get(0).is_none());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(!header_map.contains_key(0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.entries.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.keys_len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.clear().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.capacity() >= 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.try_append(0, HeaderValue::new()).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.get(0).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    ",
                  "    let found = 0; // No entries exist",
                  "    let probe = 0; // No valid probe",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    assert!(!header_map.contains_key(0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_empty` found for unit type `()` in the current scope\n    --> src/header/map.rs:3922:32\n     |\n3922 |     assert!(header_map.clear().is_empty());\n     |             ----------         ^^^^^^^^ method not found in `()`\n     |             |\n     |             method `is_empty` is available on `&mut map::HeaderMap`\n     |\nnote: method `clear` modifies its receiver in-place\n    --> src/header/map.rs:3922:24\n     |\n3922 |     assert!(header_map.clear().is_empty());\n     |                        ^^^^^ this call modifies `header_map` in-place\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `value::HeaderValue` in the current scope\n    --> src/header/map.rs:3922:51\n     |\n3922 |     assert!(header_map.try_append(0, HeaderValue::new()).is_err());\n     |                                                   ^^^ function or associated item not found in `HeaderValue`\n     |\n    ::: src/header/value.rs:22:1\n     |\n22   | pub struct HeaderValue {\n     | ---------------------- function or associated item `new` not found for this struct\n     |\nnote: if you're trying to build a new `value::HeaderValue` consider using one of the following associated functions:\n      value::HeaderValue::from_static\n      value::HeaderValue::from_str\n      value::HeaderValue::from_name\n      value::HeaderValue::from_bytes\n      and 2 others\n    --> src/header/value.rs:84:5\n     |\n84   |     pub const fn from_static(src: &'static str) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n133  |     pub fn from_str(src: &str) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n150  |     pub fn from_name(name: HeaderName) -> HeaderValue {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n179  |     pub fn from_bytes(src: &[u8]) -> Result<HeaderValue, InvalidHeaderValue> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `{integer}: IntoHeaderName` is not satisfied\n    --> src/header/map.rs:3922:35\n     |\n3922 |     assert!(header_map.try_append(0, HeaderValue::new()).is_err());\n     |                        ---------- ^ the trait `IntoHeaderName` is not implemented for `{integer}`\n     |                        |\n     |                        required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `IntoHeaderName`:\n               &'a name::HeaderName\n               &'static str\n               name::HeaderName\nnote: required by a bound in `map::HeaderMap::<T>::try_append`\n    --> src/header/map.rs:1411:12\n     |\n1409 |     pub fn try_append<K>(&mut self, key: K, value: T) -> Result<bool, MaxSizeReached>\n     |            ---------- required by a bound in this associated function\n1410 |     where\n1411 |         K: IntoHeaderName,\n     |            ^^^^^^^^^^^^^^ required by this bound in `HeaderMap::<T>::try_append`\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `{integer}: AsHeaderName` is not satisfied\n    --> src/header/map.rs:3922:28\n     |\n3922 |     assert!(header_map.get(0).is_none());\n     |                        --- ^ the trait `AsHeaderName` is not implemented for `{integer}`\n     |                        |\n     |                        required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `AsHeaderName`:\n               &'a String\n               &'a name::HeaderName\n               &'a str\n               String\n               name::HeaderName\nnote: required by a bound in `map::HeaderMap::<T>::get`\n    --> src/header/map.rs:755:12\n     |\n753  |     pub fn get<K>(&self, key: K) -> Option<&T>\n     |            --- required by a bound in this associated function\n754  |     where\n755  |         K: AsHeaderName,\n     |            ^^^^^^^^^^^^ required by this bound in `HeaderMap::<T>::get`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `{integer}: AsHeaderName` is not satisfied\n    --> src/header/map.rs:3922:38\n     |\n3922 |     assert!(!header_map.contains_key(0));\n     |                         ------------ ^ the trait `AsHeaderName` is not implemented for `{integer}`\n     |                         |\n     |                         required by a bound introduced by this call\n     |\n     = help: the following other types implement trait `AsHeaderName`:\n               &'a String\n               &'a name::HeaderName\n               &'a str\n               String\n               name::HeaderName\nnote: required by a bound in `map::HeaderMap::<T>::contains_key`\n    --> src/header/map.rs:853:12\n     |\n851  |     pub fn contains_key<K>(&self, key: K) -> bool\n     |            ------------ required by a bound in this associated function\n852  |     where\n853  |         K: AsHeaderName,\n     |            ^^^^^^^^^^^^ required by this bound in `HeaderMap::<T>::contains_key`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                true,
                false,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key = HeaderName::from(\"Key1\");",
                "    let value = HeaderValue::from(\"Value1\");",
                "    header_map.insert(key.clone(), value.clone());",
                "",
                "    let found = 0;",
                "    let probe = 0;",
                "",
                "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "",
                "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert_eq!(header_map.len(), 1);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(header_map.entries[0].links.is_some());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(header_map.extra_values.len() == 2);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(header_map.indices.len() > 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 0);"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());"
                ],
                [
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.len() == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert_eq!(header_map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(header_map.entries[0].links.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(header_map.extra_values.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    assert!(header_map.indices.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.entries.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.extra_values.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 0, tail: 1 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Verifying that the extra values were linked correctly could be part of another test outside function.",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName::from(\"Key1\");",
                  "    let value = HeaderValue::from(\"Value1\");",
                  "    header_map.insert(key.clone(), value.clone());",
                  "    header_map.extra_values[0].prev = Link::Entry(0);",
                  "    header_map.extra_values[1].prev = Link::Entry(0);",
                  "    let found = 0;",
                  "    let probe = 0;",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.len() == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:15\n     |\n3915 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:17\n     |\n3916 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3923:54\n     |\n3923 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3924:54\n     |\n3924 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:15\n     |\n3930 |     let key = HeaderName::from(\"Key1\");\n     |               ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:17\n     |\n3931 |     let value = HeaderValue::from(\"Value1\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                "    let key1 = HeaderName::from(\"Key1\");",
                "    let value1 = HeaderValue::from(\"Value1\");",
                "    let key2 = HeaderName::from(\"Key2\");",
                "    let value2 = HeaderValue::from(\"Value2\");",
                "    ",
                "    header_map.insert(key1.clone(), value1.clone());",
                "    header_map.insert(key2.clone(), value2.clone());",
                "",
                "    let found = 0; // We will remove the first entry",
                "    let probe = 0; // This should be the probe for the first entry",
                "",
                "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                "    ",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                "    ",
                "    // We assume this creates a link in extra_values.",
                "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                "",
                "    let _entry = header_map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.len(), 0);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert_eq!(header_map.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert!(!header_map.is_empty());"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert!(header_map.contains_key(key1.clone()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert!(header_map.contains_key(key2.clone()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.len(), 1);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(!header_map.contains_key(key1.clone()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.contains_key(key2.clone()));"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.extra_values.len(), 2);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.indices[probe].index, !0);"
                ],
                [
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].resolve().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    assert_eq!(header_map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    assert!(header_map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert_eq!(header_map.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert!(!header_map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert!(header_map.contains_key(key1.clone()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    assert!(header_map.contains_key(key2.clone()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(!header_map.contains_key(key1.clone()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.contains_key(key2.clone()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.extra_values.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert_eq!(header_map.indices[probe].index, !0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    ",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    ",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    ",
                  "    // We assume this creates a link in extra_values.",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "",
                  "    let _entry = header_map.remove_found(probe, found);",
                  "    let mut header_map = HeaderMap::with_capacity(10);",
                  "    let key1 = HeaderName::from(\"Key1\");",
                  "    let value1 = HeaderValue::from(\"Value1\");",
                  "    let key2 = HeaderName::from(\"Key2\");",
                  "    let value2 = HeaderValue::from(\"Value2\");",
                  "    header_map.insert(key1.clone(), value1.clone());",
                  "    header_map.insert(key2.clone(), value2.clone());",
                  "    let found = 0; // We will remove the first entry",
                  "    let probe = 0; // This should be the probe for the first entry",
                  "    header_map.entries[found].links = Some(Links { next: 1, tail: 0 });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });",
                  "    header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });",
                  "    let entry = header_map.remove_found(probe, found);",
                  "    assert!(header_map.indices[probe].resolve().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:16\n     |\n3915 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3916:18\n     |\n3916 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3917:16\n     |\n3917 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3918:18\n     |\n3918 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3928:54\n     |\n3928 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3931:54\n     |\n3931 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3935:16\n     |\n3935 |     let key1 = HeaderName::from(\"Key1\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:18\n     |\n3936 |     let value1 = HeaderValue::from(\"Value1\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `name::HeaderName: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:16\n     |\n3937 |     let key2 = HeaderName::from(\"Key2\");\n     |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `name::HeaderName`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `name::HeaderName` implements `From<&'a name::HeaderName>`\n               `name::HeaderName` implements `From<Custom>`\n               `name::HeaderName` implements `From<HdrName<'a>>`\n               `name::HeaderName` implements `From<name::StandardHeader>`\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3938:18\n     |\n3938 |     let value2 = HeaderValue::from(\"Value2\");\n     |                  ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3944:54\n     |\n3944 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra1\"), prev: Link::Entry(found), next: Link::Entry(found) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3945:54\n     |\n3945 |     header_map.extra_values.push(ExtraValue { value: HeaderValue::from(\"Extra2\"), prev: Link::Entry(found), next: Link::Entry(1) });\n     |                                                      ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 31,
      "prompt_conds": [
        "// constraint: self.entries.swap_remove(found) is \n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is false, with bound self.indices.len() == 0\n"
      ],
      "input_infer": "probe: 0..=0, found: 0..=0, self.indices.len(): 0..=0, self.entries.length: 1..=MAX_SIZE, self.mask: 0..=MAX_SIZE-1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"key\");",
                "    let value = HeaderValue::from_static(\"value\");",
                "    map.insert(key.clone(), value.clone());",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    assert!(!map.is_empty());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, value);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.len(), 0);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    assert!(!map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"key\");",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key.clone(), value.clone());",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    assert!(self.indices.len() == 0);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    assert!(self.entries.is_empty());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    assert!(self.danger.is_green());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    assert!(self.indices.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    assert!(self.entries.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    assert!(self.danger.is_green());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0424]: expected value, found module `self`\n    --> src/header/map.rs:3923:13\n     |\n3911 | #[timeout(1000)]\n     | ---------------- this function can't have a `self` parameter\n...\n3923 |     assert!(self.indices.len() == 0);\n     |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0424`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0424]: expected value, found module `self`\n    --> src/header/map.rs:3923:13\n     |\n3911 | #[timeout(1000)]\n     | ---------------- this function can't have a `self` parameter\n...\n3923 |     assert!(self.entries.is_empty());\n     |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0424`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0424]: expected value, found module `self`\n    --> src/header/map.rs:3923:13\n     |\n3911 | #[timeout(1000)]\n     | ---------------- this function can't have a `self` parameter\n...\n3923 |     assert!(self.danger.is_green());\n     |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0424`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(5);",
                "    for i in 0..5 {",
                "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                "        let value = HeaderValue::from_static(\"value\");",
                "        map.insert(key, value);",
                "    }",
                "",
                "    let probe = 1;",
                "    let found = 1;",
                "",
                "    let _entry = map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    assert_eq!(map.len(), 5);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    assert!(!map.is_empty());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.hash, map.entries[found].hash);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.indices[probe].is_none());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.len(), 4);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.get(HeaderName::from_static(\"key1\")).is_none());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.indices.iter().any(|pos| pos.resolve().is_some()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    assert_eq!(map.len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    assert!(!map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.hash, map.entries[found].hash);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.indices[probe].is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.get(HeaderName::from_static(\"key1\")).is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "        let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "        let value = HeaderValue::from_static(\"value\");",
                  "        map.insert(key, value);",
                  "    }",
                  "",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(5);",
                  "    for i in 0..5 {",
                  "    let key = HeaderName::from_static(format!(\"key{}\", i).as_str());",
                  "    let value = HeaderValue::from_static(\"value\");",
                  "    map.insert(key, value);",
                  "    }",
                  "    let probe = 1;",
                  "    let found = 1;",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert!(map.indices.iter().any(|pos| pos.resolve().is_some()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `entry`\n    --> src/header/map.rs:3933:9\n     |\n3933 |     let entry = map.remove_found(probe, found);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `entry`\n    --> src/header/map.rs:3933:9\n     |\n3933 |     let entry = map.remove_found(probe, found);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `entry`\n    --> src/header/map.rs:3933:9\n     |\n3933 |     let entry = map.remove_found(probe, found);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused variable: `entry`\n    --> src/header/map.rs:3933:9\n     |\n3933 |     let entry = map.remove_found(probe, found);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_entry`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3927:39\n     |\n3927 |     let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                       ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                       |\n     |                                       creates a temporary value which is freed while still in use\n     |                                       argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value dropped while borrowed\n    --> src/header/map.rs:3916:43\n     |\n3916 |         let key = HeaderName::from_static(format!(\"key{}\", i).as_str());\n     |                                           ^^^^^^^^^^^^^^^^^^^--------- - temporary value is freed at the end of this statement\n     |                                           |\n     |                                           creates a temporary value which is freed while still in use\n     |                                           argument requires that borrow lasts for `'static`\n     |\n     = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0716`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName::from_static(\"boundary_key\");",
                "    let value = HeaderValue::from_static(\"boundary_value\");",
                "    map.insert(key, value);",
                "    ",
                "    let probe = 0;",
                "    let found = 0;",
                "    ",
                "    let _entry = map.remove_found(probe, found);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert!(!map.is_empty());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert_eq!(map.keys_len(), 1);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert!(map.contains_key(key));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.len(), 0);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert!(map.is_empty());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert!(!map.contains_key(key));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.keys_len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert!(!map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert_eq!(map.keys_len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    assert!(map.contains_key(key));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert!(map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert!(!map.contains_key(key));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    ",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    ",
                  "    let _entry = map.remove_found(probe, found);",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName::from_static(\"boundary_key\");",
                  "    let value = HeaderValue::from_static(\"boundary_value\");",
                  "    map.insert(key, value);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "    let _entry = map.remove_found(probe, found);",
                  "    assert_eq!(map.keys_len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0382]: use of moved value: `key`\n    --> src/header/map.rs:3927:30\n     |\n3924 |     let key = HeaderName::from_static(\"boundary_key\");\n     |         --- move occurs because `key` has type `name::HeaderName`, which does not implement the `Copy` trait\n3925 |     let value = HeaderValue::from_static(\"boundary_value\");\n3926 |     map.insert(key, value);\n     |                --- value moved here\n3927 |     assert!(map.contains_key(key));\n     |                              ^^^ value used here after move\n     |\nnote: consider changing this parameter type in method `insert` to borrow instead if owning the value isn't necessary\n    --> src/header/map.rs:1228:38\n     |\n1228 |     pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n     |            ------ in this method     ^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n3926 |     map.insert(key.clone(), value);\n     |                   ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0382]: use of moved value: `key`\n    --> src/header/map.rs:3930:31\n     |\n3924 |     let key = HeaderName::from_static(\"boundary_key\");\n     |         --- move occurs because `key` has type `name::HeaderName`, which does not implement the `Copy` trait\n3925 |     let value = HeaderValue::from_static(\"boundary_value\");\n3926 |     map.insert(key, value);\n     |                --- value moved here\n...\n3930 |     assert!(!map.contains_key(key));\n     |                               ^^^ value used here after move\n     |\nnote: consider changing this parameter type in method `insert` to borrow instead if owning the value isn't necessary\n    --> src/header/map.rs:1228:38\n     |\n1228 |     pub fn insert<K>(&mut self, key: K, val: T) -> Option<T>\n     |            ------ in this method     ^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n3926 |     map.insert(key.clone(), value);\n     |                   ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                true,
                false,
                false,
                true,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}