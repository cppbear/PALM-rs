{
  "name": "http::header::map::header::map::VacantEntry<'a, T>::try_insert_entry",
  "name_with_impl": "http::header::map::{impl#36}::try_insert_entry",
  "mod_info": {
    "name": "header::map",
    "loc": "src/header/mod.rs:73:1:73:9"
  },
  "visible": true,
  "loc": "src/header/map.rs:2797:5:2808:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)? is Err/None\n"
      ],
      "input_infer": "1 <= capacity <= 16384, 0 <= hash <= 65535, 0 <= probe < 512, 0 <= danger <= 1, 0 <= value.len() < 65536\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(1024);",
                "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                "    let value = HeaderValue::from(\"test-value\");",
                "    let probe = 0;",
                "    let danger = false;",
                "    let hash = HashValue(12345);",
                "    ",
                "    let vacant_entry = VacantEntry {",
                "        map: &mut map,",
                "        key,",
                "        hash,",
                "        probe,",
                "        danger,",
                "    };",
                "    ",
                "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert_eq!(vacant_entry.map.len(), 0);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert!(vacant_entry.map.is_empty());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert!(vacant_entry.map.try_insert_phase_two(vacant_entry.key, value, vacant_entry.hash, vacant_entry.probe, vacant_entry.danger).is_ok());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(occupied_entry.map.len(), 1);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    assert!(!occupied_entry.map.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert_eq!(vacant_entry.map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert!(vacant_entry.map.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert!(vacant_entry.map.try_insert_phase_two(vacant_entry.key, value, vacant_entry.hash, vacant_entry.probe, vacant_entry.danger).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(occupied_entry.map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let mut map = HeaderMap::with_capacity(1024);",
                  "    let key = HeaderName { inner: Repr::from(\"test-header\") };",
                  "    let value = HeaderValue::from(\"test-value\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(12345);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    assert!(!occupied_entry.map.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"test-header\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"test-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let capacity = 1;",
                "    let mut map = HeaderMap::with_capacity(capacity);",
                "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                "    let value_one = HeaderValue::from(\"value-1\");",
                "    let value_two = HeaderValue::from(\"value-2\");",
                "    ",
                "    let probe = 0;",
                "    let danger = false;",
                "    let hash = HashValue(54321);",
                "    ",
                "    let vacant_entry = VacantEntry {",
                "        map: &mut map,",
                "        key,",
                "        hash,",
                "        probe,",
                "        danger,",
                "    };",
                "    ",
                "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                "    ",
                "    assert!(occupied_entry_two.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert!(occupied_entry_two.is_err());"
                ],
                [
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert!(map.contains_key(key));"
                ],
                [
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert_eq!(map.get(key), Some(&value_one));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    ",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    ",
                  "    assert!(occupied_entry_two.is_err());",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert!(occupied_entry_two.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    ",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    ",
                  "    assert!(occupied_entry_two.is_err());",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    ",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    ",
                  "    assert!(occupied_entry_two.is_err());",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert!(map.contains_key(key));",
                  "}"
                ],
                [
                  "{",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    ",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    ",
                  "    assert!(occupied_entry_two.is_err());",
                  "    let capacity = 1;",
                  "    let mut map = HeaderMap::with_capacity(capacity);",
                  "    let key = HeaderName { inner: Repr::from(\"header-full\") };",
                  "    let value_one = HeaderValue::from(\"value-1\");",
                  "    let value_two = HeaderValue::from(\"value-2\");",
                  "    let probe = 0;",
                  "    let danger = false;",
                  "    let hash = HashValue(54321);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    let _ = vacant_entry.try_insert_entry(value_one).unwrap();",
                  "    let occupied_entry_two = vacant_entry.try_insert_entry(value_two);",
                  "    assert_eq!(map.get(key), Some(&value_one));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:35\n     |\n3913 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3935:35\n     |\n3935 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3914:21\n     |\n3914 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:21\n     |\n3915 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:21\n     |\n3936 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:21\n     |\n3937 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:35\n     |\n3913 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3935:35\n     |\n3935 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3914:21\n     |\n3914 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:21\n     |\n3915 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:21\n     |\n3936 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:21\n     |\n3937 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:35\n     |\n3913 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3935:35\n     |\n3935 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3914:21\n     |\n3914 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:21\n     |\n3915 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:21\n     |\n3936 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:21\n     |\n3937 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:35\n     |\n3913 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3935:35\n     |\n3935 |     let key = HeaderName { inner: Repr::from(\"header-full\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3914:21\n     |\n3914 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3915:21\n     |\n3915 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3936:21\n     |\n3936 |     let value_one = HeaderValue::from(\"value-1\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3937:21\n     |\n3937 |     let value_two = HeaderValue::from(\"value-2\");\n     |                     ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(512);",
                "    let key = HeaderName { inner: Repr::from(\"invalid-probe\") };",
                "    let value = HeaderValue::from(\"value\");",
                "    let probe = 512; // Invalid probe",
                "    let danger = false;",
                "    let hash = HashValue(67890);",
                "    ",
                "    let vacant_entry = VacantEntry {",
                "        map: &mut map,",
                "        key,",
                "        hash,",
                "        probe,",
                "        danger,",
                "    };",
                "",
                "    let _ = vacant_entry.try_insert_entry(value);",
                "}"
              ],
              "oracles": [
                [
                  "    let map = HeaderMap::with_capacity(512);",
                  "    let key = HeaderName { inner: Repr::from(\"invalid-probe\") };",
                  "    let value = HeaderValue::from(\"value\");",
                  "    let probe = 512;",
                  "    let danger = false;",
                  "    let hash = HashValue(67890);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert_eq!(vacant_entry.try_insert_entry(value).is_err(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(512);",
                  "    let key = HeaderName { inner: Repr::from(\"invalid-probe\") };",
                  "    let value = HeaderValue::from(\"value\");",
                  "    let probe = 512; // Invalid probe",
                  "    let danger = false;",
                  "    let hash = HashValue(67890);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "",
                  "    let _ = vacant_entry.try_insert_entry(value);",
                  "    let map = HeaderMap::with_capacity(512);",
                  "    let key = HeaderName { inner: Repr::from(\"invalid-probe\") };",
                  "    let value = HeaderValue::from(\"value\");",
                  "    let probe = 512;",
                  "    let danger = false;",
                  "    let hash = HashValue(67890);",
                  "    let vacant_entry = VacantEntry { map: &mut map, key, hash, probe, danger };",
                  "    assert_eq!(vacant_entry.try_insert_entry(value).is_err(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:35\n     |\n3913 |     let key = HeaderName { inner: Repr::from(\"invalid-probe\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::from(\"invalid-probe\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3914:17\n     |\n3914 |     let value = HeaderValue::from(\"value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3930:17\n     |\n3930 |     let value = HeaderValue::from(\"value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(2048);",
                "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                "    let value = HeaderValue::from(\"danger-value\");",
                "    let probe = 1; // Arbitrary valid probe",
                "    let danger = true; // Danger set to true",
                "    let hash = HashValue(11111);",
                "    ",
                "    let vacant_entry = VacantEntry {",
                "        map: &mut map,",
                "        key,",
                "        hash,",
                "        probe,",
                "        danger,",
                "    };",
                "    ",
                "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    let vacant_entry = VacantEntry {",
                  "    map: &mut map,",
                  "    key,",
                  "    hash,",
                  "    probe,",
                  "    danger,",
                  "    };",
                  "    let result = vacant_entry.try_insert_entry(value);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    let vacant_entry = VacantEntry {",
                  "    map: &mut map,",
                  "    key,",
                  "    hash,",
                  "    probe,",
                  "    danger,",
                  "    };",
                  "    let result = vacant_entry.try_insert_entry(value);",
                  "    let occupied_entry = result.unwrap();",
                  "    assert_eq!(occupied_entry.map.len(), 1);"
                ],
                [
                  "    let map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    let vacant_entry = VacantEntry {",
                  "    map: &mut map,",
                  "    key,",
                  "    hash,",
                  "    probe,",
                  "    danger,",
                  "    };",
                  "    let result = vacant_entry.try_insert_entry(value);",
                  "    let occupied_entry = result.unwrap();",
                  "    assert_eq!(occupied_entry.map.get(\"danger-insert\").unwrap(), &value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    let vacant_entry = VacantEntry {",
                  "    map: &mut map,",
                  "    key,",
                  "    hash,",
                  "    probe,",
                  "    danger,",
                  "    };",
                  "    let result = vacant_entry.try_insert_entry(value);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    let vacant_entry = VacantEntry {",
                  "    map: &mut map,",
                  "    key,",
                  "    hash,",
                  "    probe,",
                  "    danger,",
                  "    };",
                  "    let result = vacant_entry.try_insert_entry(value);",
                  "    let occupied_entry = result.unwrap();",
                  "    assert_eq!(occupied_entry.map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    ",
                  "    let vacant_entry = VacantEntry {",
                  "        map: &mut map,",
                  "        key,",
                  "        hash,",
                  "        probe,",
                  "        danger,",
                  "    };",
                  "    ",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    let map = HeaderMap::with_capacity(2048);",
                  "    let key = HeaderName { inner: Repr::from(\"danger-insert\") };",
                  "    let value = HeaderValue::from(\"danger-value\");",
                  "    let probe = 1; // Arbitrary valid probe",
                  "    let danger = true; // Danger set to true",
                  "    let hash = HashValue(11111);",
                  "    let vacant_entry = VacantEntry {",
                  "    map: &mut map,",
                  "    key,",
                  "    hash,",
                  "    probe,",
                  "    danger,",
                  "    };",
                  "    let result = vacant_entry.try_insert_entry(value);",
                  "    let occupied_entry = result.unwrap();",
                  "    assert_eq!(occupied_entry.map.get(\"danger-insert\").unwrap(), &value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"danger-insert\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"danger-insert\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"danger-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"danger-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"danger-insert\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"danger-insert\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"danger-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"danger-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3912:35\n     |\n3912 |     let key = HeaderName { inner: Repr::from(\"danger-insert\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3928:35\n     |\n3928 |     let key = HeaderName { inner: Repr::from(\"danger-insert\") };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3913:17\n     |\n3913 |     let value = HeaderValue::from(\"danger-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nerror[E0277]: the trait bound `value::HeaderValue: From<&str>` is not satisfied\n    --> src/header/map.rs:3929:17\n     |\n3929 |     let value = HeaderValue::from(\"danger-value\");\n     |                 ^^^^^^^^^^^ the trait `From<&str>` is not implemented for `value::HeaderValue`\n     |\n     = help: the following other types implement trait `From<T>`:\n               `value::HeaderValue` implements `From<&'a value::HeaderValue>`\n               `value::HeaderValue` implements `From<i16>`\n               `value::HeaderValue` implements `From<i32>`\n               `value::HeaderValue` implements `From<i64>`\n               `value::HeaderValue` implements `From<isize>`\n               `value::HeaderValue` implements `From<name::HeaderName>`\n               `value::HeaderValue` implements `From<u16>`\n               `value::HeaderValue` implements `From<u32>`\n             and 2 others\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 4 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.map\n                .try_insert_phase_two(self.key, value, self.hash, self.probe, self.danger)? is Ok/Some\n",
        "// expected return value/type: Ok(OccupiedEntry {\n            map: self.map,\n            index,\n            probe: self.probe,\n        })\n"
      ],
      "input_infer": "0 < size <= 32768, 0 < key.length <= 256, 0 < value.length <= 256\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[should_panic]",
            "fn test_try_insert_entry_when_map_reaches_max_size() {",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() {",
            "        let _ = v.try_insert_entry(value_1).unwrap();",
            "    }",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() {",
            "        let _ = v.try_insert_entry(value_2).unwrap(); // This will panic if map is at max size",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(10);",
                "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                "    let value = \"test-value\".parse().unwrap();",
                "    ",
                "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                "        let e = v.try_insert_entry(value).unwrap();",
                "        e.insert(\"new-value\".parse().unwrap());",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    assert_eq!(map.len(), 0);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    assert!(matches!(entry_1, Entry::Vacant(_)));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    assert!(matches!(entry_2, Entry::Vacant(_)));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    assert!(std::panic::catch_unwind(|| {"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
                  "    }).is_err());",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"test-key\").unwrap();",
                  "    assert!(matches!(entry, Entry::Vacant(_)));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
                  "    }).is_err());",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"test-key\").unwrap();",
                  "    let e = entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
                  "    }).is_err());",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"test-key\").unwrap();",
                  "    let e = entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(e.key(), &key);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    assert_eq!(map.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    assert!(matches!(entry_1, Entry::Vacant(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    assert!(matches!(entry_2, Entry::Vacant(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
                  "    }).is_err());",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"test-key\").unwrap();",
                  "    assert!(matches!(entry, Entry::Vacant(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
                  "    }).is_err());",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"test-key\").unwrap();",
                  "    let e = entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"new-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
                  "    }).is_err());",
                  "    let mut map = HeaderMap::with_capacity(10);",
                  "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
                  "    let value = \"test-value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"test-key\").unwrap();",
                  "    let e = entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(e.key(), &key);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; \n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; \n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; \n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:21\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let _ = entry_1.try_insert_entry(value_1).unwrap();\n     |                     ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let _ = entry_1.or_insert_with(value_1).unwrap();\n     |                     ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; \n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:21\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let _ = entry_1.try_insert_entry(value_1).unwrap();\n     |                     ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let _ = entry_1.or_insert_with(value_1).unwrap();\n     |                     ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror: mismatched closing delimiter: `}`\n    --> src/header/map.rs:3944:37\n     |\n3927 | {\n     | - closing delimiter possibly meant for this\n...\n3944 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n3945 | }\n3946 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> src/header/map.rs:3946:3\n     |\n3905 | mod llmtests {\n     |              - unclosed delimiter\n...\n3946 | }\n     |   ^\n\nerror: could not compile `http` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror: mismatched closing delimiter: `)`\n    --> src/header/map.rs:3905:14\n     |\n3905 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n3945 |     }).is_err());\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/header/map.rs:3945:16\n     |\n3945 |     }).is_err());\n     |      -         ^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `http` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror: mismatched closing delimiter: `)`\n    --> src/header/map.rs:3905:14\n     |\n3905 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n3945 |     }).is_err());\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/header/map.rs:3945:16\n     |\n3945 |     }).is_err());\n     |      -         ^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `http` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror: mismatched closing delimiter: `)`\n    --> src/header/map.rs:3905:14\n     |\n3905 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n3945 |     }).is_err());\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/header/map.rs:3945:16\n     |\n3945 |     }).is_err());\n     |      -         ^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `http` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(1);",
                "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                "    let value = \"long-value\".repeat(10).parse().unwrap();",
                "    ",
                "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                "        let e = v.try_insert_entry(value).unwrap();",
                "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    assert!(map.try_entry(\"key1\").is_ok());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    assert!(vacant_entry_1.try_insert_entry(value_1).is_ok());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    assert!(map.try_entry(\"key2\").is_ok());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    assert!(vacant_entry_2.try_insert_entry(value_2).is_err());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    assert!(map.try_entry(\"long-key\".repeat(10)).is_ok());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
                  "    assert!(vacant_entry.try_insert_entry(value).is_ok());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(occupied_entry.map[occupied_entry.index], \"another-value\".repeat(10).parse().unwrap());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    assert!(map.try_entry(\"key1\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    assert!(vacant_entry_1.try_insert_entry(value_1).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    assert!(map.try_entry(\"key2\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    assert!(vacant_entry_2.try_insert_entry(value_2).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    assert!(map.try_entry(\"long-key\".repeat(10)).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
                  "    assert!(vacant_entry.try_insert_entry(value).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
                  "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
                  "    let value = \"long-value\".repeat(10).parse().unwrap();",
                  "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
                  "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
                  "    assert_eq!(occupied_entry.map[occupied_entry.index], \"another-value\".repeat(10).parse().unwrap());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `usize: AsHeaderName` is not satisfied\n    --> src/header/map.rs:3948:35\n     |\n3948 |     assert_eq!(occupied_entry.map[occupied_entry.index], \"another-value\".repeat(10).parse().unwrap());\n     |                                   ^^^^^^^^^^^^^^^^^^^^ the trait `AsHeaderName` is not implemented for `usize`, which is required by `map::HeaderMap<_>: Index<_>`\n     |\n     = help: the following other types implement trait `AsHeaderName`:\n               &'a String\n               &'a name::HeaderName\n               &'a str\n               String\n               name::HeaderName\nnote: required for `map::HeaderMap<_>` to implement `Index<usize>`\n    --> src/header/map.rs:2173:12\n     |\n2173 | impl<K, T> ops::Index<K> for HeaderMap<T>\n     |            ^^^^^^^^^^^^^     ^^^^^^^^^^^^\n2174 | where\n2175 |     K: AsHeaderName,\n     |        ------------ unsatisfied trait bound introduced here\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 7 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(0);",
                "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                "    let value = \"value\".parse().unwrap();",
                "    ",
                "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
                "        let e = v.try_insert_entry(value).unwrap();",
                "        e.insert(\"updated-value\".parse().unwrap());",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    assert!(matches!(entry_1, Entry::Vacant(_)));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    assert!(matches!(entry_2, Entry::Vacant(_)));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let result = entry_2.try_insert_entry(value_2);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let result = entry_2.try_insert_entry(value_2);",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
                  "    assert!(matches!(entry, Entry::Vacant(_)));"
                ],
                [
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let result = entry_2.try_insert_entry(value_2);",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
                  "    let e = entry.try_insert_entry(value).unwrap();",
                  "    let updated_value = \"updated-value\".parse().unwrap();",
                  "    let old_value = e.insert(updated_value);",
                  "    assert_eq!(old_value, &value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"updated-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    assert!(matches!(entry_1, Entry::Vacant(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"updated-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    assert!(matches!(entry_2, Entry::Vacant(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"updated-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let result = entry_2.try_insert_entry(value_2);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"updated-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let result = entry_2.try_insert_entry(value_2);",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
                  "    assert!(matches!(entry, Entry::Vacant(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
                  "        let e = v.try_insert_entry(value).unwrap();",
                  "        e.insert(\"updated-value\".parse().unwrap());",
                  "    }",
                  "    let mut map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let entry_1 = map.try_entry(\"key1\").unwrap();",
                  "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
                  "    let entry_2 = map.try_entry(\"key2\").unwrap();",
                  "    let result = entry_2.try_insert_entry(value_2);",
                  "    let mut map = HeaderMap::with_capacity(0);",
                  "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
                  "    let value = \"value\".parse().unwrap();",
                  "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
                  "    let e = entry.try_insert_entry(value).unwrap();",
                  "    let updated_value = \"updated-value\".parse().unwrap();",
                  "    let old_value = e.insert(updated_value);",
                  "    assert_eq!(old_value, &value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 5 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:21\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let _ = entry_1.try_insert_entry(value_1).unwrap();\n     |                     ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let _ = entry_1.or_insert_with(value_1).unwrap();\n     |                     ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 6 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:21\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let _ = entry_1.try_insert_entry(value_1).unwrap();\n     |                     ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let _ = entry_1.or_insert_with(value_1).unwrap();\n     |                     ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3944:26\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3944 |     let result = entry_2.try_insert_entry(value_2);\n     |                          ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3944 |     let result = entry_2.or_insert_with(value_2);\n     |                          ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 7 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3946:35\n     |\n3946 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:21\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let _ = entry_1.try_insert_entry(value_1).unwrap();\n     |                     ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let _ = entry_1.or_insert_with(value_1).unwrap();\n     |                     ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3944:26\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3944 |     let result = entry_2.try_insert_entry(value_2);\n     |                          ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3944 |     let result = entry_2.or_insert_with(value_2);\n     |                          ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 8 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3946:35\n     |\n3946 |     let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:21\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let _ = entry_1.try_insert_entry(value_1).unwrap();\n     |                     ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let _ = entry_1.or_insert_with(value_1).unwrap();\n     |                     ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3944:26\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3944 |     let result = entry_2.try_insert_entry(value_2);\n     |                          ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3944 |     let result = entry_2.or_insert_with(value_2);\n     |                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3949:19\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3949 |     let e = entry.try_insert_entry(value).unwrap();\n     |                   ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3949 |     let e = entry.or_insert_with(value).unwrap();\n     |                   ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 9 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut map = HeaderMap::with_capacity(32768);",
                "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                "    let value = \"max-value\".parse().unwrap();",
                "    ",
                "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    assert!(result_1.is_ok());"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    assert!(result_2.is_err());"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    assert!(result_entry.is_ok());"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    assert!(occupied_entry.is_ok());"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    let e = occupied_entry.unwrap();",
                  "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
                  "    assert!(result_insert.is_ok());"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    let e = occupied_entry.unwrap();",
                  "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
                  "    assert_eq!(map.len(), 1);"
                ],
                [
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    let e = occupied_entry.unwrap();",
                  "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
                  "    let inserted_value = e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    assert_eq!(inserted_value, \"new-value\".parse().unwrap());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    assert!(result_1.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    assert!(result_2.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    assert!(result_entry.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    assert!(occupied_entry.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    let e = occupied_entry.unwrap();",
                  "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
                  "    assert!(result_insert.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    let e = occupied_entry.unwrap();",
                  "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
                  "    assert_eq!(map.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    ",
                  "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
                  "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
                  "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    }",
                  "    let map = HeaderMap::with_capacity(1);",
                  "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
                  "    let value_1 = \"value1\".parse().unwrap();",
                  "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
                  "    let value_2 = \"value2\".parse().unwrap();",
                  "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
                  "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
                  "    let map = HeaderMap::with_capacity(32768);",
                  "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
                  "    let value = \"max-value\".parse().unwrap();",
                  "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
                  "    let occupied_entry = result_entry.try_insert_entry(value);",
                  "    let e = occupied_entry.unwrap();",
                  "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
                  "    let inserted_value = e.insert(\"value-at-max-capacity\".parse().unwrap());",
                  "    assert_eq!(inserted_value, \"new-value\".parse().unwrap());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 7 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 7 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 8 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 8 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_ok` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3947:26\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `is_ok` not found for this enum\n...\n3947 |     assert!(result_entry.is_ok());\n     |                          ^^^^^ method not found in `Entry<'_, _>`\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3947:39\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3947 |     let occupied_entry = result_entry.try_insert_entry(value);\n     |                                       ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3947 |     let occupied_entry = result_entry.or_insert_with(value);\n     |                                       ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3947:39\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3947 |     let occupied_entry = result_entry.try_insert_entry(value);\n     |                                       ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3947 |     let occupied_entry = result_entry.or_insert_with(value);\n     |                                       ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling serde_json v1.0.140\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3947:39\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3947 |     let occupied_entry = result_entry.try_insert_entry(value);\n     |                                       ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3947 |     let occupied_entry = result_entry.or_insert_with(value);\n     |                                       ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling libc v0.2.172\n   Compiling proc-macro2 v1.0.95\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling serde_json v1.0.140\n   Compiling doc-comment v0.3.3\n   Compiling quote v1.0.40\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling quickcheck v1.0.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates/http)\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3911:37\n     |\n3911 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3913:37\n     |\n3913 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3929:35\n     |\n3929 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3937:37\n     |\n3937 |     let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3939:37\n     |\n3939 |     let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };\n     |                                     ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Repr`\n    --> src/header/map.rs:3944:35\n     |\n3944 |     let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };\n     |                                   ^^^^ use of undeclared type `Repr`\n     |\nnote: enum `crate::header::name::Repr` exists but is inaccessible\n    --> src/header/name.rs:44:1\n     |\n44   | enum Repr<T> {\n     | ^^^^^^^^^^^^ not accessible\n\nwarning: unused import: `ntest::timeout`\n    --> src/header/map.rs:3907:8\n     |\n3907 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3932:74\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {\n     |                               ---                                        ^^^^^^^^^^^^^^^^\n     |                               |\n     |                               method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3932 |     if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().or_insert_with(value) {\n     |                                                                          ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3941:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3941 |     let result_1 = map.try_entry(\"key1\").unwrap().or_insert_with(value_1);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3942:51\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);\n     |                    ---                            ^^^^^^^^^^^^^^^^\n     |                    |\n     |                    method `try_insert_entry` is available on `&mut map::HeaderMap<_>`\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3942 |     let result_2 = map.try_entry(\"key2\").unwrap().or_insert_with(value_2);\n     |                                                   ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `try_insert_entry` found for enum `map::Entry` in the current scope\n    --> src/header/map.rs:3947:39\n     |\n159  | pub enum Entry<'a, T: 'a> {\n     | ------------------------- method `try_insert_entry` not found for this enum\n...\n3947 |     let occupied_entry = result_entry.try_insert_entry(value);\n     |                                       ^^^^^^^^^^^^^^^^\n     |\nnote: the method `try_insert_entry` exists on the type `map::VacantEntry<'_, _>`\n    --> src/header/map.rs:2797:5\n     |\n2797 |     pub fn try_insert_entry(self, value: T) -> Result<OccupiedEntry<'a, T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is a method `or_insert_with` with a similar name\n     |\n3947 |     let occupied_entry = result_entry.or_insert_with(value);\n     |                                       ~~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}