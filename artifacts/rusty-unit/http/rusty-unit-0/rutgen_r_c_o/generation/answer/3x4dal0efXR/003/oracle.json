[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
          "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    load_factor < LOAD_FACTOR_THRESHOLD;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    header_map.rebuild();",
            "    assert_eq!(result, Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    load_factor < LOAD_FACTOR_THRESHOLD;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    header_map.rebuild();",
            "    assert_eq!(result, Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
          "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert!(load_factor < LOAD_FACTOR_THRESHOLD);"
          ],
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    let capacity_before_rebuild = header_map.capacity();",
            "    header_map.rebuild();",
            "    assert!(header_map.capacity() > capacity_before_rebuild);"
          ],
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    let capacity_before_rebuild = header_map.capacity();",
            "    header_map.rebuild();",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    let capacity_before_rebuild = header_map.capacity();",
            "    header_map.rebuild();",
            "    assert!(header_map.danger.is_red());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert!(load_factor < LOAD_FACTOR_THRESHOLD);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    let capacity_before_rebuild = header_map.capacity();",
            "    header_map.rebuild();",
            "    assert!(header_map.capacity() > capacity_before_rebuild);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    let capacity_before_rebuild = header_map.capacity();",
            "    header_map.rebuild();",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 28];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none());",
            "    let capacity_before_rebuild = header_map.capacity();",
            "    header_map.rebuild();",
            "    assert!(header_map.danger.is_red());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries.clear();",
          "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(())); // expected return value/type: Ok(())"
          ],
          [
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    assert!(header_map.danger.is_yellow()); // check danger level is yellow"
          ],
          [
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    assert!(header_map.indices.len() == 8); // ensure capacity of indices is correct"
          ],
          [
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert!(load_factor < LOAD_FACTOR_THRESHOLD); // check load_factor is as expected"
          ],
          [
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red(); // transition to red danger level",
            "    assert!(header_map.danger.is_red()); // check danger level is red"
          ],
          [
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red(); // transition to red danger level",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none()); // resetting indices",
            "    assert!(header_map.indices.iter().all(|index| index.is_none())); // ensure all indices are none"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(())); // expected return value/type: Ok(())",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    assert!(header_map.danger.is_yellow()); // check danger level is yellow",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    assert!(header_map.indices.len() == 8); // ensure capacity of indices is correct",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert!(load_factor < LOAD_FACTOR_THRESHOLD); // check load_factor is as expected",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red(); // transition to red danger level",
            "    assert!(header_map.danger.is_red()); // check danger level is red",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(8);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries.clear();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.push(HeaderValue::new()); // resulting in load_factor < LOAD_FACTOR_THRESHOLD",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow(); // ensuring danger is yellow",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red(); // transition to red danger level",
            "    header_map.indices.iter_mut().for_each(|index| *index = Pos::none()); // resetting indices",
            "    assert!(header_map.indices.iter().all(|index| index.is_none())); // ensure all indices are none",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 20];",
          "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    for index in header_map.indices.iter_mut() {",
            "    *index = Pos::none();",
            "    }",
            "    header_map.rebuild();",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    for index in header_map.indices.iter_mut() {",
            "    *index = Pos::none();",
            "    }",
            "    header_map.rebuild();",
            "    assert!(header_map.danger.is_red());"
          ],
          [
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    for index in header_map.indices.iter_mut() {",
            "    *index = Pos::none();",
            "    }",
            "    header_map.rebuild();",
            "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 20];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    for index in header_map.indices.iter_mut() {",
            "    *index = Pos::none();",
            "    }",
            "    header_map.rebuild();",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 20];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    for index in header_map.indices.iter_mut() {",
            "    *index = Pos::none();",
            "    }",
            "    header_map.rebuild();",
            "    assert!(header_map.danger.is_red());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 20];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    header_map.danger.set_red();",
            "    for index in header_map.indices.iter_mut() {",
            "    *index = Pos::none();",
            "    }",
            "    header_map.rebuild();",
            "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
          "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
          "",
          "    let result = header_map.try_reserve_one();",
          "    // header_map.capacity should now be 256",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    // header_map.capacity should now be 256",
            "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "",
            "    let result = header_map.try_reserve_one();",
            "    // header_map.capacity should now be 256",
            "    let header_map = HeaderMap::<HeaderValue>::with_capacity(128);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(0), key: HeaderName::new(), value: HeaderValue::new(), links: None }; 25];",
            "    header_map.indices = vec![Pos::none(); 128].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]