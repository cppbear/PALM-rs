[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(8192);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket {",
          "        hash: HashValue(1),",
          "        key: HeaderName::from(\"test-key-1\").unwrap(),",
          "        value: HeaderValue::from(\"test-value-1\".to_string()),",
          "        links: None,",
          "    }; 3276];",
          "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
          "    ",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 8192);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.danger.is_green());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-1\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-1\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-1\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-1\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 8192);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-1\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-1\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 is chosen to satisfy 0.2 load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-1\").unwrap(), value: HeaderValue::from(\"test-value-1\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.danger.is_green());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(8192);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket {",
          "        hash: HashValue(1),",
          "        key: HeaderName::from(\"test-key-2\").unwrap(),",
          "        value: HeaderValue::from(\"test-value-2\".to_string()),",
          "        links: None,",
          "    }; 3276];",
          "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
          "    ",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.danger.is_yellow(), true);"
          ],
          [
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.entries.len(), 3276);"
          ],
          [
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.indices.len(), 4096);"
          ],
          [
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert!(header_map.try_reserve_one().is_ok());"
          ],
          [
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.danger.is_green(), true);"
          ],
          [
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert!(header_map.capacity() > 4096);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-2\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-2\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.danger.is_yellow(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-2\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-2\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.entries.len(), 3276);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-2\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-2\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.indices.len(), 4096);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-2\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-2\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert!(header_map.try_reserve_one().is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-2\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-2\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert_eq!(header_map.danger.is_green(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-2\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-2\".to_string()),",
            "        links: None,",
            "    }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice(); // 4096 to maintain load factor",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(1), key: HeaderName::from(\"test-key-2\").unwrap(), value: HeaderValue::from(\"test-value-2\".to_string()), links: None }; 3276];",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 4096].into_boxed_slice();",
            "    assert!(header_map.capacity() > 4096);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(8192);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = Vec::new();",
          "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.danger.is_yellow());"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.danger.is_yellow(), false);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.danger.is_green(), true);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.indices.len() > 8);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.danger.is_yellow());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.danger.is_yellow(), false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.danger.is_green(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice(); // initially empty with capacity no entries",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = Vec::new();",
            "    header_map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    header_map.entries.len();",
            "    header_map.indices.len();",
            "    let load_factor = header_map.entries.len() as f32 / header_map.indices.len() as f32;",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.indices.len() > 8);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(8192);",
          "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
          "    header_map.entries = vec![Bucket {",
          "        hash: HashValue(1),",
          "        key: HeaderName::from(\"test-key-3\").unwrap(),",
          "        value: HeaderValue::from(\"test-value-3\".to_string()),",
          "        links: None,",
          "    }; 8192]; // fill it to maximum capacity",
          "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
          "    ",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let len = header_map.entries.len();",
            "    assert_eq!(len, 8192);"
          ],
          [
            "    let len = header_map.entries.len();",
            "    assert!(header_map.danger.is_yellow());"
          ],
          [
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);"
          ],
          [
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.try_grow(16384).is_ok());"
          ],
          [
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.danger.is_green());"
          ],
          [
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.capacity() > 8192);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    assert_eq!(len, 8192);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    assert!(header_map.danger.is_yellow());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert_eq!(load_factor, LOAD_FACTOR_THRESHOLD);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.try_grow(16384).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.danger.is_green());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(8192);",
            "    header_map.danger.set_green(); // starts green, will simulate a full capacity",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"test-key-3\").unwrap(),",
            "        value: HeaderValue::from(\"test-value-3\".to_string()),",
            "        links: None,",
            "    }; 8192]; // fill it to maximum capacity",
            "    header_map.indices = vec![Pos::new(i, HashValue(1)); 8192].into_boxed_slice(); // set indices to max length",
            "    ",
            "    let result = header_map.try_reserve_one();",
            "    let len = header_map.entries.len();",
            "    let load_factor = len as f32 / header_map.indices.len() as f32;",
            "    assert!(header_map.capacity() > 8192);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]