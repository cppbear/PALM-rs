[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(256);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket {",
          "        hash: HashValue(1),",
          "        key: HeaderName::from(\"key1\").unwrap(),",
          "        value: HeaderValue::from(\"value1\"),",
          "        links: None,",
          "    }; 127]; // 0 < self.entries.len() < 128",
          "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_yellow(), true);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.entries.len() < 128);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.indices.len() > 128);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.danger.is_green(), true);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.capacity() > 256);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.entries.len(), 127);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.indices.len() % 2, 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_yellow(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.entries.len() < 128);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.indices.len() > 128);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.danger.is_green(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.capacity() > 256);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.entries.len(), 127);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(1),",
            "        key: HeaderName::from(\"key1\").unwrap(),",
            "        value: HeaderValue::from(\"value1\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(1),",
            "    key: HeaderName::from(\"key1\").unwrap(),",
            "    value: HeaderValue::from(\"value1\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.indices.len() % 2, 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(256);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket {",
          "        hash: HashValue(2),",
          "        key: HeaderName::from(\"key2\").unwrap(),",
          "        value: HeaderValue::from(\"value2\"),",
          "        links: None,",
          "    }; 127]; // 0 < self.entries.len() < 128",
          "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_green(), false);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_red(), false);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_yellow(), true);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.try_grow(512).is_err());"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.entries.len(), 127);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.indices.len(), 256);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(result.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_green(), false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_red(), false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.danger.is_yellow(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.try_grow(512).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.entries.len(), 127);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.indices.len(), 256);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(2),",
            "        key: HeaderName::from(\"key2\").unwrap(),",
            "        value: HeaderValue::from(\"value2\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "    hash: HashValue(2),",
            "    key: HeaderName::from(\"key2\").unwrap(),",
            "    value: HeaderValue::from(\"value2\"),",
            "    links: None,",
            "    }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(result.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(256);",
          "    header_map.danger.set_yellow();",
          "    header_map.entries = vec![Bucket {",
          "        hash: HashValue(3),",
          "        key: HeaderName::from(\"key3\").unwrap(),",
          "        value: HeaderValue::from(\"value3\"),",
          "        links: None,",
          "    }; 127]; // 0 < self.entries.len() < 128",
          "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
          "",
          "    let result = header_map.try_reserve_one();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.try_reserve_one(), Ok(()));"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.danger.is_red());"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.entries.is_empty());"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.indices.iter().all(|index| index.is_none()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName::from(\"key3\").unwrap(),",
            "        value: HeaderValue::from(\"value3\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert_eq!(header_map.try_reserve_one(), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName::from(\"key3\").unwrap(),",
            "        value: HeaderValue::from(\"value3\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.danger.is_red());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName::from(\"key3\").unwrap(),",
            "        value: HeaderValue::from(\"value3\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.entries.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName::from(\"key3\").unwrap(),",
            "        value: HeaderValue::from(\"value3\"),",
            "        links: None,",
            "    }; 127]; // 0 < self.entries.len() < 128",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256]; // self.indices.len() > 128",
            "",
            "    let result = header_map.try_reserve_one();",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    header_map.danger.set_yellow();",
            "    header_map.entries = vec![Bucket { hash: HashValue(3), key: HeaderName::from(\"key3\").unwrap(), value: HeaderValue::from(\"value3\"), links: None, }; 127];",
            "    header_map.indices = vec![Pos::new(i, HashValue(i as u64)); 256];",
            "    assert!(header_map.indices.iter().all(|index| index.is_none()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]