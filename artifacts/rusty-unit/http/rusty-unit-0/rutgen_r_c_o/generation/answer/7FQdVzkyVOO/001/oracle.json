[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(16);",
          "    let entry = map.entry(\"test_key\");",
          "    if let Entry::Vacant(_) = entry {}",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert!(matches!(entry, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert_eq!(map.len(), 0);"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert!(map.is_empty());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert_eq!(map.capacity(), 16);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    if let Entry::Vacant(_) = entry {}",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert!(matches!(entry, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    if let Entry::Vacant(_) = entry {}",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert_eq!(map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    if let Entry::Vacant(_) = entry {}",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert!(map.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    if let Entry::Vacant(_) = entry {}",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"test_key\");",
            "    assert_eq!(map.capacity(), 16);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(16);",
          "    map.insert(\"single_key\", \"single_value\".to_string());",
          "    if let Entry::Occupied(mut entry) = map.entry(\"single_key\") {",
          "        let mut iter = entry.iter_mut();",
          "        let value = iter.next().unwrap();",
          "        value.push_str(\"-modified\");",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    assert!(entry.is_ok());"
          ],
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    let occupied_entry = entry.unwrap();",
            "    let mut iter = occupied_entry.iter_mut();",
            "    assert!(iter.next().is_some());"
          ],
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    let occupied_entry = entry.unwrap();",
            "    let mut iter = occupied_entry.iter_mut();",
            "    let value = iter.next().unwrap();",
            "    assert_eq!(value, \"single_value-modified\");"
          ],
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    let occupied_entry = entry.unwrap();",
            "    let mut iter = occupied_entry.iter_mut();",
            "    let value = iter.next().unwrap();",
            "    assert!(iter.next().is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.insert(\"single_key\", \"single_value\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"single_key\") {",
            "        let mut iter = entry.iter_mut();",
            "        let value = iter.next().unwrap();",
            "        value.push_str(\"-modified\");",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    assert!(entry.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.insert(\"single_key\", \"single_value\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"single_key\") {",
            "        let mut iter = entry.iter_mut();",
            "        let value = iter.next().unwrap();",
            "        value.push_str(\"-modified\");",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    let occupied_entry = entry.unwrap();",
            "    let mut iter = occupied_entry.iter_mut();",
            "    assert!(iter.next().is_some());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.insert(\"single_key\", \"single_value\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"single_key\") {",
            "        let mut iter = entry.iter_mut();",
            "        let value = iter.next().unwrap();",
            "        value.push_str(\"-modified\");",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    let occupied_entry = entry.unwrap();",
            "    let mut iter = occupied_entry.iter_mut();",
            "    let value = iter.next().unwrap();",
            "    assert_eq!(value, \"single_value-modified\");",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.insert(\"single_key\", \"single_value\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"single_key\") {",
            "        let mut iter = entry.iter_mut();",
            "        let value = iter.next().unwrap();",
            "        value.push_str(\"-modified\");",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    let entry = map.entry(\"single_key\");",
            "    let occupied_entry = entry.unwrap();",
            "    let mut iter = occupied_entry.iter_mut();",
            "    let value = iter.next().unwrap();",
            "    assert!(iter.next().is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(16);",
          "    map.append(\"multi_key\", \"value_one\".to_string());",
          "    map.append(\"multi_key\", \"value_two\".to_string());",
          "    if let Entry::Occupied(mut entry) = map.entry(\"multi_key\") {",
          "        for value in entry.iter_mut() {",
          "            value.push_str(\"-modified\");",
          "        }",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"multi_key\");",
            "    assert!(matches!(entry, Entry::Occupied(_)));"
          ],
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"multi_key\");",
            "    let values = map.get_all(\"multi_key\");",
            "    let mut i = values.iter();",
            "    assert_eq!(i.next().unwrap(), \"value_one-modified\");"
          ],
          [
            "    let map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"multi_key\");",
            "    let values = map.get_all(\"multi_key\");",
            "    let mut i = values.iter();",
            "    assert_eq!(i.next().unwrap(), \"value_two-modified\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"multi_key\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"multi_key\");",
            "    assert!(matches!(entry, Entry::Occupied(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"multi_key\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"multi_key\");",
            "    let values = map.get_all(\"multi_key\");",
            "    let mut i = values.iter();",
            "    assert_eq!(i.next().unwrap(), \"value_one-modified\");",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"multi_key\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let map = HeaderMap::with_capacity(16);",
            "    map.append(\"multi_key\", \"value_one\".to_string());",
            "    map.append(\"multi_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"multi_key\");",
            "    let values = map.get_all(\"multi_key\");",
            "    let mut i = values.iter();",
            "    assert_eq!(i.next().unwrap(), \"value_two-modified\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let max_capacity = 32768;",
          "    let mut map = HeaderMap::with_capacity(max_capacity);",
          "    for i in 0..max_capacity {",
          "        map.append(i.to_string().as_str(), \"value\".to_string());",
          "    }",
          "    if let Entry::Occupied(mut entry) = map.entry(\"0\") {",
          "        for value in entry.iter_mut() {",
          "            value.push_str(\"-modified\");",
          "        }",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    assert!(entry.is_ok());"
          ],
          [
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    if let Entry::Occupied(ref mut entry) = entry {",
            "    let mut iter = entry.iter_mut();",
            "    assert_eq!(iter.next().unwrap(), \"value-modified\");"
          ],
          [
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    if let Entry::Occupied(ref mut entry) = entry {",
            "    let mut iter = entry.iter_mut();",
            "    }",
            "    assert_eq!(map.get(\"0\").unwrap().len(), 1);"
          ],
          [
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    if let Entry::Occupied(ref mut entry) = entry {",
            "    let mut iter = entry.iter_mut();",
            "    }",
            "    assert_eq!(map.get_all(\"0\").len(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let max_capacity = 32768;",
            "    let mut map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "        map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    if let Entry::Occupied(mut entry) = map.entry(\"0\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    assert!(entry.is_ok());",
            "}"
          ],
          [
            "{",
            "    let max_capacity = 32768;",
            "    let mut map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "        map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    if let Entry::Occupied(mut entry) = map.entry(\"0\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    if let Entry::Occupied(ref mut entry) = entry {",
            "    let mut iter = entry.iter_mut();",
            "    assert_eq!(iter.next().unwrap(), \"value-modified\");",
            "}"
          ],
          [
            "{",
            "    let max_capacity = 32768;",
            "    let mut map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "        map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    if let Entry::Occupied(mut entry) = map.entry(\"0\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    if let Entry::Occupied(ref mut entry) = entry {",
            "    let mut iter = entry.iter_mut();",
            "    }",
            "    assert_eq!(map.get(\"0\").unwrap().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let max_capacity = 32768;",
            "    let mut map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "        map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    if let Entry::Occupied(mut entry) = map.entry(\"0\") {",
            "        for value in entry.iter_mut() {",
            "            value.push_str(\"-modified\");",
            "        }",
            "    }",
            "    let max_capacity = 32768;",
            "    let map = HeaderMap::with_capacity(max_capacity);",
            "    for i in 0..max_capacity {",
            "    map.append(i.to_string().as_str(), \"value\".to_string());",
            "    }",
            "    let entry = map.entry(\"0\");",
            "    if let Entry::Occupied(ref mut entry) = entry {",
            "    let mut iter = entry.iter_mut();",
            "    }",
            "    assert_eq!(map.get_all(\"0\").len(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(16);",
          "    map.append(\"key1\", \"value1\".to_string());",
          "    map.append(\"key1\", \"value2\".to_string());",
          "    ",
          "    if let Entry::Occupied(mut entry) = map.entry(\"key1\") {",
          "        assert_eq!(entry.iter_mut().count(), 2);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"key1\", \"value1\".to_string());",
            "    map.append(\"key1\", \"value2\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"key1\") {",
            "    assert_eq!(entry.iter_mut().count(), 2);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"key1\", \"value1\".to_string());",
            "    map.append(\"key1\", \"value2\".to_string());",
            "    ",
            "    if let Entry::Occupied(mut entry) = map.entry(\"key1\") {",
            "        assert_eq!(entry.iter_mut().count(), 2);",
            "    }",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"key1\", \"value1\".to_string());",
            "    map.append(\"key1\", \"value2\".to_string());",
            "    if let Entry::Occupied(mut entry) = map.entry(\"key1\") {",
            "    assert_eq!(entry.iter_mut().count(), 2);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(16);",
          "    map.append(\"removal_key\", \"value_one\".to_string());",
          "    map.append(\"removal_key\", \"value_two\".to_string());",
          "    ",
          "    if let Entry::Occupied(entry) = map.entry(\"removal_key\") {",
          "        let first_value = entry.iter_mut().next().unwrap();",
          "        let removed_value = entry.remove();",
          "        assert_eq!(removed_value, \"value_one\".to_string());",
          "        first_value.push_str(\"-post_remove\");",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    assert!(entry.is_occupied());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    assert_eq!(entry.len(), 2);"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    let removed_value = entry.remove();",
            "    assert_eq!(removed_value, \"value_one\".to_string());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    let removed_value = entry.remove();",
            "    assert_eq!(first_value, \"value_two\".to_string());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    let removed_value = entry.remove();",
            "    first_value.push_str(\"-post_remove\");",
            "    assert_eq!(first_value, \"value_two-post_remove\".to_string());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    ",
            "    if let Entry::Occupied(entry) = map.entry(\"removal_key\") {",
            "        let first_value = entry.iter_mut().next().unwrap();",
            "        let removed_value = entry.remove();",
            "        assert_eq!(removed_value, \"value_one\".to_string());",
            "        first_value.push_str(\"-post_remove\");",
            "    }",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    assert!(entry.is_occupied());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    ",
            "    if let Entry::Occupied(entry) = map.entry(\"removal_key\") {",
            "        let first_value = entry.iter_mut().next().unwrap();",
            "        let removed_value = entry.remove();",
            "        assert_eq!(removed_value, \"value_one\".to_string());",
            "        first_value.push_str(\"-post_remove\");",
            "    }",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    assert_eq!(entry.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    ",
            "    if let Entry::Occupied(entry) = map.entry(\"removal_key\") {",
            "        let first_value = entry.iter_mut().next().unwrap();",
            "        let removed_value = entry.remove();",
            "        assert_eq!(removed_value, \"value_one\".to_string());",
            "        first_value.push_str(\"-post_remove\");",
            "    }",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    let removed_value = entry.remove();",
            "    assert_eq!(removed_value, \"value_one\".to_string());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    ",
            "    if let Entry::Occupied(entry) = map.entry(\"removal_key\") {",
            "        let first_value = entry.iter_mut().next().unwrap();",
            "        let removed_value = entry.remove();",
            "        assert_eq!(removed_value, \"value_one\".to_string());",
            "        first_value.push_str(\"-post_remove\");",
            "    }",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    let removed_value = entry.remove();",
            "    assert_eq!(first_value, \"value_two\".to_string());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    ",
            "    if let Entry::Occupied(entry) = map.entry(\"removal_key\") {",
            "        let first_value = entry.iter_mut().next().unwrap();",
            "        let removed_value = entry.remove();",
            "        assert_eq!(removed_value, \"value_one\".to_string());",
            "        first_value.push_str(\"-post_remove\");",
            "    }",
            "    let mut map = HeaderMap::with_capacity(16);",
            "    map.append(\"removal_key\", \"value_one\".to_string());",
            "    map.append(\"removal_key\", \"value_two\".to_string());",
            "    let entry = map.entry(\"removal_key\");",
            "    let first_value = entry.iter_mut().next().unwrap();",
            "    let removed_value = entry.remove();",
            "    first_value.push_str(\"-post_remove\");",
            "    assert_eq!(first_value, \"value_two-post_remove\".to_string());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]