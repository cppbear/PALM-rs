[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response = Response::new(\"some string\");",
          "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
          "}"
        ],
        "oracles": [
          [
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), &b\"some string\".to_vec());"
          ],
          [
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.method, response.head.method);"
          ],
          [
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.version, response.head.version);"
          ],
          [
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.headers, response.head.headers);"
          ],
          [
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.extensions, response.head.extensions);"
          ],
          [
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert!(mapped_response.body() == &b\"some string\".to_vec());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), &b\"some string\".to_vec());",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.method, response.head.method);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.version, response.head.version);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.headers, response.head.headers);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.head.extensions, response.head.extensions);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"some string\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert!(mapped_response.body() == &b\"some string\".to_vec());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response = Response::new(42);",
          "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
          "}"
        ],
        "oracles": [
          [
            "    let response = Response::new(42);",
            "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
            "    assert_eq!(mapped_response.body(), \"42\");"
          ],
          [
            "    let response = Response::new(42);",
            "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
            "    assert_eq!(mapped_response.head, response.head);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response = Response::new(42);",
            "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
            "    let response = Response::new(42);",
            "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
            "    assert_eq!(mapped_response.body(), \"42\");",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(42);",
            "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
            "    let response = Response::new(42);",
            "    let mapped_response: Response<String> = response.map(|b| b.to_string());",
            "    assert_eq!(mapped_response.head, response.head);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response = Response::new(\"\");",
          "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
          "}"
        ],
        "oracles": [
          [
            "    let response = Response::new(\"\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), &Vec::from(\"\"));"
          ],
          [
            "    let response = Response::new(\"\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), Vec::new());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response = Response::new(\"\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), &Vec::from(\"\"));",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"\");",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), Vec::new());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response = Response::new(\"a\".repeat(1_000_000));",
          "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
          "}"
        ],
        "oracles": [
          [
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body().len(), 1_000_000);"
          ],
          [
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body()[0], 'a' as u8);"
          ],
          [
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), &vec![b'a'; 1_000_000]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body().len(), 1_000_000);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body()[0], 'a' as u8);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    let response = Response::new(\"a\".repeat(1_000_000));",
            "    let mapped_response: Response<Vec<u8>> = response.map(|b| b.as_bytes().to_vec());",
            "    assert_eq!(mapped_response.body(), &vec![b'a'; 1_000_000]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response = Response::new(Option::<&str>::None);",
          "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
          "}"
        ],
        "oracles": [
          [
            "    let response = Response::new(Option::<&str>::None);",
            "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
            "    assert_eq!(mapped_response.body(), &None);"
          ],
          [
            "    let response = Response::new(Option::<&str>::None);",
            "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
            "    assert_eq!(mapped_response.head, response.head);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response = Response::new(Option::<&str>::None);",
            "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
            "    let response = Response::new(Option::<&str>::None);",
            "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
            "    assert_eq!(mapped_response.body(), &None);",
            "}"
          ],
          [
            "{",
            "    let response = Response::new(Option::<&str>::None);",
            "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
            "    let response = Response::new(Option::<&str>::None);",
            "    let mapped_response: Response<Option<i32>> = response.map(|b| b.map(|_| 0));",
            "    assert_eq!(mapped_response.head, response.head);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]