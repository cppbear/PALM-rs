[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let header_name = HeaderName::from_static(\"valid-header\");",
          "}"
        ],
        "oracles": [
          [
            "    let header_name = HeaderName::from_static(\"valid-header\");",
            "    assert_eq!(header_name.inner, Repr::Custom(Custom(ByteStr::from_static(\"valid-header\"))));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let header_name = HeaderName::from_static(\"valid-header\");",
            "    let header_name = HeaderName::from_static(\"valid-header\");",
            "    assert_eq!(header_name.inner, Repr::Custom(Custom(ByteStr::from_static(\"valid-header\"))));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let header_name = HeaderName::from_static(\"0header-value\");",
          "}"
        ],
        "oracles": [
          [
            "    let header_name = HeaderName::from_static(\"0header-value\");",
            "    assert_eq!(header_name.as_str(), \"0header-value\");"
          ],
          [
            "    let header_name = HeaderName::from_static(\"0header-value\");",
            "    assert!(matches!(header_name.inner, Repr::Custom(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let header_name = HeaderName::from_static(\"0header-value\");",
            "    let header_name = HeaderName::from_static(\"0header-value\");",
            "    assert_eq!(header_name.as_str(), \"0header-value\");",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"0header-value\");",
            "    let header_name = HeaderName::from_static(\"0header-value\");",
            "    assert!(matches!(header_name.inner, Repr::Custom(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let max_length_str = \"a\".repeat(super::MAX_HEADER_NAME_LEN);",
          "    let header_name = HeaderName::from_static(&max_length_str);",
          "}"
        ],
        "oracles": [
          [
            "    let max_length_str = \"a\".repeat(super::MAX_HEADER_NAME_LEN);",
            "    let header_name = HeaderName::from_static(&max_length_str);",
            "    assert_eq!(header_name.inner, Repr::Custom(Custom(ByteStr::from_static(&max_length_str))));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let max_length_str = \"a\".repeat(super::MAX_HEADER_NAME_LEN);",
            "    let header_name = HeaderName::from_static(&max_length_str);",
            "    let max_length_str = \"a\".repeat(super::MAX_HEADER_NAME_LEN);",
            "    let header_name = HeaderName::from_static(&max_length_str);",
            "    assert_eq!(header_name.inner, Repr::Custom(Custom(ByteStr::from_static(&max_length_str))));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let header_name = HeaderName::from_static(\"header12345\");",
          "}"
        ],
        "oracles": [
          [
            "    let name_bytes = b\"header12345\";",
            "    assert!(StandardHeader::from_bytes(name_bytes).is_none());"
          ],
          [
            "    let name_bytes = b\"header12345\";",
            "    assert!(!name_bytes.is_empty());"
          ],
          [
            "    let name_bytes = b\"header12345\";",
            "    assert!(name_bytes.len() <= super::MAX_HEADER_NAME_LEN);"
          ],
          [
            "    let name_bytes = b\"header12345\";",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    assert!(HEADER_CHARS_H2[name_bytes[i] as usize] != 0);"
          ],
          [
            "    let name_bytes = b\"header12345\";",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    i += 1;",
            "    }",
            "    let header_name = HeaderName { inner: Repr::Custom(Custom(ByteStr::from_static(\"header12345\"))) };",
            "    assert_eq!(header_name.as_str(), \"header12345\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header12345\");",
            "    let name_bytes = b\"header12345\";",
            "    assert!(StandardHeader::from_bytes(name_bytes).is_none());",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header12345\");",
            "    let name_bytes = b\"header12345\";",
            "    assert!(!name_bytes.is_empty());",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header12345\");",
            "    let name_bytes = b\"header12345\";",
            "    assert!(name_bytes.len() <= super::MAX_HEADER_NAME_LEN);",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header12345\");",
            "    let name_bytes = b\"header12345\";",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    assert!(HEADER_CHARS_H2[name_bytes[i] as usize] != 0);",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header12345\");",
            "    let name_bytes = b\"header12345\";",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    i += 1;",
            "    }",
            "    let header_name = HeaderName { inner: Repr::Custom(Custom(ByteStr::from_static(\"header12345\"))) };",
            "    assert_eq!(header_name.as_str(), \"header12345\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let header_name = HeaderName::from_static(\"header-name_with-dash\");",
          "}"
        ],
        "oracles": [
          [
            "    let header_name = HeaderName::from_static(\"header-name_with-dash\");",
            "    assert_eq!(header_name.inner, Repr::Custom(Custom(ByteStr::from_static(\"header-name_with-dash\"))));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header-name_with-dash\");",
            "    let header_name = HeaderName::from_static(\"header-name_with-dash\");",
            "    assert_eq!(header_name.inner, Repr::Custom(Custom(ByteStr::from_static(\"header-name_with-dash\"))));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let header_name = HeaderName::from_static(\"header.name\"); ",
          "}"
        ],
        "oracles": [
          [
            "    let name_bytes = \"header.name\".as_bytes();",
            "    assert!(StandardHeader::from_bytes(name_bytes).is_none());"
          ],
          [
            "    let name_bytes = \"header.name\".as_bytes();",
            "    assert!(!name_bytes.is_empty());"
          ],
          [
            "    let name_bytes = \"header.name\".as_bytes();",
            "    assert!(name_bytes.len() <= super::MAX_HEADER_NAME_LEN);"
          ],
          [
            "    let name_bytes = \"header.name\".as_bytes();",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    assert!(HEADER_CHARS_H2[name_bytes[i] as usize] != 0);"
          ],
          [
            "    let name_bytes = \"header.name\".as_bytes();",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    i += 1;",
            "    }",
            "    let expected = HeaderName {",
            "    inner: Repr::Custom(Custom(ByteStr::from_static(\"header.name\"))),",
            "    };",
            "    assert_eq!(header_name, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header.name\"); ",
            "    let name_bytes = \"header.name\".as_bytes();",
            "    assert!(StandardHeader::from_bytes(name_bytes).is_none());",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header.name\"); ",
            "    let name_bytes = \"header.name\".as_bytes();",
            "    assert!(!name_bytes.is_empty());",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header.name\"); ",
            "    let name_bytes = \"header.name\".as_bytes();",
            "    assert!(name_bytes.len() <= super::MAX_HEADER_NAME_LEN);",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header.name\"); ",
            "    let name_bytes = \"header.name\".as_bytes();",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    assert!(HEADER_CHARS_H2[name_bytes[i] as usize] != 0);",
            "}"
          ],
          [
            "{",
            "    let header_name = HeaderName::from_static(\"header.name\"); ",
            "    let name_bytes = \"header.name\".as_bytes();",
            "    let mut i = 0;",
            "    while i < name_bytes.len() {",
            "    i += 1;",
            "    }",
            "    let expected = HeaderName {",
            "    inner: Repr::Custom(Custom(ByteStr::from_static(\"header.name\"))),",
            "    };",
            "    assert_eq!(header_name, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let header_name = HeaderName::from_static(\"custom-header-name\");",
          "}"
        ],
        "oracles": [
          [
            "    let name_bytes = b\"custom-header-name\";",
            "    let expected_result = HeaderName { inner: Repr::Custom(Custom(ByteStr::from_static(\"custom-header-name\"))) };",
            "    assert_eq!(header_name, expected_result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let header_name = HeaderName::from_static(\"custom-header-name\");",
            "    let name_bytes = b\"custom-header-name\";",
            "    let expected_result = HeaderName { inner: Repr::Custom(Custom(ByteStr::from_static(\"custom-header-name\"))) };",
            "    assert_eq!(header_name, expected_result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]