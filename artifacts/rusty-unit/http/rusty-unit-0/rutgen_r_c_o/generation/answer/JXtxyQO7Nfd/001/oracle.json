[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response: Response<()> = Response::new(());",
          "    let (parts, body) = response.into_parts();",
          "}"
        ],
        "oracles": [
          [
            "    let response: Response<()> = Response::new(());",
            "    assert_eq!(parts.status, StatusCode::OK);"
          ],
          [
            "    let response: Response<()> = Response::new(());",
            "    assert_eq!(body, ());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response: Response<()> = Response::new(());",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<()> = Response::new(());",
            "    assert_eq!(parts.status, StatusCode::OK);",
            "}"
          ],
          [
            "{",
            "    let response: Response<()> = Response::new(());",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<()> = Response::new(());",
            "    assert_eq!(body, ());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response: Response<i32> = Response::new(42);",
          "    let (parts, body) = response.into_parts();",
          "}"
        ],
        "oracles": [
          [
            "    let response: Response<i32> = Response::new(42);",
            "    assert_eq!(body, 42);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response: Response<i32> = Response::new(42);",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<i32> = Response::new(42);",
            "    assert_eq!(body, 42);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
          "    let (parts, body) = response.into_parts();",
          "}"
        ],
        "oracles": [
          [
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert_eq!(body, String::from(\"Hello, World!\"));"
          ],
          [
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert_eq!(parts.status, StatusCode::OK);"
          ],
          [
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert_eq!(parts.version, Version::HTTP_11);"
          ],
          [
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert!(parts.headers.is_empty());"
          ],
          [
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert!(parts.extensions.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert_eq!(body, String::from(\"Hello, World!\"));",
            "}"
          ],
          [
            "{",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert_eq!(parts.status, StatusCode::OK);",
            "}"
          ],
          [
            "{",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert_eq!(parts.version, Version::HTTP_11);",
            "}"
          ],
          [
            "{",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert!(parts.headers.is_empty());",
            "}"
          ],
          [
            "{",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<String> = Response::new(String::from(\"Hello, World!\"));",
            "    let (parts, body) = response.into_parts();",
            "    assert!(parts.extensions.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Debug)]",
          "    struct CustomStruct {",
          "        data: i32,",
          "    }",
          "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
          "    let (parts, body) = response.into_parts();",
          "}"
        ],
        "oracles": [
          [
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert_eq!(body.data, 10);"
          ],
          [
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert_eq!(parts.status, StatusCode::OK);"
          ],
          [
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert_eq!(parts.version, Version::default());"
          ],
          [
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert!(parts.headers.is_empty());"
          ],
          [
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert!(parts.extensions.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    #[derive(Debug)]",
            "    struct CustomStruct {",
            "        data: i32,",
            "    }",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert_eq!(body.data, 10);",
            "}"
          ],
          [
            "{",
            "    #[derive(Debug)]",
            "    struct CustomStruct {",
            "        data: i32,",
            "    }",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert_eq!(parts.status, StatusCode::OK);",
            "}"
          ],
          [
            "{",
            "    #[derive(Debug)]",
            "    struct CustomStruct {",
            "        data: i32,",
            "    }",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert_eq!(parts.version, Version::default());",
            "}"
          ],
          [
            "{",
            "    #[derive(Debug)]",
            "    struct CustomStruct {",
            "        data: i32,",
            "    }",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert!(parts.headers.is_empty());",
            "}"
          ],
          [
            "{",
            "    #[derive(Debug)]",
            "    struct CustomStruct {",
            "        data: i32,",
            "    }",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    let (parts, body) = response.into_parts();",
            "    let response: Response<CustomStruct> = Response::new(CustomStruct { data: 10 });",
            "    assert!(parts.extensions.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parts = Parts {",
          "        status: StatusCode::OK,",
          "        version: Version::HTTP_11,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::new(),",
          "        _priv: (),",
          "    };",
          "    let response: Response<()> = Response::from_parts(parts.clone(), ());",
          "    let (returned_parts, body) = response.into_parts();",
          "}"
        ],
        "oracles": [
          [
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.status, expected_parts.status);"
          ],
          [
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.version, expected_parts.version);"
          ],
          [
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.headers, expected_parts.headers);"
          ],
          [
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.extensions, expected_parts.extensions);"
          ],
          [
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(body, expected_body);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts.clone(), ());",
            "    let (returned_parts, body) = response.into_parts();",
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.status, expected_parts.status);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts.clone(), ());",
            "    let (returned_parts, body) = response.into_parts();",
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.version, expected_parts.version);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts.clone(), ());",
            "    let (returned_parts, body) = response.into_parts();",
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.headers, expected_parts.headers);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts.clone(), ());",
            "    let (returned_parts, body) = response.into_parts();",
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(returned_parts.extensions, expected_parts.extensions);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts.clone(), ());",
            "    let (returned_parts, body) = response.into_parts();",
            "    let expected_parts = parts.clone();",
            "    let expected_body = ();",
            "    assert_eq!(body, expected_body);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parts = Parts {",
          "        status: StatusCode::NOT_FOUND,",
          "        version: Version::HTTP_11,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::new(),",
          "        _priv: (),",
          "    };",
          "    let response: Response<()> = Response::from_parts(parts, ());",
          "    let (parts, body) = response.into_parts();",
          "}"
        ],
        "oracles": [
          [
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.status, expected_status);"
          ],
          [
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.version, expected_version);"
          ],
          [
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.headers, expected_headers);"
          ],
          [
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.extensions, expected_extensions);"
          ],
          [
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(body, ());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NOT_FOUND,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts, ());",
            "    let (parts, body) = response.into_parts();",
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.status, expected_status);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NOT_FOUND,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts, ());",
            "    let (parts, body) = response.into_parts();",
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.version, expected_version);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NOT_FOUND,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts, ());",
            "    let (parts, body) = response.into_parts();",
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.headers, expected_headers);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NOT_FOUND,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts, ());",
            "    let (parts, body) = response.into_parts();",
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(parts.extensions, expected_extensions);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NOT_FOUND,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::new(),",
            "        _priv: (),",
            "    };",
            "    let response: Response<()> = Response::from_parts(parts, ());",
            "    let (parts, body) = response.into_parts();",
            "    let expected_status = StatusCode::NOT_FOUND;",
            "    let expected_version = Version::HTTP_11;",
            "    let expected_headers = HeaderMap::new();",
            "    let expected_extensions = Extensions::new();",
            "    assert_eq!(body, ());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]