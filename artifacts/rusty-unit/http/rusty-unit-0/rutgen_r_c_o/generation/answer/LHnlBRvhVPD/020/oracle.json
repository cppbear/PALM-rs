[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
          "",
          "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
          "    let value = http::HeaderValue::from_static(\"value1\");",
          "",
          "    let result = header_map.try_append2(key, value);",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.entries.is_empty());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert_eq!(header_map.indices.len(), 0);"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert_eq!(header_map.len(), 0);"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.is_empty());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.try_append2(key, value).is_ok());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert_eq!(header_map.len(), 1);"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(!header_map.is_empty());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.indices.len() > 0);"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.entries.len() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.entries.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert_eq!(header_map.indices.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert_eq!(header_map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.try_append2(key, value).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert_eq!(header_map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(!header_map.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.indices.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(1);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'a'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value1\");",
            "    assert!(header_map.entries.len() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
          "",
          "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
          "    let value = http::HeaderValue::from_static(\"value2\");",
          "",
          "    let _ = header_map.try_append2(key.clone(), value.clone());",
          "    let _ = header_map.try_append2(key, value);",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    assert_eq!(header_map.len(), 0);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    assert_eq!(header_map.capacity(), 2);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(result_first.is_ok());"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(result_first.unwrap(), false);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert!(result_second.is_ok());"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert_eq!(result_second.unwrap(), true);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert_eq!(header_map.len(), 1);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert!(header_map.contains_key(&key));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    assert_eq!(header_map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    assert_eq!(header_map.capacity(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(result_first.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(result_first.unwrap(), false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert!(result_second.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert_eq!(result_second.unwrap(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert_eq!(header_map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "",
            "    let _ = header_map.try_append2(key.clone(), value.clone());",
            "    let _ = header_map.try_append2(key, value);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'b'; 1].into()) };",
            "    let value = http::HeaderValue::from_static(\"value2\");",
            "    let result_first = header_map.try_append2(key.clone(), value.clone());",
            "    let result_second = header_map.try_append2(key, value);",
            "    assert!(header_map.contains_key(&key));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
          "",
          "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
          "    let value1 = http::HeaderValue::from_static(\"value3\");",
          "    ",
          "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
          "    let value2 = http::HeaderValue::from_static(\"value4\");",
          "",
          "    let _ = header_map.try_append2(key1.clone(), value1);",
          "    let result = header_map.try_append2(key2, value2);",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert_eq!(header_map.len(), 0);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.try_append2(key1.clone(), value1).unwrap() == false);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.len() == 1);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.try_append2(key2, value2).unwrap() == true);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.len() == 1);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.get(&key1).is_some());"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.get(&key2).is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert_eq!(header_map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.try_append2(key1.clone(), value1).unwrap() == false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.try_append2(key2, value2).unwrap() == true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.get(&key1).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    ",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "",
            "    let _ = header_map.try_append2(key1.clone(), value1);",
            "    let result = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(2);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value3\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'c'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value4\");",
            "    assert!(header_map.get(&key2).is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
          "",
          "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
          "    let value = http::HeaderValue::from_static(\"value5\");",
          "",
          "    let result = header_map.try_append2(key, value);",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.len(), 1);"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(header_map.contains_key(&key));"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.get(&key), Some(&value));"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(header_map.get_mut(&key).is_some());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(!header_map.is_empty());"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.keys_len(), 1);"
          ],
          [
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.capacity(), 32768);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(header_map.contains_key(&key));",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.get(&key), Some(&value));",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(header_map.get_mut(&key).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert!(!header_map.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.keys_len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(32768);",
            "",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "",
            "    let result = header_map.try_append2(key, value);",
            "    let header_map = http::HeaderMap::with_capacity(32768);",
            "    let key = http::HeaderName { inner: http::Repr::Custom(vec![b'd'; 128].into()) };",
            "    let value = http::HeaderValue::from_static(\"value5\");",
            "    let result = header_map.try_append2(key.clone(), value.clone());",
            "    assert_eq!(header_map.capacity(), 32768);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
          "",
          "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
          "    let value1 = http::HeaderValue::from_static(\"value6\");",
          "",
          "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
          "    let value2 = http::HeaderValue::from_static(\"value7\");",
          "",
          "    let _ = header_map.try_append2(key1, value1);",
          "",
          "    // Assuming the method wrapped in try_append2 may trigger a MaxSizeReached",
          "    let _ = header_map.try_append2(key2, value2);",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    assert!(result1.is_ok());"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    assert_eq!(result1.unwrap(), false);"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    let result2 = header_map.try_append2(key2, value2);",
            "    assert!(result2.is_err());"
          ],
          [
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    let result2 = header_map.try_append2(key2, value2);",
            "    assert_eq!(result2.unwrap_err(), http::MaxSizeReached { _priv: () });"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "",
            "    let _ = header_map.try_append2(key1, value1);",
            "",
            "    // Assuming the method wrapped in try_append2 may trigger a MaxSizeReached",
            "    let _ = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    assert!(result1.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "",
            "    let _ = header_map.try_append2(key1, value1);",
            "",
            "    // Assuming the method wrapped in try_append2 may trigger a MaxSizeReached",
            "    let _ = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    assert_eq!(result1.unwrap(), false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "",
            "    let _ = header_map.try_append2(key1, value1);",
            "",
            "    // Assuming the method wrapped in try_append2 may trigger a MaxSizeReached",
            "    let _ = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    let result2 = header_map.try_append2(key2, value2);",
            "    assert!(result2.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "",
            "    let _ = header_map.try_append2(key1, value1);",
            "",
            "    // Assuming the method wrapped in try_append2 may trigger a MaxSizeReached",
            "    let _ = header_map.try_append2(key2, value2);",
            "    let mut header_map: http::HeaderMap<http::HeaderValue> = http::HeaderMap::with_capacity(1);",
            "    let key1 = http::HeaderName { inner: http::Repr::Custom(vec![b'e'; 1].into()) };",
            "    let value1 = http::HeaderValue::from_static(\"value6\");",
            "    let key2 = http::HeaderName { inner: http::Repr::Custom(vec![b'f'; 1].into()) };",
            "    let value2 = http::HeaderValue::from_static(\"value7\");",
            "    let result1 = header_map.try_append2(key1, value1);",
            "    let result2 = header_map.try_append2(key2, value2);",
            "    assert_eq!(result2.unwrap_err(), http::MaxSizeReached { _priv: () });",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]