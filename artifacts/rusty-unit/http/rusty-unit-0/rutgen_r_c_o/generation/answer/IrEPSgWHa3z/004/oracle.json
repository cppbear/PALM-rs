[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
          "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
          "    let value = HeaderValue::from(\"value\");",
          "",
          "    header_map.insert(key.clone(), value);",
          "    ",
          "    let result = header_map.find(&key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert!(result.is_some());"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert_eq!(result.unwrap(), (0, 0));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "",
            "    header_map.insert(key.clone(), value);",
            "    ",
            "    let result = header_map.find(&key);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "",
            "    header_map.insert(key.clone(), value);",
            "    ",
            "    let result = header_map.find(&key);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert_eq!(result.unwrap(), (0, 0));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
          "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
          "    let value1 = HeaderValue::from(\"value1\");",
          "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
          "    let value2 = HeaderValue::from(\"value2\");",
          "",
          "    header_map.insert(key1.clone(), value1);",
          "    header_map.insert(key2.clone(), value2);",
          "",
          "    let result = header_map.find(&key1);",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    assert!(!header_map.entries.is_empty());"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    assert!(probe < header_map.indices.len());"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    assert!(dist <= probe_distance(mask, entry_hash, probe));"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    assert_eq!(entry_hash, hash);"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    assert_eq!(header_map.entries[i].key, key1);"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    let result = header_map.find(&key1);",
            "    assert_eq!(result, Some((probe, i)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    assert!(!header_map.entries.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    assert!(probe < header_map.indices.len());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    assert!(dist <= probe_distance(mask, entry_hash, probe));",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    assert_eq!(entry_hash, hash);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    assert_eq!(header_map.entries[i].key, key1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let hash = hash_elem_using(&header_map.danger, &key1);",
            "    let mask = header_map.mask;",
            "    let probe = desired_pos(mask, hash);",
            "    let (i, entry_hash) = header_map.indices[probe].resolve().unwrap();",
            "    let result = header_map.find(&key1);",
            "    assert_eq!(result, Some((probe, i)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
          "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
          "    let value1 = HeaderValue::from(\"value1\");",
          "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
          "    let value2 = HeaderValue::from(\"value2\");",
          "",
          "    header_map.insert(key1.clone(), value1);",
          "    header_map.insert(key2.clone(), value2);",
          "    ",
          "    let result = header_map.find(&key1);",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let result = header_map.find(&key1);",
            "    assert!(result.is_some());"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let result = header_map.find(&key1);",
            "    assert_eq!(result.unwrap().0, desired_pos(header_map.mask, hash_elem_using(&header_map.danger, &key1)));"
          ],
          [
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let result = header_map.find(&key1);",
            "    assert_eq!(result.unwrap().1, 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    ",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let result = header_map.find(&key1);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    ",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let result = header_map.find(&key1);",
            "    assert_eq!(result.unwrap().0, desired_pos(header_map.mask, hash_elem_using(&header_map.danger, &key1)));",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    ",
            "    let result = header_map.find(&key1);",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key1 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'1']) };",
            "    let value1 = HeaderValue::from(\"value1\");",
            "    let key2 = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y', b'2']) };",
            "    let value2 = HeaderValue::from(\"value2\");",
            "    header_map.insert(key1.clone(), value1);",
            "    header_map.insert(key2.clone(), value2);",
            "    let result = header_map.find(&key1);",
            "    assert_eq!(result.unwrap().1, 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
          "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
          "    let value = HeaderValue::from(\"value\");",
          "",
          "    header_map.insert(key.clone(), value);",
          "    ",
          "    let result = header_map.find(&key);",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert!(result.is_some());"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert_eq!(result.unwrap().0, /* expected probe index */);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert_eq!(result.unwrap().1, /* expected entry index */);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "",
            "    header_map.insert(key.clone(), value);",
            "    ",
            "    let result = header_map.find(&key);",
            "    let header_map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "",
            "    header_map.insert(key.clone(), value);",
            "    ",
            "    let result = header_map.find(&key);",
            "    let header_map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert_eq!(result.unwrap().0, /* expected probe index */);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "",
            "    header_map.insert(key.clone(), value);",
            "    ",
            "    let result = header_map.find(&key);",
            "    let header_map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom(vec![b'k', b'e', b'y']) };",
            "    let value = HeaderValue::from(\"value\");",
            "    header_map.insert(key.clone(), value);",
            "    let result = header_map.find(&key);",
            "    assert_eq!(result.unwrap().1, /* expected entry index */);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]