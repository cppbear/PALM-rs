[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
          "    let key = HeaderName { inner: Repr::<Custom>::default() };",
          "    let hash = HashValue(1);",
          "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
          "    map.entries.push(Bucket {",
          "        hash,",
          "        key: key.clone(),",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    let probe = 0;",
          "    let danger = false;",
          "",
          "    let _ = map.try_entry2(key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.try_entry2(key).is_ok(), true);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert!(map.indices[probe].is_some());"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.entries.len(), 1);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.entries[0].key, key);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.entries[0].hash, hash);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 0;",
            "    let danger = false;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.try_entry2(key).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 0;",
            "    let danger = false;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert!(map.indices[probe].is_some());",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 0;",
            "    let danger = false;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.entries.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 0;",
            "    let danger = false;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.entries[0].key, key);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 0;",
            "    let danger = false;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(16);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(1);",
            "    map.indices = vec![Pos::none(); 16].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 0;",
            "    let danger = false;",
            "    assert_eq!(map.entries[0].hash, hash);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
          "    let key = HeaderName { inner: Repr::<Custom>::default() };",
          "    let hash = HashValue(10);",
          "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
          "    map.entries.push(Bucket {",
          "        hash,",
          "        key: key.clone(),",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    let probe = 1;",
          "",
          "    let _ = map.try_entry2(key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(10);",
            "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(10);",
            "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    assert!(map.try_entry2(key).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(10);",
            "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 1;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(10);",
            "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(10);",
            "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 1;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(8);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(10);",
            "    map.indices = vec![Pos::none(); 8].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    assert!(map.try_entry2(key).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
          "    let key = HeaderName { inner: Repr::<Custom>::default() };",
          "    let hash = HashValue(2);",
          "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
          "    map.entries.push(Bucket {",
          "        hash,",
          "        key: key.clone(),",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    map.entries.push(Bucket {",
          "        hash: HashValue(3),",
          "        key: HeaderName { inner: Repr::<Custom>::default() },",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    let probe = 2;",
          "",
          "    let _ = map.try_entry2(key);",
          "}"
        ],
        "oracles": [
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert!(matches!(result.unwrap(), Entry::Vacant(_)));"
          ],
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert!(map.entries.len() > 0);"
          ],
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert_eq!(map.indices.len(), 32);"
          ],
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert_eq!(map.entries[probe].hash, hash);"
          ],
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert_eq!(map.entries[probe].key, key);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName { inner: Repr::<Custom>::default() },",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 2;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName { inner: Repr::<Custom>::default() },",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 2;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert!(matches!(result.unwrap(), Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName { inner: Repr::<Custom>::default() },",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 2;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert!(map.entries.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName { inner: Repr::<Custom>::default() },",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 2;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert_eq!(map.indices.len(), 32);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName { inner: Repr::<Custom>::default() },",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 2;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert_eq!(map.entries[probe].hash, hash);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(3),",
            "        key: HeaderName { inner: Repr::<Custom>::default() },",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 2;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(2);",
            "    map.indices = vec![Pos::none(); 32].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "    hash,",
            "    key: key.clone(),",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "    hash: HashValue(3),",
            "    key: HeaderName { inner: Repr::<Custom>::default() },",
            "    value: HeaderValue::default(),",
            "    links: None,",
            "    });",
            "    let probe = 2;",
            "    let result = map.try_entry2(key);",
            "    assert_eq!(map.entries[probe].key, key);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
          "    let key = HeaderName { inner: Repr::<Custom>::default() };",
          "    let hash = HashValue(32767);",
          "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
          "    map.entries.push(Bucket {",
          "        hash,",
          "        key: key.clone(),",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    let probe = 32767;",
          "",
          "    let _ = map.try_entry2(key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.len() >= 1);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert_eq!(map.indices.len(), 32768);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.entries[0].key == key);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.entries[0].hash == hash);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.entries[0].value == HeaderValue::default());"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.indices[probe].is_none() == false);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.try_entry2(key).is_ok());"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.try_entry2(key).unwrap().is_vacant() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.len() >= 1);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert_eq!(map.indices.len(), 32768);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.entries[0].key == key);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.entries[0].hash == hash);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.entries[0].value == HeaderValue::default());",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.indices[probe].is_none() == false);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.try_entry2(key).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 32767;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(32767);",
            "    map.indices = vec![Pos::none(); 32768].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None, });",
            "    let probe = 32767;",
            "    assert!(map.try_entry2(key).unwrap().is_vacant() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
          "    let key = HeaderName { inner: Repr::<Custom>::default() };",
          "    let hash = HashValue(5);",
          "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
          "    map.entries.push(Bucket {",
          "        hash,",
          "        key: key.clone(),",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    map.entries.push(Bucket {",
          "        hash: HashValue(6),",
          "        key: key.clone(),",
          "        value: HeaderValue::default(),",
          "        links: None,",
          "    });",
          "    let probe = 3;",
          "",
          "    let _ = map.try_entry2(key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert!(map.try_entry2(key).is_ok());"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.entries.len(), 2);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.indices.len(), 10);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.entries[0].key, key);"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.entries[1].hash, HashValue(6));"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert!(map.entries[0].value == HeaderValue::default());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(6),",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 3;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert!(map.try_entry2(key).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(6),",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 3;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.entries.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(6),",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 3;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.indices.len(), 10);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(6),",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 3;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.entries[0].key, key);",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(6),",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 3;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert_eq!(map.entries[1].hash, HashValue(6));",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket {",
            "        hash,",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    map.entries.push(Bucket {",
            "        hash: HashValue(6),",
            "        key: key.clone(),",
            "        value: HeaderValue::default(),",
            "        links: None,",
            "    });",
            "    let probe = 3;",
            "",
            "    let _ = map.try_entry2(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::<Custom>::default() };",
            "    let hash = HashValue(5);",
            "    map.indices = vec![Pos::none(); 10].into_boxed_slice();",
            "    map.entries.push(Bucket { hash, key: key.clone(), value: HeaderValue::default(), links: None });",
            "    map.entries.push(Bucket { hash: HashValue(6), key: key.clone(), value: HeaderValue::default(), links: None });",
            "    let probe = 3;",
            "    assert!(map.entries[0].value == HeaderValue::default());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]