[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(32768);",
          "    let key = HeaderName { inner: Repr::Custom };",
          "    let value = \"value_a\".parse().unwrap();",
          "    let vacant_entry = VacantEntry {",
          "        map: &mut map,",
          "        key,",
          "        hash: HashValue(123),",
          "        probe: 0,",
          "        danger: false,",
          "    };",
          "    let _result = vacant_entry.try_insert(value);",
          "}"
        ],
        "oracles": [
          [
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert!(vacant_entry.try_insert(value).is_err());"
          ],
          [
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert_eq!(map.len(), 0);"
          ],
          [
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert!(map.is_empty());"
          ],
          [
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert_eq!(map.capacity(), 32768);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(123),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert!(vacant_entry.try_insert(value).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(123),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert_eq!(map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(123),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert!(map.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(123),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_a\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(123),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    assert_eq!(map.capacity(), 32768);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(0);",
          "    let key = HeaderName { inner: Repr::Custom };",
          "    let value = \"value_b\".parse().unwrap();",
          "    let vacant_entry = VacantEntry {",
          "        map: &mut map,",
          "        key,",
          "        hash: HashValue(456),",
          "        probe: 0,",
          "        danger: false,",
          "    };",
          "    let _result = vacant_entry.try_insert(value);",
          "}"
        ],
        "oracles": [
          [
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert!(result.is_err());"
          ],
          [
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert_eq!(result.unwrap_err(), MaxSizeReached {});"
          ],
          [
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert_eq!(map.len(), 0);"
          ],
          [
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert!(map.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(456),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(456),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert_eq!(result.unwrap_err(), MaxSizeReached {});",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(456),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert_eq!(map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(456),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry.try_insert(value);",
            "    let map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"value_b\".parse().unwrap();",
            "    let vacant_entry = VacantEntry { map: &mut map, key, hash: HashValue(456), probe: 0, danger: false };",
            "    let result = vacant_entry.try_insert(value);",
            "    assert!(map.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(1);",
          "    let key1 = HeaderName { inner: Repr::Custom };",
          "    let key2 = HeaderName { inner: Repr::Custom };",
          "    let value1 = \"value_c\".parse().unwrap();",
          "    let vacant_entry_one = VacantEntry {",
          "        map: &mut map,",
          "        key: key1,",
          "        hash: HashValue(789),",
          "        probe: 0,",
          "        danger: false,",
          "    };",
          "    let _ = vacant_entry_one.try_insert(value1);",
          "    let value2 = \"value_d\".parse().unwrap();",
          "    let vacant_entry_two = VacantEntry {",
          "        map: &mut map,",
          "        key: key2,",
          "        hash: HashValue(101112),",
          "        probe: 0,",
          "        danger: false,",
          "    };",
          "    let _result = vacant_entry_two.try_insert(value2);",
          "}"
        ],
        "oracles": [
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key1 = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_c\".parse().unwrap();",
            "    let vacant_entry_one = VacantEntry { map: &mut map, key: key1, hash: HashValue(789), probe: 0, danger: false };",
            "    let result_one = vacant_entry_one.try_insert(value1);",
            "    let expected_one = Ok(&mut map.entries[0].value);",
            "    assert_eq!(result_one, expected_one);"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key1 = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_c\".parse().unwrap();",
            "    let vacant_entry_one = VacantEntry { map: &mut map, key: key1, hash: HashValue(789), probe: 0, danger: false };",
            "    let result_one = vacant_entry_one.try_insert(value1);",
            "    let expected_one = Ok(&mut map.entries[0].value);",
            "    let key2 = HeaderName { inner: Repr::Custom };",
            "    let value2 = \"value_d\".parse().unwrap();",
            "    let vacant_entry_two = VacantEntry { map: &mut map, key: key2, hash: HashValue(101112), probe: 0, danger: false };",
            "    let result_two = vacant_entry_two.try_insert(value2);",
            "    let expected_two = Err(MaxSizeReached { _priv: () });",
            "    assert_eq!(result_two, expected_two);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key1 = HeaderName { inner: Repr::Custom };",
            "    let key2 = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_c\".parse().unwrap();",
            "    let vacant_entry_one = VacantEntry {",
            "        map: &mut map,",
            "        key: key1,",
            "        hash: HashValue(789),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _ = vacant_entry_one.try_insert(value1);",
            "    let value2 = \"value_d\".parse().unwrap();",
            "    let vacant_entry_two = VacantEntry {",
            "        map: &mut map,",
            "        key: key2,",
            "        hash: HashValue(101112),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry_two.try_insert(value2);",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key1 = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_c\".parse().unwrap();",
            "    let vacant_entry_one = VacantEntry { map: &mut map, key: key1, hash: HashValue(789), probe: 0, danger: false };",
            "    let result_one = vacant_entry_one.try_insert(value1);",
            "    let expected_one = Ok(&mut map.entries[0].value);",
            "    assert_eq!(result_one, expected_one);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key1 = HeaderName { inner: Repr::Custom };",
            "    let key2 = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_c\".parse().unwrap();",
            "    let vacant_entry_one = VacantEntry {",
            "        map: &mut map,",
            "        key: key1,",
            "        hash: HashValue(789),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _ = vacant_entry_one.try_insert(value1);",
            "    let value2 = \"value_d\".parse().unwrap();",
            "    let vacant_entry_two = VacantEntry {",
            "        map: &mut map,",
            "        key: key2,",
            "        hash: HashValue(101112),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _result = vacant_entry_two.try_insert(value2);",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key1 = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_c\".parse().unwrap();",
            "    let vacant_entry_one = VacantEntry { map: &mut map, key: key1, hash: HashValue(789), probe: 0, danger: false };",
            "    let result_one = vacant_entry_one.try_insert(value1);",
            "    let expected_one = Ok(&mut map.entries[0].value);",
            "    let key2 = HeaderName { inner: Repr::Custom };",
            "    let value2 = \"value_d\".parse().unwrap();",
            "    let vacant_entry_two = VacantEntry { map: &mut map, key: key2, hash: HashValue(101112), probe: 0, danger: false };",
            "    let result_two = vacant_entry_two.try_insert(value2);",
            "    let expected_two = Err(MaxSizeReached { _priv: () });",
            "    assert_eq!(result_two, expected_two);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(1);",
          "    let key = HeaderName { inner: Repr::Custom };",
          "    let value1 = \"value_e\".parse().unwrap();",
          "    let vacant_entry = VacantEntry {",
          "        map: &mut map,",
          "        key: key.clone(),",
          "        hash: HashValue(1314),",
          "        probe: 0,",
          "        danger: false,",
          "    };",
          "    let _ = vacant_entry.try_insert(value1);",
          "    let value2 = \"value_f\".parse().unwrap();",
          "    let panic_entry = VacantEntry {",
          "        map: &mut map,",
          "        key,",
          "        hash: HashValue(1516),",
          "        probe: 0,",
          "        danger: true,",
          "    };",
          "    let _result = panic_entry.try_insert(value2);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert!(_result.is_err());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert!(map.get(\"value_e\").is_some());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert!(map.get(\"value_f\").is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key: key.clone(),",
            "        hash: HashValue(1314),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(1516),",
            "        probe: 0,",
            "        danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert!(_result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key: key.clone(),",
            "        hash: HashValue(1314),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(1516),",
            "        probe: 0,",
            "        danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key: key.clone(),",
            "        hash: HashValue(1314),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(1516),",
            "        probe: 0,",
            "        danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert!(map.get(\"value_e\").is_some());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "        map: &mut map,",
            "        key: key.clone(),",
            "        hash: HashValue(1314),",
            "        probe: 0,",
            "        danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "        map: &mut map,",
            "        key,",
            "        hash: HashValue(1516),",
            "        probe: 0,",
            "        danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value1 = \"value_e\".parse().unwrap();",
            "    let vacant_entry = VacantEntry {",
            "    map: &mut map,",
            "    key: key.clone(),",
            "    hash: HashValue(1314),",
            "    probe: 0,",
            "    danger: false,",
            "    };",
            "    let _ = vacant_entry.try_insert(value1);",
            "    let value2 = \"value_f\".parse().unwrap();",
            "    let panic_entry = VacantEntry {",
            "    map: &mut map,",
            "    key,",
            "    hash: HashValue(1516),",
            "    probe: 0,",
            "    danger: true,",
            "    };",
            "    let _result = panic_entry.try_insert(value2);",
            "    assert!(map.get(\"value_f\").is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]