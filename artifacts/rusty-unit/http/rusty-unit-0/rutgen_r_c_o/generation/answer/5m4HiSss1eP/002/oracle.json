[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"accept\";",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parse_result.is_ok());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let header_name = parse_result.unwrap();",
            "    assert_eq!(header_name.inner, Repr::Standard(StandardHeader::Accept));"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let header_name = parse_result.unwrap();",
            "    let expected = Ok(Custom(ByteStr::from_static(\"accept\")).into());",
            "    assert_eq!(result, expected);"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let header_name = parse_result.unwrap();",
            "    let expected = Ok(Custom(ByteStr::from_static(\"accept\")).into());",
            "    assert!(!result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"accept\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parse_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"accept\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let header_name = parse_result.unwrap();",
            "    assert_eq!(header_name.inner, Repr::Standard(StandardHeader::Accept));",
            "}"
          ],
          [
            "{",
            "    let input = b\"accept\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let header_name = parse_result.unwrap();",
            "    let expected = Ok(Custom(ByteStr::from_static(\"accept\")).into());",
            "    assert_eq!(result, expected);",
            "}"
          ],
          [
            "{",
            "    let input = b\"accept\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let header_name = parse_result.unwrap();",
            "    let expected = Ok(Custom(ByteStr::from_static(\"accept\")).into());",
            "    assert!(!result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"x-custom-header\";",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.as_str(), \"x-custom-header\");"
          ],
          [
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.inner, Repr::Custom(MaybeLower { buf: ... , lower: false }));"
          ],
          [
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert!(header_name.inner.to_bytes().len() > 0);"
          ],
          [
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert!(header_name.inner.to_bytes().iter().all(|&b| b.is_ascii()));"
          ],
          [
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert!(header_name.inner.to_bytes().iter().all(|&b| HEADER_CHARS[b as usize] != 0));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.as_str(), \"x-custom-header\");",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.inner, Repr::Custom(MaybeLower { buf: ... , lower: false }));",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert!(header_name.inner.to_bytes().len() > 0);",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert!(header_name.inner.to_bytes().iter().all(|&b| b.is_ascii()));",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"x-custom-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert!(header_name.inner.to_bytes().iter().all(|&b| HEADER_CHARS[b as usize] != 0));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"\";",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(result.is_err());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result.unwrap_err()._priv, ());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = b\"\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result.unwrap_err()._priv, ());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"\\xFF\"; // Invalid character",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let mut buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result, Err(InvalidHeaderName::new()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"\\xFF\"; // Invalid character",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = b\"\\xFF\"; // Invalid character",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result, Err(InvalidHeaderName::new()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"x-lowercase-header\";",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let mut buf = uninit_u8_array();",
            "    let expected_result = Ok(Custom(ByteStr::from_static(\"x-lowercase-header\")).into());",
            "    let parsed_hdr = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result, expected_result);"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let expected_result = Ok(Custom(ByteStr::from_static(\"x-lowercase-header\")).into());",
            "    let parsed_hdr = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parsed_hdr.is_ok());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let expected_result = Ok(Custom(ByteStr::from_static(\"x-lowercase-header\")).into());",
            "    let parsed_hdr = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(matches!(parsed_hdr.unwrap().inner, Repr::Custom(MaybeLower { lower: true, .. })));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"x-lowercase-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let expected_result = Ok(Custom(ByteStr::from_static(\"x-lowercase-header\")).into());",
            "    let parsed_hdr = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result, expected_result);",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-lowercase-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let expected_result = Ok(Custom(ByteStr::from_static(\"x-lowercase-header\")).into());",
            "    let parsed_hdr = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parsed_hdr.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"x-lowercase-header\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let expected_result = Ok(Custom(ByteStr::from_static(\"x-lowercase-header\")).into());",
            "    let parsed_hdr = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(matches!(parsed_hdr.unwrap().inner, Repr::Custom(MaybeLower { lower: true, .. })));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"X-HEADER\";",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parse_result.is_ok());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    let repr = hdr_name.inner;",
            "    assert!(matches!(repr, Repr::Custom(MaybeLower { lower: true, .. })));"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    let repr = hdr_name.inner;",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    let repr = hdr_name.inner;",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.as_str(), \"X-HEADER\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"X-HEADER\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parse_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"X-HEADER\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    let repr = hdr_name.inner;",
            "    assert!(matches!(repr, Repr::Custom(MaybeLower { lower: true, .. })));",
            "}"
          ],
          [
            "{",
            "    let input = b\"X-HEADER\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    let repr = hdr_name.inner;",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"X-HEADER\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    let repr = hdr_name.inner;",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.as_str(), \"X-HEADER\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.as_str(), \"valid-header-name-with-63-chars-in-length-valid-h\");"
          ],
          [
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
            "    let result_invalid = HeaderName::from_bytes(invalid_input);",
            "    assert!(result_invalid.is_err());"
          ],
          [
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
            "    let result_invalid = HeaderName::from_bytes(invalid_input);",
            "    let empty_input: &[u8] = b\"\";",
            "    let result_empty = HeaderName::from_bytes(empty_input);",
            "    assert!(result_empty.is_err());"
          ],
          [
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
            "    let result_invalid = HeaderName::from_bytes(invalid_input);",
            "    let empty_input: &[u8] = b\"\";",
            "    let result_empty = HeaderName::from_bytes(empty_input);",
            "    let too_long_input = b\"this-header-name-is-way-too-long-to-be-valid-and-exceeds-the-maximum-length-which-is-63-characters\";",
            "    let result_too_long = HeaderName::from_bytes(too_long_input);",
            "    assert!(result_too_long.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    assert_eq!(header_name.as_str(), \"valid-header-name-with-63-chars-in-length-valid-h\");",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
            "    let result_invalid = HeaderName::from_bytes(invalid_input);",
            "    assert!(result_invalid.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
            "    let result_invalid = HeaderName::from_bytes(invalid_input);",
            "    let empty_input: &[u8] = b\"\";",
            "    let result_empty = HeaderName::from_bytes(empty_input);",
            "    assert!(result_empty.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\"; // 63 characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"valid-header-name-with-63-chars-in-length-valid-h\";",
            "    let result = HeaderName::from_bytes(input);",
            "    let header_name = result.unwrap();",
            "    let invalid_input = b\"invalid_header_name_with_invalid_characters\";",
            "    let result_invalid = HeaderName::from_bytes(invalid_input);",
            "    let empty_input: &[u8] = b\"\";",
            "    let result_empty = HeaderName::from_bytes(empty_input);",
            "    let too_long_input = b\"this-header-name-is-way-too-long-to-be-valid-and-exceeds-the-maximum-length-which-is-63-characters\";",
            "    let result_too_long = HeaderName::from_bytes(too_long_input);",
            "    assert!(result_too_long.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_err());"
          ],
          [
            "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert_eq!(result.err().unwrap().to_string(), \"Invalid header name\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\"; // Exceeds max length",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = b\"this-header-name-is-way-too-long-for-the-buffer-\";",
            "    let result = HeaderName::from_bytes(input);",
            "    assert_eq!(result.err().unwrap().to_string(), \"Invalid header name\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"\\x00\"; // Control character",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = uninit_u8_array();",
            "    let res = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(res.is_err());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let res = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result, Err(InvalidHeaderName::new()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"\\x00\"; // Control character",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let res = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(res.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = b\"\\x00\"; // Control character",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let res = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert_eq!(result, Err(InvalidHeaderName::new()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = uninit_u8_array();",
            "    assert!(parse_hdr(input, &mut buf, &HEADER_CHARS).is_err());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_err());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_err());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', 1, 2, 3, 4]; // Array with mixed characters",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    assert!(parse_hdr(input, &mut buf, &HEADER_CHARS).is_err());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = &[0u8; SCRATCH_BUF_OVERFLOW]; // Array at overflow size",
            "    let result = HeaderName::from_bytes(input);",
            "    let buf = uninit_u8_array();",
            "    let input = &[0u8; SCRATCH_BUF_SIZE]; // Array at max size",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[1u8, 2u8, 3u8]; // Array with valid byte values",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[0u8, 1u8, 255u8]; // Array with byte value that maps to 0",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', b'\\0']; // Array with a null byte",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'A', b'B', b'C']; // Array with uppercase letters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'!', b'#', b'$', b'%']; // Array with special characters",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c']; // Array with lowercase letters for MaybeLower",
            "    let result = HeaderName::from_bytes(input);",
            "    let input = &[b'a', b'b', b'c', 1, 2, 3, 4]; // Array with mixed characters",
            "    let result = HeaderName::from_bytes(input);",
            "    assert!(result.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
          "    let result = HeaderName::from_bytes(input);",
          "}"
        ],
        "oracles": [
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parse_result.is_ok());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    assert_eq!(hdr_name.inner, Repr::Custom(MaybeLower { buf, lower: true }));"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    match result {",
            "    Ok(name) => {",
            "    assert!(matches!(name.inner, Repr::Custom(_)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    assert!(parse_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    assert_eq!(hdr_name.inner, Repr::Custom(MaybeLower { buf, lower: true }));",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = b\"valid-header-\\xE2\\x9C\\x94\"; // Includes valid utf-8",
            "    let result = HeaderName::from_bytes(input);",
            "    let mut buf = uninit_u8_array();",
            "    let parse_result = parse_hdr(input, &mut buf, &HEADER_CHARS);",
            "    let hdr_name = parse_result.unwrap();",
            "    match result {",
            "    Ok(name) => {",
            "    assert!(matches!(name.inner, Repr::Custom(_)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]