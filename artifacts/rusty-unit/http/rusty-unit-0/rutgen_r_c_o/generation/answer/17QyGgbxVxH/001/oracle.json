[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parts = Parts {",
          "        status: StatusCode::OK,",
          "        version: Version::HTTP_11,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body = \"valid body\";",
          "    let response = Response::from_parts(parts, body);",
          "}"
        ],
        "oracles": [
          [
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.status(), StatusCode::OK);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.version(), Version::HTTP_11);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.headers().len(), 0);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.extensions().len(), 0);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(*response.body(), \"valid body\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.status(), StatusCode::OK);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.version(), Version::HTTP_11);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.headers().len(), 0);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.extensions().len(), 0);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::OK,",
            "    version: Version::HTTP_11,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"valid body\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(*response.body(), \"valid body\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parts = Parts {",
          "        status: StatusCode::BAD_REQUEST,",
          "        version: Version::HTTP_10,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body: &str = \"\";",
          "    let response = Response::from_parts(parts, body);",
          "}"
        ],
        "oracles": [
          [
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.status(), StatusCode::BAD_REQUEST);"
          ],
          [
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.version(), Version::HTTP_10);"
          ],
          [
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.headers(), &HeaderMap::new());"
          ],
          [
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.extensions(), &Extensions::default());"
          ],
          [
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.body(), &body);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::BAD_REQUEST,",
            "        version: Version::HTTP_10,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.status(), StatusCode::BAD_REQUEST);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::BAD_REQUEST,",
            "        version: Version::HTTP_10,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.version(), Version::HTTP_10);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::BAD_REQUEST,",
            "        version: Version::HTTP_10,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.headers(), &HeaderMap::new());",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::BAD_REQUEST,",
            "        version: Version::HTTP_10,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.extensions(), &Extensions::default());",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::BAD_REQUEST,",
            "        version: Version::HTTP_10,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::BAD_REQUEST, version: Version::HTTP_10, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body: &str = \"\";",
            "    let response = Response::from_parts(parts.clone(), body);",
            "    assert_eq!(response.body(), &body);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut headers = HeaderMap::new();",
          "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
          "    ",
          "    let parts = Parts {",
          "        status: StatusCode::CREATED,",
          "        version: Version::HTTP_11,",
          "        headers,",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body = \"body with valid header\";",
          "    let response = Response::from_parts(parts, body);",
          "}"
        ],
        "oracles": [
          [
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.status(), StatusCode::CREATED);"
          ],
          [
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.version(), Version::HTTP_11);"
          ],
          [
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.headers().get(HeaderName::from_static(\"content-type\")), Some(&HeaderValue::from_static(\"text/plain\")));"
          ],
          [
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(*response.body(), \"body with valid header\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    ",
            "    let parts = Parts {",
            "        status: StatusCode::CREATED,",
            "        version: Version::HTTP_11,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.status(), StatusCode::CREATED);",
            "}"
          ],
          [
            "{",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    ",
            "    let parts = Parts {",
            "        status: StatusCode::CREATED,",
            "        version: Version::HTTP_11,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.version(), Version::HTTP_11);",
            "}"
          ],
          [
            "{",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    ",
            "    let parts = Parts {",
            "        status: StatusCode::CREATED,",
            "        version: Version::HTTP_11,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.headers().get(HeaderName::from_static(\"content-type\")), Some(&HeaderValue::from_static(\"text/plain\")));",
            "}"
          ],
          [
            "{",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    ",
            "    let parts = Parts {",
            "        status: StatusCode::CREATED,",
            "        version: Version::HTTP_11,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    let mut headers = HeaderMap::new();",
            "    headers.insert(HeaderName::from_static(\"content-type\"), HeaderValue::from_static(\"text/plain\"));",
            "    let parts = Parts {",
            "    status: StatusCode::CREATED,",
            "    version: Version::HTTP_11,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with valid header\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(*response.body(), \"body with valid header\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parts = Parts {",
          "        status: StatusCode::NO_CONTENT,",
          "        version: Version::HTTP_20,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body = \"body with no extensions\";",
          "    let response = Response::from_parts(parts, body);",
          "}"
        ],
        "oracles": [
          [
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.status(), StatusCode::NO_CONTENT);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.version(), Version::HTTP_20);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.headers().is_empty(), true);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.extensions().is_empty(), true);"
          ],
          [
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(*response.body(), \"body with no extensions\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NO_CONTENT,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.status(), StatusCode::NO_CONTENT);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NO_CONTENT,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.version(), Version::HTTP_20);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NO_CONTENT,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.headers().is_empty(), true);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NO_CONTENT,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(response.extensions().is_empty(), true);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::NO_CONTENT,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts {",
            "    status: StatusCode::NO_CONTENT,",
            "    version: Version::HTTP_20,",
            "    headers: HeaderMap::new(),",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let body = \"body with no extensions\";",
            "    let response = Response::from_parts(parts, body);",
            "    assert_eq!(*response.body(), \"body with no extensions\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let parts = Parts {",
          "        status: StatusCode::INTERNAL_SERVER_ERROR,",
          "        version: Version::HTTP_11,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
          "    let response = Response::from_parts(parts, body);",
          "}"
        ],
        "oracles": [
          [
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);"
          ],
          [
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.version(), Version::HTTP_11);"
          ],
          [
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert!(response.headers().is_empty());"
          ],
          [
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert!(response.extensions().is_empty());"
          ],
          [
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.body(), &body);"
          ],
          [
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.body_mut(), &mut body);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.version(), Version::HTTP_11);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert!(response.headers().is_empty());",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert!(response.extensions().is_empty());",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.body(), &body);",
            "}"
          ],
          [
            "{",
            "    let parts = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body = \"This is a test body that exceeds the maximum allowable length of 4096 characters...\";",
            "    let response = Response::from_parts(parts, body);",
            "    let parts = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    assert_eq!(response.body_mut(), &mut body);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parts_ok = Parts {",
          "        status: StatusCode::OK,",
          "        version: Version::HTTP_11,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body_ok = \"body for status OK\";",
          "    let response_ok = Response::from_parts(parts_ok, body_ok);",
          "    ",
          "    let parts_server_error = Parts {",
          "        status: StatusCode::INTERNAL_SERVER_ERROR,",
          "        version: Version::HTTP_20,",
          "        headers: HeaderMap::new(),",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let body_server_error = \"body for status 500\";",
          "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
          "}"
        ],
        "oracles": [
          [
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_ok.status(), StatusCode::OK);"
          ],
          [
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_ok.version(), Version::HTTP_11);"
          ],
          [
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_server_error.status(), StatusCode::INTERNAL_SERVER_ERROR);"
          ],
          [
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_server_error.version(), Version::HTTP_20);"
          ],
          [
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(*response_ok.body(), \"body for status OK\");"
          ],
          [
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(*response_server_error.body(), \"body for status 500\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parts_ok = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    ",
            "    let parts_server_error = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_ok.status(), StatusCode::OK);",
            "}"
          ],
          [
            "{",
            "    let parts_ok = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    ",
            "    let parts_server_error = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_ok.version(), Version::HTTP_11);",
            "}"
          ],
          [
            "{",
            "    let parts_ok = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    ",
            "    let parts_server_error = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_server_error.status(), StatusCode::INTERNAL_SERVER_ERROR);",
            "}"
          ],
          [
            "{",
            "    let parts_ok = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    ",
            "    let parts_server_error = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(response_server_error.version(), Version::HTTP_20);",
            "}"
          ],
          [
            "{",
            "    let parts_ok = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    ",
            "    let parts_server_error = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(*response_ok.body(), \"body for status OK\");",
            "}"
          ],
          [
            "{",
            "    let parts_ok = Parts {",
            "        status: StatusCode::OK,",
            "        version: Version::HTTP_11,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    ",
            "    let parts_server_error = Parts {",
            "        status: StatusCode::INTERNAL_SERVER_ERROR,",
            "        version: Version::HTTP_20,",
            "        headers: HeaderMap::new(),",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    let parts_ok = Parts { status: StatusCode::OK, version: Version::HTTP_11, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_ok = \"body for status OK\";",
            "    let response_ok = Response::from_parts(parts_ok, body_ok);",
            "    let parts_server_error = Parts { status: StatusCode::INTERNAL_SERVER_ERROR, version: Version::HTTP_20, headers: HeaderMap::new(), extensions: Extensions::default(), _priv: () };",
            "    let body_server_error = \"body for status 500\";",
            "    let response_server_error = Response::from_parts(parts_server_error, body_server_error);",
            "    assert_eq!(*response_server_error.body(), \"body for status 500\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]