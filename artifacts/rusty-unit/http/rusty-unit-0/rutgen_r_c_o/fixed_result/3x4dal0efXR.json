{
    "function_name": "http::header::map::header::map::HeaderMap<T>::try_reserve_one",
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/http",
    "tests": 163,
    "tests_lines": [
        21,
        21,
        21,
        21,
        21,
        22,
        22,
        11,
        14,
        15,
        15,
        15,
        19,
        20,
        20,
        25,
        29,
        29,
        19,
        19,
        20,
        17,
        17,
        17,
        17,
        17,
        17,
        16,
        16,
        17,
        17,
        17,
        17,
        15,
        15,
        21,
        16,
        16,
        16,
        16,
        14,
        10,
        14,
        14,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        15,
        15,
        15,
        15,
        15,
        23,
        23,
        23,
        24,
        24,
        26,
        24,
        24,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        18,
        18,
        18,
        18,
        14,
        14,
        14,
        14,
        14,
        14,
        21,
        21,
        21,
        21,
        17,
        17,
        17,
        17,
        17,
        22,
        22,
        22,
        22,
        22,
        8,
        8,
        8,
        8,
        8,
        6,
        6,
        6,
        6,
        6,
        6,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        8,
        10,
        10,
        10,
        10,
        10,
        10,
        9,
        9,
        9,
        9,
        8,
        8,
        8,
        8,
        8,
        9,
        9,
        9,
        9,
        9,
        9,
        9,
        10,
        10,
        23,
        23,
        23,
        34,
        34,
        34,
        34,
        25,
        25,
        25,
        25,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        15,
        15,
        16,
        16,
        16
    ],
    "oracles": 33,
    "oracles_compiled": 11,
    "oracles_compiled_rate": 33.33333333333333,
    "tests_compiled": 47,
    "tests_compiled_rate": 28.834355828220858,
    "oracles_run": 11,
    "oracles_passed": 5,
    "oracles_passed_rate": 45.45454545454545,
    "tests_run": 47,
    "tests_passed": 15,
    "tests_passed_rate": 31.914893617021278,
    "lines": 31,
    "lines_covered": 14,
    "lines_coveraged_rate": 45.16129032258064,
    "branches": 8,
    "branches_covered": 4,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        1694,
        1695,
        1696,
        1697,
        1698,
        1699,
        1700,
        1702,
        1703,
        1704,
        1705,
        1706,
        1707,
        1708,
        1710,
        1713,
        1714,
        1715,
        1717,
        1719,
        1720,
        1721,
        1722,
        1723,
        1724,
        1725,
        1726,
        1727,
        1729,
        1731,
        1732
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.len(), 2);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.danger.is_red(), true);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.indices.iter().all(|pos| pos.is_none()), true);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.entries.len(), 2);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    // Insert enough items to exceed the load factor threshold",
                "    for _ in 0..4 { ",
                "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                "    assert_eq!(header_map.len(), 4);",
                "    ",
                "    // This should not trigger any error, but should attempt to grow",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    for _ in 0..4 {",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.len(), 4);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    // Insert enough items to exceed the load factor threshold",
                "    for _ in 0..4 { ",
                "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                "    assert_eq!(header_map.len(), 4);",
                "    ",
                "    // This should not trigger any error, but should attempt to grow",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    for _ in 0..4 {",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.try_reserve_one().is_err());",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    header_map.danger.set_yellow();",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    header_map.danger.set_yellow();",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                "    header_map.danger.set_red();",
                "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                "    let result = header_map.try_reserve_one();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    header_map.danger.set_yellow();",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                "    header_map.danger.set_red();",
                "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                "    let result = header_map.try_reserve_one();",
                "    assert_eq!(header_map.danger.is_red(), true);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert_eq!(len, 1);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert_eq!(capacity, 16);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(!danger_state);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(header_map.entries.capacity() >= 16);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(header_map.mask == 15);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.danger.is_yellow(), false);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.len(), 2);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.capacity(), 32);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.indices.len(), 32);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1719,
                1729,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.capacity(), 16);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.indices.len(), 16);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.try_reserve_one().is_ok());",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.capacity() == 8);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.indices.len() == 8);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.mask == 7);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert!(result.is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert_eq!(header_map.capacity(), 8);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.danger.is_yellow());",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.capacity(), 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.indices.len(), 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert_eq!(header_map.capacity(), 8);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert!(header_map.entries.capacity() > 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            [
                1694,
                1695,
                1696,
                1697,
                1698,
                1699,
                1700,
                1710,
                1713,
                1717,
                1731,
                1732
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    assert_eq!(header_map.capacity(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    assert!(header_map.capacity() > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(0),",
                "        key: HeaderName::from_static(\"Key1\"),",
                "        value: HeaderValue::from_static(\"Value1\"),",
                "        links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "    hash: HashValue(0),",
                "    key: HeaderName::from_static(\"Key1\"),",
                "    value: HeaderValue::from_static(\"Value1\"),",
                "    links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    let expected_entries_len = 1;",
                "    let expected_capacity = usable_capacity(16);",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.entries.len(), expected_entries_len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(0),",
                "        key: HeaderName::from_static(\"Key1\"),",
                "        value: HeaderValue::from_static(\"Value1\"),",
                "        links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "    hash: HashValue(0),",
                "    key: HeaderName::from_static(\"Key1\"),",
                "    value: HeaderValue::from_static(\"Value1\"),",
                "    links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    let expected_entries_len = 1;",
                "    let expected_capacity = usable_capacity(16);",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.capacity(), expected_capacity);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1697,
            "start_column": 12,
            "end_line": 1697,
            "end_column": 35,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 1700,
            "start_column": 16,
            "end_line": 1700,
            "end_column": 52,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1719,
            "start_column": 19,
            "end_line": 1719,
            "end_column": 41,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1720,
            "start_column": 16,
            "end_line": 1720,
            "end_column": 24,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.len(), 2);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.danger.is_red(), true);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.indices.iter().all(|pos| pos.is_none()), true);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    // Simulating a load factor of exactly 0.2",
                "    for _ in 0..2 { ",
                "        header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    // Insert enough items to reach load factor threshold",
                "    assert_eq!(header_map.len(), 2);",
                "    ",
                "    // This should trigger try_grow with new_cap greater than MAX_SIZE",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(8);",
                "    for _ in 0..2 {",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.entries.len(), 2);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    // Insert enough items to exceed the load factor threshold",
                "    for _ in 0..4 { ",
                "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                "    assert_eq!(header_map.len(), 4);",
                "    ",
                "    // This should not trigger any error, but should attempt to grow",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    for _ in 0..4 {",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.len(), 4);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    // Insert enough items to exceed the load factor threshold",
                "    for _ in 0..4 { ",
                "        header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set this to ensure load_factor is 0.25 (which is above 0.2)",
                "    assert_eq!(header_map.len(), 4);",
                "    ",
                "    // This should not trigger any error, but should attempt to grow",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    for _ in 0..4 {",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    }",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.try_reserve_one().is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    header_map.danger.set_yellow();",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    header_map.danger.set_yellow();",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                "    header_map.danger.set_red();",
                "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                "    let result = header_map.try_reserve_one();",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    ",
                "    // Simulating conditions that should lead to rebuilding",
                "    for _ in 0..3 {",
                "        header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    }",
                "    ",
                "    // Simulate yellow danger state",
                "    header_map.danger.set_yellow();",
                "    ",
                "    // Set entries to ensure rebuilding occurs",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    assert_eq!(header_map.len(), 3);",
                "    ",
                "    // Trigger a reserve which should lead to rebuilding",
                "    let result = header_map.try_reserve_one();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.insert(\"key1\", HeaderValue::from_static(\"value1\"));",
                "    header_map.insert(\"key2\", HeaderValue::from_static(\"value2\"));",
                "    header_map.insert(\"key3\", HeaderValue::from_static(\"value3\"));",
                "    header_map.danger.set_yellow();",
                "    header_map.indices = vec![Pos::none(); 32].into_boxed_slice();",
                "    header_map.entries.clear(); // Simulating a state where rebuilding would kick in",
                "    header_map.danger.set_red();",
                "    header_map.try_grow(8).err().unwrap(); // Induces an error when trying to grow",
                "    let result = header_map.try_reserve_one();",
                "    assert_eq!(header_map.danger.is_red(), true);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert_eq!(len, 1);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert_eq!(capacity, 16);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(!danger_state);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(header_map.entries.capacity() >= 16);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let len = header_map.entries.len();",
                "    let capacity = header_map.capacity();",
                "    let danger_state = header_map.danger.is_yellow();",
                "    assert!(header_map.mask == 15);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.danger.is_yellow(), false);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.len(), 2);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.capacity(), 32);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"test1\"),",
                "        value: HeaderValue::from_static(\"value1\"),",
                "        links: None,",
                "    });",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"test2\"),",
                "        value: HeaderValue::from_static(\"value2\"),",
                "        links: None,",
                "    });",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(32);",
                "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"test1\"), value: HeaderValue::from_static(\"value1\"), links: None });",
                "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"test2\"), value: HeaderValue::from_static(\"value2\"), links: None });",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.indices.len(), 32);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.capacity(), 16);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.indices.len(), 16);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.try_reserve_one().is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.capacity() == 8);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.indices.len() == 8);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(0);",
                "    header_map.len();",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.mask == 7);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert_eq!(header_map.capacity(), 8);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    let result = header_map.try_reserve_one();",
                "    assert!(header_map.indices.iter().all(|pos| pos.is_none()));",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert!(header_map.danger.is_yellow());",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.entries.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    assert_eq!(header_map.indices.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert_eq!(header_map.capacity(), 8);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert!(header_map.indices.len() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert!(header_map.entries.capacity() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow(); // Set danger to yellow",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_yellow();",
                "    header_map.danger.set_green();",
                "    assert!(header_map.entries.len() == 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    assert_eq!(header_map.capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green(); // Set danger to green",
                "    // Ensure the length and capacity are both zero",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map: HeaderMap = HeaderMap::with_capacity(0);",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    assert!(header_map.capacity() > 0);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(0),",
                "        key: HeaderName::from_static(\"Key1\"),",
                "        value: HeaderValue::from_static(\"Value1\"),",
                "        links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "    hash: HashValue(0),",
                "    key: HeaderName::from_static(\"Key1\"),",
                "    value: HeaderValue::from_static(\"Value1\"),",
                "    links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    let expected_entries_len = 1;",
                "    let expected_capacity = usable_capacity(16);",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.entries.len(), expected_entries_len);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(0),",
                "        key: HeaderName::from_static(\"Key1\"),",
                "        value: HeaderValue::from_static(\"Value1\"),",
                "        links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    header_map.try_reserve_one().unwrap();",
                "    let mut header_map = HeaderMap::with_capacity(16);",
                "    header_map.entries.push(Bucket {",
                "    hash: HashValue(0),",
                "    key: HeaderName::from_static(\"Key1\"),",
                "    value: HeaderValue::from_static(\"Value1\"),",
                "    links: None,",
                "    });",
                "    header_map.danger.set_green();",
                "    let expected_entries_len = 1;",
                "    let expected_capacity = usable_capacity(16);",
                "    header_map.try_reserve_one().unwrap();",
                "    assert_eq!(header_map.capacity(), expected_capacity);",
                "}"
            ],
            [
                {
                    "start_line": 1697,
                    "start_column": 12,
                    "end_line": 1697,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1700,
                    "start_column": 16,
                    "end_line": 1700,
                    "end_column": 52,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1719,
                    "start_column": 19,
                    "end_line": 1719,
                    "end_column": 41,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1720,
                    "start_column": 16,
                    "end_line": 1720,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}