{
    "function_name": "http::method::extension::write_checked",
    "tests": 14,
    "tests_lines": [
        7,
        8,
        7,
        7,
        8,
        6,
        5,
        5,
        5,
        5,
        6,
        9,
        8,
        8
    ],
    "oracles": 14,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 42.857142857142854,
    "tests_compiled": 6,
    "tests_compiled_rate": 42.857142857142854,
    "oracles_run": 6,
    "oracles_passed": 4,
    "oracles_passed_rate": 66.66666666666666,
    "tests_run": 6,
    "tests_passed": 4,
    "tests_passed_rate": 66.66666666666666,
    "lines": 11,
    "lines_covered": 8,
    "lines_coveraged_rate": 72.72727272727273,
    "branches": 2,
    "branches_covered": 1,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        407,
        408,
        409,
        410,
        411,
        412,
        413,
        414,
        415,
        418,
        419
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let input: &[u8] = &[0, 1, 2, 255]; // Includes 0 which is invalid",
                "    let mut output = [0u8; 4]; // An appropriate size for the output buffer",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                407,
                408,
                409,
                410,
                411,
                412,
                419
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[1, 2, 3, 4, 65, 66, 67]; // All valid indices",
                "    let mut output = [0u8; 7]; // Adjust size accordingly",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, [b'!', b'#', b'$', b'%', b'A', b'B', b'C']); // Expected mapping",
                "}"
            ],
            [
                407,
                408,
                409,
                410,
                411,
                412,
                419
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[0, 0, 0]; // All values are invalid",
                "    let mut output = [0u8; 3];",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                407,
                408,
                409,
                410,
                411,
                412,
                419
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[]; // Edge case: empty input",
                "    let mut output = [0u8; 0]; // No output needed",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                407,
                408,
                418,
                419
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[254, 255]; // Test maximum valid indices",
                "    let mut output = [0u8; 2];",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, [b'~', b'\\0']); // Ensure that the output matches the expected mapping",
                "}"
            ],
            [
                407,
                408,
                409,
                410,
                411,
                412,
                419
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = b\"\\xFF\"; // Invalid byte that does not correspond to valid characters",
                "    let mut dst = [0u8; 1]; // Destination buffer",
                "",
                "    let result = write_checked(src, &mut dst);",
                "",
                "    assert!(result.is_err()); // Expect an error due to invalid input",
                "}"
            ],
            [
                407,
                408,
                409,
                410,
                411,
                412,
                419
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 411,
            "start_column": 16,
            "end_line": 411,
            "end_column": 22,
            "positive": true,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let input: &[u8] = &[0, 1, 2, 255]; // Includes 0 which is invalid",
                "    let mut output = [0u8; 4]; // An appropriate size for the output buffer",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 411,
                    "start_column": 16,
                    "end_line": 411,
                    "end_column": 22,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[1, 2, 3, 4, 65, 66, 67]; // All valid indices",
                "    let mut output = [0u8; 7]; // Adjust size accordingly",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, [b'!', b'#', b'$', b'%', b'A', b'B', b'C']); // Expected mapping",
                "}"
            ],
            [
                {
                    "start_line": 411,
                    "start_column": 16,
                    "end_line": 411,
                    "end_column": 22,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[0, 0, 0]; // All values are invalid",
                "    let mut output = [0u8; 3];",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 411,
                    "start_column": 16,
                    "end_line": 411,
                    "end_column": 22,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[]; // Edge case: empty input",
                "    let mut output = [0u8; 0]; // No output needed",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 411,
                    "start_column": 16,
                    "end_line": 411,
                    "end_column": 22,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[254, 255]; // Test maximum valid indices",
                "    let mut output = [0u8; 2];",
                "",
                "    let result = write_checked(input, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, [b'~', b'\\0']); // Ensure that the output matches the expected mapping",
                "}"
            ],
            [
                {
                    "start_line": 411,
                    "start_column": 16,
                    "end_line": 411,
                    "end_column": 22,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = b\"\\xFF\"; // Invalid byte that does not correspond to valid characters",
                "    let mut dst = [0u8; 1]; // Destination buffer",
                "",
                "    let result = write_checked(src, &mut dst);",
                "",
                "    assert!(result.is_err()); // Expect an error due to invalid input",
                "}"
            ],
            [
                {
                    "start_line": 411,
                    "start_column": 16,
                    "end_line": 411,
                    "end_column": 22,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/method.rs"
}