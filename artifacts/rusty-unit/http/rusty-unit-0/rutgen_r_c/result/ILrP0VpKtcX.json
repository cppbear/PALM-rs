{
    "function_name": "http::header::map::header::map::HeaderMap<T>::remove_found",
    "tests": 11,
    "tests_lines": [
        30,
        9,
        36,
        23,
        33,
        28,
        21,
        21,
        7,
        22,
        23
    ],
    "oracles": 11,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 63.63636363636363,
    "tests_compiled": 7,
    "tests_compiled_rate": 63.63636363636363,
    "oracles_run": 7,
    "oracles_passed": 5,
    "oracles_passed_rate": 71.42857142857143,
    "tests_run": 7,
    "tests_passed": 5,
    "tests_passed_rate": 71.42857142857143,
    "lines": 37,
    "lines_covered": 25,
    "lines_coveraged_rate": 67.56756756756756,
    "branches": 14,
    "branches_covered": 6,
    "branches_coverage_rate": 42.857142857142854,
    "codes_lines": [
        1552,
        1553,
        1554,
        1555,
        1556,
        1557,
        1560,
        1563,
        1564,
        1565,
        1566,
        1567,
        1569,
        1570,
        1571,
        1572,
        1576,
        1577,
        1578,
        1579,
        1580,
        1584,
        1585,
        1586,
        1587,
        1588,
        1589,
        1590,
        1591,
        1592,
        1593,
        1594,
        1597,
        1600,
        1602,
        1604,
        1605
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(1);",
                "    let probe = 0;",
                "    let found = 0;",
                "",
                "    // This should panic since entries is empty",
                "    header_map.remove_found(probe, found);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    impl fmt::Debug for TestHeaderValue {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"TestHeaderValue\")",
                "        }",
                "    }",
                "",
                "    // Setup HeaderMap with multiple entries",
                "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                "    ",
                "    // Add two test entries to enforce conditions in remove_found",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"Header-One\"),",
                "        value: TestHeaderValue,",
                "        links: Some(Links { next: 1, tail: 1 }),",
                "    });",
                "    ",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"Header-Two\"),",
                "        value: TestHeaderValue,",
                "        links: Some(Links { next: 0, tail: 0 }),",
                "    });",
                "",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                "    let probe = 0; // Test removing the first entry",
                "    let found = 0; // Should return the first entry",
                "",
                "    // Call remove_found with a valid probe and found index",
                "    let entry = header_map.remove_found(probe, found);",
                "",
                "    // Assert removed entry is as expected",
                "    assert_eq!(entry.key, HeaderName::from_static(\"Header-One\"));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                "    ",
                "    // Prepare valid entries for testing",
                "    let key = HeaderName::from_static(\"Header-At-Probe\");",
                "    let value = TestHeaderValue;",
                "",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key,",
                "        value: value,",
                "        links: None,",
                "    });",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                "",
                "    // Set an invalid probe for removal",
                "    let probe = 1; // Out of bounds",
                "    let found = 0;",
                "",
                "    // This should panic due to invalid probe handling",
                "    header_map.remove_found(probe, found);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    // Create a HeaderMap with a small capacity for testing",
                "    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(4);",
                "    ",
                "    // Insert some entries to ensure we have a populated map",
                "    map.insert(\"key1\", 1);",
                "    map.insert(\"key2\", 2);",
                "    map.insert(\"key3\", 3);",
                "    map.insert(\"key4\", 4);",
                "",
                "    // Get the index of the entry to be removed",
                "    let found = 2; // Assuming we want to remove the entry with key \"key3\"",
                "    ",
                "    // Simulate the probe index. In a real scenario, this would need to be set accordingly",
                "    let probe = desired_pos(map.mask, HashValue(3)); // HashValue corresponding to \"key3\"",
                "    ",
                "    // Create links to ensure we hit link constraints",
                "    let link = Links { next: 0, tail: 1 };",
                "    map.entries[found].links = Some(link);",
                "    map.extra_values.push(ExtraValue { value: 10, prev: Link::Entry(0), next: Link::Entry(1) });",
                "    map.extra_values.push(ExtraValue { value: 20, prev: Link::Entry(1), next: Link::Entry(0) });",
                "",
                "    // The main function call we want to test",
                "    let entry = map.remove_found(probe, found);",
                "",
                "    // Check that the returned entry matches the expected entry",
                "    assert_eq!(entry.key, \"key3\");",
                "    assert_eq!(entry.value, 3);",
                "",
                "    // Verify the current state of the map",
                "    assert_eq!(map.entries.len(), 3); // One entry should be removed",
                "    assert!(map.indices[probe].is_none()); // The probe should be empty",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576,
                1579,
                1584,
                1585,
                1586,
                1587,
                1588,
                1589,
                1597,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    struct TestValue;",
                "    struct TestHeaderMap {",
                "        map: HeaderMap<TestValue>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let mut map = HeaderMap::with_capacity(4);",
                "            // Add a dummy entry for removal",
                "            map.insert(\"Key1\", TestValue);",
                "            map.insert(\"Key2\", TestValue);",
                "            map.insert(\"Key3\", TestValue);",
                "            Self { map }",
                "        }",
                "",
                "        fn setup_for_removal(&mut self) -> (usize, usize) {",
                "            let found = 1; // Index for \"Key2\"",
                "            let probe = found; // Probe index corresponding to found",
                "            (probe, found)",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let (probe, found) = header_map.setup_for_removal();",
                "    let bucket = header_map.map.remove_found(probe, found);",
                "    assert!(bucket.key == HeaderName::try_from(\"Key2\").unwrap());",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576,
                1579,
                1584,
                1585,
                1586,
                1587,
                1588,
                1589,
                1597,
                1604,
                1605
            ]
        ],
        [
            [
                "{",
                "    struct TestValue;",
                "    struct TestHeaderMap {",
                "        map: HeaderMap<TestValue>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let mut map = HeaderMap::with_capacity(2);",
                "            // Add two dummy entries",
                "            map.insert(\"Key1\", TestValue);",
                "            map.insert(\"Key2\", TestValue);",
                "            Self { map }",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let probe = 0; // Valid probe index",
                "    let found = 2; // Out of bounds found index",
                "    header_map.map.remove_found(probe, found);",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ],
        [
            [
                "{",
                "    struct TestValue;",
                "    struct TestHeaderMap {",
                "        map: HeaderMap<TestValue>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let map = HeaderMap::with_capacity(0);",
                "            Self { map }",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let probe = 0; // Valid probe index (though map is empty)",
                "    let found = 0; // Found index (also empty)",
                "    // calling remove_found on an empty map should not panic, ",
                "    // will just return a default Bucket.",
                "    let bucket = header_map.map.remove_found(probe, found);",
                "    assert_eq!(bucket.hash, HashValue(0)); // Bucket should be default",
                "}"
            ],
            [
                1552,
                1553,
                1554,
                1555,
                1556,
                1557,
                1560,
                1563,
                1564,
                1565,
                1566,
                1567,
                1569,
                1570,
                1576
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1560,
            "start_column": 16,
            "end_line": 1560,
            "end_column": 27,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1566,
            "start_column": 24,
            "end_line": 1566,
            "end_column": 36,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1567,
            "start_column": 24,
            "end_line": 1567,
            "end_column": 47,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1576,
            "start_column": 20,
            "end_line": 1576,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1584,
            "start_column": 12,
            "end_line": 1584,
            "end_column": 36,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 1589,
            "start_column": 24,
            "end_line": 1589,
            "end_column": 45,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1590,
            "start_column": 24,
            "end_line": 1590,
            "end_column": 72,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(1);",
                "    let probe = 0;",
                "    let found = 0;",
                "",
                "    // This should panic since entries is empty",
                "    header_map.remove_found(probe, found);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    impl fmt::Debug for TestHeaderValue {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"TestHeaderValue\")",
                "        }",
                "    }",
                "",
                "    // Setup HeaderMap with multiple entries",
                "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                "    ",
                "    // Add two test entries to enforce conditions in remove_found",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key: HeaderName::from_static(\"Header-One\"),",
                "        value: TestHeaderValue,",
                "        links: Some(Links { next: 1, tail: 1 }),",
                "    });",
                "    ",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(2),",
                "        key: HeaderName::from_static(\"Header-Two\"),",
                "        value: TestHeaderValue,",
                "        links: Some(Links { next: 0, tail: 0 }),",
                "    });",
                "",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                "    let probe = 0; // Test removing the first entry",
                "    let found = 0; // Should return the first entry",
                "",
                "    // Call remove_found with a valid probe and found index",
                "    let entry = header_map.remove_found(probe, found);",
                "",
                "    // Assert removed entry is as expected",
                "    assert_eq!(entry.key, HeaderName::from_static(\"Header-One\"));",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestHeaderValue;",
                "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                "    ",
                "    // Prepare valid entries for testing",
                "    let key = HeaderName::from_static(\"Header-At-Probe\");",
                "    let value = TestHeaderValue;",
                "",
                "    header_map.entries.push(Bucket {",
                "        hash: HashValue(1),",
                "        key,",
                "        value: value,",
                "        links: None,",
                "    });",
                "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                "",
                "    // Set an invalid probe for removal",
                "    let probe = 1; // Out of bounds",
                "    let found = 0;",
                "",
                "    // This should panic due to invalid probe handling",
                "    header_map.remove_found(probe, found);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Create a HeaderMap with a small capacity for testing",
                "    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(4);",
                "    ",
                "    // Insert some entries to ensure we have a populated map",
                "    map.insert(\"key1\", 1);",
                "    map.insert(\"key2\", 2);",
                "    map.insert(\"key3\", 3);",
                "    map.insert(\"key4\", 4);",
                "",
                "    // Get the index of the entry to be removed",
                "    let found = 2; // Assuming we want to remove the entry with key \"key3\"",
                "    ",
                "    // Simulate the probe index. In a real scenario, this would need to be set accordingly",
                "    let probe = desired_pos(map.mask, HashValue(3)); // HashValue corresponding to \"key3\"",
                "    ",
                "    // Create links to ensure we hit link constraints",
                "    let link = Links { next: 0, tail: 1 };",
                "    map.entries[found].links = Some(link);",
                "    map.extra_values.push(ExtraValue { value: 10, prev: Link::Entry(0), next: Link::Entry(1) });",
                "    map.extra_values.push(ExtraValue { value: 20, prev: Link::Entry(1), next: Link::Entry(0) });",
                "",
                "    // The main function call we want to test",
                "    let entry = map.remove_found(probe, found);",
                "",
                "    // Check that the returned entry matches the expected entry",
                "    assert_eq!(entry.key, \"key3\");",
                "    assert_eq!(entry.value, 3);",
                "",
                "    // Verify the current state of the map",
                "    assert_eq!(map.entries.len(), 3); // One entry should be removed",
                "    assert!(map.indices[probe].is_none()); // The probe should be empty",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestValue;",
                "    struct TestHeaderMap {",
                "        map: HeaderMap<TestValue>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let mut map = HeaderMap::with_capacity(4);",
                "            // Add a dummy entry for removal",
                "            map.insert(\"Key1\", TestValue);",
                "            map.insert(\"Key2\", TestValue);",
                "            map.insert(\"Key3\", TestValue);",
                "            Self { map }",
                "        }",
                "",
                "        fn setup_for_removal(&mut self) -> (usize, usize) {",
                "            let found = 1; // Index for \"Key2\"",
                "            let probe = found; // Probe index corresponding to found",
                "            (probe, found)",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let (probe, found) = header_map.setup_for_removal();",
                "    let bucket = header_map.map.remove_found(probe, found);",
                "    assert!(bucket.key == HeaderName::try_from(\"Key2\").unwrap());",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestValue;",
                "    struct TestHeaderMap {",
                "        map: HeaderMap<TestValue>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let mut map = HeaderMap::with_capacity(2);",
                "            // Add two dummy entries",
                "            map.insert(\"Key1\", TestValue);",
                "            map.insert(\"Key2\", TestValue);",
                "            Self { map }",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let probe = 0; // Valid probe index",
                "    let found = 2; // Out of bounds found index",
                "    header_map.map.remove_found(probe, found);",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestValue;",
                "    struct TestHeaderMap {",
                "        map: HeaderMap<TestValue>,",
                "    }",
                "",
                "    impl TestHeaderMap {",
                "        fn new() -> Self {",
                "            let map = HeaderMap::with_capacity(0);",
                "            Self { map }",
                "        }",
                "    }",
                "",
                "    let mut header_map = TestHeaderMap::new();",
                "    let probe = 0; // Valid probe index (though map is empty)",
                "    let found = 0; // Found index (also empty)",
                "    // calling remove_found on an empty map should not panic, ",
                "    // will just return a default Bucket.",
                "    let bucket = header_map.map.remove_found(probe, found);",
                "    assert_eq!(bucket.hash, HashValue(0)); // Bucket should be default",
                "}"
            ],
            [
                {
                    "start_line": 1560,
                    "start_column": 16,
                    "end_line": 1560,
                    "end_column": 27,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1566,
                    "start_column": 24,
                    "end_line": 1566,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1567,
                    "start_column": 24,
                    "end_line": 1567,
                    "end_column": 47,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1576,
                    "start_column": 20,
                    "end_line": 1576,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1584,
                    "start_column": 12,
                    "end_line": 1584,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1589,
                    "start_column": 24,
                    "end_line": 1589,
                    "end_column": 45,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1590,
                    "start_column": 24,
                    "end_line": 1590,
                    "end_column": 72,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/http/rusty-unit-0/src/header/map.rs"
}